From 9c696bbf136b02b8ae19113f078da77009278296 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Moreau?= <mamoreau@devolutions.net>
Date: Fri, 2 Feb 2024 09:15:27 -0500
Subject: [PATCH 2/8] Win32-OpenSSH v8.9.0 modified files

---
 .gitignore                                  | 291 ++++++++++-
 auth-passwd.c                               |  12 +-
 auth-rhosts.c                               |   5 +-
 auth.c                                      |  45 +-
 auth2-pubkey.c                              |   6 +
 auth2.c                                     |   6 +
 authfile.c                                  |  14 +
 channels.c                                  |   1 +
 clientloop.c                                |  10 +-
 dh.c                                        |  44 ++
 gss-serv.c                                  |   4 +-
 kex.c                                       |  26 +
 log.c                                       |   5 +
 match.c                                     |   8 +
 misc.c                                      | 104 +++-
 misc.h                                      |   3 +
 monitor.c                                   | 137 +++++-
 monitor.h                                   |   4 +-
 monitor_wrap.c                              |  13 +
 openbsd-compat/arc4random.c                 |  14 +
 openbsd-compat/bsd-pselect.c                |   1 +
 openbsd-compat/openbsd-compat.h             |   3 +
 openbsd-compat/timingsafe_bcmp.c            |   8 +-
 openbsd-compat/vis.c                        |  10 +
 openbsd-compat/vis.h                        |   7 +
 pathnames.h                                 |   8 +
 platform.c                                  |   2 +-
 progressmeter.c                             |   5 +
 readconf.c                                  |  23 +-
 readpass.c                                  |  39 ++
 regress/addrmatch.sh                        |   3 +
 regress/agent-restrict.sh                   |   6 +
 regress/agent-timeout.sh                    |   5 +-
 regress/agent.sh                            |   6 +
 regress/authinfo.sh                         |   6 +
 regress/banner.sh                           |  15 +-
 regress/cert-hostkey.sh                     |   3 +
 regress/cert-userkey.sh                     |   7 +-
 regress/cfginclude.sh                       |  17 +
 regress/cfgmatch.sh                         |  39 +-
 regress/cfgmatchlisten.sh                   |  18 +-
 regress/cfgparse.sh                         |  34 +-
 regress/connect.sh                          |  12 +-
 regress/dynamic-forward.sh                  |   6 +
 regress/envpass.sh                          |   5 +
 regress/exit-status-signal.sh               |   4 +
 regress/forcecommand.sh                     |   7 +-
 regress/forwarding.sh                       |   6 +
 regress/host-expand.sh                      |   9 +-
 regress/hostkey-agent.sh                    |  27 +-
 regress/integrity.sh                        |  18 +-
 regress/kextype.sh                          |  11 +-
 regress/keygen-comment.sh                   |   2 +-
 regress/keygen-convert.sh                   |  17 +-
 regress/keygen-knownhosts.sh                |  56 ++-
 regress/keygen-sshfp.sh                     |   8 +-
 regress/knownhosts-command.sh               |  10 +-
 regress/krl.sh                              |   7 +-
 regress/limit-keytype.sh                    |  10 +-
 regress/localcommand.sh                     |   5 +
 regress/multiplex.sh                        |   6 +
 regress/reconfigure.sh                      |   7 +-
 regress/reexec.sh                           |   4 +-
 regress/rekey.sh                            |  20 +-
 regress/scp-uri.sh                          |  28 +-
 regress/scp.sh                              |  48 +-
 regress/scp3.sh                             |  26 +-
 regress/servcfginclude.sh                   |   8 +
 regress/sftp-cmds.sh                        |  10 +-
 regress/sftp-glob.sh                        |  15 +-
 regress/sftp-perm.sh                        |  55 ++-
 regress/sftp-uri.sh                         |   8 +-
 regress/sshcfgparse.sh                      |  66 +++
 regress/sshsig.sh                           |   2 +-
 regress/test-exec.sh                        | 194 +++++---
 regress/try-ciphers.sh                      |   4 +
 regress/unittests/sshkey/test_file.c        |   8 +
 regress/unittests/test_helper/test_helper.c |  28 ++
 scp.c                                       | 311 +++++++++++-
 servconf.c                                  |  61 +++
 session.c                                   |  45 +-
 sftp-client.c                               |  32 +-
 sftp-server.c                               |  72 ++-
 sftp.c                                      |  89 +++-
 sk-usbhid.c                                 |  58 ++-
 ssh-add.c                                   |  20 +-
 ssh-keygen.c                                |  38 ++
 ssh-pkcs11-client.c                         | 211 ++++++++
 ssh-pkcs11.h                                |   4 +-
 ssh-sk-client.c                             | 130 ++++-
 ssh-sk-helper.c                             |  19 +
 ssh.c                                       |  17 +
 sshbuf-io.c                                 |   8 +
 sshbuf.h                                    |   6 +
 sshconnect.c                                |  41 ++
 sshconnect2.c                               |  55 +++
 sshd.c                                      | 503 +++++++++++++++++++-
 sshkey.c                                    |  55 ++-
 sshsig.c                                    |  35 +-
 version.h                                   |   2 +-
 100 files changed, 3343 insertions(+), 243 deletions(-)

diff --git a/.gitignore b/.gitignore
index 5e4ae5a60..b5dbe4c85 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
+# Ignores in parent branch
 Makefile
 buildpkg.sh
 config.h
@@ -19,18 +20,284 @@ survey.sh
 **/*.out
 **/*.a
 autom4te.cache/
-scp
-sftp
-sftp-server
-ssh
-ssh-add
-ssh-agent
-ssh-keygen
-ssh-keyscan
-ssh-keysign
-ssh-pkcs11-helper
-ssh-sk-helper
-sshd
 !regress/misc/fuzz-harness/Makefile
 !regress/unittests/sshsig/Makefile
 tags
+
+# Ignores in Windows fork
+/bin/x64/Debug
+/contrib/win32/openssh/.vs/Win32-OpenSSH/v14
+/contrib/win32/openssh/lib
+/contrib/win32/openssh/Win32/Debug/config/config.tlog
+/contrib/win32/openssh/Win32/Debug/libssh/libssh.tlog
+/contrib/win32/openssh/Win32/Debug/libssh
+/config.h
+/contrib/win32/openssh/LibreSSL
+/contrib/win32/openssh/ZLib
+/contrib/win32/openssh/libfido2
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+
+# User-specific files
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+bld/
+[Bb]in/
+[Oo]bj/
+[Ll]og/
+.vs/
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+TestResult.xml
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+project.lock.json
+project.fragment.lock.json
+artifacts/
+Properties/launchSettings.json
+*_i.c
+*_p.c
+*_i.h
+*.ilk
+*.meta
+*.obj
+*.pch
+*.pdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+*.c.bak
+*.h.bak
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# VSCode profiler
+*.vscode
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# JustCode is a .NET coding add-in
+.JustCode
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# TODO: Comment the next line if you want to checkin your web deploy settings
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# The packages folder can be ignored because of Package Restore
+**/packages/*
+# except build/, which is used as an MSBuild target.
+!**/packages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/packages/repositories.config
+# NuGet v3's project.json files produces more ignoreable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+node_modules/
+orleans.codegen.cs
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+
+# SQL Server files
+*.mdf
+*.ldf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# JetBrains Rider
+.idea/
+*.sln.iml
+
+# CodeRush
+.cr/
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/
+contrib/win32/win32compat/inc/crtheaders.h
+
+contrib/win32/openssh/LibreSSLSDK/
diff --git a/auth-passwd.c b/auth-passwd.c
index 347d91e25..85c9d77a2 100644
--- a/auth-passwd.c
+++ b/auth-passwd.c
@@ -56,6 +56,7 @@
 #include "auth.h"
 #include "auth-options.h"
 
+
 extern struct sshbuf *loginmsg;
 extern ServerOptions options;
 
@@ -111,6 +112,14 @@ auth_password(struct ssh *ssh, const char *password)
 		return ok;
 	}
 #endif
+#ifdef WINDOWS
+	{
+		int windows_password_auth(const char *, const char *);
+		if (windows_password_auth(pw->pw_name, password) == 0)
+			return 0;
+		return ok;
+	}
+#endif
 #ifdef USE_PAM
 	if (options.use_pam)
 		return (sshpam_auth_passwd(authctxt, password) && ok);
@@ -220,4 +229,5 @@ sys_auth_passwd(struct ssh *ssh, const char *password)
 	return encrypted_password != NULL &&
 	    strcmp(encrypted_password, pw_password) == 0;
 }
-#endif
+
+#endif
\ No newline at end of file
diff --git a/auth-rhosts.c b/auth-rhosts.c
index cac5cd84d..4fc9252a6 100644
--- a/auth-rhosts.c
+++ b/auth-rhosts.c
@@ -1,4 +1,4 @@
-/* $OpenBSD: auth-rhosts.c,v 1.55 2022/02/23 11:15:57 djm Exp $ */
+/* $OpenBSD: auth-rhosts.c,v 1.56 2022/02/23 21:21:49 djm Exp $ */
 /*
  * Author: Tatu Ylonen <ylo@cs.hut.fi>
  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
@@ -19,6 +19,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#include <fcntl.h>
 #ifdef HAVE_NETGROUP_H
 # include <netgroup.h>
 #endif
@@ -26,7 +27,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
-#include <fcntl.h>
+#include <stdlib.h>
 #include <unistd.h>
 
 #include "packet.h"
diff --git a/auth.c b/auth.c
index 560e8ecac..043492ca8 100644
--- a/auth.c
+++ b/auth.c
@@ -77,6 +77,12 @@
 #include "compat.h"
 #include "channels.h"
 
+#ifdef WINDOWS
+#include <Windows.h>
+#include "misc_internal.h"
+#include "sshfileperm.h"
+#endif // WINDOWS
+
 /* import */
 extern ServerOptions options;
 extern struct include_list includes;
@@ -436,6 +442,13 @@ expand_authorized_keys(const char *filename, struct passwd *pw)
 	file = percent_expand(filename, "h", pw->pw_dir,
 	    "u", pw->pw_name, "U", uidstr, (char *)NULL);
 
+#ifdef WINDOWS
+	/* Return if the path is absolute. If not, prepend the '%h\\' */
+	if(is_absolute_path(file))
+		return (file);
+
+	i = snprintf(ret, sizeof(ret), "%s\\%s", pw->pw_dir, file);
+#else
 	/*
 	 * Ensure that filename starts anchored. If not, be backward
 	 * compatible and prepend the '%h/'
@@ -444,6 +457,8 @@ expand_authorized_keys(const char *filename, struct passwd *pw)
 		return (file);
 
 	i = snprintf(ret, sizeof(ret), "%s/%s", pw->pw_dir, file);
+#endif // WINDOWS
+
 	if (i < 0 || (size_t)i >= sizeof(ret))
 		fatal("expand_authorized_keys: path too long");
 	free(file);
@@ -513,6 +528,23 @@ auth_openfile(const char *file, struct passwd *pw, int strict_modes,
 	int fd;
 	FILE *f;
 
+#ifdef WINDOWS
+	/* Windows POSIX adapter does not support fdopen() on open(file)*/
+	if ((f = fopen(file, "r")) == NULL) {
+		debug("Could not open %s '%s': %s", file_type, file,
+			strerror(errno));
+		return NULL;
+	}
+
+	// read permissions for non-admin/non-system accounts are allowed.
+	// Unix does safe_path_fd() which allows 022 file permissions i.e., allowing read for other users.
+	if (strict_modes && check_secure_file_permission(file, pw, 1) != 0) {
+		fclose(f);
+		logit("Authentication refused.");
+		auth_debug_add("Ignored %s", file_type);
+		return NULL;
+	}
+#else  /* !WINDOWS */
 	if ((fd = open(file, O_RDONLY|O_NONBLOCK)) == -1) {
 		if (log_missing || errno != ENOENT)
 			debug("Could not open %s '%s': %s", file_type, file,
@@ -542,6 +574,7 @@ auth_openfile(const char *file, struct passwd *pw, int strict_modes,
 		auth_debug_add("Ignored %s: %s", file_type, line);
 		return NULL;
 	}
+#endif  /* !WINDOWS */
 
 	return f;
 }
@@ -574,7 +607,16 @@ getpwnamallow(struct ssh *ssh, const char *user)
 	u_int i;
 
 	ci = get_connection_info(ssh, 1, options.use_dns);
+#ifdef WINDOWS
+	/* getpwname - normalizes the incoming user and makes it lowercase
+	/* it must be duped as the server matching routines may use getpwnam() and
+	 * and free the name being assigned to the connection info structure 
+	 */
+	pw = getpwnam(user);
+	ci->user = pw? xstrdup(pw->pw_name): user;
+#else
 	ci->user = user;
+#endif // WINDOWS
 	parse_server_match_config(&options, &includes, ci);
 	log_change_level(options.log_level);
 	log_verbose_reset();
@@ -585,8 +627,9 @@ getpwnamallow(struct ssh *ssh, const char *user)
 #if defined(_AIX) && defined(HAVE_SETAUTHDB)
 	aix_setauthdb(user);
 #endif
-
+#ifndef WINDOWS
 	pw = getpwnam(user);
+#endif
 
 #if defined(_AIX) && defined(HAVE_SETAUTHDB)
 	aix_restoreauthdb();
diff --git a/auth2-pubkey.c b/auth2-pubkey.c
index 9c2298fc8..60b27e9bf 100644
--- a/auth2-pubkey.c
+++ b/auth2-pubkey.c
@@ -358,6 +358,12 @@ check_principals_line(struct ssh *ssh, char *cp, const struct sshkey_cert *cert,
 	while (ep > cp && (*ep == '\n' || *ep == ' ' || *ep == '\t'))
 		*ep-- = '\0';
 
+#ifdef SUPPORT_CRLF
+	/* account for \r at line end */
+	if (*ep == '\r')
+		*ep-- = '\0';
+#endif
+
 	/*
 	 * If the line has internal whitespace then assume it has
 	 * key options.
diff --git a/auth2.c b/auth2.c
index 6c061934b..c158fd7cb 100644
--- a/auth2.c
+++ b/auth2.c
@@ -58,6 +58,9 @@
 #endif
 #include "monitor_wrap.h"
 #include "digest.h"
+#ifdef WINDOWS
+#include "sshTelemetry.h"
+#endif
 
 /* import */
 extern ServerOptions options;
@@ -445,6 +448,9 @@ userauth_finish(struct ssh *ssh, int authenticated, const char *packet_method,
 		methods = authmethods_get(authctxt);
 		debug3_f("failure partial=%d next methods=\"%s\"",
 		    partial, methods);
+#ifdef WINDOWS
+		send_auth_method_telemetry(methods);
+#endif
 		if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_FAILURE)) != 0 ||
 		    (r = sshpkt_put_cstring(ssh, methods)) != 0 ||
 		    (r = sshpkt_put_u8(ssh, partial)) != 0 ||
diff --git a/authfile.c b/authfile.c
index a399efc3e..4e32cb216 100644
--- a/authfile.c
+++ b/authfile.c
@@ -48,6 +48,7 @@
 #include "sshbuf.h"
 #include "ssherr.h"
 #include "krl.h"
+#include "sshfileperm.h"
 
 #define MAX_KEY_FILE_SIZE	(1024 * 1024)
 
@@ -58,9 +59,13 @@ sshkey_save_private_blob(struct sshbuf *keybuf, const char *filename)
 	int r;
 	mode_t omask;
 
+#ifdef WINDOWS
+	r = sshbuf_write_file(filename, keybuf, 0600);
+#else
 	omask = umask(077);
 	r = sshbuf_write_file(filename, keybuf);
 	umask(omask);
+#endif
 	return r;
 }
 
@@ -101,12 +106,21 @@ sshkey_perm_ok(int fd, const char *filename)
 #ifdef HAVE_CYGWIN
 	if (check_ntsec(filename))
 #endif
+		
+#ifdef WINDOWS  /*implement permission checks on Windows*/
+	if(check_secure_file_permission(filename, NULL, 0) != 0) {
+		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
+		error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
+		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
+		error("Permissions for '%s' are too open.", filename);
+#else
 	if ((st.st_uid == getuid()) && (st.st_mode & 077) != 0) {
 		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
 		error("@         WARNING: UNPROTECTED PRIVATE KEY FILE!          @");
 		error("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
 		error("Permissions 0%3.3o for '%s' are too open.",
 		    (u_int)st.st_mode & 0777, filename);
+#endif /* !WINDOWS */
 		error("It is required that your private key files are NOT accessible by others.");
 		error("This private key will be ignored.");
 		return SSH_ERR_KEY_BAD_PERMISSIONS;
diff --git a/channels.c b/channels.c
index 73e93c032..1af508d42 100644
--- a/channels.c
+++ b/channels.c
@@ -2324,6 +2324,7 @@ channel_post_mux_listener(struct ssh *ssh, Channel *c)
 		close(newsock);
 		return;
 	}
+
 	nc = channel_new(ssh, "multiplex client", SSH_CHANNEL_MUX_CLIENT,
 	    newsock, newsock, -1, c->local_window_max,
 	    c->local_maxpacket, 0, "mux-control", 1);
diff --git a/clientloop.c b/clientloop.c
index f8350e672..cd0c74ba6 100644
--- a/clientloop.c
+++ b/clientloop.c
@@ -364,7 +364,11 @@ client_x11_get_proto(struct ssh *ssh, const char *display,
 					/* Don't overflow on long timeouts */
 					x11_timeout_real = UINT_MAX;
 				}
+#ifdef WINDOWS
+				xasprintf(&cmd, "\"%s\" -f %s generate %s %s "
+#else
 				xasprintf(&cmd, "%s -f %s generate %s %s "
+#endif
 				    "untrusted timeout %u 2>%s",
 				    xauth_path, xauthfile, display,
 				    SSH_X11_PROTO, x11_timeout_real,
@@ -393,7 +397,11 @@ client_x11_get_proto(struct ssh *ssh, const char *display,
 		 */
 		if (trusted || generated) {
 			xasprintf(&cmd,
-			    "%s %s%s list %s 2>" _PATH_DEVNULL,
+#ifdef WINDOWS
+				"\"%s\" %s%s list %s 2>" _PATH_DEVNULL,
+#else
+				"%s %s%s list %s 2>" _PATH_DEVNULL,
+#endif
 			    xauth_path,
 			    generated ? "-f " : "" ,
 			    generated ? xauthfile : "",
diff --git a/dh.c b/dh.c
index ce2eb4725..f32495381 100644
--- a/dh.c
+++ b/dh.c
@@ -44,6 +44,9 @@
 #include "ssherr.h"
 
 #include "openbsd-compat/openssl-compat.h"
+#ifdef WINDOWS
+#include "sshfileperm.h"
+#endif
 
 static const char *moduli_filename;
 
@@ -164,11 +167,52 @@ choose_dh(int min, int wantbits, int max)
 	int best, bestcount, which, linenum;
 	struct dhgroup dhg;
 
+#ifndef WINDOWS
 	if ((f = fopen(get_moduli_filename(), "r")) == NULL) {
 		logit("WARNING: could not open %s (%s), using fixed modulus",
 		    get_moduli_filename(), strerror(errno));
 		return (dh_new_group_fallback(max));
 	}
+#else
+	/* First check the moduli file in the %programdata%\ssh\ directory.
+	 * If not then search for the moduli file in the current executable directory. This file will be updated in new OpenSSH releases.
+	 */
+	if ((f = fopen(get_moduli_filename(), "r")) == NULL) {
+		debug3("Could not open %s (%s)",
+			_PATH_DH_MODULI, strerror(errno));
+
+		int isFallback = 1;
+		extern char* __progdir;
+		if (__progdir) {
+			char moduli_path[PATH_MAX] = { 0 };
+			_snprintf_s(moduli_path, PATH_MAX, _TRUNCATE, "%s\\moduli", __progdir);
+
+			if ((f = fopen(moduli_path, "r")) == NULL) {
+				debug3("Could not open %s (%s)", moduli_path, strerror(errno));
+			} else {
+				if (check_secure_file_permission(moduli_path, NULL, 1) != 0) {
+					debug3("Permissions for '%s' are too open", moduli_path);
+				} else {
+					debug3("Using %s", moduli_path);
+					isFallback = 0;
+				}
+			}
+		}
+
+		if (isFallback) {
+			logit("WARNING: using fixed modulus");
+			return (dh_new_group_fallback(max));
+		}
+	} else {
+		/* Make sure only system, administrators group have write access otherwise don't use */
+		if (check_secure_file_permission(_PATH_DH_MODULI, NULL, 1) != 0) {
+			logit("WARNING: Permissions for '%s' are too open, using fixed modulus", _PATH_DH_MODULI);
+			return (dh_new_group_fallback(max));
+		}
+
+		debug3("Using %s", _PATH_DH_MODULI);
+	}
+#endif
 
 	linenum = 0;
 	best = bestcount = 0;
diff --git a/gss-serv.c b/gss-serv.c
index b5d4bb2d1..8774ca3c6 100644
--- a/gss-serv.c
+++ b/gss-serv.c
@@ -56,12 +56,12 @@ static ssh_gssapi_client gssapi_client =
 ssh_gssapi_mech gssapi_null_mech =
     { NULL, NULL, {0, NULL}, NULL, NULL, NULL, NULL};
 
-#ifdef KRB5
+#if defined(KRB5) || defined (GSSAPI_SSPI)
 extern ssh_gssapi_mech gssapi_kerberos_mech;
 #endif
 
 ssh_gssapi_mech* supported_mechs[]= {
-#ifdef KRB5
+#if defined (KRB5) || defined (GSSAPI_SSPI)
 	&gssapi_kerberos_mech,
 #endif
 	&gssapi_null_mech,
diff --git a/kex.c b/kex.c
index 0bcd27dc5..f9bf5a223 100644
--- a/kex.c
+++ b/kex.c
@@ -42,6 +42,10 @@
 #include <openssl/dh.h>
 #endif
 
+#ifdef WINDOWS
+#include "sshTelemetry.h"
+#endif
+
 #include "ssh.h"
 #include "ssh2.h"
 #include "atomicio.h"
@@ -1007,6 +1011,14 @@ kex_choose_conf(struct ssh *ssh)
 		    newkeys->enc.name,
 		    authlen == 0 ? newkeys->mac.name : "<implicit>",
 		    newkeys->comp.name);
+#ifdef WINDOWS
+		send_encryption_telemetry(ctos ? "ctos" : "stoc",
+			newkeys->enc.name, kex->name ? kex->name : "(no match)", 
+			authlen == 0 ? newkeys->mac.name : "<implicit>", 
+			newkeys->comp.name, 
+			kex->hostkey_alg ? kex->hostkey_alg : "(no match)", 
+			my, peer);
+#endif
 	}
 	need = dh_need = 0;
 	for (mode = 0; mode < MODE_MAX; mode++) {
@@ -1361,6 +1373,11 @@ kex_exchange_identification(struct ssh *ssh, int timeout_ms,
 	    &remote_major, &remote_minor, remote_version) != 3) {
 		error("Bad remote protocol version identification: '%.100s'",
 		    peer_version_string);
+#ifdef WINDOWS
+		send_ssh_version_telemetry(our_version_string, peer_version_string,
+			"Bad remote protocol version identification");
+#endif
+
  invalid:
 		send_error(ssh, "Invalid SSH identification string.");
 		r = SSH_ERR_INVALID_FORMAT;
@@ -1386,6 +1403,10 @@ kex_exchange_identification(struct ssh *ssh, int timeout_ms,
 		error("Protocol major versions differ: %d vs. %d",
 		    PROTOCOL_MAJOR_2, remote_major);
 		send_error(ssh, "Protocol major versions differ.");
+#ifdef WINDOWS
+		send_ssh_version_telemetry(our_version_string, 
+			peer_version_string, "Protocol major versions differ");
+#endif
 		r = SSH_ERR_NO_PROTOCOL_VERSION;
 		goto out;
 	}
@@ -1408,6 +1429,11 @@ kex_exchange_identification(struct ssh *ssh, int timeout_ms,
 		logit("Remote version \"%.100s\" uses unsafe RSA signature "
 		    "scheme; disabling use of RSA keys", remote_version);
 	}
+
+#ifdef WINDOWS
+	send_ssh_version_telemetry(our_version_string, 
+		peer_version_string, "none");
+#endif
 	/* success */
 	r = 0;
  out:
diff --git a/log.c b/log.c
index 99bf046a7..ddfd72d50 100644
--- a/log.c
+++ b/log.c
@@ -65,7 +65,12 @@ static size_t nlog_verbose;
 
 extern char *__progname;
 
+#ifdef WINDOWS
+#define LOG_SYSLOG_VIS	(VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL|VIS_LOG_UTF16)
+#else
 #define LOG_SYSLOG_VIS	(VIS_CSTYLE|VIS_NL|VIS_TAB|VIS_OCTAL)
+#endif
+
 #define LOG_STDERR_VIS	(VIS_SAFE|VIS_OCTAL)
 
 /* textual representation of log-facilities/levels */
diff --git a/match.c b/match.c
index 3ac854d38..13441e0e3 100644
--- a/match.c
+++ b/match.c
@@ -178,6 +178,14 @@ match_usergroup_pattern_list(const char *string, const char *pattern)
 #ifdef HAVE_CYGWIN
 	/* Windows usernames may be Unicode and are not case sensitive */
 	return cygwin_ug_match_pattern_list(string, pattern);
+#elif WINDOWS
+	/* We support both domain/username and domain\\username format	*/
+	char *tmp = NULL;
+	if (tmp = strstr(pattern, "/"))
+		*tmp = '\\';
+
+	/* Windows usernames are case insensitive */
+	return match_pattern_list(string, pattern, 1);
 #else
 	/* Case sensitive match */
 	return match_pattern_list(string, pattern, 0);
diff --git a/misc.c b/misc.c
index 417498deb..bc7804fc3 100644
--- a/misc.c
+++ b/misc.c
@@ -477,6 +477,7 @@ pwcopy(struct passwd *pw)
 #endif
 	copy->pw_dir = xstrdup(pw->pw_dir);
 	copy->pw_shell = xstrdup(pw->pw_shell);
+
 	return copy;
 }
 
@@ -748,6 +749,17 @@ colon(char *cp)
 
 	if (*cp == ':')		/* Leading colon is part of file name. */
 		return NULL;
+
+#ifdef WINDOWS
+	/*
+	 * Account for Windows file names in the form x: or /x: 
+	 * Note: This may conflict with potential single character targets
+	 */
+	if ((*cp != '\0' && cp[1] == ':') ||
+	    (cp[0] == '/' && cp[1] != '\0' && cp[2] == ':'))
+		return NULL;
+#endif
+
 	if (*cp == '[')
 		flag = 1;
 
@@ -994,6 +1006,16 @@ parse_uri(const char *scheme, const char *uri, char **userp, char **hostp,
 	if ((cp = strchr(tmp, '@')) != NULL) {
 		char *delim;
 
+#ifdef WINDOWS
+		/* TODO - This looks to be a core bug in unix code as user can be in UPN format
+		 *  The above line should be strrchr() instead of strchr.
+		 *  For time being, special handling when username is in User@domain format
+		 */
+
+		char *cp_1 = cp;
+		if ((cp_1 = strchr(cp + 1, '@')) != NULL)
+			cp = cp_1;
+#endif
 		*cp = '\0';
 		/* Extract username and connection params */
 		if ((delim = strchr(tmp, ';')) != NULL) {
@@ -1118,6 +1140,21 @@ freeargs(arglist *args)
 	}
 }
 
+#ifdef WINDOWS
+void
+duplicateargs(arglist *dest, arglist *source)
+{
+	if (!source || !dest)
+		return;
+	
+	if (source->list != NULL) {
+		for (int i = 0; i < source->num; i++) {
+			addargs(dest, source->list[i]);
+		}
+	}
+}
+#endif
+
 /*
  * Expands tildes in the file name.  Returns data allocated by xmalloc.
  * Warning: this calls getpw*.
@@ -1775,7 +1812,15 @@ mktemp_proto(char *s, size_t len)
 	const char *tmpdir;
 	int r;
 
-	if ((tmpdir = getenv("TMPDIR")) != NULL) {
+	tmpdir = getenv("TMPDIR");
+
+#ifdef WINDOWS
+	if (tmpdir == NULL) {
+		tmpdir = getenv("TEMP");
+	}
+#endif
+
+	if (tmpdir != NULL) {
 		r = snprintf(s, len, "%s/ssh-XXXXXXXXXXXX", tmpdir);
 		if (r > 0 && (size_t)r < len)
 			return;
@@ -1953,6 +1998,14 @@ forward_equals(const struct Forward *a, const struct Forward *b)
 }
 
 /* returns 1 if process is already daemonized, 0 otherwise */
+#ifdef WINDOWS
+/* This should go away once sshd platform specific startup code is refactored */
+int 
+daemonized(void)
+{
+	return 1;
+}
+#else /* !WINDOWS */
 int
 daemonized(void)
 {
@@ -1969,6 +2022,7 @@ daemonized(void)
 	debug3("already daemonized");
 	return 1;
 }
+#endif /* !WINDOWS */
 
 /*
  * Splits 's' into an argument vector. Handles quoted string and basic
@@ -2444,7 +2498,11 @@ format_absolute_time(uint64_t t, char *buf, size_t len)
 int
 path_absolute(const char *path)
 {
+#ifdef WINDOWS        
+	return is_absolute_path(path);
+#else
 	return (*path == '/') ? 1 : 0;
+#endif
 }
 
 void
@@ -2557,6 +2615,9 @@ opt_array_append(const char *file, const int line, const char *directive,
 sshsig_t
 ssh_signal(int signum, sshsig_t handler)
 {
+#ifdef WINDOWS
+	return signal(signum, handler);
+#else
 	struct sigaction sa, osa;
 
 	/* mask all other signals while in handler */
@@ -2572,6 +2633,7 @@ ssh_signal(int signum, sshsig_t handler)
 		return SIG_ERR;
 	}
 	return osa.sa_handler;
+#endif // WINDOWS
 }
 
 int
@@ -2658,11 +2720,18 @@ subprocess(const char *tag, const char *command,
 		    av[0], strerror(errno));
 		goto restore_return;
 	}
+
 	if ((flags & SSH_SUBPROCESS_UNSAFE_PATH) == 0 &&
+#ifdef WINDOWS
+	    (check_secure_file_permission(av[0], pw, 1) != 0)) {
+		error("Permissions on %s:\"%s\" are too open", tag, av[0]);
+#else
 	    safe_path(av[0], &st, NULL, 0, errmsg, sizeof(errmsg)) != 0) {
 		error("Unsafe %s \"%s\": %s", tag, av[0], errmsg);
+#endif
 		goto restore_return;
 	}
+
 	/* Prepare to keep the child's stdout if requested */
 	if (pipe(p) == -1) {
 		error("%s: pipe: %s", tag, strerror(errno));
@@ -2674,6 +2743,37 @@ subprocess(const char *tag, const char *command,
 	if (restore_privs != NULL)
 		restore_privs();
 
+#ifdef FORK_NOT_SUPPORTED
+	{
+		posix_spawn_file_actions_t actions;
+		pid = -1;
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, p[1], STDOUT_FILENO) != 0)
+			fatal("posix_spawn initialization failed");
+		else {
+#ifdef WINDOWS
+			extern PSID get_sid(const char*);
+			/* If the user's SID is the System SID and sshd is running as system,
+			 * launch as a child process.
+			 */
+			if (IsWellKnownSid(get_sid(pw->pw_name), WinLocalSystemSid) && am_system()) {
+				debug("starting subprocess using posix_spawnp");
+				if (posix_spawnp((pid_t*)&pid, av[0], &actions, NULL, av, NULL) != 0)
+					fatal("posix_spawnp: %s", strerror(errno));
+			}
+			else
+#endif
+			{
+				debug("starting subprocess as user using __posix_spawn_asuser");
+				if (__posix_spawn_asuser((pid_t*)&pid, av[0], &actions, NULL, av, NULL, pw->pw_name) != 0)
+					fatal("posix_spawn_user: %s", strerror(errno));
+			}
+		}
+
+		posix_spawn_file_actions_destroy(&actions);
+	}
+#else
 	switch ((pid = fork())) {
 	case -1: /* error */
 		error("%s: fork: %s", tag, strerror(errno));
@@ -2750,7 +2850,7 @@ subprocess(const char *tag, const char *command,
 	default: /* parent */
 		break;
 	}
-
+#endif
 	close(p[1]);
 	if ((flags & SSH_SUBPROCESS_STDOUT_CAPTURE) == 0)
 		close(p[0]);
diff --git a/misc.h b/misc.h
index 2e1b5feca..8195197f0 100644
--- a/misc.h
+++ b/misc.h
@@ -123,6 +123,9 @@ void	 addargs(arglist *, char *, ...)
 void	 replacearg(arglist *, u_int, char *, ...)
 	    __attribute__((format(printf, 3, 4)));
 void	 freeargs(arglist *);
+#ifdef WINDOWS
+void	 duplicateargs(arglist *, arglist *);
+#endif
 
 int	 tun_open(int, int, char **);
 
diff --git a/monitor.c b/monitor.c
index c199cb9bc..f88fbb123 100644
--- a/monitor.c
+++ b/monitor.c
@@ -447,15 +447,44 @@ monitor_read_log(struct monitor *pmonitor)
 		fatal_fr(r, "reserve msg");
 	if (atomicio(read, pmonitor->m_log_recvfd, p, len) != len)
 		fatal_f("log fd read: %s", strerror(errno));
+
 	if ((r = sshbuf_get_u32(logmsg, &level)) != 0 ||
 	    (r = sshbuf_get_u32(logmsg, &forced)) != 0 ||
 	    (r = sshbuf_get_cstring(logmsg, &msg, NULL)) != 0)
 		fatal_fr(r, "parse");
-
-	/* Log it */
+	
 	if (log_level_name(level) == NULL)
 		fatal_f("invalid log level %u (corrupted message?)", level);
+
+#ifdef WINDOWS
+	char* pname;
+	u_int sftp_log_level, sftp_log_facility, sftp_log_stderr;
+	extern int log_stderr;
+	if ((r = sshbuf_get_cstring(logmsg, &pname, NULL)) != 0)
+		fatal_fr(r, "parse");
+
+	if (strcmp(pname, "sftp-server") == 0) {
+		if ((r = sshbuf_get_u32(logmsg, &sftp_log_level)) != 0 ||
+			(r = sshbuf_get_u32(logmsg, &sftp_log_facility)) != 0 ||
+			(r = sshbuf_get_u32(logmsg, &sftp_log_stderr)) != 0)
+			fatal_fr(r, "parse");
+	}
+
+	/*log it*/
+	if (authctxt->authenticated == 0) 
+		sshlogdirect(level, forced, "%s [preauth]", msg);
+	else {
+		if (strcmp(pname, "sftp-server") == 0) {
+			log_init(pname, sftp_log_level, sftp_log_facility, sftp_log_stderr);
+			sshlogdirect(level, forced, "%s", msg);
+			log_init("sshd", options.log_level, options.log_facility, log_stderr);
+		} else  
+			sshlogdirect(level, forced, "%s", msg);
+	}
+#else
+	/*log it*/
 	sshlogdirect(level, forced, "%s [preauth]", msg);
+#endif
 
 	sshbuf_free(logmsg);
 	free(msg);
@@ -1706,6 +1735,57 @@ mm_answer_audit_command(struct ssh *ssh, int socket, struct sshbuf *m)
 }
 #endif /* SSH_AUDIT_EVENTS */
 
+void
+monitor_send_keystate(struct monitor *pmonitor) {
+	struct sshbuf *m;
+	int r;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	if ((r = sshbuf_put_string(m, session_id2, session_id2_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if ((r = sshbuf_put_stringb(m, child_state)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (ssh_msg_send(pmonitor->m_sendfd, 0, m) == -1)
+		fatal("%s: ssh_msg_send failed", __func__);
+
+	sshbuf_free(m);
+}
+
+void 
+monitor_recv_keystate(struct monitor*pmonitor) {
+	struct sshbuf *m;
+	u_char *cp, ver;
+	size_t len;
+	int r;
+
+	debug3("%s: entering ", __func__);
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (ssh_msg_recv(pmonitor->m_recvfd, m) == -1)
+		fatal("%s: ssh_msg_recv failed", __func__);
+	if ((r = sshbuf_get_u8(m, &ver)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (ver != 0)
+		fatal("%s: rexec version mismatch", __func__);
+
+	if ((r = sshbuf_get_string(m, &session_id2, &session_id2_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if ((r = sshbuf_get_string_direct(m, &cp, &len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	child_state = sshbuf_new();
+	if ((r = sshbuf_put(child_state, cp, len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	debug3("%s: done", __func__);
+	sshbuf_free(m);
+}
+
+
 void
 monitor_clear_keystate(struct ssh *ssh, struct monitor *pmonitor)
 {
@@ -1715,6 +1795,48 @@ monitor_clear_keystate(struct ssh *ssh, struct monitor *pmonitor)
 	child_state = NULL;
 }
 
+void
+monitor_send_authopt(struct monitor *pmonitor, int untrusted) {
+	struct sshbuf *m = NULL;
+	int r = 0;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	
+	if (auth_opts != NULL && (r = sshauthopt_serialise(auth_opts, m, untrusted)) != 0)
+		fatal("%s: sshauthopt_serialise: %s", __func__, ssh_err(r));
+
+	if (ssh_msg_send(pmonitor->m_sendfd, 0, m) == -1)
+		fatal("%s: ssh_msg_send failed", __func__);
+
+	sshbuf_free(m);
+}
+
+void
+monitor_recv_authopt(struct monitor*pmonitor) {
+	struct sshbuf *m;
+	u_char *cp, ver;
+	int r = 0;
+
+	debug3("%s: entering ", __func__);
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (ssh_msg_recv(pmonitor->m_recvfd, m) == -1)
+		fatal("%s: ssh_msg_recv failed", __func__);
+	if ((r = sshbuf_get_u8(m, &ver)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (ver != 0)
+		fatal("%s: rexec version mismatch", __func__);
+
+	if ((r = sshauthopt_deserialise(m, &auth_opts)) != 0)
+		fatal("%s: sshauthopt_deserialise: %s",
+			__func__, ssh_err(r));
+	
+	debug3("%s: done", __func__);
+	sshbuf_free(m);
+}
+
 void
 monitor_apply_keystate(struct ssh *ssh, struct monitor *pmonitor)
 {
@@ -1732,9 +1854,11 @@ monitor_apply_keystate(struct ssh *ssh, struct monitor *pmonitor)
 		fatal_f("incorrect session id length %zu (expected %u)",
 		    sshbuf_len(ssh->kex->session_id), session_id2_len);
 	}
+
 	if (memcmp(sshbuf_ptr(ssh->kex->session_id), session_id2,
 	    session_id2_len) != 0)
 		fatal_f("session ID mismatch");
+
 	/* XXX set callbacks */
 #ifdef WITH_OPENSSL
 	kex->kex[KEX_DH_GRP1_SHA1] = kex_gen_server;
@@ -1829,6 +1953,14 @@ monitor_reinit(struct monitor *mon)
 	monitor_openfds(mon, 0);
 }
 
+#ifdef WINDOWS
+void
+monitor_reinit_withlogs(struct monitor* mon)
+{
+	monitor_openfds(mon, 1);
+}
+#endif
+
 #ifdef GSSAPI
 int
 mm_answer_gss_setup_ctx(struct ssh *ssh, int sock, struct sshbuf *m)
@@ -1956,3 +2088,4 @@ mm_answer_gss_userok(struct ssh *ssh, int sock, struct sshbuf *m)
 }
 #endif /* GSSAPI */
 
+
diff --git a/monitor.h b/monitor.h
index 683e5e071..a9562c5f3 100644
--- a/monitor.h
+++ b/monitor.h
@@ -78,7 +78,9 @@ struct monitor {
 
 struct monitor *monitor_init(void);
 void monitor_reinit(struct monitor *);
-
+#ifdef WINDOWS
+void monitor_reinit_withlogs(struct monitor*);
+#endif
 struct Authctxt;
 void monitor_child_preauth(struct ssh *, struct monitor *);
 void monitor_child_postauth(struct ssh *, struct monitor *);
diff --git a/monitor_wrap.c b/monitor_wrap.c
index 748333c75..9d0f476d2 100644
--- a/monitor_wrap.c
+++ b/monitor_wrap.c
@@ -100,6 +100,19 @@ mm_log_handler(LogLevel level, int forced, const char *msg, void *ctx)
 	    (r = sshbuf_put_u32(log_msg, forced)) != 0 ||
 	    (r = sshbuf_put_cstring(log_msg, msg)) != 0)
 		fatal_fr(r, "assemble");
+
+#ifdef WINDOWS
+	/*
+	 * Log messages are fowarded to SSHD parent process from
+	 * both sshd children and sftp-server processes. 
+	 * Attach progname to the end of the message so that SSHD 
+	 * parent process can differentitate between messages
+	 * coming from sshd children and sftp-server. 
+	 */
+	if (r = sshbuf_put_cstring(log_msg, "sshd") != 0)
+		fatal_fr(r, "assemble");
+#endif
+		
 	if ((len = sshbuf_len(log_msg)) < 4 || len > 0xffffffff)
 		fatal_f("bad length %zu", len);
 	POKE_U32(sshbuf_mutable_ptr(log_msg), len - 4);
diff --git a/openbsd-compat/arc4random.c b/openbsd-compat/arc4random.c
index 80ff3c180..87c7a99e0 100644
--- a/openbsd-compat/arc4random.c
+++ b/openbsd-compat/arc4random.c
@@ -84,6 +84,19 @@ _rs_init(u_char *buf, size_t n)
 }
 
 #ifndef WITH_OPENSSL
+#ifdef WINDOWS
+#include <Wincrypt.h>
+static void
+getrnd(u_char *s, size_t len) {
+	HCRYPTPROV hProvider;
+	if (CryptAcquireContextW(&hProvider, 0, 0, PROV_RSA_FULL, 
+		CRYPT_VERIFYCONTEXT | CRYPT_SILENT) == FALSE ||
+	    CryptGenRandom(hProvider, len, s) == FALSE ||
+	    CryptReleaseContext(hProvider, 0) == FALSE)
+		fatal("%s Crypto error: %d", __func__, GetLastError());
+}
+
+#else /* !WINDOWS */
 # ifndef SSH_RANDOM_DEV
 #  define SSH_RANDOM_DEV "/dev/urandom"
 # endif /* SSH_RANDOM_DEV */
@@ -119,6 +132,7 @@ getrnd(u_char *s, size_t len)
 	}
 	close(fd);
 }
+#endif /* !WINDOWS */
 #endif /* WITH_OPENSSL */
 
 static void
diff --git a/openbsd-compat/bsd-pselect.c b/openbsd-compat/bsd-pselect.c
index b36320863..7866729bb 100644
--- a/openbsd-compat/bsd-pselect.c
+++ b/openbsd-compat/bsd-pselect.c
@@ -201,5 +201,6 @@ pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
 		pselect_notify_done(readfds);
 	errno = saved_errno;
 	return ret;
+
 }
 #endif
diff --git a/openbsd-compat/openbsd-compat.h b/openbsd-compat/openbsd-compat.h
index c202e1429..33d09a32d 100644
--- a/openbsd-compat/openbsd-compat.h
+++ b/openbsd-compat/openbsd-compat.h
@@ -261,7 +261,10 @@ long long strtonum(const char *, long long, long long, const char **);
 # define wcwidth(x)	(((x) >= 0x20 && (x) <= 0x7e) ? 1 : -1)
 /* force our no-op nl_langinfo and mbtowc */
 # undef HAVE_NL_LANGINFO
+#ifndef WINDOWS
+/* Windows does not have wcwidth but does have mbtowc*/
 # undef HAVE_MBTOWC
+#endif  /* WINDOWS */
 # undef HAVE_LANGINFO_H
 #endif
 
diff --git a/openbsd-compat/timingsafe_bcmp.c b/openbsd-compat/timingsafe_bcmp.c
index 7e28c0e2a..7c6a949d3 100644
--- a/openbsd-compat/timingsafe_bcmp.c
+++ b/openbsd-compat/timingsafe_bcmp.c
@@ -26,8 +26,14 @@ timingsafe_bcmp(const void *b1, const void *b2, size_t n)
 	const unsigned char *p1 = b1, *p2 = b2;
 	int ret = 0;
 
-	for (; n > 0; n--)
+	for (; n > 0; n--) {
+#ifdef WINDOWS
+		if (*p1 == '\r' && *(p1 + 1) == '\n' && *p2 == '\n')
+			p1++;
+#endif // WINDOWS
 		ret |= *p1++ ^ *p2++;
+	}
+
 	return (ret != 0);
 }
 
diff --git a/openbsd-compat/vis.c b/openbsd-compat/vis.c
index 0e04ed025..40cb0a80f 100644
--- a/openbsd-compat/vis.c
+++ b/openbsd-compat/vis.c
@@ -114,6 +114,16 @@ vis(char *dst, int c, int flag, int nextc)
 			goto done;
 		}
 	}
+
+#ifdef WINDOWS
+	/*Avoid encoding UTF-16 chatacters so they 
+	  show up correctly in the logs*/
+	if (flag & VIS_LOG_UTF16) {
+		*dst++ = c;
+		goto done;
+	}
+#endif 
+
 	if (((c & 0177) == ' ') || (flag & VIS_OCTAL) ||
 	    ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {
 		*dst++ = '\\';
diff --git a/openbsd-compat/vis.h b/openbsd-compat/vis.h
index 2cdfd364b..7c4d9b043 100644
--- a/openbsd-compat/vis.h
+++ b/openbsd-compat/vis.h
@@ -81,6 +81,13 @@
  */
 #define	UNVIS_END	1	/* no more characters */
 
+#ifdef WINDOWS
+/*
+ * UTF16 logs
+ */
+#define VIS_LOG_UTF16	0x800
+#endif
+
 char	*vis(char *, int, int, int);
 int	strvis(char *, const char *, int);
 int	stravis(char **, const char *, int);
diff --git a/pathnames.h b/pathnames.h
index f7ca5a75a..6c07f7989 100644
--- a/pathnames.h
+++ b/pathnames.h
@@ -131,13 +131,21 @@
 
 /* Location of ssh-pkcs11-helper to support keys in tokens */
 #ifndef _PATH_SSH_PKCS11_HELPER
+#ifdef WINDOWS
+#define _PATH_SSH_PKCS11_HELPER		"C:\\Windows\\System32\\OpenSSH\\ssh-pkcs11-helper.exe"
+#else
 #define _PATH_SSH_PKCS11_HELPER		"/usr/libexec/ssh-pkcs11-helper"
 #endif
+#endif
 
 /* Location of ssh-sk-helper to support keys in security keys */
 #ifndef _PATH_SSH_SK_HELPER
+#ifdef WINDOWS
+#define _PATH_SSH_SK_HELPER		"C:\\Windows\\System32\\OpenSSH\\ssh-sk-helper.exe"
+#else
 #define _PATH_SSH_SK_HELPER		"/usr/libexec/ssh-sk-helper"
 #endif
+#endif
 
 /* xauth for X11 forwarding */
 #ifndef _PATH_XAUTH
diff --git a/platform.c b/platform.c
index 44ba71dc5..25ef03d34 100644
--- a/platform.c
+++ b/platform.c
@@ -82,7 +82,7 @@ platform_post_fork_child(void)
 int
 platform_privileged_uidswap(void)
 {
-#ifdef HAVE_CYGWIN
+#if defined(HAVE_CYGWIN) || defined(WINDOWS)
 	/* uid 0 is not special on Cygwin so always try */
 	return 1;
 #else
diff --git a/progressmeter.c b/progressmeter.c
index 8baf798f1..c73d45897 100644
--- a/progressmeter.c
+++ b/progressmeter.c
@@ -81,7 +81,12 @@ static const char unit[] = " KMGT";
 static int
 can_output(void)
 {
+#ifdef WINDOWS
+	/* On Windows, we can output if the stdout is a terminal*/
+	return isatty(STDOUT_FILENO);
+#else 
 	return (getpgrp() == tcgetpgrp(STDOUT_FILENO));
+#endif
 }
 
 static void
diff --git a/readconf.c b/readconf.c
index f26fabaa6..fa014bb70 100644
--- a/readconf.c
+++ b/readconf.c
@@ -39,6 +39,7 @@
 #include <string.h>
 #include <stdarg.h>
 #include <unistd.h>
+#include <sshfileperm.h>
 #ifdef USE_SYSTEM_GLOB
 # include <glob.h>
 #else
@@ -528,6 +529,10 @@ execute_in_shell(const char *cmd)
 	pid_t pid;
 	int status;
 
+#ifdef WINDOWS
+	return system(cmd);
+#else
+
 	if ((shell = getenv("SHELL")) == NULL)
 		shell = _PATH_BSHELL;
 
@@ -572,6 +577,7 @@ execute_in_shell(const char *cmd)
 	}
 	debug3("command returned status %d", WEXITSTATUS(status));
 	return WEXITSTATUS(status);
+#endif
 }
 
 /*
@@ -1890,6 +1896,10 @@ parse_pubkey_algos:
 			} else
 				arg2 = xstrdup(arg);
 			memset(&gl, 0, sizeof(gl));
+#ifdef WINDOWS
+			convertToForwardslash(arg2);
+#endif // WINDOWS
+
 			r = glob(arg2, GLOB_TILDE, NULL, &gl);
 			if (r == GLOB_NOMATCH) {
 				debug("%.200s line %d: include %s matched no "
@@ -2257,7 +2267,16 @@ read_config_file_depth(const char *filename, struct passwd *pw,
 	if ((f = fopen(filename, "r")) == NULL)
 		return 0;
 
-	if (flags & SSHCONF_CHECKPERM) {
+	if (flags & SSHCONF_CHECKPERM) {		
+#if WINDOWS
+		/*
+		file permissions are designed differently on windows.
+		implementation on windows to make sure the config file is owned by a user, administrators group, or LOCALSYSTEM account
+		and nobody else except Administrators group, LOCALSYSTEM, and file owner account has the write permission
+		*/
+		if (check_secure_file_permission(filename, pw, 1) != 0)
+			fatal("Bad owner or permissions on %s", filename);
+#else
 		struct stat sb;
 
 		if (fstat(fileno(f), &sb) == -1)
@@ -2265,8 +2284,10 @@ read_config_file_depth(const char *filename, struct passwd *pw,
 		if (((sb.st_uid != 0 && sb.st_uid != getuid()) ||
 		    (sb.st_mode & 022) != 0))
 			fatal("Bad owner or permissions on %s", filename);
+#endif /* !WINDOWS */
 	}
 
+
 	debug("Reading configuration data %.200s", filename);
 
 	/*
diff --git a/readpass.c b/readpass.c
index 39af25c88..d19ae953c 100644
--- a/readpass.c
+++ b/readpass.c
@@ -66,6 +66,36 @@ ssh_askpass(char *askpass, const char *msg, const char *env_hint)
 		return NULL;
 	}
 	osigchld = ssh_signal(SIGCHLD, SIG_DFL);
+#ifdef FORK_NOT_SUPPORTED
+	fcntl(p[0], F_SETFD, FD_CLOEXEC);
+	fcntl(p[1], F_SETFD, FD_CLOEXEC);
+	{
+		if (env_hint != NULL)
+			setenv("SSH_ASKPASS_PROMPT", env_hint, 1);
+
+		posix_spawn_file_actions_t actions;
+		pid = -1;
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, p[1], STDOUT_FILENO) != 0 ) {
+			error("posix_spawn initialization failed");
+			ssh_signal(SIGCHLD, osigchld);
+			return NULL;
+		} else {
+			const char* spawn_argv[3];
+			spawn_argv[0] = askpass;
+			spawn_argv[1] = msg;
+			spawn_argv[2] = NULL;
+			if (posix_spawnp(&pid, spawn_argv[0], &actions, NULL, (char* const*) spawn_argv, NULL) != 0) {
+				posix_spawn_file_actions_destroy(&actions);
+				error("ssh_askpass: posix_spawnp: %s", strerror(errno));
+				ssh_signal(SIGCHLD, osigchld);
+				return NULL;
+			}
+			posix_spawn_file_actions_destroy(&actions);
+		}
+
+	}
+#else 
 	if ((pid = fork()) == -1) {
 		error_f("fork: %s", strerror(errno));
 		ssh_signal(SIGCHLD, osigchld);
@@ -80,6 +110,7 @@ ssh_askpass(char *askpass, const char *msg, const char *env_hint)
 		execlp(askpass, askpass, msg, (char *)NULL);
 		fatal_f("exec(%s): %s", askpass, strerror(errno));
 	}
+#endif
 	close(p[1]);
 
 	len = 0;
@@ -176,12 +207,20 @@ read_passphrase(const char *prompt, int flags)
 			askpass = getenv(SSH_ASKPASS_ENV);
 		else
 			askpass = _PATH_SSH_ASKPASS_DEFAULT;
+
+#ifdef WINDOWS
+		if (getenv(SSH_ASKPASS_ENV)) {
+#endif
 		if ((flags & RP_ASK_PERMISSION) != 0)
 			askpass_hint = "confirm";
 		if ((ret = ssh_askpass(askpass, prompt, askpass_hint)) == NULL)
 			if (!(flags & RP_ALLOW_EOF))
 				return xstrdup("");
 		return ret;
+
+#ifdef WINDOWS
+		}
+#endif
 	}
 
 	if (readpassphrase(prompt, buf, sizeof buf, rppflags) == NULL) {
diff --git a/regress/addrmatch.sh b/regress/addrmatch.sh
index 26e0c9910..8480b88c7 100644
--- a/regress/addrmatch.sh
+++ b/regress/addrmatch.sh
@@ -14,6 +14,9 @@ run_trial()
 	result=`${SSHD} -f $OBJ/sshd_proxy -T \
 	    -C user=${user},addr=${addr},host=${host},laddr=${laddr},lport=${lport} | \
 	    awk '/^forcecommand/ {print $2}'`
+	if [ "$os" == "windows" ]; then
+		result=${result/$'\r'/} # remove CR (carriage return)
+	fi
 	if [ "$result" != "$expected" ]; then
 		fail "failed '$descr' expected $expected got $result"
 	fi
diff --git a/regress/agent-restrict.sh b/regress/agent-restrict.sh
index a30aed7bf..1f3410390 100644
--- a/regress/agent-restrict.sh
+++ b/regress/agent-restrict.sh
@@ -3,6 +3,12 @@
 
 tid="agent restrictions"
 
+if [ "$os" == "windows" ]; then
+	# Not yet implemented
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
+
 SSH_AUTH_SOCK="$OBJ/agent.sock"
 export SSH_AUTH_SOCK
 rm -f $SSH_AUTH_SOCK $OBJ/agent.log $OBJ/host_[abcdex]* $OBJ/user_[abcdex]*
diff --git a/regress/agent-timeout.sh b/regress/agent-timeout.sh
index 6dec09285..9b2f168d1 100644
--- a/regress/agent-timeout.sh
+++ b/regress/agent-timeout.sh
@@ -2,7 +2,10 @@
 #	Placed in the Public Domain.
 
 tid="agent timeout test"
-
+if [ "$os" == "windows" ]; then
+	echo "skipped (not supported on WINDOWS platform)"
+	exit 0
+fi
 SSHAGENT_TIMEOUT=10
 
 trace "start agent"
diff --git a/regress/agent.sh b/regress/agent.sh
index f187b6757..13f0239a7 100644
--- a/regress/agent.sh
+++ b/regress/agent.sh
@@ -21,6 +21,12 @@ if [ $r -ne 0 ]; then
 	fatal "could not start second ssh-agent: exit code $r"
 fi
 
+if [ "$os" == "windows" ]; then
+	#windows ssh-agent doesn't support "-s" option so we need to set SSH_AUTH_SOCK env here.
+	SSH_AUTH_SOCK="\\\\.\\pipe\\openssh-ssh-agent"
+	${SSHADD} -D
+fi
+
 ${SSHADD} -l > /dev/null 2>&1
 if [ $? -ne 1 ]; then
 	fail "ssh-add -l did not fail with exit code 1"
diff --git a/regress/authinfo.sh b/regress/authinfo.sh
index 693424afa..6d9ad8e80 100644
--- a/regress/authinfo.sh
+++ b/regress/authinfo.sh
@@ -3,6 +3,12 @@
 
 tid="authinfo"
 
+if [ "$os" == "windows" ]; then
+	# Windows, ssh.exe -S option is not supported on windows
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
+
 # Ensure the environment variable doesn't leak when ExposeAuthInfo=no.
 verbose "ExposeAuthInfo=no"
 env SSH_USER_AUTH=blah ${SSH} -F $OBJ/ssh_proxy x \
diff --git a/regress/banner.sh b/regress/banner.sh
index a84feb5ad..9347eeddb 100644
--- a/regress/banner.sh
+++ b/regress/banner.sh
@@ -30,9 +30,18 @@ for s in 0 10 100 1000 10000 100000 ; do
 
 	trace "test banner size $s"
 	verbose "test $tid: size $s"
-	( ${SSH} -F $OBJ/ssh_proxy otherhost true 2>$OBJ/banner.out && \
-		cmp $OBJ/banner.in $OBJ/banner.out ) || \
-		fail "banner size $s mismatch"
+	if [ "$os" == "windows" ]; then
+		# For windows, compare files by ignoring line breaks (CR vs CRLF).
+		# CYGWIN created files (banner.in) will have CR.
+		# SSH output files (banner.out) will have CRLF.
+		( ${SSH} -F $OBJ/ssh_proxy otherhost true 2>$OBJ/banner.out && \
+			diff --strip-trailing-cr $OBJ/banner.in $OBJ/banner.out ) || \
+			fail "banner size $s mismatch"
+	else
+		( ${SSH} -F $OBJ/ssh_proxy otherhost true 2>$OBJ/banner.out && \
+			cmp $OBJ/banner.in $OBJ/banner.out ) || \
+			fail "banner size $s mismatch"
+	fi
 done
 
 trace "test suppress banner (-q)"
diff --git a/regress/cert-hostkey.sh b/regress/cert-hostkey.sh
index a3414e1a5..f66d493c1 100644
--- a/regress/cert-hostkey.sh
+++ b/regress/cert-hostkey.sh
@@ -10,6 +10,9 @@ rm -f $OBJ/cert_host_key* $OBJ/host_krl_*
 rsa=0
 types=""
 for i in `$SSH -Q key | maybe_filter_sk`; do
+	if [ "$os" == "windows" ]; then
+		i=${i/$'\r'/} # remove CR (carriage return)
+	fi
 	if [ -z "$types" ]; then
 		types="$i"
 		continue
diff --git a/regress/cert-userkey.sh b/regress/cert-userkey.sh
index 4ea29b7cd..d3bc1d6e6 100644
--- a/regress/cert-userkey.sh
+++ b/regress/cert-userkey.sh
@@ -6,8 +6,13 @@ tid="certified user keys"
 rm -f $OBJ/authorized_keys_$USER $OBJ/user_ca_key* $OBJ/cert_user_key*
 cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
 cp $OBJ/ssh_proxy $OBJ/ssh_proxy_bak
+if [ "$os" == "windows" ]; then
+	# remove CR (carriage return)
+	PLAIN_TYPES=`$SSH -Q key-plain | sed 's/\r$//' | maybe_filter_sk | sed 's/^ssh-dss/ssh-dsa/;s/^ssh-//'`
+else
+	PLAIN_TYPES=`$SSH -Q key-plain | maybe_filter_sk | sed 's/^ssh-dss/ssh-dsa/;s/^ssh-//'`
+fi
 
-PLAIN_TYPES=`$SSH -Q key-plain | maybe_filter_sk | sed 's/^ssh-dss/ssh-dsa/;s/^ssh-//'`
 EXTRA_TYPES=""
 rsa=""
 
diff --git a/regress/cfginclude.sh b/regress/cfginclude.sh
index f5b492f17..9f496f0ea 100644
--- a/regress/cfginclude.sh
+++ b/regress/cfginclude.sh
@@ -86,9 +86,17 @@ _EOF
 trial() {
 	_host="$1"
 	_exp="$2"
+	if [ "$os" == "windows" ]; then
+		# Fix the file permissions (ACLs)
+		OBJ_WIN=`windows_path $OBJ`
+		powershell.exe /c "get-acl $OBJ_WIN/authorized_keys_$USER | set-acl $OBJ_WIN/ssh_config.i.*"
+	fi
 	${REAL_SSH} -F $OBJ/ssh_config.i -G "$_host" > $OBJ/ssh_config.out ||
 		fatal "ssh config parse failed"
 	_got=`grep -i '^hostname ' $OBJ/ssh_config.out | awk '{print $2}'`
+	if [ "$os" == "windows" ]; then
+		_got=`echo $_got | sed 's/\r$//'`  # remove CR (carriage return)
+	fi
 	if test "x$_exp" != "x$_got" ; then
 		fail "host $_host include fail: expected $_exp got $_got"
 	fi
@@ -227,9 +235,18 @@ _EOF
 trial() {
 	_host="$1"
 	_exp="$2"
+	if [ "$os" == "windows" ]; then
+		OBJ_WIN=`windows_path $OBJ`
+		# Fix the file permissions (ACLs)
+		powershell.exe /c "get-acl $OBJ_WIN/authorized_keys_$USER | set-acl $OBJ_WIN/ssh_config.i.*"
+	fi
 	${REAL_SSH} -F $OBJ/ssh_config.i -G "$_host" > $OBJ/ssh_config.out ||
 		fatal "ssh config parse failed"
 	_got=`grep -i '^hostname ' $OBJ/ssh_config.out | awk '{print $2}'`
+	if [ "$os" == "windows" ]; then
+		 # remove CR (carriage return)
+		_got=`echo $_got | sed 's/\r$//'`
+	fi
 	if test "x$_exp" != "x$_got" ; then
 		fail "host $_host include fail: expected $_exp got $_got"
 	fi
diff --git a/regress/cfgmatch.sh b/regress/cfgmatch.sh
index 05a666855..2422b0928 100644
--- a/regress/cfgmatch.sh
+++ b/regress/cfgmatch.sh
@@ -23,19 +23,30 @@ start_client()
 		sleep 1
 		n=`expr $n + 1`
 		if test $n -gt 60; then
-			kill $client_pid
+			if [ "$os" == "windows" ]; then
+				# We can't kill windows process from cygwin / wsl so use "stop-process"
+				powershell.exe /c "stop-process -id $client_pid" >/dev/null 2>&1
+			else
+				kill $client_pid
+			fi
 			fatal "timeout waiting for background ssh"
 		fi
-	done	
+	done
 }
 
 stop_client()
 {
 	pid=`cat $pidfile`
-	if [ ! -z "$pid" ]; then
-		kill $pid
+	if [ "$os" == "windows" ]; then
+		# We can't kill windows process from cygwin / wsl so use "stop-process"
+		powershell.exe /c "stop-process -id $pid" >/dev/null 2>&1
+		powershell.exe /c "stop-process -name sleep" >/dev/null 2>&1
+	else
+		if [ ! -z "$pid" ]; then
+			kill $pid
+		fi
+		wait
 	fi
-	wait
 }
 
 cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
@@ -46,7 +57,13 @@ echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_config
 grep -v AuthorizedKeysFile $OBJ/sshd_proxy_bak > $OBJ/sshd_proxy
 echo "AuthorizedKeysFile /dev/null # comment" >>$OBJ/sshd_proxy
 echo "PermitOpen 127.0.0.1:1" >>$OBJ/sshd_proxy
-echo "Match user $USER" >>$OBJ/sshd_proxy
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+else
+	echo "Match user $USER" >>$OBJ/sshd_proxy
+fi
+
 echo "AuthorizedKeysFile /dev/null $OBJ/authorized_keys_%u" >>$OBJ/sshd_proxy
 echo "Match Address 127.0.0.1 # comment" >>$OBJ/sshd_proxy
 echo "PermitOpen 127.0.0.1:2 127.0.0.1:3 127.0.0.1:$PORT" >>$OBJ/sshd_proxy
@@ -92,7 +109,12 @@ stop_client
 
 cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
 echo "PermitOpen 127.0.0.1:1 127.0.0.1:$PORT 127.0.0.2:2" >>$OBJ/sshd_proxy
-echo "Match User $USER" >>$OBJ/sshd_proxy
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+else
+	echo "Match user $USER" >>$OBJ/sshd_proxy
+fi
 echo "PermitOpen 127.0.0.1:1 127.0.0.1:2" >>$OBJ/sshd_proxy
 
 # Test that a Match overrides a PermitOpen in the global section
@@ -152,6 +174,9 @@ for i in $params; do
 	trace "test spec $spec"
 	result=`${SUDO} ${SSHD} -f $OBJ/sshd_config -T -C "$spec" | \
 	    awk '$1=="banner"{print $2}'`
+	if [ "$os" == "windows" ]; then
+		result=${result/$'\r'/} # remove CR (carriage return)
+	fi
 	if [ "$result" != "$expected" ]; then
 		fail "match $config expected $expected got $result"
 	fi
diff --git a/regress/cfgmatchlisten.sh b/regress/cfgmatchlisten.sh
index a4fd66b32..aef97b710 100644
--- a/regress/cfgmatchlisten.sh
+++ b/regress/cfgmatchlisten.sh
@@ -29,8 +29,12 @@ start_client()
 		sleep 1
 		n=`expr $n + 1`
 		if test $n -gt 60; then
-			kill $client_pid
-			fatal "timeout waiting for background ssh"
+			if [ "$os" == "windows" ]; then
+				powershell.exe /c "stop-process -Id $client_pid -Force" >/dev/null 2>&1
+			else
+				kill $client_pid
+				fatal "timeout waiting for background ssh"
+			fi
 		fi
 	done
 	return $r
@@ -53,10 +57,14 @@ expect_client_fail()
 stop_client()
 {
 	pid=`cat $pidfile`
-	if [ ! -z "$pid" ]; then
-		kill $pid
+	if [ "$os" == "windows" ]; then
+		powershell.exe /c "stop-process -Id $pid -Force" >/dev/null 2>&1
+	else
+		if [ ! -z "$pid" ]; then
+			kill $pid
+		fi
+		wait
 	fi
-	wait
 }
 
 cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
diff --git a/regress/cfgparse.sh b/regress/cfgparse.sh
index a9e5c6b09..060116fb7 100644
--- a/regress/cfgparse.sh
+++ b/regress/cfgparse.sh
@@ -49,11 +49,18 @@ EOD
 [ X${SKIP_IPV6} = Xyes ] || cat >> $OBJ/sshd_config.1 <<EOD
 listenaddress ::1
 EOD
-
-($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
- grep 'listenaddress ' >$OBJ/sshd_config.2 &&
- diff $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
- fail "listenaddress order 1"
+if [ "$os" == "windows" ]; then
+	# Ignore the CR (carriage return) during diff
+	($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
+	 grep 'listenaddress ' >$OBJ/sshd_config.2 &&
+	 diff --strip-trailing-cr $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
+	 fail "listenaddress order 1"
+else
+	($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
+	 grep 'listenaddress ' >$OBJ/sshd_config.2 &&
+	 diff $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
+	 fail "listenaddress order 1"
+fi
 # test 2: listenaddress first
 cat > $OBJ/sshd_config.1 <<EOD
 ${SSHD_KEYS}
@@ -65,11 +72,18 @@ EOD
 [ X${SKIP_IPV6} = Xyes ] || cat >> $OBJ/sshd_config.1 <<EOD
 listenaddress ::1
 EOD
-
-($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
- grep 'listenaddress ' >$OBJ/sshd_config.2 &&
- diff $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
- fail "listenaddress order 2"
+if [ "$os" == "windows" ]; then
+	# Ignore the CR (carriage return) during diff
+	($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
+	 grep 'listenaddress ' >$OBJ/sshd_config.2 &&
+	 diff --strip-trailing-cr $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
+	 fail "listenaddress order 2"
+else
+	($SUDO ${SSHD} -T -f $OBJ/sshd_config.1 | \
+	 grep 'listenaddress ' >$OBJ/sshd_config.2 &&
+	 diff $OBJ/sshd_config.0 $OBJ/sshd_config.2) || \
+	 fail "listenaddress order 2"
+fi
 
 # cleanup
 rm -f $OBJ/sshd_config.[012]
diff --git a/regress/connect.sh b/regress/connect.sh
index 46f12b7b3..cf83da64c 100644
--- a/regress/connect.sh
+++ b/regress/connect.sh
@@ -11,8 +11,10 @@ if [ $? -ne 0 ]; then
 	fail "ssh direct connect failed"
 fi
 
-trace "proxy connect"
-${SSH} -F $OBJ/ssh_config -o "proxycommand $NC %h %p" somehost true
-if [ $? -ne 0 ]; then
-	fail "ssh proxycommand connect failed"
-fi
+if [ "$os" != "windows" ]; then
+	trace "proxy connect"
+	${SSH} -F $OBJ/ssh_config -o "proxycommand $NC %h %p" somehost true
+	if [ $? -ne 0 ]; then
+		fail "ssh proxycommand connect failed"
+	fi
+fi
\ No newline at end of file
diff --git a/regress/dynamic-forward.sh b/regress/dynamic-forward.sh
index 84f8ee192..afca70019 100644
--- a/regress/dynamic-forward.sh
+++ b/regress/dynamic-forward.sh
@@ -3,6 +3,12 @@
 
 tid="dynamic forwarding"
 
+if [ "$os" == "windows" ]; then
+	# Windows, ssh.exe -S option is not supported on windows
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
+
 FWDPORT=`expr $PORT + 1`
 
 if have_prog nc && nc -h 2>&1 | grep "proxy address" >/dev/null; then
diff --git a/regress/envpass.sh b/regress/envpass.sh
index af7eafe3d..bd3305c1e 100644
--- a/regress/envpass.sh
+++ b/regress/envpass.sh
@@ -2,6 +2,11 @@
 #	Placed in the Public Domain.
 
 tid="environment passing"
+if [ "$os" == "windows" ]; then
+	# Windows, ssh client hungs.. To be investigated..
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
 
 # NB accepted env vars are in test-exec.sh (_XXX_TEST_* and _XXX_TEST)
 
diff --git a/regress/exit-status-signal.sh b/regress/exit-status-signal.sh
index 1b3af0d84..cc16876e4 100644
--- a/regress/exit-status-signal.sh
+++ b/regress/exit-status-signal.sh
@@ -11,6 +11,7 @@ ssh_pid=$!
 n=20
 while [ ! -f $OBJ/remote_pid ] && [ $n -gt 0 ]; do
 	n=$(($n - 1))
+	echo "sleep for 1 sec"
 	sleep 1
 done
 
@@ -22,3 +23,6 @@ if [ $exit_code -eq 0 ]; then
 	fail "ssh client should fail on signal"
 fi
 
+if [ "$os" == "windows" ]; then
+	powershell.exe /c "stop-process -name sleep" >/dev/null 2>&1
+fi
\ No newline at end of file
diff --git a/regress/forcecommand.sh b/regress/forcecommand.sh
index e059f1fdb..14bd9d225 100644
--- a/regress/forcecommand.sh
+++ b/regress/forcecommand.sh
@@ -28,7 +28,12 @@ ${SSH} -F $OBJ/ssh_proxy somehost false || fail "forced command in key"
 
 cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
 echo "ForceCommand false" >> $OBJ/sshd_proxy
-echo "Match User $USER" >> $OBJ/sshd_proxy
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	echo "Match user ${USER//\//\\}" >>$OBJ/sshd_proxy
+else
+	echo "Match User $USER" >>$OBJ/sshd_proxy
+fi
 echo "    ForceCommand true" >> $OBJ/sshd_proxy
 
 trace "forced command with match"
diff --git a/regress/forwarding.sh b/regress/forwarding.sh
index a72bd3a05..0aedc1079 100644
--- a/regress/forwarding.sh
+++ b/regress/forwarding.sh
@@ -3,6 +3,12 @@
 
 tid="local and remote forwarding"
 
+if [ "$os" == "windows" ]; then
+	# Windows, ssh.exe -S option is not supported on windows
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
+
 DATA=/bin/ls${EXEEXT}
 
 start_sshd
diff --git a/regress/host-expand.sh b/regress/host-expand.sh
index 9444f7fb6..8d7276cca 100644
--- a/regress/host-expand.sh
+++ b/regress/host-expand.sh
@@ -4,7 +4,14 @@
 tid="expand %h and %n"
 
 echo 'PermitLocalCommand yes' >> $OBJ/ssh_proxy
-printf 'LocalCommand printf "%%%%s\\n" "%%n" "%%h"\n' >> $OBJ/ssh_proxy
+if [ "$os" == "windows" ]; then
+	# Use bash shell for local command execution as the default shell in windows is cmd.exe
+	printf 'LocalCommand ' >> $OBJ/ssh_proxy
+	printf $TEST_SHELL_PATH >> $OBJ/ssh_proxy
+	printf ' -c "printf \\"%%%%s\\n\\" \\"%%n\\" \\"%%h\\""\n' >> $OBJ/ssh_proxy
+else
+	printf 'LocalCommand printf "%%%%s\\n" "%%n" "%%h"\n' >> $OBJ/ssh_proxy
+fi
 
 cat >$OBJ/expect <<EOE
 somehost
diff --git a/regress/hostkey-agent.sh b/regress/hostkey-agent.sh
index 222d424bd..ad674d990 100644
--- a/regress/hostkey-agent.sh
+++ b/regress/hostkey-agent.sh
@@ -6,10 +6,18 @@ tid="hostkey agent"
 rm -f $OBJ/agent-key.* $OBJ/ssh_proxy.orig $OBJ/known_hosts.orig $OBJ/agent-ca*
 
 trace "start agent"
-eval `${SSHAGENT} ${EXTRA_AGENT_ARGS} -s` > /dev/null
-r=$?
-[ $r -ne 0 ] && fatal "could not start ssh-agent: exit code $r"
 
+if [ "$os" == "windows" ]; then
+	# Windows ssh-agent doesn't support "-s" option so we need to set SSH_AUTH_SOCK env here.
+	SSH_AUTH_SOCK="\\\\\\.\\pipe\\openssh-ssh-agent"
+	powershell.exe -c "net start ssh-agent"
+	powershell.exe -c "Get-Process -Name ssh*"
+	${SSHADD} -D
+else
+	eval `${SSHAGENT} ${EXTRA_AGENT_ARGS} -s` > /dev/null
+	r=$?
+	[ $r -ne 0 ] && fatal "could not start ssh-agent: exit code $r"
+fi
 grep -vi 'hostkey' $OBJ/sshd_proxy > $OBJ/sshd_proxy.orig
 echo "HostKeyAgent $SSH_AUTH_SOCK" >> $OBJ/sshd_proxy.orig
 
@@ -49,12 +57,15 @@ for k in $SSH_KEYTYPES ; do
 	fi
 done
 
-SSH_CERTTYPES=`ssh -Q key-sig | grep 'cert-v01@openssh.com'`
+SSH_CERTTYPES=`ssh -Q key-sig | grep 'cert-v01@openssh.com' | maybe_filter_sk`
 
 # Prepare sshd_proxy for certificates.
 cp $OBJ/sshd_proxy.orig $OBJ/sshd_proxy
 HOSTKEYALGS=""
 for k in $SSH_CERTTYPES ; do
+	if [ "$os" == "windows" ]; then
+		k=${k/$'\r'/} # Remove CR (carriage return)
+	fi
 	test -z "$HOSTKEYALGS" || HOSTKEYALGS="${HOSTKEYALGS},"
 	HOSTKEYALGS="${HOSTKEYALGS}${k}"
 done
@@ -83,5 +94,11 @@ for k in $SSH_CERTTYPES ; do
 done
 
 trace "kill agent"
-${SSHAGENT} -k > /dev/null
+if [ "$os" == "windows" ]; then
+	#keys added through ssh-add are stored in windows registry so delete them.
+	${SSHADD} -D
+	powershell.exe -c "net stop ssh-agent"
+else
+	${SSHAGENT} -k > /dev/null
+fi
 
diff --git a/regress/integrity.sh b/regress/integrity.sh
index bc030cb74..0ad886c26 100644
--- a/regress/integrity.sh
+++ b/regress/integrity.sh
@@ -7,10 +7,17 @@ cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
 # start at byte 2900 (i.e. after kex) and corrupt at different offsets
 tries=10
 startoffset=2900
-macs=`${SSH} -Q mac`
+
 # The following are not MACs, but ciphers with integrated integrity. They are
 # handled specially below.
-macs="$macs `${SSH} -Q cipher-auth`"
+if [ "$os" == "windows" ]; then
+	# remove CR (Carriage return)
+	macs=`${SSH} -Q mac | sed 's/\r$//'`
+	macs="$macs `${SSH} -Q cipher-auth | sed 's/\r$//'`"
+else
+	macs=`${SSH} -Q mac`
+	macs="$macs `${SSH} -Q cipher-auth`"
+fi
 
 # avoid DH group exchange as the extra traffic makes it harder to get the
 # offset into the stream right.
@@ -28,7 +35,12 @@ for m in $macs; do
 	etmo=0
 	ecnt=0
 	skip=0
-	for off in `jot $tries $startoffset`; do
+	if [ "$os" == "windows" ]; then
+		offsets=$(seq $startoffset 1 $((startoffset+tries))) # use seq instead of jot
+	else
+		offsets=`jot $tries $startoffset`
+	fi
+	for off in $offsets; do
 		skip=`expr $skip - 1`
 		if [ $skip -gt 0 ]; then
 			# avoid modifying the high bytes of the length
diff --git a/regress/kextype.sh b/regress/kextype.sh
index e27189904..1949eb5ed 100644
--- a/regress/kextype.sh
+++ b/regress/kextype.sh
@@ -8,12 +8,21 @@ cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
 cp $OBJ/ssh_proxy $OBJ/ssh_proxy_bak
 
 # Make server accept all key exchanges.
-ALLKEX=`${SSH} -Q kex`
+
+if [ "$os" == "windows" ]; then
+	# Remove CR (carriage return)
+	ALLKEX=`${SSH} -Q kex | sed 's/\r$//'`
+else
+	ALLKEX=`${SSH} -Q kex`
+fi
 KEXOPT=`echo $ALLKEX | tr ' ' ,`
 echo "KexAlgorithms=$KEXOPT" >> $OBJ/sshd_proxy
 
 tries="1 2 3 4"
 for k in `${SSH} -Q kex`; do
+	if [ "$os" == "windows" ]; then
+		k=${k/$'\r'/} # Remove CR (carriage return)
+	fi
 	verbose "kex $k"
 	for i in $tries; do
 		${SSH} -F $OBJ/ssh_proxy -o KexAlgorithms=$k x true
diff --git a/regress/keygen-comment.sh b/regress/keygen-comment.sh
index af571d390..57c2c10ca 100644
--- a/regress/keygen-comment.sh
+++ b/regress/keygen-comment.sh
@@ -11,7 +11,7 @@ check_fingerprint () {
 	if ! ${SSHKEYGEN} -l -E sha256 -f $file > $OBJ/$t-fgp ; then
 		fail "ssh-keygen -l failed for $t-key"
 	fi
-	if ! egrep "^([0-9]+) SHA256:(.){43} ${comment} \(.*\)\$" \
+	if ! egrep "^([0-9]+) SHA256:(.){43} ${comment} (.*)\$" \
 	    $OBJ/$t-fgp >/dev/null 2>&1 ; then
 		fail "comment is not correctly recovered for $t-key"
 	fi
diff --git a/regress/keygen-convert.sh b/regress/keygen-convert.sh
index 95656581c..95ff26acd 100644
--- a/regress/keygen-convert.sh
+++ b/regress/keygen-convert.sh
@@ -28,7 +28,7 @@ for t in ${SSH_KEYTYPES}; do
 		${SSHKEYGEN} -q -e -f $OBJ/$t-key.pub >$OBJ/$t-key-rfc.pub || \
 		    fail "$t public to rfc4716 public"
 
-		cmp $OBJ/$t-key-rfc $OBJ/$t-key-rfc.pub || \
+		diff --strip-trailing-cr $OBJ/$t-key-rfc $OBJ/$t-key-rfc.pub || \
 		    fail "$t rfc4716 exports differ between public and private"
 
 		trace "import $t rfc4716 public"
@@ -36,7 +36,7 @@ for t in ${SSH_KEYTYPES}; do
 		    fail "$t import rfc4716 public"
 
 		cut -f1,2 -d " " $OBJ/$t-key.pub >$OBJ/$t-key-nocomment.pub
-		cmp $OBJ/$t-key-nocomment.pub $OBJ/$t-rfc-imported || \
+		diff --strip-trailing-cr $OBJ/$t-key-nocomment.pub $OBJ/$t-rfc-imported || \
 		    fail "$t imported differs from original"
 	fi
 
@@ -45,9 +45,16 @@ for t in ${SSH_KEYTYPES}; do
 	    fail "$t set passphrase failed"
 
 	trace "export $t to public with passphrase"
-	SSH_ASKPASS=$OBJ/askpass SSH_ASKPASS_REQUIRE=force \
-	    ${SSHKEYGEN} -y -f $OBJ/$t-key >$OBJ/$t-key-nocomment.pub
-	cmp $OBJ/$t-key.pub $OBJ/$t-key-nocomment.pub || \
+	
+	if [ "$os" == "windows" ]; then
+		SSH_ASKPASS=$TEST_SSH_ASKPASS SSH_ASKPASS_REQUIRE=force ASKPASS_PASSWORD="hunter2" \
+			${SSHKEYGEN} -y -f $OBJ/$t-key >$OBJ/$t-key-nocomment.pub	
+	else
+		SSH_ASKPASS=$OBJ/askpass SSH_ASKPASS_REQUIRE=force \
+			${SSHKEYGEN} -y -f $OBJ/$t-key >$OBJ/$t-key-nocomment.pub
+	fi
+
+	diff --strip-trailing-cr $OBJ/$t-key.pub $OBJ/$t-key-nocomment.pub || \
 	    fail "$t exported pubkey differs from generated"
 
 	rm -f $OBJ/$t-key $OBJ/$t-key.pub $OBJ/$t-key-rfc $OBJ/$t-key-rfc.pub \
diff --git a/regress/keygen-knownhosts.sh b/regress/keygen-knownhosts.sh
index 37af34769..0b1ecf04c 100644
--- a/regress/keygen-knownhosts.sh
+++ b/regress/keygen-knownhosts.sh
@@ -158,47 +158,87 @@ check_hashed_find host-h "find multiple hosts"
 # Attempt remove key on invalid file.
 cp $OBJ/kh.invalid.orig $OBJ/kh.invalid
 ${SSHKEYGEN} -qf $OBJ/kh.invalid -R host-a 2>/dev/null
-diff $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "remove on invalid succeeded"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "remove on invalid succeeded"
+else
+	diff $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "remove on invalid succeeded"
+fi
 
 # Remove key
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -R host-a 2>/dev/null
 grep -v "^host-a " $OBJ/kh.hosts.orig > $OBJ/kh.expect
-diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove simple"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts $OBJ/kh.expect || fail "remove simple"
+else
+	diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove simple"
+fi
 
 # Remove CA key
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -R host-c 2>/dev/null
 # CA key should not be removed.
-diff $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove CA"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove CA"
+else
+	diff $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove CA"
+fi
 
 # Remove revoked key
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -R host-d 2>/dev/null
 # revoked key should not be removed.
-diff $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove revoked"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove revoked"
+else
+	diff $OBJ/kh.hosts $OBJ/kh.hosts.orig || fail "remove revoked"
+fi
 
 # Remove wildcard
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -R host-e.blahblah 2>/dev/null
 grep -v "^host-e[*] " $OBJ/kh.hosts.orig > $OBJ/kh.expect
-diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+else
+	diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+fi
 
 # Remove multiple
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -R host-h 2>/dev/null
 grep -v "^host-f," $OBJ/kh.hosts.orig > $OBJ/kh.expect
-diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+else
+	diff $OBJ/kh.hosts $OBJ/kh.expect || fail "remove wildcard"
+fi
 
 # Attempt hash on invalid file
 cp $OBJ/kh.invalid.orig $OBJ/kh.invalid
 ${SSHKEYGEN} -qf $OBJ/kh.invalid -H 2>/dev/null && fail "hash invalid succeeded"
-diff $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "invalid file modified"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "invalid file modified"
+else
+	diff $OBJ/kh.invalid $OBJ/kh.invalid.orig || fail "invalid file modified"
+fi
 
 # Hash valid file
 cp $OBJ/kh.hosts.orig $OBJ/kh.hosts
 ${SSHKEYGEN} -qf $OBJ/kh.hosts -H 2>/dev/null || fail "hash failed"
-diff $OBJ/kh.hosts.old $OBJ/kh.hosts.orig || fail "backup differs"
+if [ "$os" == "windows" ]; then
+	# Ignore CR (carriage return) while comparing files
+	diff --strip-trailing-cr $OBJ/kh.hosts.old $OBJ/kh.hosts.orig || fail "backup differs"
+else
+	diff $OBJ/kh.hosts.old $OBJ/kh.hosts.orig || fail "backup differs"
+fi
 grep "^host-[abfgh]" $OBJ/kh.hosts && fail "original hostnames persist"
 
 cp $OBJ/kh.hosts $OBJ/kh.hashed.orig
diff --git a/regress/keygen-sshfp.sh b/regress/keygen-sshfp.sh
index 2abf9adec..f056c6351 100644
--- a/regress/keygen-sshfp.sh
+++ b/regress/keygen-sshfp.sh
@@ -5,23 +5,23 @@ tid="keygen-sshfp"
 
 trace "keygen fingerprints"
 fp=`${SSHKEYGEN} -r test -f ${SRC}/ed25519_openssh.pub | \
-    awk '$5=="1"{print $6}'`
+    awk '$5=="1"{print $6}' | sed 's/\r$//'`
 if [ "$fp" != "8a8647a7567e202ce317e62606c799c53d4c121f" ]; then
 	fail "keygen fingerprint sha1"
 fi
 fp=`${SSHKEYGEN} -r test -f ${SRC}/ed25519_openssh.pub | \
-    awk '$5=="2"{print $6}'`
+    awk '$5=="2"{print $6}' | sed 's/\r$//'`
 if [ "$fp" != \
     "54a506fb849aafb9f229cf78a94436c281efcb4ae67c8a430e8c06afcb5ee18f" ]; then
 	fail "keygen fingerprint sha256"
 fi
 
 if ${SSH} -Q key-plain | grep ssh-rsa >/dev/null; then
-	fp=`${SSHKEYGEN} -r test -f ${SRC}/rsa_openssh.pub | awk '$5=="1"{print $6}'`
+	fp=`${SSHKEYGEN} -r test -f ${SRC}/rsa_openssh.pub | awk '$5=="1"{print $6}' | sed 's/\r$//'`
 	if [ "$fp" != "99c79cc09f5f81069cc017cdf9552cfc94b3b929" ]; then
 		fail "keygen fingerprint sha1"
 	fi
-	fp=`${SSHKEYGEN} -r test -f ${SRC}/rsa_openssh.pub | awk '$5=="2"{print $6}'`
+	fp=`${SSHKEYGEN} -r test -f ${SRC}/rsa_openssh.pub | awk '$5=="2"{print $6}' | sed 's/\r$//'`
 	if [ "$fp" != \
 	    "e30d6b9eb7a4de495324e4d5870b8220577993ea6af417e8e4a4f1c5bf01a9b6" ]; then
 		fail "keygen fingerprint sha256"
diff --git a/regress/knownhosts-command.sh b/regress/knownhosts-command.sh
index 8472ec812..1eeeca521 100644
--- a/regress/knownhosts-command.sh
+++ b/regress/knownhosts-command.sh
@@ -10,7 +10,11 @@ cp $OBJ/ssh_proxy $OBJ/ssh_proxy_orig
     grep -vi UserKnownHostsFile;
   echo "GlobalKnownHostsFile none" ;
   echo "UserKnownHostsFile none" ;
+if [ "$os" == "windows" ]; then
+  echo "KnownHostsCommand ${TEST_SHELL_PATH} $OBJ/knownhosts_command '%t' '%K' '%u'" ;
+else
   echo "KnownHostsCommand $OBJ/knownhosts_command '%t' '%K' '%u'" ;
+fi
 ) > $OBJ/ssh_proxy
 
 verbose "simple connection"
@@ -38,6 +42,10 @@ _EOF
 chmod a+x $OBJ/knownhosts_command
 ${SSH} -F $OBJ/ssh_proxy x true && fail "ssh connect succeeded with bad exit"
 
+# replace "redmond/<username>" to "redmond\<username>"
+expected_username="${LOGNAME////\\}"
+echo "expected_username: $expected_username"
+
 for keytype in ${SSH_HOSTKEY_TYPES} ; do
 	algs=$keytype
 	test "x$keytype" = "xssh-dss" && continue
@@ -47,7 +55,7 @@ for keytype in ${SSH_HOSTKEY_TYPES} ; do
 #!/bin/sh
 die() { echo "\$@" 1>&2 ; exit 1; }
 test "x\$1" = "x$keytype" || die "wrong keytype \$1 (expected $keytype)"
-test "x\$3" = "x$LOGNAME" || die "wrong username \$3 (expected $LOGNAME)"
+test "x\$3" = "x$expected_username" || die "wrong username \$3 (expected $expected_username)"
 grep -- "\$1.*\$2" $OBJ/known_hosts
 _EOF
 	${SSH} -F $OBJ/ssh_proxy -oHostKeyAlgorithms=$algs x true ||
diff --git a/regress/krl.sh b/regress/krl.sh
index c381225ed..bf73c9e37 100644
--- a/regress/krl.sh
+++ b/regress/krl.sh
@@ -55,7 +55,12 @@ EOF
 
 # A specification that revokes some certificated by key ID.
 touch $OBJ/revoked-keyid
-for n in 1 2 3 4 10 15 30 50 90 `jot 500 300` 999 1000 1001 1002; do
+if [ "$os" == "windows" ]; then
+    revokedids=$(seq 300 1 $((500+300))) # use seq instead of jot
+else
+    revokedids=`jot 500 300`
+fi
+for n in 1 2 3 4 10 15 30 50 90 $revokedids 999 1000 1001 1002; do
 	test "x$n" = "x499" && continue
 	# Fill in by-ID revocation spec.
 	echo "id: revoked $n" >> $OBJ/revoked-keyid
diff --git a/regress/limit-keytype.sh b/regress/limit-keytype.sh
index 7127de007..e333de9a7 100644
--- a/regress/limit-keytype.sh
+++ b/regress/limit-keytype.sh
@@ -125,8 +125,14 @@ ${SSH} $opts -i $OBJ/user_key2 proxy true || fatal "key2 failed"
 
 # Allow only DSA in main config, Ed25519 for user.
 verbose "match w/ matching"
-prepare_config "PubkeyAcceptedAlgorithms `keytype $ktype4`" \
-	"Match user $USER" "PubkeyAcceptedAlgorithms +`keytype $ktype1`"
+if [ "$os" == "windows" ]; then
+	# If User is domainuser then it will be in "domain/user" so convert it to "domain\user"
+	prepare_config "PubkeyAcceptedAlgorithms `keytype $ktype4`" \
+		"Match user ${USER//\//\\}" "PubkeyAcceptedAlgorithms +`keytype $ktype1`"
+else
+	prepare_config "PubkeyAcceptedAlgorithms `keytype $ktype4`" \
+		"Match user $USER" "PubkeyAcceptedAlgorithms +`keytype $ktype1`"
+fi
 ${SSH} $certopts proxy true || fatal "cert failed"
 ${SSH} $opts -i $OBJ/user_key1 proxy true || fatal "key1 failed"
 ${SSH} $opts -i $OBJ/user_key4 proxy true && fatal "key4 succeeded"
diff --git a/regress/localcommand.sh b/regress/localcommand.sh
index 5224a16b2..c40681f56 100644
--- a/regress/localcommand.sh
+++ b/regress/localcommand.sh
@@ -8,6 +8,11 @@ echo 'LocalCommand echo foo' >> $OBJ/ssh_proxy
 
 verbose "test $tid: proto $p localcommand"
 a=`${SSH} -F $OBJ/ssh_proxy somehost true`
+
+if [ "$os" == "windows" ]; then
+	a=`echo $a | tr -d '\r\n'` # Remove CR (carriage return)
+fi
+
 if [ "$a" != "foo" ] ; then
 	fail "$tid proto $p"
 fi
diff --git a/regress/multiplex.sh b/regress/multiplex.sh
index 4744fa3d9..7a3478e23 100644
--- a/regress/multiplex.sh
+++ b/regress/multiplex.sh
@@ -6,6 +6,12 @@ CTL=${SSH_REGRESS_TMP}/ctl-sock
 
 tid="connection multiplexing"
 
+if [ "$os" == "windows" ]; then
+	# Windows, ssh.exe -S option is not supported on windows
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
+
 trace "will use ProxyCommand $proxycmd"
 if config_defined DISABLE_FD_PASSING ; then
 	echo "skipped (not supported on this platform)"
diff --git a/regress/reconfigure.sh b/regress/reconfigure.sh
index d5b4e9808..166ce0888 100644
--- a/regress/reconfigure.sh
+++ b/regress/reconfigure.sh
@@ -2,7 +2,12 @@
 #	Placed in the Public Domain.
 
 tid="simple connect after reconfigure"
-
+if [ "$os" == "windows" ]; then
+	# In windows, sshd service process will not restart if we kill it.
+	# This test case is not applicable to windows OS.
+	echo "skipped, not applicable on windows OS"
+	exit 0
+fi
 # we need the full path to sshd for -HUP
 if test "x$USE_VALGRIND" = "x" ; then
 	case $SSHD in
diff --git a/regress/reexec.sh b/regress/reexec.sh
index 8966ba524..50ca7e206 100644
--- a/regress/reexec.sh
+++ b/regress/reexec.sh
@@ -43,8 +43,8 @@ stop_sshd
 
 cp $OBJ/sshd_config.orig $OBJ/sshd_config
 
-# cygwin can't fork a deleted binary
-if [ "$os" != "cygwin" ]; then
+# cygwin, windows can't fork a deleted binary
+if [ "$os" != "cygwin" ] && [ "$os" != "windows" ]; then
 
 verbose "test reexec fallback"
 
diff --git a/regress/rekey.sh b/regress/rekey.sh
index 61723cd86..68684c6e8 100644
--- a/regress/rekey.sh
+++ b/regress/rekey.sh
@@ -21,7 +21,11 @@ ssh_data_rekeying()
 	fi
 	rm -f ${COPY} ${LOG}
 	_opts="$_opts -oCompression=no"
-	${SSH} <${DATA} $_opts -v -F $OBJ/ssh_proxy somehost "cat > ${COPY}"
+	if [ "$os" == "windows" ]; then
+		cat ${DATA} | ${SSH} $_opts -v -F $OBJ/ssh_proxy somehost "cat > ${COPY}"
+	else
+		${SSH} <${DATA} $_opts -v -F $OBJ/ssh_proxy somehost "cat > ${COPY}"
+	fi
 	if [ $? -ne 0 ]; then
 		fail "ssh failed ($@)"
 	fi
@@ -70,8 +74,14 @@ done
 for s in 5 10; do
 	verbose "client rekeylimit default ${s}"
 	rm -f ${COPY} ${LOG}
-	${SSH} < ${DATA} -oCompression=no -oRekeyLimit="default $s" -F \
-		$OBJ/ssh_proxy somehost "cat >${COPY};sleep $s;sleep 10"
+	if [ "$os" == "windows" ]; then
+		cat ${DATA} | ${SSH} -oCompression=no -oRekeyLimit="default $s" -F \
+			$OBJ/ssh_proxy somehost "cat >${COPY};sleep $s;sleep 10"
+	else
+		${SSH} < ${DATA} -oCompression=no -oRekeyLimit="default $s" -F \
+			$OBJ/ssh_proxy somehost "cat >${COPY};sleep $s;sleep 10"
+	fi
+
 	if [ $? -ne 0 ]; then
 		fail "ssh failed"
 	fi
@@ -159,7 +169,9 @@ for size in 16 1k 1K 1m 1M 1g 1G 4G 8G; do
 	    awk '/rekeylimit/{print $2}'`
 	s=`$SUDO ${SSHD} -T -o "rekeylimit $size $time" -f $OBJ/sshd_proxy | \
 	    awk '/rekeylimit/{print $3}'`
-
+	if [ "$os" == "windows" ]; then
+		s=${s/$'\r'/} # Remove CR (carriage return)
+	fi
 	if [ "$bytes" != "$b" ]; then
 		fatal "rekeylimit size: expected $bytes bytes got $b"
 	fi
diff --git a/regress/scp-uri.sh b/regress/scp-uri.sh
index 20ac3c89e..006b6baf8 100644
--- a/regress/scp-uri.sh
+++ b/regress/scp-uri.sh
@@ -25,38 +25,48 @@ egrep -v '^	+(Port|User)	+.*$' $OBJ/ssh_config.orig > $OBJ/ssh_config
 
 for mode in scp sftp ; do
 	tag="$tid: $mode mode"
-	if test $mode = scp ; then
-		scpopts="-O -q -S ${OBJ}/scp-ssh-wrapper.scp"
+	# scpopts should be an array to preverse the double quotes
+	if [ "$os" == "windows" ]; then
+		if test $mode = scp ; then
+			scpopts=(-O -q -S "$TEST_SHELL_PATH ${OBJ}/scp-ssh-wrapper.scp")
+		else
+			scpopts=(-s -D ${SFTPSERVER})
+		fi
 	else
-		scpopts="-s -D ${SFTPSERVER}"
+		if test $mode = scp ; then
+			scpopts="-O -q -S ${OBJ}/scp-ssh-wrapper.scp"
+		else
+			scpopts="-s -D ${SFTPSERVER}"
+		fi
 	fi
+
 	verbose "$tag: simple copy local file to remote file"
 	scpclean
-	$SCP $scpopts ${DATA} "scp://${USER}@somehost:${PORT}/${COPY}" || fail "copy failed"
+	$SCP "${scpopts[@]}" ${DATA} "scp://${USER}@somehost:${PORT}/${COPY}" || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy remote file to local file"
 	scpclean
-	$SCP $scpopts "scp://${USER}@somehost:${PORT}/${DATA}" ${COPY} || fail "copy failed"
+	$SCP "${scpopts[@]}" "scp://${USER}@somehost:${PORT}/${DATA}" ${COPY} || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy local file to remote dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts ${COPY} "scp://${USER}@somehost:${PORT}/${DIR}" || fail "copy failed"
+	$SCP "${scpopts[@]}" ${COPY} "scp://${USER}@somehost:${PORT}/${DIR}" || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: simple copy remote file to local dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts "scp://${USER}@somehost:${PORT}/${COPY}" ${DIR} || fail "copy failed"
+	$SCP "${scpopts[@]}" "scp://${USER}@somehost:${PORT}/${COPY}" ${DIR} || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: recursive local dir to remote dir"
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -r ${DIR} "scp://${USER}@somehost:${PORT}/${DIR2}" || fail "copy failed"
+	$SCP "${scpopts[@]}" -r ${DIR} "scp://${USER}@somehost:${PORT}/${DIR2}" || fail "copy failed"
 	for i in $(cd ${DIR} && echo *); do
 		cmp ${DIR}/$i ${DIR2}/$i || fail "corrupted copy"
 	done
@@ -65,7 +75,7 @@ for mode in scp sftp ; do
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -r "scp://${USER}@somehost:${PORT}/${DIR}" ${DIR2} || fail "copy failed"
+	$SCP "${scpopts[@]}" -r "scp://${USER}@somehost:${PORT}/${DIR}" ${DIR2} || fail "copy failed"
 	for i in $(cd ${DIR} && echo *); do
 		cmp ${DIR}/$i ${DIR2}/$i || fail "corrupted copy"
 	done
diff --git a/regress/scp.sh b/regress/scp.sh
index 358a8df66..63bfa88d5 100644
--- a/regress/scp.sh
+++ b/regress/scp.sh
@@ -29,70 +29,80 @@ scpclean() {
 
 for mode in scp sftp ; do
 	tag="$tid: $mode mode"
-	if test $mode = scp ; then
-		scpopts="-O -q -S ${OBJ}/scp-ssh-wrapper.scp"
+	# scpopts should be an array to preverse the double quotes
+	if [ "$os" == "windows" ]; then
+		if test $mode = scp ; then
+			scpopts=(-O -q -S "$TEST_SHELL_PATH ${OBJ}/scp-ssh-wrapper.scp")
+		else
+			scpopts=(-s -D ${SFTPSERVER})
+		fi
 	else
-		scpopts="-s -D ${SFTPSERVER}"
+		if test $mode = scp ; then
+			scpopts="-O -q -S ${OBJ}/scp-ssh-wrapper.scp"
+		else
+			scpopts="-s -D ${SFTPSERVER}"
+		fi	
 	fi
+
 	verbose "tid: simple copy local file to local file"
 	scpclean
-	$SCP $scpopts ${DATA} ${COPY} || fail "copy failed"
+	$SCP "${scpopts[@]}" ${DATA} ${COPY} 2>&1 1>/dev/null || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy local file to remote file"
 	scpclean
-	$SCP $scpopts ${DATA} somehost:${COPY} || fail "copy failed"
+	$SCP "${scpopts[@]}" ${DATA} somehost:${COPY} || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy remote file to local file"
 	scpclean
-	$SCP $scpopts somehost:${DATA} ${COPY} || fail "copy failed"
+	$SCP "${scpopts[@]}" somehost:${DATA} ${COPY} || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy local file to remote dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts ${COPY} somehost:${DIR} || fail "copy failed"
+	$SCP "${scpopts[@]}" ${COPY} somehost:${DIR} || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: simple copy local file to local dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts ${COPY} ${DIR} || fail "copy failed"
+	$SCP "${scpopts[@]}" ${COPY} ${DIR} 2>&1 1>/dev/null || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: simple copy remote file to local dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts somehost:${COPY} ${DIR} || fail "copy failed"
+	$SCP "${scpopts[@]}" somehost:${COPY} ${DIR} || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: recursive local dir to remote dir"
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -r ${DIR} somehost:${DIR2} || fail "copy failed"
+	$SCP "${scpopts[@]}" -r ${DIR} somehost:${DIR2} || fail "copy failed"
 	diff ${DIFFOPT} ${DIR} ${DIR2} || fail "corrupted copy"
 
 	verbose "$tag: recursive local dir to local dir"
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -r ${DIR} ${DIR2} || fail "copy failed"
+	$SCP "${scpopts[@]}" -r ${DIR} ${DIR2} 2>&1 1>/dev/null || fail "copy failed"
 	diff ${DIFFOPT} ${DIR} ${DIR2} || fail "corrupted copy"
 
 	verbose "$tag: recursive remote dir to local dir"
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -r somehost:${DIR} ${DIR2} || fail "copy failed"
+	$SCP "${scpopts[@]}" -r somehost:${DIR} ${DIR2} || fail "copy failed"
 	diff ${DIFFOPT} ${DIR} ${DIR2} || fail "corrupted copy"
 
 	verbose "$tag: shell metacharacters"
 	scpclean
 	(cd ${DIR} && \
 	 touch '`touch metachartest`' && \
-	 $SCP $scpopts *metachar* ${DIR2} 2>/dev/null; \
+	 $SCP "${scpopts[@]}" *metachar* ${DIR2} 2>&1 2>/dev/null; \
 	 [ ! -f metachartest ] ) || fail "shell metacharacters"
 
 	if [ ! -z "$SUDO" ]; then
@@ -103,7 +113,7 @@ for mode in scp sftp ; do
 		cp ${DATA} ${DIR2}/copy
 		chmod 660 ${DIR2}/copy
 		$SUDO chown root ${DIR2}/copy
-		$SCP -p $scpopts somehost:${DIR}/\* ${DIR2} >/dev/null 2>&1
+		$SCP -p "${scpopts[@]}" somehost:${DIR}/\* ${DIR2} >/dev/null 2>&1
 		$SUDO diff ${DIFFOPT} ${DIR} ${DIR2} || fail "corrupted copy"
 		$SUDO rm ${DIR2}/copy
 	fi
@@ -113,20 +123,20 @@ for mode in scp sftp ; do
 		SCPTESTMODE=badserver_$i
 		export DIR SCPTESTMODE
 		scpclean
-		$SCP $scpopts somehost:${DATA} ${DIR} >/dev/null 2>/dev/null
+		$SCP "${scpopts[@]}" somehost:${DATA} ${DIR} >/dev/null 2>/dev/null
 		[ -d {$DIR}/rootpathdir ] && fail "allows dir relative to root dir"
 		[ -d ${DIR}/dotpathdir ] && fail "allows dir creation in non-recursive mode"
 
 		scpclean
-		$SCP -r $scpopts somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
+		$SCP -r "${scpopts[@]}" somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
 		[ -d ${DIR}/dotpathdir ] && fail "allows dir creation outside of subdir"
 
 		scpclean
-		$SCP -pr $scpopts somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
+		$SCP -pr "${scpopts[@]}" somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
 		[ ! -w ${DIR2} ] && fail "allows target root attribute change"
 
 		scpclean
-		$SCP $scpopts somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
+		$SCP "${scpopts[@]}" somehost:${DATA} ${DIR2} >/dev/null 2>/dev/null
 		[ -e ${DIR2}/extrafile ] && fail "allows unauth object creation"
 		rm -f ${DIR2}/extrafile
 	done
@@ -135,7 +145,7 @@ for mode in scp sftp ; do
 	scpclean
 	echo a > ${COPY}
 	echo b > ${COPY2}
-	$SCP $scpopts ${DATA} ${COPY} ${COPY2}
+	$SCP "${scpopts[@]}" ${DATA} ${COPY} ${COPY2}
 	cmp ${COPY} ${COPY2} >/dev/null && fail "corrupt target"
 done
 
diff --git a/regress/scp3.sh b/regress/scp3.sh
index f71b15677..dd1795d82 100644
--- a/regress/scp3.sh
+++ b/regress/scp3.sh
@@ -21,30 +21,40 @@ scpclean() {
 }
 
 for mode in scp sftp ; do
-	scpopts="-F${OBJ}/ssh_proxy -S ${SSH} -q"
 	tag="$tid: $mode mode"
-	if test $mode = scp ; then
-		scpopts="$scpopts -O"
+
+	# scpopts should be an array to preverse the double quotes
+	if [ "$os" == "windows" ]; then
+		if test $mode = scp ; then
+			scpopts=(-F${OBJ}/ssh_proxy -S "$TEST_SHELL_PATH ${SSH}" -q -O)
+		else
+			scpopts=(-s -D ${SFTPSERVER})
+		fi
 	else
-		scpopts="-s -D ${SFTPSERVER}"
+		scpopts="-F${OBJ}/ssh_proxy -S ${SSH} -q"
+		if test $mode = scp ; then
+			scpopts="$scpopts -O"
+		else
+			scpopts="-s -D ${SFTPSERVER}"
+		fi
 	fi
 
 	verbose "$tag: simple copy remote file to remote file"
 	scpclean
-	$SCP $scpopts -3 hostA:${DATA} hostB:${COPY} || fail "copy failed"
+	$SCP "${scpopts[@]}" -3 hostA:${DATA} hostB:${COPY} || fail "copy failed"
 	cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 	verbose "$tag: simple copy remote file to remote dir"
 	scpclean
 	cp ${DATA} ${COPY}
-	$SCP $scpopts -3 hostA:${COPY} hostB:${DIR} || fail "copy failed"
+	$SCP "${scpopts[@]}" -3 hostA:${COPY} hostB:${DIR} || fail "copy failed"
 	cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 	verbose "$tag: recursive remote dir to remote dir"
 	scpclean
 	rm -rf ${DIR2}
 	cp ${DATA} ${DIR}/copy
-	$SCP $scpopts -3r hostA:${DIR} hostB:${DIR2} || fail "copy failed"
+	$SCP "${scpopts[@]}" -3r hostA:${DIR} hostB:${DIR2} || fail "copy failed"
 	diff -r ${DIR} ${DIR2} || fail "corrupted copy"
 	diff -r ${DIR2} ${DIR} || fail "corrupted copy"
 
@@ -52,7 +62,7 @@ for mode in scp sftp ; do
 	scpclean
 	echo a > ${COPY}
 	echo b > ${COPY2}
-	$SCP $scpopts -3 hostA:${DATA} hostA:${COPY} hostB:${COPY2}
+	$SCP "${scpopts[@]}" -3 hostA:${DATA} hostA:${COPY} hostB:${COPY2}
 	cmp ${COPY} ${COPY2} >/dev/null && fail "corrupt target"
 done
 
diff --git a/regress/servcfginclude.sh b/regress/servcfginclude.sh
index 518a703d1..eebbe4cd9 100644
--- a/regress/servcfginclude.sh
+++ b/regress/servcfginclude.sh
@@ -90,6 +90,9 @@ trial() {
 	    -C "host=$_host,user=test,addr=127.0.0.1" > $OBJ/sshd_config.out ||
 		fatal "ssh config parse failed: $_desc host=$_host expect=$_exp"
 	_got=`grep -i '^banner ' $OBJ/sshd_config.out | awk '{print $2}'`
+	if [ "$os" == "windows" ]; then
+		_got=`echo $_got | tr -d '\r'`  # remove \r
+	fi
 	if test "x$_exp" != "x$_got" ; then
 		fail "$desc_ host $_host include fail: expected $_exp got $_got"
 	fi
@@ -180,6 +183,11 @@ ${SUDO} ${REAL_SSHD} -f $OBJ/sshd_config.i -T \
     -C "host=x,user=test,addr=127.0.0.1" > $OBJ/sshd_config.out || \
 	fail "failed to parse Port after included files"
 _port=`grep -i '^port ' $OBJ/sshd_config.out | awk '{print $2}'`
+
+if [ "$os" == "windows" ]; then
+	_port=`echo $_port | tr -d '\r','\n'`  # remove \r\n
+fi
+
 if test "x7722" != "x$_port" ; then
 	fail "The Port in included file was intertepretted wrongly. Expected 7722, got $_port"
 fi
diff --git a/regress/sftp-cmds.sh b/regress/sftp-cmds.sh
index 1289c4089..6f8ae841a 100644
--- a/regress/sftp-cmds.sh
+++ b/regress/sftp-cmds.sh
@@ -20,7 +20,11 @@ QUOTECOPY=${COPY}".\"blah\""
 QUOTECOPY_ARG=${COPY}'.\"blah\"'
 # File with spaces
 SPACECOPY="${COPY} this has spaces.txt"
-SPACECOPY_ARG="${COPY}\ this\ has\ spaces.txt"
+if [ "$os" == "windows" ]; then
+    SPACECOPY_ARG="\"${COPY} this has spaces.txt\""
+else
+    SPACECOPY_ARG="${COPY}\ this\ has\ spaces.txt"
+fi
 # File with glob metacharacters
 GLOBMETACOPY="${COPY} [metachar].txt"
 
@@ -77,6 +81,7 @@ echo "get \"$DATA\" $COPY" | ${SFTP} -D ${SFTPSERVER} >/dev/null 2>&1 \
 	|| fail "get failed"
 cmp $DATA ${COPY} || fail "corrupted copy after get"
 
+if [ "$os" != "windows" ]; then
 rm -f ${QUOTECOPY}
 cp $DATA ${QUOTECOPY}
 verbose "$tid: get filename with quotes"
@@ -84,6 +89,7 @@ echo "get \"$QUOTECOPY_ARG\" ${COPY}" | ${SFTP} -D ${SFTPSERVER} >/dev/null 2>&1
 	|| fail "get failed"
 cmp ${COPY} ${QUOTECOPY} || fail "corrupted copy after get with quotes"
 rm -f ${QUOTECOPY} ${COPY}
+fi
 
 rm -f "$SPACECOPY" ${COPY}
 cp $DATA "$SPACECOPY"
@@ -134,11 +140,13 @@ echo "put $DATA $COPY" | \
 	${SFTP} -D ${SFTPSERVER} >/dev/null 2>&1 || fail "put failed"
 cmp $DATA ${COPY} || fail "corrupted copy after put"
 
+if [ "$os" != "windows" ]; then
 rm -f ${QUOTECOPY}
 verbose "$tid: put filename with quotes"
 echo "put $DATA \"$QUOTECOPY_ARG\"" | \
 	${SFTP} -D ${SFTPSERVER} >/dev/null 2>&1 || fail "put failed"
 cmp $DATA ${QUOTECOPY} || fail "corrupted copy after put with quotes"
+fi
 
 rm -f "$SPACECOPY"
 verbose "$tid: put filename with spaces"
diff --git a/regress/sftp-glob.sh b/regress/sftp-glob.sh
index 8d4df2c98..827c4fd14 100644
--- a/regress/sftp-glob.sh
+++ b/regress/sftp-glob.sh
@@ -57,12 +57,15 @@ test "x$nobs" = "x" && touch "${QSLASH}" "${ESLASH}" "${SLASH}"
 #       target                   message                expected     unexpected
 sftp_ls "${DIR}/fil*"            "file glob"            "${DATA}"    ""
 sftp_ls "${BASE}/d*"             "dir glob"             "`basename ${DATA}`" ""
-sftp_ls "${DIR}/g-wild\"*\""     "quoted glob"          "g-wild*"    "g-wildx"
-sftp_ls "${DIR}/g-wild\*"        "escaped glob"         "g-wild*"    "g-wildx"
-sftp_ls "${DIR}/g-quote\\\""     "escaped quote"        "g-quote\""  ""
-sftp_ls "\"${DIR}/g-quote\\\"\"" "quoted quote"         "g-quote\""  ""
-sftp_ls "'${DIR}/g-quote\"'"     "single-quoted quote"  "g-quote\""  ""
-sftp_ls "${DIR}/g-q\\ space"     "escaped space"        "g-q space"  ""
+if [ "$os" != "windows" ]; then
+    sftp_ls "${DIR}/g-wild\"*\""     "quoted glob"          "g-wild*"    "g-wildx"
+    sftp_ls "${DIR}/g-wild\*"        "escaped glob"         "g-wild*"    "g-wildx"
+    sftp_ls "${DIR}/g-quote\\\""     "escaped quote"        "g-quote\""  ""
+    sftp_ls "\"${DIR}/g-quote\\\"\"" "quoted quote"         "g-quote\""  ""
+    sftp_ls "'${DIR}/g-quote\"'"     "single-quoted quote"  "g-quote\""  ""
+    sftp_ls "${DIR}/g-q\\ space"     "escaped space"        "g-q space"  ""
+fi
+
 sftp_ls "'${DIR}/g-q space'"     "quoted space"         "g-q space"  ""
 sftp_ls "${DIR}/g-sl\\\\ash"     "escaped slash"        "g-sl\\ash"  "" "$nobs"
 sftp_ls "'${DIR}/g-sl\\\\ash'"   "quoted slash"         "g-sl\\ash"  "" "$nobs"
diff --git a/regress/sftp-perm.sh b/regress/sftp-perm.sh
index de96a14da..f7a43c405 100644
--- a/regress/sftp-perm.sh
+++ b/regress/sftp-perm.sh
@@ -14,7 +14,11 @@ prepare_server() {
 }
 
 run_client() {
-	echo "$@" | ${SFTP} -D ${TEST_SFTP_SERVER} -vvvb - >$CLIENT_LOG 2>&1
+	if [ "$os" == "windows" ]; then
+		echo "$@" | ${SFTP} -D "$TEST_SHELL_PATH ${TEST_SFTP_SERVER}" -vvvb - >$CLIENT_LOG 2>&1
+	else
+		echo "$@" | ${SFTP} -D ${TEST_SFTP_SERVER} -vvvb - >$CLIENT_LOG 2>&1
+	fi
 }
 
 prepare_files() {
@@ -22,6 +26,10 @@ prepare_files() {
 	rm -f ${COPY} ${COPY}.1
 	test -d ${COPY}.dd && { rmdir ${COPY}.dd || fatal "rmdir ${COPY}.dd"; }
 	test -z "$_prep" && return
+	if [ "$os" == "windows" ]; then
+		# Remove starting, ending double-quotes
+		_prep=`echo $_prep | sed -e 's/^"//' -e 's/"$//'`
+	fi
 	sh -c "$_prep" || fail "preparation failed: \"$_prep\""
 }
 
@@ -88,12 +96,21 @@ ro_test \
 	"cmp $DATA $COPY" \
 	"test ! -f $COPY"
 
-ro_test \
-	"setstat" \
-	"chmod 0700 $COPY" \
-	"touch $COPY; chmod 0400 $COPY" \
-	"test -x $COPY" \
-	"test ! -x $COPY"
+if [ "$os" == "windows" ]; then
+	ro_test \
+		"setstat" \
+		"chmod 0700 $COPY" \
+		"\"powershell.exe /c new-item `windows_path $OBJ`/copy 1>/dev/null; powershell.exe /c set-itemproperty `windows_path $OBJ`/copy -Name IsReadOnly -Value 1\"" \
+		"powershell.exe /c \"(Get-ChildItem `windows_path $OBJ`/copy).IsReadOnly\" 1>/dev/null" \
+		"powershell.exe /c \"!(Get-ChildItem $`windows_path $OBJ`/copy).IsReadOnly\" 1>/dev/null"
+else
+	ro_test \
+		"setstat" \
+		"chmod 0700 $COPY" \
+		"touch $COPY; chmod 0400 $COPY" \
+		"test -x $COPY" \
+		"test ! -x $COPY"
+fi
 
 ro_test \
 	"rm" \
@@ -188,13 +205,23 @@ perm_test \
 	"realpath,opendir,stat,lstat" \
 	"ls -ln $OBJ"
 
-perm_test \
-	"setstat" \
-	"realpath,stat,lstat" \
-	"chmod 0700 $COPY" \
-	"touch $COPY; chmod 0400 $COPY" \
-	"test -x $COPY" \
-	"test ! -x $COPY"
+if [ "$os" == "windows" ]; then
+	perm_test \
+		"setstat" \
+		"realpath,stat,lstat" \
+		"chmod 0700 $COPY" \
+		"\"powershell.exe /c new-item `windows_path $OBJ`/copy 1>/dev/null; powershell.exe /c set-itemproperty `windows_path $OBJ`/copy -Name IsReadOnly -Value 1\"" \
+		"powershell.exe /c \"(Get-ChildItem `windows_path $OBJ`/copy).IsReadOnly\" 1>/dev/null" \
+		"powershell.exe /c \"!(Get-ChildItem `windows_path $OBJ`/copy).IsReadOnly\" 1>/dev/null"
+else
+	perm_test \
+		"setstat" \
+		"realpath,stat,lstat" \
+		"chmod 0700 $COPY" \
+		"touch $COPY; chmod 0400 $COPY" \
+		"test -x $COPY" \
+		"test ! -x $COPY"
+fi
 
 perm_test \
 	"remove" \
diff --git a/regress/sftp-uri.sh b/regress/sftp-uri.sh
index 7be104dfb..1cf3be103 100644
--- a/regress/sftp-uri.sh
+++ b/regress/sftp-uri.sh
@@ -23,18 +23,18 @@ egrep -v '^	+(Port|User)	+.*$' $OBJ/ssh_config.orig > $OBJ/ssh_config
 
 verbose "$tid: non-interactive fetch to local file"
 sftpclean
-${SFTP} -q -S "$SSH" -F $OBJ/ssh_config "sftp://${USER}@somehost:${PORT}/${DATA}" ${COPY} || fail "copy failed"
+${SFTP} -q -S "$TEST_SHELL_PATH $SSH" -F $OBJ/ssh_config "sftp://${USER}@somehost:${PORT}/${DATA}" ${COPY} || fail "copy failed"
 cmp ${DATA} ${COPY} || fail "corrupted copy"
 
 verbose "$tid: non-interactive fetch to local dir"
 sftpclean
 cp ${DATA} ${COPY}
-${SFTP} -q -S "$SSH" -F $OBJ/ssh_config "sftp://${USER}@somehost:${PORT}/${COPY}" ${DIR} || fail "copy failed"
+${SFTP} -q -S "$TEST_SHELL_PATH $SSH" -F $OBJ/ssh_config "sftp://${USER}@somehost:${PORT}/${COPY}" ${DIR} || fail "copy failed"
 cmp ${COPY} ${DIR}/copy || fail "corrupted copy"
 
 verbose "$tid: put to remote directory (trailing slash)"
 sftpclean
-${SFTP} -q -S "$SSH" -F $OBJ/ssh_config -b - \
+${SFTP} -q -S "$TEST_SHELL_PATH $SSH" -F $OBJ/ssh_config -b - \
     "sftp://${USER}@somehost:${PORT}/${DIR}/" > /dev/null 2>&1 << EOF
 	version
 	put ${DATA} copy
@@ -48,7 +48,7 @@ fi
 
 verbose "$tid: put to remote directory (no slash)"
 sftpclean
-${SFTP} -q -S "$SSH" -F $OBJ/ssh_config -b - \
+${SFTP} -q -S "$TEST_SHELL_PATH $SSH" -F $OBJ/ssh_config -b - \
     "sftp://${USER}@somehost:${PORT}/${DIR}" > /dev/null 2>&1 << EOF
 	version
 	put ${DATA} copy
diff --git a/regress/sshcfgparse.sh b/regress/sshcfgparse.sh
index 504853d32..bf6971ebe 100644
--- a/regress/sshcfgparse.sh
+++ b/regress/sshcfgparse.sh
@@ -36,49 +36,91 @@ verbose "reparse minimal config"
 
 verbose "ssh -W opts"
 f=`${SSH} -GF $OBJ/ssh_config host | awk '/exitonforwardfailure/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "no" || fail "exitonforwardfailure default"
 f=`${SSH} -GF $OBJ/ssh_config -W a:1 h | awk '/exitonforwardfailure/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "yes" || fail "exitonforwardfailure enable"
 f=`${SSH} -GF $OBJ/ssh_config -W a:1 -o exitonforwardfailure=no h | \
     awk '/exitonforwardfailure/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "no" || fail "exitonforwardfailure override"
 
 f=`${SSH} -GF $OBJ/ssh_config host | awk '/clearallforwardings/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "no" || fail "clearallforwardings default"
 f=`${SSH} -GF $OBJ/ssh_config -W a:1 h | awk '/clearallforwardings/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "yes" || fail "clearallforwardings enable"
 f=`${SSH} -GF $OBJ/ssh_config -W a:1 -o clearallforwardings=no h | \
     awk '/clearallforwardings/{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "no" || fail "clearallforwardings override"
 
 verbose "user first match"
 user=`awk '$1=="User" {print $2}' $OBJ/ssh_config`
 f=`${SSH} -GF $OBJ/ssh_config host | awk '/^user /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "$user" || fail "user from config, expected '$user' got '$f'"
 f=`${SSH} -GF $OBJ/ssh_config -o user=foo -l bar baz@host | awk '/^user /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "foo" || fail "user first match -oUser, expected 'foo' got '$f' "
 f=`${SSH} -GF $OBJ/ssh_config -lbar baz@host user=foo baz@host | awk '/^user /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "bar" || fail "user first match -l, expected 'bar' got '$f'"
 f=`${SSH} -GF $OBJ/ssh_config baz@host -o user=foo -l bar baz@host | awk '/^user /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 test "$f" = "baz" || fail "user first match user@host, expected 'baz' got '$f'"
 
 verbose "pubkeyacceptedalgorithms"
 # Default set
 f=`${SSH} -GF none host | awk '/^pubkeyacceptedalgorithms /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "ssh-ed25519" "ssh-ed25519-cert-v01.*"
 expect_result_absent "$f" "ssh-dss"
 # Explicit override
 f=`${SSH} -GF none -opubkeyacceptedalgorithms=ssh-ed25519 host | \
     awk '/^pubkeyacceptedalgorithms /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "ssh-ed25519"
 expect_result_absent "$f" "ssh-ed25519-cert-v01.*" "ssh-dss"
 # Removal from default set
 f=`${SSH} -GF none -opubkeyacceptedalgorithms=-ssh-ed25519-cert* host | \
     awk '/^pubkeyacceptedalgorithms /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "ssh-ed25519"
 expect_result_absent "$f" "ssh-ed25519-cert-v01.*" "ssh-dss"
 f=`${SSH} -GF none -opubkeyacceptedalgorithms=-ssh-ed25519 host | \
     awk '/^pubkeyacceptedalgorithms /{print $2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "ssh-ed25519-cert-v01.*"
 expect_result_absent "$f" "ssh-ed25519" "ssh-dss"
 # Append to default set.
@@ -86,22 +128,40 @@ expect_result_absent "$f" "ssh-ed25519" "ssh-dss"
 if [ "$dsa" = "1" ]; then
 	f=`${SSH} -GF none -opubkeyacceptedalgorithms=+ssh-dss-cert* host | \
 	    awk '/^pubkeyacceptedalgorithms /{print $2}'`
+	if [ "$os" == "windows" ]; then
+		f=${f/$'\r'/} # remove CR (carriage return)
+	fi
 	expect_result_present "$f" "ssh-ed25519" "ssh-dss-cert-v01.*"
 	expect_result_absent "$f" "ssh-dss"
 	f=`${SSH} -GF none -opubkeyacceptedalgorithms=+ssh-dss host | \
 	    awk '/^pubkeyacceptedalgorithms /{print $2}'`
+	if [ "$os" == "windows" ]; then
+		f=${f/$'\r'/} # remove CR (carriage return)
+	fi
 	expect_result_present "$f" "ssh-ed25519" "ssh-ed25519-cert-v01.*" "ssh-dss"
 	expect_result_absent "$f" "ssh-dss-cert-v01.*"
 fi
 
 verbose "agentforwarding"
 f=`${SSH} -GF none host | awk '/^forwardagent /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "no"
 f=`${SSH} -GF none -oforwardagent=no host | awk '/^forwardagent /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "no"
 f=`${SSH} -GF none -oforwardagent=yes host | awk '/^forwardagent /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "yes"
 f=`${SSH} -GF none '-oforwardagent=SSH_AUTH_SOCK.forward' host | awk '/^forwardagent /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "SSH_AUTH_SOCK.forward"
 
 verbose "command line override"
@@ -111,8 +171,14 @@ Host *
     TunnelDevice 1:2
 EOD
 f=`${SSH} -GF $OBJ/ssh_config.0 -oipqos=cs1 host | awk '/^ipqos /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "cs1"
 f=`${SSH} -GF $OBJ/ssh_config.0 -otunneldevice=3:4 host | awk '/^tunneldevice /{print$2}'`
+if [ "$os" == "windows" ]; then
+	f=${f/$'\r'/} # remove CR (carriage return)
+fi
 expect_result_present "$f" "3:4"
 
 # cleanup
diff --git a/regress/sshsig.sh b/regress/sshsig.sh
index d4daa5c9d..97b9b360a 100644
--- a/regress/sshsig.sh
+++ b/regress/sshsig.sh
@@ -85,7 +85,7 @@ for t in $SIGNKEYS; do
 		< $DATA | cut -d' ' -f1-2 > ${OBJ}/${keybase}-fromsig.pub || \
 		fail "failed signature for $t key w/ print-pubkey"
 	cut -d' ' -f1-2 ${OBJ}/${keybase}.pub > ${OBJ}/${keybase}-strip.pub
-	diff -r ${OBJ}/${keybase}-strip.pub ${OBJ}/${keybase}-fromsig.pub || \
+	diff --strip-trailing-cr -r ${OBJ}/${keybase}-strip.pub ${OBJ}/${keybase}-fromsig.pub || \
 		fail "print-pubkey differs from signature key"
 
 	# Invalid option
diff --git a/regress/test-exec.sh b/regress/test-exec.sh
index 9fb02d1cb..8077e7096 100644
--- a/regress/test-exec.sh
+++ b/regress/test-exec.sh
@@ -40,34 +40,40 @@ fi
 unset SSH_AUTH_SOCK
 
 # Portable-specific settings.
-
-if [ -x /usr/ucb/whoami ]; then
-	USER=`/usr/ucb/whoami`
-elif whoami >/dev/null 2>&1; then
-	USER=`whoami`
-elif logname >/dev/null 2>&1; then
-	USER=`logname`
+if [ "x$TEST_WINDOWS_SSH" != "x" ]; then
+	os="windows"
+	USER=$TEST_SSH_USER
+	USER_DOMAIN=$TEST_SSH_USER_DOMAIN
+	LOGNAME=$USER
 else
-	USER=`id -un`
-fi
-if test -z "$LOGNAME"; then
-	LOGNAME="${USER}"
-	export LOGNAME
-fi
-
-# Unbreak GNU head(1)
-_POSIX2_VERSION=199209
-export _POSIX2_VERSION
+	if [ -x /usr/ucb/whoami ]; then
+		USER=`/usr/ucb/whoami`
+	elif whoami >/dev/null 2>&1; then
+		USER=`whoami`
+	elif logname >/dev/null 2>&1; then
+		USER=`logname`
+	else
+		USER=`id -un`
+	fi
+	if test -z "$LOGNAME"; then
+		LOGNAME="${USER}"
+		export LOGNAME
+	fi
 
-case `uname -s 2>/dev/null` in
-OSF1*)
-	BIN_SH=xpg4
-	export BIN_SH
-	;;
-CYGWIN*)
-	os=cygwin
-	;;
-esac
+	# Unbreak GNU head(1)
+	_POSIX2_VERSION=199209
+	export _POSIX2_VERSION
+
+	case `uname -s 2>/dev/null` in
+	OSF1*)
+		BIN_SH=xpg4
+		export BIN_SH
+		;;
+	CYGWIN*)
+		os=cygwin
+		;;
+	esac
+fi
 
 # If configure tells us to use a different egrep, create a wrapper function
 # to call it.  This means we don't need to change all the tests that depend
@@ -260,6 +266,7 @@ fi
 # to use -q so we remove those to preserve our debug logging.  In the rare
 # instance where -q is desirable -qq is equivalent and is not removed.
 SSHLOGWRAP=$OBJ/ssh-log-wrapper.sh
+# BALU todo - check if we need to pass -T flag
 cat >$SSHLOGWRAP <<EOD
 #!/bin/sh
 echo "Executing: ${SSH} \$@" >>${TEST_SSH_LOGFILE}
@@ -282,6 +289,9 @@ cat ${SSHAGENT_BIN} >${DATA}
 chmod u+w ${DATA}
 COPY=$OBJ/copy
 rm -f ${COPY}
+if [ "$os" == "windows" ]; then
+	EXEEXT=".exe"
+fi
 
 increase_datafile_size()
 {
@@ -296,6 +306,11 @@ export SSH_PKCS11_HELPER SSH_SK_HELPER
 #echo $SSH $SSHD $SSHAGENT $SSHADD $SSHKEYGEN $SSHKEYSCAN $SFTP $SFTPSERVER $SCP
 
 # Portable specific functions
+windows_path()
+{
+	cygpath -m $1
+}
+
 have_prog()
 {
 	saved_IFS="$IFS"
@@ -359,36 +374,48 @@ fi
 
 make_tmpdir ()
 {
-	SSH_REGRESS_TMP="$($OBJ/mkdtemp openssh-XXXXXXXX)" || \
-	    fatal "failed to create temporary directory"
+	if [ "$os" == "windows" ]; then
+		powershell.exe /c "New-Item -Path $OBJ\openssh-XXXXXXXX -ItemType Directory -Force" >/dev/null 2>&1
+		if [ $? -ne 0 ]; then
+			fatal "failed to create temporary directory"
+		fi
+	else
+		SSH_REGRESS_TMP="$($OBJ/mkdtemp openssh-XXXXXXXX)" || \
+			fatal "failed to create temporary directory"
+	fi
 }
 # End of portable specific functions
 
 stop_sshd ()
 {
-	if [ -f $PIDFILE ]; then
-		pid=`$SUDO cat $PIDFILE`
-		if [ "X$pid" = "X" ]; then
-			echo no sshd running
-		else
-			if [ $pid -lt 2 ]; then
-				echo bad pid for sshd: $pid
+	# windows process can't be stopped using kill command so use stop-process
+	if [ "$os" == "windows" ]; then
+		powershell.exe /c "stop-process -Name sshd -Force" >/dev/null 2>&1
+	 else
+	 	if [ -f $PIDFILE ]; then
+			pid=`$SUDO cat $PIDFILE`
+			if [ "X$pid" = "X" ]; then
+				echo no sshd running
 			else
-				$SUDO kill $pid
-				trace "wait for sshd to exit"
-				i=0;
-				while [ -f $PIDFILE -a $i -lt 5 ]; do
-					i=`expr $i + 1`
-					sleep $i
-				done
-				if test -f $PIDFILE; then
-					if $SUDO kill -0 $pid; then
-						echo "sshd didn't exit " \
-						    "port $PORT pid $pid"
-					else
-						echo "sshd died without cleanup"
+				if [ $pid -lt 2 ]; then
+					echo bad pid for sshd: $pid
+				else
+					$SUDO kill $pid
+					trace "wait for sshd to exit"
+					i=0;
+					while [ -f $PIDFILE -a $i -lt 5 ]; do
+						i=`expr $i + 1`
+						sleep $i
+					done
+					if test -f $PIDFILE; then
+						if $SUDO kill -0 $pid; then
+							echo "sshd didn't exit " \
+								"port $PORT pid $pid"
+						else
+							echo "sshd died without cleanup"
+						fi
+						exit 1
 					fi
-					exit 1
 				fi
 			fi
 		fi
@@ -398,11 +425,19 @@ stop_sshd ()
 # helper
 cleanup ()
 {
-	if [ "x$SSH_PID" != "x" ]; then
-		if [ $SSH_PID -lt 2 ]; then
-			echo bad pid for ssh: $SSH_PID
-		else
-			kill $SSH_PID
+	# windows process can't be stopped using kill command so use stop-process
+	if [ "$os" == "windows" ]; then
+		powershell.exe /c "stop-process -Name ssh-agent -Force" >/dev/null 2>&1
+		if [ "x$SSH_PID" != "x" ]; then
+			powershell.exe /c "stop-process -Id $SSH_PID -Force" >/dev/null 2>&1
+		fi
+	else
+		if [ "x$SSH_PID" != "x" ]; then
+			if [ $SSH_PID -lt 2 ]; then
+				echo bad pid for ssh: $SSH_PID
+			else
+				kill $SSH_PID
+			fi
 		fi
 	fi
 	if [ "x$SSH_REGRESS_TMP" != "x" ]; then
@@ -497,6 +532,7 @@ cat << EOF > $OBJ/sshd_config
 	Subsystem	sftp	$SFTPSERVER
 EOF
 
+if [ "$os" != "windows" ]; then
 # This may be necessary if /usr/src and/or /usr/obj are group-writable,
 # but if you aren't careful with permissions then the unit tests could
 # be abused to locally escalate privileges.
@@ -528,6 +564,7 @@ bypass this check by setting TEST_SSH_UNSAFE_PERMISSIONS=1
 EOD
 	fi
 fi
+fi
 
 if [ ! -z "$TEST_SSH_MODULI_FILE" ]; then
 	trace "adding modulifile='$TEST_SSH_MODULI_FILE' to sshd_config"
@@ -600,6 +637,25 @@ maybe_filter_sk() {
 SSH_KEYTYPES=`$SSH -Q key-plain | maybe_filter_sk`
 SSH_HOSTKEY_TYPES=`$SSH -Q key-plain | maybe_filter_sk`
 
+if [ "$os" == "windows" ]; then
+	SSH_KEYTYPES=`echo $SSH_KEYTYPES | tr -d '\r','\n'`  # remove \r\n
+	SSH_HOSTKEY_TYPES=`echo $SSH_HOSTKEY_TYPES | tr -d '\r','\n'`  # remove \r\n
+	OBJ_WIN_FORMAT=`windows_path $OBJ`
+	first_key_type=${SSH_KEYTYPES%% *}
+	if [ "x$USER_DOMAIN" != "x" ]; then
+		# For domain user, create folders
+		if [ ! -d $OBJ/authorized_keys_$USER_DOMAIN ]; then
+			mkdir $OBJ/authorized_keys_$USER_DOMAIN
+		fi
+		if [ ! -d $OBJ/authorized_principals_$USER_DOMAIN ]; then
+			mkdir $OBJ/authorized_principals_$USER_DOMAIN
+		fi
+		if [ ! -d /var/run/principals_command_$USER_DOMAIN ]; then
+			mkdir /var/run/principals_command_$USER_DOMAIN
+		fi
+	fi
+fi
+
 for t in ${SSH_KEYTYPES}; do
 	# generate user key
 	if [ ! -f $OBJ/$t ] || [ ${SSHKEYGEN_BIN} -nt $OBJ/$t ]; then
@@ -625,12 +681,21 @@ for t in ${SSH_HOSTKEY_TYPES}; do
 
 	# use key as host key, too
 	(umask 077; $SUDO cp $OBJ/$t $OBJ/host.$t)
+	if [ "$os" == "windows" ]; then
+		# set the file permissions (ACLs) properly
+		powershell.exe /c "get-acl $OBJ_WIN_FORMAT/$t | set-acl $OBJ_WIN_FORMAT/host.$t"
+	fi
+
 	echo HostKey $OBJ/host.$t >> $OBJ/sshd_config
 
 	# don't use SUDO for proxy connect
 	echo HostKey $OBJ/$t >> $OBJ/sshd_proxy
 done
-chmod 644 $OBJ/authorized_keys_$USER
+
+if [ "$os" == "windows" ]; then
+	# set the file permissions (ACLs) properly
+	powershell.exe /c "get-acl $OBJ_WIN_FORMAT/$first_key_type | set-acl $OBJ_WIN_FORMAT/authorized_keys_$USER"
+fi
 
 # Activate Twisted Conch tests if the binary is present
 REGRESS_INTEROP_CONCH=no
@@ -690,7 +755,13 @@ fi
 # create a proxy version of the client config
 (
 	cat $OBJ/ssh_config
-	echo proxycommand ${SUDO} env SSH_SK_HELPER=\"$SSH_SK_HELPER\" sh ${SRC}/sshd-log-wrapper.sh ${TEST_SSHD_LOGFILE} ${SSHD} -i -f $OBJ/sshd_proxy
+	if [ "$os" == "windows" ]; then
+		# TODO - having SSH_SK_HELPER is causing issues. Need to find a way.
+		# This is fine for now as we don't have FIDO enabled.
+		echo proxycommand  `windows_path ${SSHD}` -i -f $OBJ_WIN_FORMAT/sshd_proxy
+	else
+		echo proxycommand ${SUDO} env SSH_SK_HELPER=\"$SSH_SK_HELPER\" sh ${SRC}/sshd-log-wrapper.sh ${TEST_SSHD_LOGFILE} ${SSHD} -i -f $OBJ/sshd_proxy
+	fi
 ) > $OBJ/ssh_proxy
 
 # check proxy config
@@ -700,8 +771,15 @@ start_sshd ()
 {
 	# start sshd
 	$SUDO ${SSHD} -f $OBJ/sshd_config "$@" -t || fatal "sshd_config broken"
-	$SUDO env SSH_SK_HELPER="$SSH_SK_HELPER" \
-	    ${SSHD} -f $OBJ/sshd_config "$@" -E$TEST_SSHD_LOGFILE
+	if [ "$os" == "windows" ]; then
+		# In windows, we need to explicitly remove the sshd pid file.
+		rm -rf $PIDFILE
+		#TODO (Code BUG) : -E<sshd.log> is writing the data the cygwin terminal.
+		${SSHD} -f $OBJ/sshd_config "$@" &
+	else
+		$SUDO env SSH_SK_HELPER="$SSH_SK_HELPER" \
+	    	${SSHD} -f $OBJ/sshd_config "$@" -E$TEST_SSHD_LOGFILE
+	fi
 
 	trace "wait for sshd"
 	i=0;
diff --git a/regress/try-ciphers.sh b/regress/try-ciphers.sh
index e04268ba3..44da190fc 100644
--- a/regress/try-ciphers.sh
+++ b/regress/try-ciphers.sh
@@ -8,6 +8,10 @@ cp $OBJ/sshd_proxy $OBJ/sshd_proxy_bak
 for c in `${SSH} -Q cipher`; do
 	n=0
 	for m in `${SSH} -Q mac`; do
+		if [ "$os" == "windows" ]; then
+			c=${c/$'\r'/} # remove CR (carriage return)
+			m=${m/$'\r'/} # remove CR (carriage return)
+		fi
 		trace "cipher $c mac $m"
 		verbose "test $tid: cipher $c mac $m"
 		cp $OBJ/sshd_proxy_bak $OBJ/sshd_proxy
diff --git a/regress/unittests/sshkey/test_file.c b/regress/unittests/sshkey/test_file.c
index 497ab6dde..2cdb522bc 100644
--- a/regress/unittests/sshkey/test_file.c
+++ b/regress/unittests/sshkey/test_file.c
@@ -72,6 +72,7 @@ sshkey_file_tests(void)
 	BN_free(c);
 	TEST_DONE();
 
+#ifndef WINDOWS /* TODO: test fails (atleast) on Windows as Licrypto is unable to parse legacy private key file with passphrase*/
 	TEST_START("parse RSA from private w/ passphrase");
 	buf = load_file("rsa_1_pw");
 	ASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,
@@ -81,6 +82,7 @@ sshkey_file_tests(void)
 	ASSERT_INT_EQ(sshkey_equal(k1, k2), 1);
 	sshkey_free(k2);
 	TEST_DONE();
+#endif
 
 	TEST_START("parse RSA from new-format");
 	buf = load_file("rsa_n");
@@ -181,6 +183,7 @@ sshkey_file_tests(void)
 	BN_free(c);
 	TEST_DONE();
 
+#ifndef WINDOWS /* TODO: test fails (atleast) on Windows as Licrypto is unable to parse legacy private key file with passphrase*/
 	TEST_START("parse DSA from private w/ passphrase");
 	buf = load_file("dsa_1_pw");
 	ASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,
@@ -190,6 +193,7 @@ sshkey_file_tests(void)
 	ASSERT_INT_EQ(sshkey_equal(k1, k2), 1);
 	sshkey_free(k2);
 	TEST_DONE();
+#endif
 
 	TEST_START("parse DSA from new-format");
 	buf = load_file("dsa_n");
@@ -279,6 +283,7 @@ sshkey_file_tests(void)
 	BN_free(c);
 	TEST_DONE();
 
+#ifndef WINDOWS /* TODO: test fails (atleast) on Windows as Licrypto is unable to parse legacy private key file with passphrase*/
 	TEST_START("parse ECDSA from private w/ passphrase");
 	buf = load_file("ecdsa_1_pw");
 	ASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,
@@ -288,6 +293,7 @@ sshkey_file_tests(void)
 	ASSERT_INT_EQ(sshkey_equal(k1, k2), 1);
 	sshkey_free(k2);
 	TEST_DONE();
+#endif
 
 	TEST_START("parse ECDSA from new-format");
 	buf = load_file("ecdsa_n");
@@ -365,6 +371,7 @@ sshkey_file_tests(void)
 	/* XXX check key contents */
 	TEST_DONE();
 
+#ifndef WINDOWS /* TODO: test fails (atleast) on Windows as Licrypto is unable to parse legacy private key file with passphrase*/
 	TEST_START("parse Ed25519 from private w/ passphrase");
 	buf = load_file("ed25519_1_pw");
 	ASSERT_INT_EQ(sshkey_parse_private_fileblob(buf,
@@ -374,6 +381,7 @@ sshkey_file_tests(void)
 	ASSERT_INT_EQ(sshkey_equal(k1, k2), 1);
 	sshkey_free(k2);
 	TEST_DONE();
+#endif
 
 	TEST_START("load Ed25519 from public");
 	ASSERT_INT_EQ(sshkey_load_public(test_data_file("ed25519_1.pub"), &k2,
diff --git a/regress/unittests/test_helper/test_helper.c b/regress/unittests/test_helper/test_helper.c
index 6461d7ffc..0f396edb2 100644
--- a/regress/unittests/test_helper/test_helper.c
+++ b/regress/unittests/test_helper/test_helper.c
@@ -134,6 +134,28 @@ main(int argc, char **argv)
 	ERR_load_CRYPTO_strings();
 #endif
 
+#ifdef WINDOWS
+	/* copy moduli file to __PROGRAMDATA__\SSH folder */
+	extern wchar_t* __wprogdir;
+	extern wchar_t* __wprogdata;
+	int isModuliFileCopied = 0;
+	wchar_t programdata_moduli_path[PATH_MAX] = { 0, };
+	if (__wprogdir && __wprogdata) {
+		wcscat_s(programdata_moduli_path, _countof(programdata_moduli_path), __wprogdata);
+		wcscat_s(programdata_moduli_path, _countof(programdata_moduli_path), L"\\ssh\\moduli");
+		if (GetFileAttributesW(programdata_moduli_path) == INVALID_FILE_ATTRIBUTES) {
+			wchar_t moduli_default_path[PATH_MAX] = { 0, };
+			swprintf_s(moduli_default_path, PATH_MAX, L"%s\\..\\%s", __wprogdir, L"moduli");
+
+			if (CopyFileW(moduli_default_path, programdata_moduli_path, TRUE) == 0) {
+				printf("Failed to copy %ls to %ls, error:%d", moduli_default_path, programdata_moduli_path, GetLastError());
+				exit(255);
+			}
+			isModuliFileCopied = 1;
+		}
+	}
+#endif
+
 	/* Handle systems without __progname */
 	if (__progname == NULL) {
 		__progname = strrchr(argv[0], '/');
@@ -180,6 +202,12 @@ main(int argc, char **argv)
 
 	tests();
 
+#ifdef WINDOWS
+	if (isModuliFileCopied) {
+		_wunlink(programdata_moduli_path);
+	}
+#endif
+
 	if (!quiet_mode)
 		printf(" %u tests ok\n", test_number);
 	return 0;
diff --git a/scp.c b/scp.c
index 519bffa1b..8bc8dc91b 100644
--- a/scp.c
+++ b/scp.c
@@ -118,6 +118,7 @@
 #include <string.h>
 #include <time.h>
 #include <unistd.h>
+#include "openbsd-compat/glob.h"
 #if defined(HAVE_STRNVIS) && defined(HAVE_VIS_H) && !defined(BROKEN_STRNVIS)
 #include <vis.h>
 #endif
@@ -236,6 +237,48 @@ do_local_cmd(arglist *a)
 			fmprintf(stderr, " %s", a->list[i]);
 		fprintf(stderr, "\n");
 	}
+#ifdef WINDOWS
+	/* flatten the cmd into a long space separated string and execute using system(cmd) api */
+	{
+		char* cmd;
+		size_t cmdlen = 0;
+		for (i = 0; i < a->num; i++)
+			cmdlen += strlen(a->list[i]) + 1;
+
+		cmd = xmalloc(cmdlen);
+		cmd[0] = '\0';
+		for (i = 0; i < a->num; i++) {
+			char *path = a->list[i];
+			if (is_bash_test_env()) {
+				char resolved[PATH_MAX] = { 0, };
+				convertToForwardslash(path);
+
+				if(bash_to_win_path(path, resolved, _countof(resolved)))
+					convertToBackslash(resolved);
+
+				strcat(cmd, " ");
+				strcat(cmd, resolved);
+			} else {
+				if (i != 0)
+					strcat_s(cmd, cmdlen, " ");
+				strcat_s(cmd, cmdlen, a->list[i]);
+			}
+		}
+
+		wchar_t *cmd_w = utf8_to_utf16(cmd);
+		if (cmd_w) {
+			if (_wsystem(cmd_w))
+				return -1;
+
+			free(cmd_w);
+			return 0;
+		} else {
+			error("%s out of memory", __func__);
+			return -1;
+		}
+	}
+
+#else /* !WINDOWS */
 	if ((pid = fork()) == -1)
 		fatal("do_local_cmd: fork: %s", strerror(errno));
 
@@ -260,6 +303,7 @@ do_local_cmd(arglist *a)
 		return (-1);
 
 	return (0);
+#endif /* !WINDOWS */
 }
 
 /*
@@ -295,6 +339,10 @@ do_cmd(char *program, char *host, char *remuser, int port, int subsystem,
 		fatal("pipe: %s", strerror(errno));
 	if (pipe(pout) == -1)
 		fatal("pipe: %s", strerror(errno));
+	fcntl(pout[0], F_SETFD, FD_CLOEXEC);
+	fcntl(pout[1], F_SETFD, FD_CLOEXEC);
+	fcntl(pin[0], F_SETFD, FD_CLOEXEC);
+	fcntl(pin[1], F_SETFD, FD_CLOEXEC);
 
 	/* Free the reserved descriptors. */
 	close(reserved[0]);
@@ -305,6 +353,43 @@ do_cmd(char *program, char *host, char *remuser, int port, int subsystem,
 	ssh_signal(SIGTTOU, suspchild);
 
 	/* Fork a child to execute the command on the remote host using ssh. */
+#ifdef FORK_NOT_SUPPORTED
+	// We shouldn't change the "args"
+	arglist args_dup;
+	memset(&args_dup, '\0', sizeof(remote_remote_args));
+	duplicateargs(&args_dup, &args);
+
+	replacearg(&args_dup, 0, "%s", program);		
+	if (port != -1) {
+		addargs(&args_dup, "-p");
+		addargs(&args_dup, "%d", port);
+	}
+	if (remuser != NULL) {
+		addargs(&args_dup, "-l");
+		addargs(&args_dup, "%s", remuser);
+	}
+	if (subsystem)
+		addargs(&args_dup, "-s");
+	addargs(&args_dup, "--");
+	addargs(&args_dup, "%s", host);
+	addargs(&args_dup, "%s", cmd);
+
+	{
+		posix_spawn_file_actions_t actions;
+		*pid = -1;
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, pin[0], STDIN_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, pout[1], STDOUT_FILENO) != 0 )
+			fatal("posix_spawn initialization failed");
+		else if (posix_spawn(pid, args_dup.list[0], &actions, NULL, args_dup.list, NULL) != 0)
+			fatal("posix_spawn: %s", strerror(errno));
+			
+			posix_spawn_file_actions_destroy(&actions);
+	}
+
+	freeargs(&args_dup);
+#else
 	*pid = fork();
 	if (*pid == 0) {
 		/* Child. */
@@ -336,6 +421,7 @@ do_cmd(char *program, char *host, char *remuser, int port, int subsystem,
 	} else if (*pid == -1) {
 		fatal("fork: %s", strerror(errno));
 	}
+#endif 
 	/* Parent.  Close the other side, and return the local side. */
 	close(pin[0]);
 	*fdout = pin[1];
@@ -369,6 +455,44 @@ do_cmd2(char *host, char *remuser, int port, char *cmd,
 		port = sshport;
 
 	/* Fork a child to execute the command on the remote host using ssh. */
+#ifdef FORK_NOT_SUPPORTED
+	/* generate command line and spawn_child */
+	
+	// We shouldn't change the "args"
+	arglist args_dup;
+	memset(&args_dup, '\0', sizeof(remote_remote_args));
+	duplicateargs(&args_dup, &args);
+
+	replacearg(&args_dup, 0, "%s", ssh_program);	
+	if (port != -1) {
+		addargs(&args_dup, "-p");
+		addargs(&args_dup, "%d", port);
+	}
+	if (remuser != NULL) {
+		addargs(&args_dup, "-l");
+		addargs(&args_dup, "%s", remuser);
+	}
+	addargs(&args_dup, "-oBatchMode=yes");
+	addargs(&args_dup, "--");
+	addargs(&args_dup, "%s", host);
+	addargs(&args_dup, "%s", cmd);
+
+	{
+		posix_spawn_file_actions_t actions;
+		pid = -1;
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, fdin, STDIN_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, fdout, STDOUT_FILENO) != 0 ) 
+			fatal("posix_spawn initialization failed");
+		else if (posix_spawn(&pid, args_dup.list[0], &actions, NULL, args_dup.list, NULL) != 0) 
+			fatal("posix_spawn: %s", strerror(errno));
+
+		posix_spawn_file_actions_destroy(&actions);
+	}
+
+	freeargs(&args_dup);
+#else 
 	pid = fork();
 	if (pid == 0) {
 		dup2(fdin, 0);
@@ -394,6 +518,7 @@ do_cmd2(char *host, char *remuser, int port, char *cmd,
 	} else if (pid == -1) {
 		fatal("fork: %s", strerror(errno));
 	}
+#endif
 	while (waitpid(pid, &status, 0) == -1)
 		if (errno != EINTR)
 			fatal("do_cmd2: waitpid: %s", strerror(errno));
@@ -462,8 +587,43 @@ main(int argc, char **argv)
 	/* Copy argv, because we modify it */
 	argv0 = argv[0];
 	newargv = xcalloc(MAXIMUM(argc + 1, 1), sizeof(*newargv));
+#ifdef WINDOWS	
+	{
+		/* 
+		 * Wildcards are not expanded by shell on Windows; expand them
+		 * Convert '\\' to '/' in path portion to support both Windows and Unix style paths
+		 */
+		char *p, *argdup;
+		int i = 0;		
+		glob_t g;
+		int expandargc = 0;
+		memset(&g, 0, sizeof(g));
+		for (n = 0; n < argc; n++) {
+			argdup = xstrdup(argv[n]);
+			if (p = colon(argdup))
+				convertToForwardslash(p);
+			else
+				convertToForwardslash(argdup);
+			if (glob(argdup, GLOB_NOCHECK | GLOB_NOESCAPE, NULL, &g)) {
+				if (expandargc > argc)
+					newargv = xreallocarray(newargv, expandargc + 1, sizeof(*newargv));
+				newargv[expandargc++] = xstrdup(argdup);
+			} else {
+				int count = g.gl_matchc > 1 ? g.gl_matchc : 1;
+				if (expandargc + count > argc - 1)
+					newargv = xreallocarray(newargv, expandargc + count, sizeof(*newargv));
+				for (i = 0; i < count; i++)
+					newargv[expandargc++] = xstrdup(g.gl_pathv[i]);
+			}
+			free(argdup);
+			globfree(&g);
+		}
+		argc = expandargc;		
+	}
+#else  /* !WINDOWS */
 	for (n = 0; n < argc; n++)
 		newargv[n] = xstrdup(argv[n]);
+#endif /* !WINDOWS */
 	argv = newargv;
 
 	__progname = ssh_get_progname(argv[0]);
@@ -614,7 +774,7 @@ main(int argc, char **argv)
 	}
 
 	remin = STDIN_FILENO;
-	remout = STDOUT_FILENO;
+	remout = STDOUT_FILENO;	
 
 	if (fflag) {
 		/* Follow "protocol", send data. */
@@ -968,6 +1128,10 @@ do_sftp_connect(char *host, char *user, int port, char *sftp_direct,
 			return NULL;
 
 	} else {
+		if (args.list) {
+			freeargs(&args);
+		}
+
 		args.list = NULL;
 		addargs(&args, "sftp-server");
 		if (do_cmd(sftp_direct, host, NULL, -1, 0, "sftp",
@@ -1197,6 +1361,48 @@ tolocal(int argc, char **argv, enum scp_mode_e mode, char *sftp_direct)
 		}
 		if (!host) {	/* Local to local. */
 			freeargs(&alist);
+#ifdef WINDOWS
+#define _PATH_XCOPY "xcopy"
+#define _PATH_COPY "copy"
+			/* local to local on windows - need to use local native copy command */
+			struct stat stb;
+			int exists;
+			char *last;
+
+			exists = stat(argv[i], &stb) == 0;
+			/* convert '/' to '\\' 	*/
+			convertToBackslash(argv[i]);
+			convertToBackslash(argv[argc - 1]);
+			if (exists && (S_ISDIR(stb.st_mode))) {
+				addargs(&alist, "%s", _PATH_XCOPY);
+				if (iamrecursive)
+					addargs(&alist, "/S /E /H");
+				if (pflag)
+					addargs(&alist, "/K /X");
+				addargs(&alist, "/Y /F /I");
+				addargs(&alist, "%s", argv[i]);
+
+				/* This logic is added to align with UNIX behavior.
+				 * If the argv[argc-1] exists then append direcorty name from argv[i]
+				 */
+				if (0 == stat(argv[argc - 1], &stb) && (S_ISDIR(stb.st_mode))) {
+					if ((last = strrchr(argv[i], '\\')) == NULL)
+						last = argv[i];
+					else
+						++last;
+
+					addargs(&alist, "%s%s%s", argv[argc - 1],
+						strcmp(argv[argc - 1], "\\") ? "\\" : "", last);
+				} else {
+					addargs(&alist, "%s", argv[argc - 1]);
+				}
+			} else {
+				addargs(&alist, "%s", _PATH_COPY);
+				addargs(&alist, "/Y");				
+				addargs(&alist, "%s", argv[i]);
+				addargs(&alist, "%s", argv[argc - 1]);
+			}			
+#else  /* !WINDOWS */
 			addargs(&alist, "%s", _PATH_CP);
 			if (iamrecursive)
 				addargs(&alist, "-r");
@@ -1205,6 +1411,7 @@ tolocal(int argc, char **argv, enum scp_mode_e mode, char *sftp_direct)
 			addargs(&alist, "--");
 			addargs(&alist, "%s", argv[i]);
 			addargs(&alist, "%s", argv[argc-1]);
+#endif /* !WINDOWS */
 			if (do_local_cmd(&alist))
 				++errs;
 			continue;
@@ -1333,7 +1540,14 @@ source(int argc, char **argv)
 	off_t i, statbytes;
 	size_t amt, nr;
 	int fd = -1, haderr, indx;
+#ifdef WINDOWS
+	/* PATH_MAX is too large on Windows.*/
+	/* Allocate memory dynamically for encname and buf to avoid stack overflow on recursive calls.*/
+	char *last, *name, *buf = NULL, *encname = NULL;
+	size_t encname_len, buf_len, tmp_len;
+#else
 	char *last, *name, buf[PATH_MAX + 128], encname[PATH_MAX];
+#endif
 	int len;
 
 	for (indx = 0; indx < argc; ++indx) {
@@ -1345,7 +1559,20 @@ source(int argc, char **argv)
 		if ((fd = open(name, O_RDONLY|O_NONBLOCK)) == -1)
 			goto syserr;
 		if (strchr(name, '\n') != NULL) {
+#ifdef WINDOWS
+			if (!encname) {
+				encname_len = ((2 * len) < PATH_MAX) ? 2 * len : PATH_MAX;
+				encname = xmalloc(encname_len);
+			}
+			while ((tmp_len = strnvis(encname, name, encname_len, VIS_NL)) >= encname_len) {
+				if (tmp_len >= PATH_MAX)
+					break;
+				encname_len = tmp_len + 1;
+				encname = xreallocarray(encname, encname_len, sizeof(char));
+			}
+#else
 			strnvis(encname, name, sizeof(encname), VIS_NL);
+#endif
 			name = encname;
 		}
 		if (fstat(fd, &stb) == -1) {
@@ -1380,9 +1607,27 @@ syserr:			run_err("%s: %s", name, strerror(errno));
 				goto next;
 		}
 #define	FILEMODEMASK	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
+#ifdef WINDOWS
+		if (!buf) 
+		{
+			/*Set the initial size of buf to "strlen(last) + 20" based on multiple tests that*/
+			/*inidicate that this is usually enough. If not enough, more space will be allocated below.*/
+			buf_len = ((strlen(last) + 20) < PATH_MAX) ? strlen(last) + 20 : PATH_MAX;
+			buf = xmalloc(buf_len);
+		}
+		while ((tmp_len = snprintf(buf, buf_len, "C%04o %lld %s\n",
+		      (u_int) (stb.st_mode & FILEMODEMASK),
+			  (long long)stb.st_size, last)) >= buf_len) {
+			if (tmp_len >= PATH_MAX)
+				break;
+			buf_len = tmp_len + 1;
+			buf = xreallocarray(buf, buf_len, sizeof(char));
+		}
+#else
 		snprintf(buf, sizeof buf, "C%04o %lld %s\n",
 		    (u_int) (stb.st_mode & FILEMODEMASK),
 		    (long long)stb.st_size, last);
+#endif
 		if (verbose_mode)
 			fmprintf(stderr, "Sending file modes: %s", buf);
 		(void) atomicio(vwrite, remout, buf, strlen(buf));
@@ -1434,6 +1679,12 @@ next:			if (fd != -1) {
 		if (showprogress)
 			stop_progress_meter();
 	}
+#ifdef WINDOWS
+	if (encname)
+		free(encname);
+	if (buf)
+		free(buf);
+#endif
 }
 
 void
@@ -1441,7 +1692,16 @@ rsource(char *name, struct stat *statp)
 {
 	DIR *dirp;
 	struct dirent *dp;
+#ifndef WINDOWS
 	char *last, *vect[1], path[PATH_MAX];
+#else
+	/* PATH_MAX is too large on Windows.*/
+	/* Allocate memory dynamically for path to avoid stack overflow on recursive calls.*/
+	char *last, *vect[1], *path;
+	size_t path_len = 260, len;
+
+	path = xmalloc(path_len);
+#endif
 
 	if (!(dirp = opendir(name))) {
 		run_err("%s: %s", name, strerror(errno));
@@ -1458,8 +1718,19 @@ rsource(char *name, struct stat *statp)
 			return;
 		}
 	}
+#ifdef WINDOWS
+	while ((len = snprintf(path, path_len, "D%04o %d %.1024s\n",
+		  (u_int)(statp->st_mode & FILEMODEMASK), 0, last)) >= path_len)
+	{
+		if (len >= PATH_MAX)
+			break;
+		path_len = len + 1;
+		path = xreallocarray(path, path_len, sizeof(char));
+	}
+#else
 	(void) snprintf(path, sizeof path, "D%04o %d %.1024s\n",
 	    (u_int) (statp->st_mode & FILEMODEMASK), 0, last);
+#endif
 	if (verbose_mode)
 		fmprintf(stderr, "Entering directory: %s", path);
 	(void) atomicio(vwrite, remout, path, strlen(path));
@@ -1472,14 +1743,29 @@ rsource(char *name, struct stat *statp)
 			continue;
 		if (!strcmp(dp->d_name, ".") || !strcmp(dp->d_name, ".."))
 			continue;
+#ifdef WINDOWS
+		if (strlen(name) + 1 + strlen(dp->d_name) >= PATH_MAX - 1) {
+#else 
 		if (strlen(name) + 1 + strlen(dp->d_name) >= sizeof(path) - 1) {
+#endif
 			run_err("%s/%s: name too long", name, dp->d_name);
 			continue;
 		}
+#ifdef WINDOWS
+		while ((len = snprintf(path, path_len, "%s/%s", name, dp->d_name)) >= path_len) {
+			path_len = len + 1;
+			path = xreallocarray(path, path_len, sizeof(char));
+		}
+#else
 		(void) snprintf(path, sizeof path, "%s/%s", name, dp->d_name);
+#endif
 		vect[0] = path;
 		source(1, vect);
 	}
+#ifdef WINDOWS
+	if (path)
+		free(path);
+#endif
 	(void) closedir(dirp);
 	(void) atomicio(vwrite, remout, "E\n", 2);
 	(void) response();
@@ -1787,7 +2073,12 @@ sink(int argc, char **argv, const char *src)
 		}
 		omode = mode;
 		mode |= S_IWUSR;
+#ifdef WINDOWS
+		// In windows, we would like to inherit the parent folder permissions by setting mode to USHRT_MAX.
+		if ((ofd = open(np, O_WRONLY|O_CREAT, USHRT_MAX)) == -1) {
+#else
 		if ((ofd = open(np, O_WRONLY|O_CREAT, mode)) == -1) {
+#endif // WINDOWS
 bad:			run_err("%s: %s", np, strerror(errno));
 			continue;
 		}
@@ -1849,6 +2140,22 @@ bad:			run_err("%s: %s", np, strerror(errno));
 		if (!wrerr && (!exists || S_ISREG(stb.st_mode)) &&
 		    ftruncate(ofd, size) != 0)
 			note_err("%s: truncate: %s", np, strerror(errno));
+#ifdef WINDOWS
+		/* When p flag is used, set timestamps before setting the
+		 * mode to avoid error caused by when the mode is set to
+		 * "read-only" and timestamps can't be set.*/
+		if (setimes && !wrerr) {
+			setimes = 0;
+			if (utimes(np, tv) == -1) {
+				note_err("%s: set times: %s",
+					np, strerror(errno));
+			}
+		}
+		/* When the file descriptor (ofd) is closed, the Accessed
+		 * timestamp gets updated. Therefore, when the p flag is 
+		 * used, the inherited Accessed timestamp is overwritten.
+		 * However, the Modify timestamp is inherited correctly.*/
+#endif
 		if (pflag) {
 			if (exists || omode != mode)
 #ifdef HAVE_FCHMOD
@@ -1875,6 +2182,7 @@ bad:			run_err("%s: %s", np, strerror(errno));
 		(void) response();
 		if (showprogress)
 			stop_progress_meter();
+#ifndef WINDOWS
 		if (setimes && !wrerr) {
 			setimes = 0;
 			if (utimes(np, tv) == -1) {
@@ -1882,6 +2190,7 @@ bad:			run_err("%s: %s", np, strerror(errno));
 				    np, strerror(errno));
 			}
 		}
+#endif
 		/* If no error was noted then signal success for this file */
 		if (note_err(NULL) == 0)
 			(void) atomicio(vwrite, remout, "", 1);
diff --git a/servconf.c b/servconf.c
index 903169621..e9601bbeb 100644
--- a/servconf.c
+++ b/servconf.c
@@ -733,6 +733,7 @@ derelativise_path(const char *path)
 	if (strcasecmp(path, "none") == 0)
 		return xstrdup("none");
 	expanded = tilde_expand_filename(path, getuid());
+
 	if (path_absolute(expanded))
 		return expanded;
 	if (getcwd(cwd, sizeof(cwd)) == NULL)
@@ -1076,6 +1077,7 @@ match_cfg_line(char **condition, int line, struct connection_info *ci)
 			}
 			if (ci->user == NULL)
 				match_test_missing_fatal("User", "user");
+
 			if (match_usergroup_pattern_list(ci->user, arg) != 1)
 				result = 0;
 			else
@@ -2319,7 +2321,11 @@ process_server_config_line_depth(ServerOptions *options, char *line,
 		charptr = &options->authorized_keys_command;
  parse_command:
 		len = strspn(str, WHITESPACE);
+#ifdef WINDOWS
+		if (!path_absolute(str + len) && strcasecmp(str + len, "none") != 0) {
+#else
 		if (str[len] != '/' && strcasecmp(str + len, "none") != 0) {
+#endif
 			fatal("%.200s line %d: %s must be an absolute path",
 			    filename, linenum, keyword);
 		}
@@ -2704,6 +2710,61 @@ parse_server_config(ServerOptions *options, const char *filename,
 	parse_server_config_depth(options, filename, conf, includes,
 	    connectinfo, (connectinfo ? SSHCFG_MATCH_ONLY : 0), &active, 0);
 	process_queued_listen_addrs(options);
+
+#ifdef WINDOWS	
+	/* TODO - Refactor this into a platform specific post-read config processing routine.
+	 * TODO - support all forms of username, groupname.
+	 *   a) domain\groupname
+	 *   b) domain\groupname@hostip
+	 *   c) full_domain_name\groupname
+	 *   d) full_domain_name\groupname@hostip
+	 *   e) user@domain
+	 *   f) domain\user
+	 *   g) fulldomain\user
+	 *   h) user@domain@hostip
+	 */
+	/* convert the users, user groups to lower case */
+	char *tmp = NULL;
+	for (int i = 0; i < options->num_allow_users; i++) {
+		/* For domain user we need special handling.
+		* We support both "domain\user" and "domain/user" formats.
+		*/
+		if (tmp = strstr(options->allow_users[i], "/"))
+			*tmp = '\\';
+
+		lowercase(options->allow_users[i]);
+	}
+
+	for (int i = 0; i < options->num_deny_users; i++) {
+		/* For domain user we need special handling.
+		 * We support both "domain\user" and "domain/user" formats.
+		 */
+		if (tmp = strstr(options->deny_users[i], "/"))
+			*tmp = '\\';
+
+		lowercase(options->deny_users[i]);
+	}
+
+	for (int i = 0; i < options->num_allow_groups; i++) {
+		/* For domain group we need special handling.
+		* We support both "domain\group" and "domain/group" formats.
+		*/
+		if (tmp = strstr(options->allow_groups[i], "/"))
+			*tmp = '\\';
+
+		lowercase(options->allow_groups[i]);
+	}
+
+	for (int i = 0; i < options->num_deny_groups; i++) {
+		/* For domain group we need special handling.
+		* We support both "domain\group" and "domain/group" formats.
+		*/
+		if (tmp = strstr(options->deny_groups[i], "/"))
+			*tmp = '\\';
+
+		lowercase(options->deny_groups[i]);
+	}
+#endif // WINDOWS
 }
 
 static const char *
diff --git a/session.c b/session.c
index e67d24d23..ec5f9ed7e 100644
--- a/session.c
+++ b/session.c
@@ -95,6 +95,7 @@
 #include "monitor_wrap.h"
 #include "sftp.h"
 #include "atomicio.h"
+#include "pal_doexec.h"
 
 #if defined(KRB5) && defined(USE_AFS)
 #include <kafs.h>
@@ -117,8 +118,10 @@ void	session_set_fds(struct ssh *, Session *, int, int, int, int, int);
 void	session_pty_cleanup(Session *);
 void	session_proctitle(Session *);
 int	session_setup_x11fwd(struct ssh *, Session *);
+#ifndef WINDOWS /* !WINDOWS */
 int	do_exec_pty(struct ssh *, Session *, const char *);
 int	do_exec_no_pty(struct ssh *, Session *, const char *);
+#endif
 int	do_exec(struct ssh *, Session *, const char *);
 void	do_login(struct ssh *, Session *, const char *);
 void	do_child(struct ssh *, Session *, const char *);
@@ -380,6 +383,8 @@ xauth_valid_string(const char *s)
 }
 
 #define USE_PIPES 1
+
+#ifndef WINDOWS /* !WINDOWS */
 /*
  * This is called to fork and execute a command when we have no tty.  This
  * will call do_child from the child, and server_loop from the parent after
@@ -649,6 +654,7 @@ do_exec_pty(struct ssh *ssh, Session *s, const char *command)
 	session_set_fds(ssh, s, ptyfd, fdout, -1, 1, 1);
 	return 0;
 }
+#endif   /* !WINDOWS */
 
 /*
  * This is called to fork and execute a command.  If another command is
@@ -1315,6 +1321,15 @@ safely_chroot(const char *path, uid_t uid)
 	if (strlen(path) >= sizeof(component))
 		fatal("chroot path too long");
 
+#ifdef WINDOWS
+	/* ensure chroot path exists and is a directory */
+	if (stat(path, &st) != 0)
+		fatal("%s: stat(\"%s\"): %s", __func__,
+			path, strerror(errno));
+	if (!S_ISDIR(st.st_mode))
+		fatal("chroot path %s is not a directory",
+			path);
+#else
 	/*
 	 * Descend the path, checking that each component is a
 	 * root-owned directory with strict permissions.
@@ -1342,7 +1357,7 @@ safely_chroot(const char *path, uid_t uid)
 			    cp == NULL ? "" : "component ", component);
 
 	}
-
+#endif
 	if (chdir(path) == -1)
 		fatal("Unable to chdir to chroot path \"%s\": "
 		    "%s", path, strerror(errno));
@@ -1513,6 +1528,10 @@ child_close_fds(struct ssh *ssh)
 void
 do_child(struct ssh *ssh, Session *s, const char *command)
 {
+#ifdef WINDOWS
+	/*not called for Windows */
+	return;
+#else  /* !WINDOWS */
 	extern char **environ;
 	char **env, *argv[ARGV_MAX], remote_id[512];
 	const char *shell, *shell0;
@@ -1713,6 +1732,7 @@ do_child(struct ssh *ssh, Session *s, const char *command)
 	execve(shell, argv, env);
 	perror(shell);
 	exit(1);
+#endif   /* !WINDOWS */
 }
 
 void
@@ -1924,7 +1944,11 @@ session_pty_req(struct ssh *ssh, Session *s)
 
 	/* Allocate a pty and open it. */
 	debug("Allocating pty.");
+#ifdef WINDOWS	
+	if (!(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
+#else
 	if (!PRIVSEP(pty_allocate(&s->ptyfd, &s->ttyfd, s->tty,
+#endif
 	    sizeof(s->tty)))) {
 		free(s->term);
 		s->term = NULL;
@@ -2711,4 +2735,23 @@ session_get_remote_name_or_ip(struct ssh *ssh, u_int utmp_size, int use_dns)
 		remote = ssh_remote_ipaddr(ssh);
 	return remote;
 }
+/*
+* Since in_chroot is static for now, create this function
+* to have unix code intact
+*/
+#ifdef WINDOWS
+int get_in_chroot()
+{
+	return in_chroot;
+}
 
+/*
+ * Since do_setup_env is static for now, create this function
+ * to have unix code intact 
+*/
+char **
+do_setup_env_proxy(struct ssh *ssh, Session *s, const char *shell)
+{
+	return do_setup_env(ssh, s, shell);
+}
+#endif
\ No newline at end of file
diff --git a/sftp-client.c b/sftp-client.c
index c75657553..d622c8426 100644
--- a/sftp-client.c
+++ b/sftp-client.c
@@ -1507,8 +1507,13 @@ do_download(struct sftp_conn *conn, const char *remote_path,
 	    &handle, &handle_len) != 0)
 		return -1;
 
+#ifdef WINDOWS
+	// In windows, we would like to inherit the parent folder permissions by setting mode to USHRT_MAX.
+	local_fd = open(local_path, O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), USHRT_MAX);
+#else
 	local_fd = open(local_path,
-	    O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);
+		O_WRONLY | O_CREAT | (resume_flag ? 0 : O_TRUNC), mode | S_IWUSR);
+#endif // WINDOWS
 	if (local_fd == -1) {
 		error("open local \"%s\": %s", local_path, strerror(errno));
 		goto fail;
@@ -2630,12 +2635,37 @@ make_absolute(char *p, const char *pwd)
 	char *abs_str;
 
 	/* Derelativise */
+#ifdef WINDOWS
+	/*
+	* For Windows - given path is absolute when
+	*   - first character is "/"
+	*   - or second character is ":"
+	* This code is also applicable from a Linux client to Windows target
+	* Need to follow up with community if this makes sense in common code
+	*/
+	char *s1, *s2;
+	if (!is_absolute_path(p)) {
+		abs_str = path_append(pwd, p);
+		free(p);
+		p = abs_str;
+	}
+
+	/* Append "/" if needed to the absolute windows path */	
+	if (p && p[0] != '\0' && p[1] == ':') {
+		s1 = path_append("/", p);
+		free(p);
+		p = s1;
+	}
+	
+	return(p);
+#else /* !WINDOWS */
 	if (p && !path_absolute(p)) {
 		abs_str = path_append(pwd, p);
 		free(p);
 		return(abs_str);
 	} else
 		return(p);
+#endif /* !WINDOWS */
 }
 
 int
diff --git a/sftp-server.c b/sftp-server.c
index d4c6a3b4c..4c012b457 100644
--- a/sftp-server.c
+++ b/sftp-server.c
@@ -62,6 +62,10 @@ char *sftp_realpath(const char *, char *); /* sftp-realpath.c */
 
 /* Our verbosity */
 static LogLevel log_level = SYSLOG_LEVEL_ERROR;
+#ifdef WINDOWS
+static SyslogFacility log_facility_g = SYSLOG_FACILITY_AUTH;
+int log_stderr_g = 0;
+#endif
 
 /* Our client */
 static struct passwd *pw = NULL;
@@ -157,7 +161,9 @@ static const struct sftp_handler extended_handlers[] = {
 	{ "posix-rename", "posix-rename@openssh.com", 0,
 	    process_extended_posix_rename, 1 },
 	{ "statvfs", "statvfs@openssh.com", 0, process_extended_statvfs, 0 },
+#ifndef WINDOWS
 	{ "fstatvfs", "fstatvfs@openssh.com", 0, process_extended_fstatvfs, 0 },
+#endif
 	{ "hardlink", "hardlink@openssh.com", 0, process_extended_hardlink, 1 },
 	{ "fsync", "fsync@openssh.com", 0, process_extended_fsync, 1 },
 	{ "lsetstat", "lsetstat@openssh.com", 0, process_extended_lsetstat, 1 },
@@ -714,7 +720,9 @@ process_init(void)
 	 /* extension advertisements */
 	compose_extension(msg, "posix-rename@openssh.com", "1");
 	compose_extension(msg, "statvfs@openssh.com", "2");
+#ifndef WINDOWS
 	compose_extension(msg, "fstatvfs@openssh.com", "2");
+#endif
 	compose_extension(msg, "hardlink@openssh.com", "1");
 	compose_extension(msg, "fsync@openssh.com", "1");
 	compose_extension(msg, "lsetstat@openssh.com", "1");
@@ -749,7 +757,12 @@ process_open(u_int32_t id)
 		verbose("Refusing open request in read-only mode");
 		status = SSH2_FX_PERMISSION_DENIED;
 	} else {
+#ifdef WINDOWS
+		// In windows, we would like to inherit the parent folder permissions by setting mode to USHRT_MAX.
+		fd = open(name, flags, USHRT_MAX);
+#else
 		fd = open(name, flags, mode);
+#endif // WINDOWS
 		if (fd == -1) {
 			status = errno_to_portable(errno);
 		} else {
@@ -1239,7 +1252,12 @@ process_realpath(u_int32_t id)
 	}
 	debug3("request %u: realpath", id);
 	verbose("realpath \"%s\"", path);
+
+#ifdef WINDOWS
+	if (realpath(path, resolvedname) == NULL) {
+#else
 	if (sftp_realpath(path, resolvedname) == NULL) {
+#endif // WINDOWS
 		send_status(id, errno_to_portable(errno));
 	} else {
 		Stat s;
@@ -1515,7 +1533,6 @@ process_extended_limits(u_int32_t id)
 	if (getrlimit(RLIMIT_NOFILE, &rlim) != -1 && rlim.rlim_cur > 5)
 		nfiles = rlim.rlim_cur - 5; /* stdio(3) + syslog + spare */
 #endif
-
 	if ((msg = sshbuf_new()) == NULL)
 		fatal_f("sshbuf_new failed");
 	if ((r = sshbuf_put_u8(msg, SSH2_FXP_EXTENDED_REPLY)) != 0 ||
@@ -1581,7 +1598,11 @@ process_extended_expand(u_int32_t id)
 		path = npath;
 	}
 	verbose("expand \"%s\"", path);
+#ifdef WINDOWS
+	if (realpath(path, resolvedname) == NULL) {
+#else
 	if (sftp_realpath(path, resolvedname) == NULL) {
+#endif
 		send_status(id, errno_to_portable(errno));
 		goto out;
 	}
@@ -1702,6 +1723,42 @@ sftp_server_cleanup_exit(int i)
 	_exit(i);
 }
 
+#ifdef WINDOWS
+void
+log_handler(LogLevel level, int forced, const char* msg, void* ctx)
+{
+	#include "atomicio.h"
+	struct sshbuf* log_msg;
+	int* log_fd = (int*)ctx;
+	int r;
+	size_t len;
+
+	if (*log_fd == -1)
+		fatal_f("no log channel");
+
+	if ((log_msg = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new failed");
+
+	if ((r = sshbuf_put_u32(log_msg, 0)) != 0 || /* length; filled below */
+		(r = sshbuf_put_u32(log_msg, level)) != 0 ||
+		(r = sshbuf_put_u32(log_msg, forced)) != 0 ||
+		(r = sshbuf_put_cstring(log_msg, msg)) != 0 ||
+		(r = sshbuf_put_cstring(log_msg, __progname)) != 0 ||
+		(r = sshbuf_put_u32(log_msg, log_level)) != 0 ||
+		(r = sshbuf_put_u32(log_msg, log_facility_g)) != 0 ||
+		(r = sshbuf_put_u32(log_msg, log_stderr_g)) != 0)
+		fatal_fr(r, "assemble");
+	if ((len = sshbuf_len(log_msg)) < 4 || len > 0xffffffff)
+		fatal_f("bad length %zu", len);
+	POKE_U32(sshbuf_mutable_ptr(log_msg), len - 4);
+	if (atomicio(vwrite, *log_fd,
+		sshbuf_mutable_ptr(log_msg), len) != len)
+		fatal_f("write: %s", strerror(errno));
+	sshbuf_free(log_msg);
+
+}
+#endif
+
 static void
 sftp_server_usage(void)
 {
@@ -1803,7 +1860,18 @@ sftp_server_main(int argc, char **argv, struct passwd *user_pw)
 	}
 
 	log_init(__progname, log_level, log_facility, log_stderr);
-
+#ifdef WINDOWS
+	/*
+	 * SFTP-Server fowards log messages to SSHD System process.
+	 * SSHD system process logs the messages to either ETW or sftp-server.log.
+	 * This allows us to log the messages of both non-admin and admin users.
+	 */
+	int log_send_fd = SFTP_SERVER_LOG_FD;
+	log_facility_g = log_facility;
+	log_stderr_g = log_stderr;
+	if (fcntl(log_send_fd, F_SETFD, FD_CLOEXEC) != -1)
+		set_log_handler(log_handler, (void*)&log_send_fd);
+#endif
 	/*
 	 * On platforms where we can, avoid making /proc/self/{mem,maps}
 	 * available to the user so that sftp access doesn't automatically
diff --git a/sftp.c b/sftp.c
index 8cb5917a9..a70ca27db 100644
--- a/sftp.c
+++ b/sftp.c
@@ -52,6 +52,7 @@ typedef void EditLine;
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
+#include <fcntl.h>
 
 #ifdef HAVE_UTIL_H
 # include <util.h>
@@ -68,6 +69,9 @@ typedef void EditLine;
 #include "sshbuf.h"
 #include "sftp-common.h"
 #include "sftp-client.h"
+#ifdef WINDOWS
+#include "misc_internal.h"
+#endif // WINDOWS
 
 /* File to read commands from */
 FILE* infile;
@@ -318,6 +322,38 @@ help(void)
 static void
 local_do_shell(const char *args)
 {
+  #ifdef WINDOWS
+	/* execute via system call in Windows*/	
+	if (!*args) {
+		char cmd_path[PATH_MAX] = { 0, };
+		if (!GetSystemDirectory(cmd_path, sizeof(cmd_path)))
+			fatal("GetSystemDirectory failed");
+
+		strcat_s(cmd_path, PATH_MAX, "\\cmd.exe");
+		args = cmd_path;
+	} else {
+		if (is_bash_test_env()) {
+			char *cygwin_path_prefix_start = NULL;
+			if (cygwin_path_prefix_start = strstr(args, CYGWIN_PATH_PREFIX)) {
+				int len = strlen(cygwin_path_prefix_start) + 1;
+				char *tmp = malloc(len);
+				memset(tmp, 0, len);
+
+				bash_to_win_path(cygwin_path_prefix_start, tmp, len);
+				strcpy_s(cygwin_path_prefix_start, len, tmp); /* override the original string */
+
+				if (tmp)
+					free(tmp);
+			}
+		}
+
+		convertToBackslash((char *) args);
+	}
+	
+	wchar_t* path_utf16 = utf8_to_utf16(args);
+	_wsystem(path_utf16); // execute the shell or cmd given
+	free(path_utf16);
+  #else   /* !WINDOWS */
 	int status;
 	char *shell;
 	pid_t pid;
@@ -351,6 +387,7 @@ local_do_shell(const char *args)
 		error("Shell exited abnormally");
 	else if (WEXITSTATUS(status))
 		error("Shell exited with status %d", WEXITSTATUS(status));
+ #endif   /* !WINDOWS */
 }
 
 static void
@@ -792,6 +829,7 @@ sdirent_comp(const void *aa, const void *bb)
 		return (rmul * NCMP(a->a.size, b->a.size));
 
 	fatal("Unknown ls sort type");
+	return 0;
 }
 
 /* sftp ls.1 replacement for directories */
@@ -1502,6 +1540,13 @@ parse_dispatch_command(struct sftp_conn *conn, const char *cmd, char **pwd,
 	glob_t g;
 
 	path1 = path2 = NULL;
+#ifdef WINDOWS
+	/* 
+	 * convert '\\' to '/' in Windows styled paths. 
+	 * else they get treated as escape sequence in makeargv 
+	 */
+	convertToForwardslash((char *)cmd);
+#endif
 	cmdnum = parse_args(&cmd, &ignore_errors, &disable_echo, &aflag, &fflag,
 	    &hflag, &iflag, &lflag, &pflag, &rflag, &sflag, &n_arg,
 	    &path1, &path2);
@@ -2203,9 +2248,13 @@ interactive_loop(struct sftp_conn *conn, char *file1, char *file2)
 	interactive = !batchmode && isatty(STDIN_FILENO);
 	err = 0;
 	for (;;) {
+#ifdef WINDOWS
+	void (*handler)(int);
+	handler = interactive ? read_interrupt : killchild;
+	ssh_signal(SIGINT, handler); 
+#else
 		struct sigaction sa;
 
-		interrupted = 0;
 		memset(&sa, 0, sizeof(sa));
 		sa.sa_handler = interactive ? read_interrupt : killchild;
 		if (sigaction(SIGINT, &sa, NULL) == -1) {
@@ -2213,6 +2262,8 @@ interactive_loop(struct sftp_conn *conn, char *file1, char *file2)
 			    strerror(errno));
 			break;
 		}
+#endif
+		interrupted = 0;
 		if (el == NULL) {
 			if (interactive)
 				printf("sftp> ");
@@ -2282,6 +2333,10 @@ connect_to_server(char *path, char **args, int *in, int *out)
 	*out = pout[1];
 	c_in = pout[0];
 	c_out = pin[1];
+	fcntl(pout[0], F_SETFD, FD_CLOEXEC);
+	fcntl(pout[1], F_SETFD, FD_CLOEXEC);
+	fcntl(pin[0], F_SETFD, FD_CLOEXEC);
+	fcntl(pin[1], F_SETFD, FD_CLOEXEC);
 #else /* USE_PIPES */
 	int inout[2];
 
@@ -2289,8 +2344,26 @@ connect_to_server(char *path, char **args, int *in, int *out)
 		fatal("socketpair: %s", strerror(errno));
 	*in = *out = inout[0];
 	c_in = c_out = inout[1];
+	fcntl(inout[0], F_SETFD, FD_CLOEXEC);
+	fcntl(inout[1], F_SETFD, FD_CLOEXEC);
 #endif /* USE_PIPES */
 
+
+#ifdef FORK_NOT_SUPPORTED
+	{
+		posix_spawn_file_actions_t actions;
+		sshpid = -1;
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, c_in, STDIN_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, c_out, STDOUT_FILENO) != 0 ) 
+			fatal("posix_spawn initialization failed");
+		else if (posix_spawn((pid_t*)&sshpid, path, &actions, NULL, args, NULL) != 0) 
+			fatal("posix_spawn: %s", strerror(errno));
+		
+		posix_spawn_file_actions_destroy(&actions);
+	}
+#else 
 	if ((sshpid = fork()) == -1)
 		fatal("fork: %s", strerror(errno));
 	else if (sshpid == 0) {
@@ -2317,7 +2390,7 @@ connect_to_server(char *path, char **args, int *in, int *out)
 		fprintf(stderr, "exec: %s: %s\n", path, strerror(errno));
 		_exit(1);
 	}
-
+#endif
 	ssh_signal(SIGTERM, killchild);
 	ssh_signal(SIGINT, killchild);
 	ssh_signal(SIGHUP, killchild);
@@ -2521,8 +2594,13 @@ main(int argc, char **argv)
 			host = cleanhostname(host);
 			break;
 		}
-		file2 = *(argv + 1);
 
+#ifdef WINDOWS
+		if (argc == (optind + 2))
+			file2 = *(argv + 1);
+#else
+		file2 = *(argv + 1);
+#endif
 		if (!*host) {
 			fprintf(stderr, "Missing hostname\n");
 			usage();
@@ -2547,7 +2625,12 @@ main(int argc, char **argv)
 		connect_to_server(ssh_program, args.list, &in, &out);
 	} else {
 		args.list = NULL;
+
+#ifdef WINDOWS
+		addargs(&args, "sftp-server.exe");
+#else
 		addargs(&args, "sftp-server");
+#endif // WINDOWS
 
 		connect_to_server(sftp_direct, args.list, &in, &out);
 	}
diff --git a/sk-usbhid.c b/sk-usbhid.c
index 2d36ac337..f99c0cfe6 100644
--- a/sk-usbhid.c
+++ b/sk-usbhid.c
@@ -789,7 +789,12 @@ sk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,
 		goto out;
 	}
 	*enroll_response = NULL;
+#ifdef WINDOWS
+	/* Don't overwrite existing credentials on FIDO authenticators. */
+	arc4random_buf(user_id, sizeof(user_id));
+#else
 	memset(user_id, 0, sizeof(user_id));
+#endif
 	if (check_enroll_options(options, &device, user_id,
 	    sizeof(user_id)) != 0)
 		goto out; /* error already logged */
@@ -809,8 +814,15 @@ sk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,
 	}
 	if (device != NULL)
 		sk = sk_open(device);
-	else
+	else {
+#ifdef WINDOWS
+		if ((sk = sk_open("windows://hello")) == NULL)
+			sk = sk_probe(NULL, NULL, 0);
+#else
 		sk = sk_probe(NULL, NULL, 0);
+#endif
+	}
+	
 	if (sk == NULL) {
 		ret = SSH_SK_ERR_DEVICE_NOT_FOUND;
 		skdebug(__func__, "failed to find sk");
@@ -825,12 +837,26 @@ sk_enroll(uint32_t alg, const uint8_t *challenge, size_t challenge_len,
 		skdebug(__func__, "fido_cred_set_type: %s", fido_strerr(r));
 		goto out;
 	}
+#ifndef WINDOWS
 	if ((r = fido_cred_set_clientdata(cred,
 	    challenge, challenge_len)) != FIDO_OK) {
 		skdebug(__func__, "fido_cred_set_clientdata: %s",
 		    fido_strerr(r));
 		goto out;
 	}
+#else
+	/*
+	 * webauthn.dll (windows://hello in libfido2) requires the unhashed
+	 * clientdata body, so we use fido_cred_set_clientdata() instead of
+	 * fido_cred_set_clientdata_hash().
+	 */
+	if ((r = fido_cred_set_clientdata(cred, challenge,
+	    challenge_len)) != FIDO_OK) {
+		skdebug(__func__, "fido_cred_set_clientdata: %s",
+		    fido_strerr(r));
+		goto out;
+	}
+#endif
 	if ((r = fido_cred_set_rk(cred, (flags & SSH_SK_RESIDENT_KEY) != 0 ?
 	    FIDO_OPT_TRUE : FIDO_OPT_OMIT)) != FIDO_OK) {
 		skdebug(__func__, "fido_cred_set_rk: %s", fido_strerr(r));
@@ -1084,6 +1110,9 @@ sk_sign(uint32_t alg, const uint8_t *data, size_t datalen,
 	char *device = NULL;
 	struct sk_usbhid *sk = NULL;
 	struct sk_sign_response *response = NULL;
+#ifndef WINDOWS
+	uint8_t message[32];
+#endif
 	int ret = SSH_SK_ERR_GENERAL, internal_uv;
 	int r;
 
@@ -1098,10 +1127,23 @@ sk_sign(uint32_t alg, const uint8_t *data, size_t datalen,
 		goto out; /* error already logged */
 	if (device != NULL)
 		sk = sk_open(device);
+#ifdef WINDOWS
+	else {
+		if ((sk = sk_open("windows://hello")) == NULL) {
+			if (pin != NULL ||
+			    (flags & SSH_SK_USER_VERIFICATION_REQD))
+				sk = sk_probe(NULL, NULL, 0);
+			else
+				sk = sk_probe(application, key_handle,
+				    key_handle_len);
+		}
+	}
+#else
 	else if (pin != NULL || (flags & SSH_SK_USER_VERIFICATION_REQD))
 		sk = sk_probe(NULL, NULL, 0);
 	else
 		sk = sk_probe(application, key_handle, key_handle_len);
+#endif
 	if (sk == NULL) {
 		ret = SSH_SK_ERR_DEVICE_NOT_FOUND;
 		skdebug(__func__, "failed to find sk");
@@ -1111,12 +1153,26 @@ sk_sign(uint32_t alg, const uint8_t *data, size_t datalen,
 		skdebug(__func__, "fido_assert_new failed");
 		goto out;
 	}
+#ifndef WINDOWS
 	if ((r = fido_assert_set_clientdata(assert,
 	    data, datalen)) != FIDO_OK)  {
 		skdebug(__func__, "fido_assert_set_clientdata: %s",
 		    fido_strerr(r));
 		goto out;
 	}
+#else
+	/*
+	 * webauthn.dll (windows://hello in libfido2) requires the unhashed
+	 * clientdata body, so we use fido_assert_set_clientdata() instead of
+	 * fido_assert_set_clientdata_hash().
+	 */
+	if ((r = fido_assert_set_clientdata(assert, data,
+	    datalen)) != FIDO_OK) {
+		skdebug(__func__, "fido_assert_set_clientdata: %s",
+		    fido_strerr(r));
+		goto out;
+	}
+#endif
 	if ((r = fido_assert_set_rp(assert, application)) != FIDO_OK) {
 		skdebug(__func__, "fido_assert_set_rp: %s", fido_strerr(r));
 		goto out;
diff --git a/ssh-add.c b/ssh-add.c
index 755547748..813ce4db4 100644
--- a/ssh-add.c
+++ b/ssh-add.c
@@ -349,7 +349,7 @@ add_file(int agent_fd, const char *filename, int key_only, int qflag,
 		}
 		ssh_free_identitylist(idlist);
 	}
-
+#ifndef WINDOWS
 	if (sshkey_is_sk(private)) {
 		if (skprovider == NULL) {
 			fprintf(stderr, "Cannot load FIDO key %s "
@@ -360,7 +360,10 @@ add_file(int agent_fd, const char *filename, int key_only, int qflag,
 		/* Don't send provider constraint for other keys */
 		skprovider = NULL;
 	}
-
+#else
+	if (!sshkey_is_sk(private))
+		skprovider = NULL;
+#endif
 	if ((r = ssh_add_identity_constrained(agent_fd, private, comment,
 	    lifetime, confirm, maxsign, skprovider,
 	    dest_constraints, ndest_constraints)) == 0) {
@@ -766,9 +769,14 @@ parse_dest_constraint(const char *s, struct dest_constraint ***dcp,
 static void
 usage(void)
 {
+#ifdef WINDOWS
+	fprintf(stderr,
+"usage: ssh-add [-cDdKkLlqvXx] [-E fingerprint_hash] [-S provider] [-t life]\n"
+#else
 	fprintf(stderr,
 "usage: ssh-add [-cDdKkLlqvXx] [-E fingerprint_hash] [-H hostkey_file]\n"
 "               [-h destination_constraint] [-S provider] [-t life]\n"
+#endif
 #ifdef WITH_XMSS
 "               [-M maxsign] [-m minleft]\n"
 #endif
@@ -819,7 +827,11 @@ main(int argc, char **argv)
 
 	skprovider = getenv("SSH_SK_PROVIDER");
 
+#ifdef WINDOWS
+	while ((ch = getopt(argc, argv, "vkKlLcdDTxXE:e:M:m:qs:S:t:")) != -1) {
+#else
 	while ((ch = getopt(argc, argv, "vkKlLcdDTxXE:e:h:H:M:m:qs:S:t:")) != -1) {
+#endif
 		switch (ch) {
 		case 'v':
 			if (log_level == SYSLOG_LEVEL_INFO)
@@ -832,12 +844,14 @@ main(int argc, char **argv)
 			if (fingerprint_hash == -1)
 				fatal("Invalid hash algorithm \"%s\"", optarg);
 			break;
+#ifndef WINDOWS
 		case 'H':
 			stringlist_append(&hostkey_files, optarg);
 			break;
 		case 'h':
 			stringlist_append(&dest_constraint_strings, optarg);
 			break;
+#endif
 		case 'k':
 			key_only = 1;
 			break;
@@ -929,7 +943,7 @@ main(int argc, char **argv)
 		goto done;
 	}
 
-#ifdef ENABLE_SK_INTERNAL
+#if !defined(WINDOWS) && defined(ENABLE_SK_INTERNAL)
 	if (skprovider == NULL)
 		skprovider = "internal";
 #endif
diff --git a/ssh-keygen.c b/ssh-keygen.c
index d4b7f4dcf..5a51f8a35 100644
--- a/ssh-keygen.c
+++ b/ssh-keygen.c
@@ -1125,6 +1125,7 @@ do_gen_all_hostkeys(struct passwd *pw)
 			    pub_tmp, strerror(errno));
 			goto failnext;
 		}
+
 		(void)fchmod(fd, 0644);
 		(void)close(fd);
 		if ((r = sshkey_save_public(public, pub_tmp, comment)) != 0) {
@@ -1746,6 +1747,9 @@ do_ca_sign(struct passwd *pw, const char *ca_key_path, int prefer_agent,
 	struct ssh_identitylist *agent_ids;
 	size_t j;
 	struct notifier_ctx *notifier = NULL;
+#ifdef WINDOWS
+	int retried = 0;
+#endif
 
 #ifdef ENABLE_PKCS11
 	pkcs11_init(1);
@@ -1781,12 +1785,14 @@ do_ca_sign(struct passwd *pw, const char *ca_key_path, int prefer_agent,
 	} else {
 		/* CA key is assumed to be a private key on the filesystem */
 		ca = load_identity(tmp, NULL);
+#ifndef WINDOWS
 		if (sshkey_is_sk(ca) &&
 		    (ca->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {
 			if ((pin = read_passphrase("Enter PIN for CA key: ",
 			    RP_ALLOW_STDIN)) == NULL)
 				fatal_f("couldn't read PIN");
 		}
+#endif
 	}
 	free(tmp);
 
@@ -1848,6 +1854,9 @@ do_ca_sign(struct passwd *pw, const char *ca_key_path, int prefer_agent,
 			    &agent_fd)) != 0)
 				fatal_r(r, "Couldn't certify %s via agent", tmp);
 		} else {
+#ifdef WINDOWS
+ retry:
+#endif
 			if (sshkey_is_sk(ca) &&
 			    (ca->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {
 				notifier = notify_start(0,
@@ -1857,6 +1866,17 @@ do_ca_sign(struct passwd *pw, const char *ca_key_path, int prefer_agent,
 			r = sshkey_certify(public, ca, key_type_name,
 			    sk_provider, pin);
 			notify_complete(notifier, "User presence confirmed");
+#ifdef WINDOWS
+			if (r == SSH_ERR_KEY_WRONG_PASSPHRASE &&
+			    pin == NULL && !retried && sshkey_is_sk(ca) &&
+			    (ca->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {
+				if ((pin = read_passphrase("Enter PIN for CA "
+				    "key: ", RP_ALLOW_STDIN)) == NULL)
+					fatal_f("couldn't read PIN");
+				retried = 1;
+				goto retry;
+			}
+#endif
 			if (r != 0)
 				fatal_r(r, "Couldn't certify key %s", tmp);
 		}
@@ -2419,7 +2439,11 @@ do_gen_krl(struct passwd *pw, int updating, const char *ca_key_path,
 		fatal("sshbuf_new failed");
 	if (ssh_krl_to_blob(krl, kbuf, NULL, 0) != 0)
 		fatal("Couldn't generate KRL");
+#ifdef WINDOWS
+	if ((r = sshbuf_write_file(identity_file, kbuf, 0644)) != 0)
+#else
 	if ((r = sshbuf_write_file(identity_file, kbuf)) != 0)
+#endif
 		fatal("write %s: %s", identity_file, strerror(errno));
 	sshbuf_free(kbuf);
 	ssh_krl_free(krl);
@@ -2527,6 +2551,7 @@ sign_one(struct sshkey *signkey, const char *filename, int fd,
 			fprintf(stderr, "Signing file %s\n", filename);
 	}
 	if (signer == NULL && sshkey_is_sk(signkey)) {
+#ifndef WINDOWS
 		if ((signkey->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {
 			xasprintf(&prompt, "Enter PIN for %s key: ",
 			    sshkey_type(signkey));
@@ -2534,6 +2559,7 @@ sign_one(struct sshkey *signkey, const char *filename, int fd,
 			    RP_ALLOW_STDIN)) == NULL)
 				fatal_f("couldn't read PIN");
 		}
+#endif
 		if ((signkey->sk_flags & SSH_SK_USER_PRESENCE_REQD)) {
 			if ((fp = sshkey_fingerprint(signkey, fingerprint_hash,
 			    SSH_FP_DEFAULT)) == NULL)
@@ -3062,6 +3088,7 @@ sk_suffix(const char *application, const uint8_t *user, size_t userlen)
 
 	/* Append user-id, escaping non-UTF-8 characters */
 	slen = userlen - i;
+#ifndef WINDOWS
 	if (asmprintf(&cp, INT_MAX, NULL, "%.*s", (int)slen, user) == -1)
 		fatal_f("asmprintf failed");
 	/* Don't emit a user-id that contains path or control characters */
@@ -3070,6 +3097,9 @@ sk_suffix(const char *application, const uint8_t *user, size_t userlen)
 		free(cp);
 		cp = tohex(user, slen);
 	}
+#else
+	cp = tohex(user, slen);
+#endif
 	xextendf(&ret, "_", "%s", cp);
 	free(cp);
 	return ret;
@@ -3176,9 +3206,13 @@ save_attestation(struct sshbuf *attest, const char *path)
 		return; /* nothing to do */
 	if (attest == NULL || sshbuf_len(attest) == 0)
 		fatal("Enrollment did not return attestation data");
+#ifdef WINDOWS
+	r = sshbuf_write_file(path, attest, 0644);
+#else
 	omask = umask(077);
 	r = sshbuf_write_file(path, attest);
 	umask(omask);
+#endif
 	if (r != 0)
 		fatal_r(r, "Unable to write attestation data \"%s\"", path);
 	if (!quiet)
@@ -3751,6 +3785,7 @@ main(int argc, char **argv)
 		}
 		if ((attest = sshbuf_new()) == NULL)
 			fatal("sshbuf_new failed");
+#ifndef WINDOWS
 		if ((sk_flags &
 		    (SSH_SK_USER_VERIFICATION_REQD|SSH_SK_RESIDENT_KEY))) {
 			passphrase = read_passphrase("Enter PIN for "
@@ -3758,6 +3793,9 @@ main(int argc, char **argv)
 		} else {
 			passphrase = NULL;
 		}
+#else
+		passphrase = NULL;
+#endif
 		for (i = 0 ; ; i++) {
 			fflush(stdout);
 			r = sshsk_enroll(type, sk_provider, sk_device,
diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index cfd833d74..45cda44b5 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -47,6 +47,127 @@
 #include "ssh-pkcs11.h"
 #include "ssherr.h"
 
+#ifdef WINDOWS
+#include "openbsd-compat/sys-queue.h"
+#define CRYPTOKI_COMPAT
+#include "pkcs11.h"
+
+static char module_path[PATH_MAX + 1];
+extern char *sshagent_con_username;
+extern HANDLE sshagent_client_primary_token;
+
+struct pkcs11_provider {
+	char			*name;
+	TAILQ_ENTRY(pkcs11_provider) next;
+};
+
+TAILQ_HEAD(, pkcs11_provider) pkcs11_providers;
+
+struct pkcs11_keyinfo {
+	struct sshkey	*key;
+	char		*providername, *label;
+	TAILQ_ENTRY(pkcs11_keyinfo) next;
+};
+
+TAILQ_HEAD(, pkcs11_keyinfo) pkcs11_keylist;
+
+#define MAX_MSG_LENGTH		10240 /*XXX*/
+
+/* input and output queue */
+struct sshbuf *iqueue;
+struct sshbuf *oqueue;
+
+void
+add_key(struct sshkey *k, char *name)
+{
+	struct pkcs11_keyinfo *ki;
+
+	ki = xcalloc(1, sizeof(*ki));
+	ki->providername = xstrdup(name);
+	ki->key = k;
+	TAILQ_INSERT_TAIL(&pkcs11_keylist, ki, next);
+}
+
+void
+del_all_keys()
+{
+	struct pkcs11_keyinfo *ki, *nxt;
+
+	for (ki = TAILQ_FIRST(&pkcs11_keylist); ki; ki = nxt) {
+		nxt = TAILQ_NEXT(ki, next);
+		TAILQ_REMOVE(&pkcs11_keylist, ki, next);
+		free(ki->providername);
+		sshkey_free(ki->key);
+		free(ki);
+	}
+}
+
+/* lookup matching 'private' key */
+struct sshkey *
+lookup_key(const struct sshkey *k)
+{
+	struct pkcs11_keyinfo *ki;
+
+	TAILQ_FOREACH(ki, &pkcs11_keylist, next) {
+		debug("check %p %s %s", ki, ki->providername, ki->label);
+		if (sshkey_equal(k, ki->key))
+			return (ki->key);
+	}
+	return (NULL);
+}
+
+static char *
+find_helper_in_module_path(void)
+{
+	wchar_t path[PATH_MAX + 1];
+	DWORD n;
+	char *ep;
+
+	memset(module_path, 0, sizeof(module_path));
+	memset(path, 0, sizeof(path));
+	if ((n = GetModuleFileNameW(NULL, path, PATH_MAX)) == 0 ||
+		n >= PATH_MAX) {
+		error_f("GetModuleFileNameW failed");
+		return NULL;
+	}
+	if (wcstombs_s(NULL, module_path, sizeof(module_path), path,
+		sizeof(module_path) - 1) != 0) {
+		error_f("wcstombs_s failed");
+		return NULL;
+	}
+	if ((ep = strrchr(module_path, '\\')) == NULL) {
+		error_f("couldn't locate trailing \\");
+		return NULL;
+	}
+	*(++ep) = '\0'; /* trim */
+	strlcat(module_path, "ssh-pkcs11-helper.exe", sizeof(module_path) - 1);
+
+	return module_path;
+}
+
+static char *
+find_helper(void)
+{
+	char *helper;
+	char module_path[PATH_MAX + 1];
+	char *ep;
+	DWORD n;
+
+	if ((helper = getenv("SSH_PKCS11_HELPER")) == NULL || strlen(helper) == 0) {
+		if ((helper = find_helper_in_module_path()) == NULL)
+			helper = _PATH_SSH_PKCS11_HELPER;
+	}
+	if (!path_absolute(helper)) {
+		error_f("helper \"%s\" unusable: path not absolute", helper);
+		return NULL;
+	}
+	debug_f("using \"%s\" as helper", helper);
+
+	return helper;
+}
+
+#endif /* WINDOWS */
+
 /* borrows code from sftp-server and ssh-agent */
 
 static int fd = -1;
@@ -104,14 +225,38 @@ recv_msg(struct sshbuf *m)
 int
 pkcs11_init(int interactive)
 {
+#ifdef WINDOWS
+	TAILQ_INIT(&pkcs11_providers);
+	TAILQ_INIT(&pkcs11_keylist);
+#endif /* WINDOWS */
 	return (0);
 }
 
 void
 pkcs11_terminate(void)
 {
+#ifdef WINDOWS
+	struct pkcs11_provider *p;
+
+	while ((p = TAILQ_FIRST(&pkcs11_providers)) != NULL) {
+		// Send message to helper to gracefully unload providers
+		pkcs11_del_provider(p->name);
+		TAILQ_REMOVE(&pkcs11_providers, p, next);
+	}
+
+	if (pid != -1) {
+		kill(pid, SIGTERM);
+		waitpid(pid, NULL, 0);
+		pid = -1;
+	}
+#endif /* WINDOWS */
+
 	if (fd >= 0)
 		close(fd);
+
+#ifdef WINDOWS
+	fd = -1;
+#endif
 }
 
 static int
@@ -273,6 +418,23 @@ pkcs11_start_helper(void)
 {
 	int pair[2];
 	char *helper, *verbosity = NULL;
+#ifdef WINDOWS
+	int r, actions_inited = 0;
+	char *av[3];
+	posix_spawn_file_actions_t actions;
+	HANDLE client_token = NULL, client_process_handle = NULL;
+
+	r = SSH_ERR_SYSTEM_ERROR;
+	pair[0] = pair[1] = -1;
+
+	if ((helper = find_helper()) == NULL)
+		goto out;
+#endif /* WINDOWS */
+
+
+#ifdef DEBUG_PKCS11
+	verbosity = "-vvv";
+#endif
 
 	if (log_level_get() >= SYSLOG_LEVEL_DEBUG1)
 		verbosity = "-vvv";
@@ -286,6 +448,41 @@ pkcs11_start_helper(void)
 		error("socketpair: %s", strerror(errno));
 		return (-1);
 	}
+#ifdef WINDOWS
+	if (posix_spawn_file_actions_init(&actions) != 0) {
+		error_f("posix_spawn_file_actions_init failed");
+		goto out;
+	}
+	actions_inited = 1;
+	if (posix_spawn_file_actions_adddup2(&actions, pair[1],
+		STDIN_FILENO) != 0 ||
+		posix_spawn_file_actions_adddup2(&actions, pair[1],
+			STDOUT_FILENO) != 0) {
+		error_f("posix_spawn_file_actions_adddup2 failed");
+		goto out;
+	}
+
+	av[0] = helper;
+	av[1] = verbosity;
+	av[2] = NULL;
+
+	if (!sshagent_con_username) {
+		error_f("sshagent_con_username is NULL");
+		goto out;
+	}
+
+	if (!sshagent_client_primary_token) {
+		error_f("sshagent_client_primary_token is NULL for user:%s", sshagent_con_username);
+		goto out;
+	}
+
+	if (posix_spawnp_as_user((pid_t *)&pid, av[0], &actions, NULL, av, NULL, sshagent_client_primary_token) != 0) {
+		error_f("failed to spwan process %s", av[0]);
+		goto out;
+	}
+	fd = pair[0];
+	r = 0;
+#else
 	if ((pid = fork()) == -1) {
 		error("fork: %s", strerror(errno));
 		return (-1);
@@ -309,6 +506,13 @@ pkcs11_start_helper(void)
 	close(pair[1]);
 	fd = pair[0];
 	return (0);
+#endif
+	/* success */
+	debug3_f("started pid=%ld", (long)pid);
+out:
+	if (client_token)
+		CloseHandle(client_token);
+	return r;
 }
 
 int
@@ -322,6 +526,7 @@ pkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp,
 	size_t blen;
 	u_int nkeys, i;
 	struct sshbuf *msg;
+	struct pkcs11_provider *p;
 
 	if (fd < 0 && pkcs11_start_helper() < 0)
 		return (-1);
@@ -363,6 +568,12 @@ pkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp,
 	} else {
 		nkeys = -1;
 	}
+
+#ifdef WINDOWS
+	p = xcalloc(1, sizeof(*p));
+	p->name = xstrdup(name);
+	TAILQ_INSERT_TAIL(&pkcs11_providers, p, next);
+#endif /* WINDOWS */
 	sshbuf_free(msg);
 	return (nkeys);
 }
diff --git a/ssh-pkcs11.h b/ssh-pkcs11.h
index 81f1d7c5d..7f181cb6a 100644
--- a/ssh-pkcs11.h
+++ b/ssh-pkcs11.h
@@ -24,8 +24,8 @@
 
 int	pkcs11_init(int);
 void	pkcs11_terminate(void);
-int	pkcs11_add_provider(char *, char *, struct sshkey ***, char ***);
-int	pkcs11_del_provider(char *);
+int	pkcs11_add_provider(char*, char*, struct sshkey***, char***);
+int	pkcs11_del_provider(char*);
 #ifdef WITH_PKCS11_KEYGEN
 struct sshkey *
 	pkcs11_gakp(char *, char *, unsigned int, char *, unsigned int,
diff --git a/ssh-sk-client.c b/ssh-sk-client.c
index 321fe53a2..1aa89e3aa 100644
--- a/ssh-sk-client.c
+++ b/ssh-sk-client.c
@@ -43,6 +43,62 @@
 
 /* #define DEBUG_SK 1 */
 
+#ifdef WINDOWS
+extern HANDLE sshagent_client_primary_token = NULL;
+extern char *sshagent_con_username = NULL;
+static char module_path[PATH_MAX + 1];
+
+static char *
+find_helper_in_module_path(void)
+{
+	wchar_t path[PATH_MAX + 1];
+	DWORD n;
+	char *ep;
+
+	memset(module_path, 0, sizeof(module_path));
+	memset(path, 0, sizeof(path));
+	if ((n = GetModuleFileNameW(NULL, path, PATH_MAX)) == 0 ||
+	    n >= PATH_MAX) {
+		error_f("GetModuleFileNameW failed");
+		return NULL;
+	}
+	if (wcstombs_s(NULL, module_path, sizeof(module_path), path,
+	    sizeof(module_path) - 1) != 0) {
+		error_f("wcstombs_s failed");
+		return NULL;
+	}
+	if ((ep = strrchr(module_path, '\\')) == NULL) {
+		error_f("couldn't locate trailing \\");
+		return NULL;
+	}
+	*(++ep) = '\0'; /* trim */
+	strlcat(module_path, "ssh-sk-helper.exe", sizeof(module_path) - 1);
+
+	return module_path;
+}
+
+static char *
+find_helper(void)
+{
+	char *helper;
+	char module_path[PATH_MAX + 1];
+	char *ep;
+	DWORD n;
+
+	if ((helper = getenv("SSH_SK_HELPER")) == NULL || strlen(helper) == 0) {
+		if ((helper = find_helper_in_module_path()) == NULL)
+			helper = _PATH_SSH_SK_HELPER;
+	}
+	if (!path_absolute(helper)) {
+		error_f("helper \"%s\" unusable: path not absolute", helper);
+		return NULL;
+	}
+	debug_f("using \"%s\" as helper", helper);
+
+	return helper;
+}
+#endif /* WINDOWS */
+
 static int
 start_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))
 {
@@ -50,11 +106,24 @@ start_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))
 	int oerrno, pair[2];
 	pid_t pid;
 	char *helper, *verbosity = NULL;
+#ifdef WINDOWS
+	int r, actions_inited = 0;
+	char *av[3];
+	posix_spawn_file_actions_t actions;
+#endif
 
 	*fdp = -1;
 	*pidp = 0;
 	*osigchldp = SIG_DFL;
+#ifdef WINDOWS
+	r = SSH_ERR_SYSTEM_ERROR;
+	pair[0] = pair[1] = -1;
+#endif
 
+#ifdef WINDOWS
+	if ((helper = find_helper()) == NULL)
+		goto out;
+#else
 	helper = getenv("SSH_SK_HELPER");
 	if (helper == NULL || strlen(helper) == 0)
 		helper = _PATH_SSH_SK_HELPER;
@@ -64,6 +133,8 @@ start_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))
 		errno = oerrno;
 		return SSH_ERR_SYSTEM_ERROR;
 	}
+#endif
+
 #ifdef DEBUG_SK
 	verbosity = "-vvv";
 #endif
@@ -71,9 +142,53 @@ start_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))
 	/* Start helper */
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {
 		error("socketpair: %s", strerror(errno));
+#ifdef WINDOWS
+		goto out;
+#else
 		return SSH_ERR_SYSTEM_ERROR;
+#endif
 	}
 	osigchld = ssh_signal(SIGCHLD, SIG_DFL);
+
+#ifdef WINDOWS
+	if (posix_spawn_file_actions_init(&actions) != 0) {
+		error_f("posix_spawn_file_actions_init failed");
+		goto out;
+	}
+	actions_inited = 1;
+	if (posix_spawn_file_actions_adddup2(&actions, pair[1],
+	    STDIN_FILENO) != 0 ||
+	    posix_spawn_file_actions_adddup2(&actions, pair[1],
+	    STDOUT_FILENO) != 0) {
+		error_f("posix_spawn_file_actions_adddup2 failed");
+		goto out;
+	}
+#endif
+
+#ifdef WINDOWS
+	av[0] = helper;
+	av[1] = verbosity;
+	av[2] = NULL;
+
+	if (sshagent_con_username) {
+		debug_f("sshagent_con_username:%s", sshagent_con_username);
+		if (!sshagent_client_primary_token) {
+			error_f("sshagent_client_primary_token is NULL for user:%s", sshagent_con_username);
+			goto out;
+		}
+
+		if (posix_spawnp_as_user((pid_t*)&pid, av[0], &actions, NULL, av, NULL, sshagent_client_primary_token) != 0) {
+			error_f("failed to spwan process %s", av[0]);
+			goto out;
+		}
+	} else {
+		if (posix_spawnp((pid_t *)&pid, av[0], &actions, NULL, av, NULL) != 0) {
+			error_f("posix_spawnp failed");
+			goto out;
+		}
+	}
+	r = 0;
+#else
 	if ((pid = fork()) == -1) {
 		oerrno = errno;
 		error("fork: %s", strerror(errno));
@@ -99,13 +214,26 @@ start_helper(int *fdp, pid_t *pidp, void (**osigchldp)(int))
 		_exit(1);
 	}
 	close(pair[1]);
-
+#endif
 	/* success */
 	debug3_f("started pid=%ld", (long)pid);
 	*fdp = pair[0];
 	*pidp = pid;
 	*osigchldp = osigchld;
+#ifdef WINDOWS
+	pair[0] = -1;
+out:
+	if (pair[0] != -1)
+		close(pair[0]);
+	if (pair[1] != -1)
+		close(pair[1]);
+	if (actions_inited)
+		posix_spawn_file_actions_destroy(&actions);
+
+	return r;
+#else
 	return 0;
+#endif
 }
 
 static int
diff --git a/ssh-sk-helper.c b/ssh-sk-helper.c
index b1d22631f..b71b6b947 100644
--- a/ssh-sk-helper.c
+++ b/ssh-sk-helper.c
@@ -112,10 +112,20 @@ process_sign(struct sshbuf *req)
 
 	if ((r = sshkey_private_deserialize(kbuf, &key)) != 0)
 		fatal_r(r, "%s: Unable to parse private key", __progname);
+#ifndef WINDOWS
 	if (!sshkey_is_sk(key)) {
 		fatal("%s: Unsupported key type %s",
 		    __progname, sshkey_ssh_name(key));
 	}
+#else
+	if (!sshkey_is_sk(key) || key->sk_application == NULL) {
+		fatal("%s: Unsupported key type %s",
+		    __progname, sshkey_ssh_name(key));
+	}
+	if (strncmp(key->sk_application, "ssh:", 4) != 0) {
+		fatal("%s: web-origin key", __progname);
+	}
+#endif
 
 	debug_f("ready to sign with key %s, provider %s: "
 	    "msg len %zu, compat 0x%lx", sshkey_type(key),
@@ -174,6 +184,10 @@ process_enroll(struct sshbuf *req)
 
 	if (type > INT_MAX)
 		fatal("%s: bad type %u", __progname, type);
+#ifdef WINDOWS
+	if (application == NULL || strncmp(application, "ssh:", 4) != 0)
+		fatal("%s: bogus application", __progname);
+#endif
 	if (sshbuf_len(challenge) == 0) {
 		sshbuf_free(challenge);
 		challenge = NULL;
@@ -248,6 +262,11 @@ process_load_resident(struct sshbuf *req)
 		fatal_r(r, "%s: compose", __progname);
 
 	for (i = 0; i < nsrks; i++) {
+#ifdef WINDOWS
+		if (srks[i]->key->sk_application == NULL ||
+		    strncmp(srks[i]->key->sk_application, "ssh:", 4) != 0)
+			fatal("%s: non-ssh application", __progname);
+#endif
 		debug_f("key %zu %s %s uidlen %zu", i,
 		    sshkey_type(srks[i]->key), srks[i]->key->sk_application,
 		    srks[i]->user_id_len);
diff --git a/ssh.c b/ssh.c
index 8ff978818..e7df27444 100644
--- a/ssh.c
+++ b/ssh.c
@@ -566,9 +566,20 @@ process_config_files(const char *host_name, struct passwd *pw, int final_pass,
 			    (final_pass ? SSHCONF_FINAL : 0), want_final_pass);
 
 		/* Read systemwide configuration file after user config. */
+#ifdef WINDOWS
+		/*
+		 *	Windows doesn't have systemwide configuration folder created by default.
+		 *	If a non-admin user creates the systemwide folder then systemwide ssh_config inherits parent folder permissions i.e., non-admin user have write permissions.
+		 *	This is not desirable. For windows, We make sure the systemwide sshd_config file is not editable by non-admin users.
+		 */
+		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,
+			host, host_name, &options, SSHCONF_CHECKPERM |
+			(final_pass ? SSHCONF_FINAL : 0), want_final_pass);
+#else
 		(void)read_config_file(_PATH_HOST_CONFIG_FILE, pw,
 		    host, host_name, &options,
 		    final_pass ? SSHCONF_FINAL : 0, want_final_pass);
+#endif
 	}
 }
 
@@ -1247,12 +1258,14 @@ main(int ac, char **av)
 		    strcmp(options.user, jumpuser) == 0)
 			fatal("jumphost loop via %s", options.jump_host);
 
+#ifndef WINDOWS /* TODO - implement "acesss" in posix layer and enable this */
 		/*
 		 * Try to use SSH indicated by argv[0], but fall back to
 		 * "ssh" if it appears unavailable.
 		 */
 		if (strchr(argv0, '/') != NULL && access(argv0, X_OK) != 0)
 			sshbin = "ssh";
+#endif
 
 		/* Consistency check */
 		if (options.proxy_command != NULL)
@@ -1261,7 +1274,11 @@ main(int ac, char **av)
 		options.proxy_use_fdpass = 0;
 		snprintf(port_s, sizeof(port_s), "%d", options.jump_port);
 		xasprintf(&options.proxy_command,
+#ifdef WINDOWS
+		    "\"%s\" %s%s%s%s%s%s%s%s%s%.*s -W \"[%%h]:%%p\" %s",
+#else
 		    "%s%s%s%s%s%s%s%s%s%s%.*s -W '[%%h]:%%p' %s",
+#endif
 		    sshbin,
 		    /* Optional "-l user" argument if jump_user set */
 		    options.jump_user == NULL ? "" : " -l ",
diff --git a/sshbuf-io.c b/sshbuf-io.c
index 13ef40e7d..18a819612 100644
--- a/sshbuf-io.c
+++ b/sshbuf-io.c
@@ -98,11 +98,19 @@ sshbuf_load_file(const char *path, struct sshbuf **bufp)
 }
 
 int
+#ifdef WINDOWS
+sshbuf_write_file(const char *path, struct sshbuf *buf, mode_t mode)
+#else
 sshbuf_write_file(const char *path, struct sshbuf *buf)
+#endif
 {
 	int fd, oerrno;
 
+#ifdef WINDOWS
+	if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, mode)) == -1)
+#else
 	if ((fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644)) == -1)
+#endif
 		return SSH_ERR_SYSTEM_ERROR;
 	if (atomicio(vwrite, fd, sshbuf_mutable_ptr(buf),
 	    sshbuf_len(buf)) != sshbuf_len(buf) || close(fd) != 0) {
diff --git a/sshbuf.h b/sshbuf.h
index 07d54f0a9..2f44ffc22 100644
--- a/sshbuf.h
+++ b/sshbuf.h
@@ -306,8 +306,14 @@ int sshbuf_load_file(const char *, struct sshbuf **)
  * Write a buffer to a path, creating/truncating as needed (mode 0644,
  * subject to umask). The buffer contents are not modified.
  */
+ #ifdef WINDOWS
+ /* umask doesn't work the same on windows. so pass the mode instead. */
+int sshbuf_write_file(const char *path, struct sshbuf *buf, mode_t mode)
+__attribute__((__nonnull__(2)));
+ #else
 int sshbuf_write_file(const char *path, struct sshbuf *buf)
     __attribute__((__nonnull__ (2)));
+#endif
 
 /* Read up to maxlen bytes from a fd directly to a buffer */
 int sshbuf_read(int, struct sshbuf *, size_t, size_t *)
diff --git a/sshconnect.c b/sshconnect.c
index ebecc8374..0ea64046f 100644
--- a/sshconnect.c
+++ b/sshconnect.c
@@ -49,6 +49,10 @@
 # include <ifaddrs.h>
 #endif
 
+#ifdef WINDOWS
+#include "sshTelemetry.h"
+#endif
+
 #include "xmalloc.h"
 #include "hostfile.h"
 #include "ssh.h"
@@ -213,6 +217,32 @@ ssh_proxy_connect(struct ssh *ssh, const char *host, const char *host_arg,
 	    host, host_arg, port);
 	debug("Executing proxy command: %.500s", command_string);
 
+
+#ifdef FORK_NOT_SUPPORTED
+	{
+		posix_spawn_file_actions_t actions;
+		char* spawn_argv[2];
+		/* 
+		 * expand_proxy_command prefixes cmdline with "exec " 
+		 */
+		spawn_argv[0] = command_string + 5;
+		spawn_argv[1] = NULL;
+		pid = -1;
+
+		/* disable inheritance */
+		fcntl(pin[1], F_SETFD, FD_CLOEXEC);
+		fcntl(pout[0], F_SETFD, FD_CLOEXEC);
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, pin[0], STDIN_FILENO) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, pout[1], STDOUT_FILENO) != 0)
+			fatal("posix_spawn initialization failed");
+		else if (posix_spawnp(&pid, spawn_argv[0], &actions, NULL, spawn_argv, NULL) != 0)
+			fatal("posix_spawnp: %s", strerror(errno));
+
+		posix_spawn_file_actions_destroy(&actions);
+	}
+#else 
 	/* Fork and execute the proxy command. */
 	if ((pid = fork()) == 0) {
 		char *argv[10];
@@ -252,6 +282,7 @@ ssh_proxy_connect(struct ssh *ssh, const char *host, const char *host_arg,
 		perror(argv[0]);
 		exit(1);
 	}
+#endif
 	/* Parent. */
 	if (pid == -1)
 		fatal("fork failed: %.100s", strerror(errno));
@@ -516,10 +547,16 @@ ssh_connect_direct(struct ssh *ssh, const char *host, struct addrinfo *aitop,
 	if (sock == -1) {
 		error("ssh: connect to host %s port %s: %s",
 		    host, strport, errno == 0 ? "failure" : strerror(errno));
+#ifdef WINDOWS
+		send_ssh_connection_telemetry(strerror(errno), strport);
+#endif
 		return -1;
 	}
 
 	debug("Connection established.");
+#ifdef WINDOWS
+	send_ssh_connection_telemetry("Connection established.", strport);
+#endif
 
 	/* Set SO_KEEPALIVE if requested. */
 	if (want_keepalive &&
@@ -1649,6 +1686,10 @@ ssh_local_cmd(const char *args)
 	    args == NULL || !*args)
 		return (1);
 
+#ifdef WINDOWS
+	return system(args);
+#endif
+
 	if ((shell = getenv("SHELL")) == NULL || *shell == '\0')
 		shell = _PATH_BSHELL;
 
diff --git a/sshconnect2.c b/sshconnect2.c
index b25225e64..31e1992ff 100644
--- a/sshconnect2.c
+++ b/sshconnect2.c
@@ -76,6 +76,10 @@
 #include "ssh-sk.h"
 #include "sk-api.h"
 
+#ifdef WINDOWS
+#include "sshTelemetry.h"
+#endif
+
 #ifdef GSSAPI
 #include "ssh-gss.h"
 #endif
@@ -485,6 +489,9 @@ ssh_userauth2(struct ssh *ssh, const char *local_user,
 
 	ssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);
 
+#ifdef WINDOWS
+	send_auth_telemetry(authctxt.success, authctxt.success ? authctxt.method->name : "NULL");
+#endif
 	if (!authctxt.success)
 		fatal("Authentication failed.");
 	if (ssh_packet_connection_is_on_socket(ssh)) {
@@ -710,22 +717,45 @@ input_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)
 	int r;
 
 	if (authctxt == NULL)
+#ifdef WINDOWS
+	{
+		send_pubkey_telemetry("input_userauth_pk_ok: no authentication context");
+		fatal("input_userauth_pk_ok: no authentication context");
+	}
+#else
 		fatal("input_userauth_pk_ok: no authentication context");
+#endif
 
 	if ((r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||
 	    (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0 ||
 	    (r = sshpkt_get_end(ssh)) != 0)
+#ifdef WINDOWS
+	{
+		send_pubkey_telemetry("failure");
+		goto done;
+	}
+#else
 		goto done;
+#endif
 
 	if ((pktype = sshkey_type_from_name(pkalg)) == KEY_UNSPEC) {
+#ifdef WINDOWS
+		send_pubkey_telemetry("server sent unknown pkalg");
+#endif
 		debug_f("server sent unknown pkalg %s", pkalg);
 		goto done;
 	}
 	if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {
+#ifdef WINDOWS
+		send_pubkey_telemetry("no key from blob");
+#endif		
 		debug_r(r, "no key from blob. pkalg %s", pkalg);
 		goto done;
 	}
 	if (key->type != pktype) {
+#ifdef WINDOWS
+		send_pubkey_telemetry("type mistmatch for decoded key");
+#endif 
 		error("input_userauth_pk_ok: type mismatch "
 		    "for decoded key (received %d, expected %d)",
 		    key->type, pktype);
@@ -752,6 +782,9 @@ input_userauth_pk_ok(int type, u_int32_t seq, struct ssh *ssh)
 	}
 	ident = format_identity(id);
 	debug("Server accepts key: %s", ident);
+#ifdef WINDOWS
+	send_pubkey_telemetry("success");
+#endif
 	sent = sign_and_send_pubkey(ssh, id);
 	r = 0;
  done:
@@ -1263,8 +1296,21 @@ identity_sign(struct identity *id, u_char **sigp, size_t *lenp,
 		}
 		sign_key = prv;
 		if (sshkey_is_sk(sign_key)) {
+#ifdef WINDOWS
+			/*
+			 * Don't prompt for FIDO2 PINs by default on Windows.
+			 * The odds are we are communicating with webauthn.dll,
+			 * which handles this internally. In the event we are
+			 * talking directly to a FIDO2 device and a PIN is
+			 * required, sshkey_sign() will return WRONG_PASSPHRASE
+			 * and we will prompt for a PIN when we retry.
+			 */
+			if ((sign_key->sk_flags &
+			    SSH_SK_USER_VERIFICATION_REQD) && 0) {
+#else
 			if ((sign_key->sk_flags &
 			    SSH_SK_USER_VERIFICATION_REQD)) {
+#endif
  retry_pin:
 				xasprintf(&prompt, "Enter PIN for %s key %s: ",
 				    sshkey_type(sign_key), id->filename);
@@ -1418,6 +1464,9 @@ sign_and_send_pubkey(struct ssh *ssh, Identity *id)
 		signature = NULL;
 		if ((alg = key_sig_algorithm(fallback_sigtype ? NULL : ssh,
 		    id->key)) == NULL) {
+#ifdef WINDOWS
+			send_pubkey_sign_telemetry("no mutual signature supported");
+#endif
 			error_f("no mutual signature supported");
 			goto out;
 		}
@@ -1469,6 +1518,9 @@ sign_and_send_pubkey(struct ssh *ssh, Identity *id)
 			    loc, sshkey_type(id->key), fp);
 			continue;
 		}
+#ifdef WINDOWS
+		send_pubkey_sign_telemetry("signing failed");
+#endif
 		error_fr(r, "signing failed for %s \"%s\"%s",
 		    sshkey_type(sign_id->key), sign_id->filename,
 		    id->agent_fd != -1 ? " from agent" : "");
@@ -1496,6 +1548,9 @@ sign_and_send_pubkey(struct ssh *ssh, Identity *id)
 
 	/* success */
 	sent = 1;
+#ifdef WINDOWS
+	send_pubkey_sign_telemetry("success");
+#endif
 
  out:
 	free(fp);
diff --git a/sshd.c b/sshd.c
index ef18ba467..17fe758f9 100644
--- a/sshd.c
+++ b/sshd.c
@@ -88,6 +88,10 @@
 #include <prot.h>
 #endif
 
+#ifdef WINDOWS
+#include "sshTelemetry.h"
+#endif
+
 #include "xmalloc.h"
 #include "ssh.h"
 #include "ssh2.h"
@@ -135,6 +139,17 @@
 #define REEXEC_CONFIG_PASS_FD		(STDERR_FILENO + 3)
 #define REEXEC_MIN_FREE_FD		(STDERR_FILENO + 4)
 
+/* Privilege separation related spawn fds */
+#define PRIVSEP_MONITOR_FD		(STDERR_FILENO + 1)
+#define PRIVSEP_LOG_FD			(STDERR_FILENO + 2)
+#define PRIVSEP_UNAUTH_MIN_FREE_FD	(PRIVSEP_LOG_FD + 1)
+
+#ifdef WINDOWS
+#define PRIVSEP_AUTH_MIN_FREE_FD	(PRIVSEP_LOG_FD + 1)
+#else
+#define PRIVSEP_AUTH_MIN_FREE_FD	(PRIVSEP_MONITOR_FD + 1)
+#endif
+
 extern char *__progname;
 
 /* Server configuration options. */
@@ -166,7 +181,11 @@ static int inetd_flag = 0;
 static int no_daemon_flag = 0;
 
 /* debug goes to stderr unless inetd_flag is set */
+#ifdef WINDOWS
+int log_stderr = 0;
+#else
 static int log_stderr = 0;
+#endif
 
 /* Saved arguments to main(). */
 static char **saved_argv;
@@ -190,6 +209,11 @@ static int num_listen_socks = 0;
 int auth_sock = -1;
 static int have_agent = 0;
 
+int privsep_unauth_child = 0;
+int privsep_auth_child = 0;
+int io_sock_in = 0;
+int io_sock_out = 0;
+
 /*
  * Any really sensitive data in the application is contained in this
  * structure. The idea is that this structure could be locked into memory so
@@ -469,6 +493,246 @@ privsep_preauth_child(void)
 	}
 }
 
+static void
+send_rexec_state(int, struct sshbuf *);
+static void send_config_state(int fd, struct sshbuf *conf)
+{
+	send_rexec_state(fd, conf);
+}
+
+static void
+recv_rexec_state(int, struct sshbuf *);
+static void recv_config_state(int fd, struct sshbuf *conf)
+{
+	recv_rexec_state(fd, conf);
+}
+
+
+static void
+send_idexch_state(struct ssh *ssh, int fd)
+{
+	struct sshbuf *m;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	if (sshbuf_put_stringb(m, ssh->kex->client_version) != 0  ||
+	    sshbuf_put_stringb(m, ssh->kex->server_version) != 0  ||
+	    sshbuf_put_u32(m, ssh->compat) != 0 )
+		fatal("%s: buffer error", __func__);
+
+	if (ssh_msg_send(fd, 0, m) == -1)
+		fatal("%s: ssh_msg_send failed", __func__);
+
+	sshbuf_free(m);
+}
+
+static void
+recv_idexch_state(struct ssh *ssh, int fd)
+{
+	struct sshbuf *m;
+	u_char *cp, ver;
+	size_t tmp;
+	int r;
+	const u_char *valp;
+	size_t lenp;
+	
+	debug3("%s: entering fd = %d", __func__, fd);
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (ssh_msg_recv(fd, m) == -1)
+		fatal("%s: ssh_msg_recv failed", __func__);
+	if ((r = sshbuf_get_u8(m, &ver)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (ver != 0)
+		fatal("%s: rexec version mismatch", __func__);
+
+	if (sshbuf_get_stringb(m, ssh->kex->client_version) != 0 ||
+	    sshbuf_get_stringb(m, ssh->kex->server_version) != 0 ||
+	    sshbuf_get_u32(m, &ssh->compat) != 0 )
+		fatal("%s: unable to retrieve idexch state", __func__);
+
+	sshbuf_free(m);
+
+	debug3("%s: done", __func__);
+}
+
+static void
+send_hostkeys_state(int fd)
+{
+	struct sshbuf *m;
+	int i;
+	u_char *blob = NULL;
+	size_t blen = 0;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	
+	sshbuf_put_u32(m, options.num_host_key_files);
+	for (i = 0; i < options.num_host_key_files; i++) {
+		if (blob) {
+			free(blob);
+			blob = NULL;
+		}
+		if (sensitive_data.host_pubkeys[i]) {
+			sshkey_to_blob(sensitive_data.host_pubkeys[i], &blob, &blen);
+			sshbuf_put_string(m, blob, blen);
+		}
+		else
+			sshbuf_put_string(m, NULL, 0);		
+	}
+
+	for (i = 0; i < options.num_host_key_files; i++) {
+		if (blob) {
+			free(blob);
+			blob = NULL;
+		}
+		if (sensitive_data.host_certificates[i]) {
+			sshkey_to_blob(sensitive_data.host_certificates[i], &blob, &blen);
+			sshbuf_put_string(m, blob, blen);
+		}
+		else
+			sshbuf_put_string(m, NULL, 0);
+	}
+
+	if (ssh_msg_send(fd, 0, m) == -1)
+		fatal("%s: ssh_msg_send failed", __func__);
+
+	if (blob)
+		free(blob);
+	sshbuf_free(m);
+}
+
+static void
+recv_hostkeys_state(int fd)
+{
+	struct sshbuf *m;
+	u_char *cp, ver;
+	struct sshkey *key = NULL;
+	const u_char *blob;
+	size_t blen;
+	int r;
+	u_int32_t num_host_key_files;
+
+	debug3("%s: entering fd = %d", __func__, fd);
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (ssh_msg_recv(fd, m) == -1)
+		fatal("%s: ssh_msg_recv failed", __func__);
+	if ((r = sshbuf_get_u8(m, &ver)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (ver != 0)
+		fatal("%s: rexec version mismatch", __func__);
+
+	if ((r = sshbuf_get_u32(m, &num_host_key_files)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	sensitive_data.host_keys = xcalloc(num_host_key_files, sizeof(struct sshkey *));
+	sensitive_data.host_pubkeys = xcalloc(num_host_key_files, sizeof(struct sshkey *));
+	sensitive_data.host_certificates = xcalloc(num_host_key_files, sizeof(struct sshkey *));
+	for (int i = 0; i < num_host_key_files; i++) {
+		if ((r = sshbuf_get_string_direct(m, &blob, &blen)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		sensitive_data.host_pubkeys[i] = NULL;
+		sensitive_data.host_keys[i] = NULL;
+
+		if (blen) {
+			sshkey_from_blob(blob, blen, &key);
+			sensitive_data.host_pubkeys[i] = key;
+		}
+	}
+
+	for (int i = 0; i < num_host_key_files; i++) {
+		if ((r = sshbuf_get_string_direct(m, &blob, &blen)) != 0)
+			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		sensitive_data.host_certificates[i] = NULL;
+		if (blen) {
+			sshkey_from_blob(blob, blen, &key);
+			sensitive_data.host_certificates[i] = key;
+		}
+	}
+
+	sshbuf_free(m);
+	debug3("%s: done", __func__);
+}
+
+static void
+send_autxctx_state(Authctxt *auth, int fd)
+{
+	struct sshbuf *m;
+	int r;
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if ((r = sshbuf_put_cstring(m, auth->pw->pw_name)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+	if (ssh_msg_send(fd, 0, m) == -1)
+		fatal("%s: ssh_msg_send failed", __func__);
+
+	sshbuf_free(m);
+}
+
+static void
+recv_autxctx_state(Authctxt *auth, int fd)
+{
+	struct sshbuf *m;
+	u_char *cp, ver, *user;
+	size_t user_len;
+	int r;
+
+	debug3("%s: entering fd = %d", __func__, fd);
+
+	if ((m = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+	if (ssh_msg_recv(fd, m) == -1)
+		fatal("%s: ssh_msg_recv failed", __func__);
+	if ((r = sshbuf_get_u8(m, &ver)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	if (ver != 0)
+		fatal("%s: rexec version mismatch", __func__);
+	if ((r = sshbuf_get_string_direct(m, &user, &user_len)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+	auth->user = xstrdup(user);
+
+	debug3("%s: done", __func__);
+	sshbuf_free(m);
+}
+
+static char**
+privsep_child_cmdline(int authenticated)
+{
+	char** argv = rexec_argv ? rexec_argv : saved_argv;
+	int argc = 0;
+	
+	if (rexec_argv)
+		argc = rexec_argc;
+	else {
+		if (rexeced_flag)
+			argc = saved_argc - 1; // override '-R'
+		else {
+			char **tmp = xcalloc(saved_argc + 1 + 1, sizeof(*saved_argv)); // 1 - extra argument "-y/-z", 1 - NULL
+			int i = 0;
+			for (i = 0; (int)i < saved_argc; i++) {
+				tmp[i] = xstrdup(saved_argv[i]);
+				free(saved_argv[i]);
+			}
+
+			free(saved_argv);
+			argv = saved_argv = tmp;
+			argc = saved_argc;
+		}
+	}
+
+	if (authenticated)
+		argv[argc] = "-z";
+	else
+		argv[argc] = "-y";
+
+	return argv;
+}
+
 static int
 privsep_preauth(struct ssh *ssh)
 {
@@ -481,6 +745,80 @@ privsep_preauth(struct ssh *ssh)
 	/* Store a pointer to the kex for later rekeying */
 	pmonitor->m_pkex = &ssh->kex;
 
+#ifdef FORK_NOT_SUPPORTED
+	if (privsep_auth_child) {
+		Authctxt *authctxt = ssh->authctxt;
+		recv_autxctx_state(authctxt, PRIVSEP_MONITOR_FD);
+		authctxt->pw = getpwnamallow(ssh, authctxt->user);
+		authctxt->valid = 1;
+		return 1;
+	}
+	else if (privsep_unauth_child) {
+		close(pmonitor->m_sendfd);
+		close(pmonitor->m_log_recvfd);
+		close(pmonitor->m_recvfd);
+		close(pmonitor->m_log_sendfd);
+
+		pmonitor->m_recvfd = PRIVSEP_MONITOR_FD;
+		pmonitor->m_log_sendfd = PRIVSEP_LOG_FD;
+		
+		fcntl(pmonitor->m_recvfd, F_SETFD, FD_CLOEXEC);
+		fcntl(pmonitor->m_log_sendfd, F_SETFD, FD_CLOEXEC);
+
+		/* Arrange for logging to be sent to the monitor */
+		set_log_handler(mm_log_handler, pmonitor);
+
+		privsep_preauth_child();
+		setproctitle("%s", "[net]");
+		return 0;
+	}
+	else { /* parent */
+		posix_spawn_file_actions_t actions;
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, io_sock_in, STDIN_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, io_sock_out, STDOUT_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, pmonitor->m_recvfd, PRIVSEP_MONITOR_FD) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, pmonitor->m_log_sendfd, PRIVSEP_LOG_FD) != 0 )
+			fatal("posix_spawn initialization failed");		
+		
+		{
+			char** argv = privsep_child_cmdline(0);
+			if (__posix_spawn_asuser(&pid, argv[0], &actions, NULL, argv, NULL, SSH_PRIVSEP_USER) != 0)
+				fatal("%s, fork of unprivileged child failed", __func__);
+			
+			posix_spawn_file_actions_destroy(&actions);
+		}
+
+		debug2("Network child is on pid %ld", (long)pid);
+
+		pmonitor->m_pid = pid;
+		if (have_agent) {
+			r = ssh_get_authentication_socket(&auth_sock);
+			if (r != 0) {
+				error("Could not get agent socket: %s",
+					ssh_err(r));
+				have_agent = 0;
+			}
+		}
+
+		close(pmonitor->m_recvfd);
+		close(pmonitor->m_log_sendfd);
+		send_config_state(pmonitor->m_sendfd, cfg);
+		send_hostkeys_state(pmonitor->m_sendfd);
+		send_idexch_state(ssh, pmonitor->m_sendfd);
+		monitor_child_preauth(ssh, pmonitor);
+		while (waitpid(pid, &status, 0) < 0) {
+			if (errno == EINTR)
+				continue;
+			pmonitor->m_pid = -1;
+			fatal("%s: waitpid: %s", __func__, strerror(errno));
+		}
+		privsep_is_preauth = 0;
+		pmonitor->m_pid = -1;
+		return 1;
+	}
+#else
 	if (use_privsep == PRIVSEP_ON)
 		box = ssh_sandbox_init(pmonitor);
 	pid = fork();
@@ -535,6 +873,7 @@ privsep_preauth(struct ssh *ssh)
 
 		return 0;
 	}
+#endif
 }
 
 static void
@@ -551,8 +890,77 @@ privsep_postauth(struct ssh *ssh, Authctxt *authctxt)
 	}
 
 	/* New socket pair */
+#ifdef WINDOWS
+	monitor_reinit_withlogs(pmonitor);
+#else
 	monitor_reinit(pmonitor);
+#endif
+
+#ifdef FORK_NOT_SUPPORTED
+	if (!privsep_auth_child) { /* parent */
+		posix_spawn_file_actions_t actions;
 
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, io_sock_in, STDIN_FILENO) != 0 ||
+		    posix_spawn_file_actions_adddup2(&actions, io_sock_out, STDOUT_FILENO) != 0 ||
+#ifdef WINDOWS
+			/*Allow authenticated child process to foward log messages to parent for processing*/
+		    posix_spawn_file_actions_adddup2(&actions, pmonitor->m_log_sendfd, PRIVSEP_LOG_FD) != 0 ||
+#endif
+		    posix_spawn_file_actions_adddup2(&actions, pmonitor->m_recvfd, PRIVSEP_MONITOR_FD) != 0)
+			fatal("posix_spawn initialization failed");
+		
+		{
+			char** argv = privsep_child_cmdline(1);
+			if (__posix_spawn_asuser(&pmonitor->m_pid, argv[0], &actions, NULL, argv, NULL, authctxt->pw->pw_name) != 0)
+				fatal("fork of unprivileged child failed");
+			posix_spawn_file_actions_destroy(&actions);
+		}
+		
+		verbose("User child is on pid %ld", (long)pmonitor->m_pid);
+		send_config_state(pmonitor->m_sendfd, cfg);
+		send_hostkeys_state(pmonitor->m_sendfd);
+		send_idexch_state(ssh, pmonitor->m_sendfd);
+		send_autxctx_state(authctxt, pmonitor->m_sendfd);
+		monitor_send_keystate(pmonitor);
+		monitor_clear_keystate(ssh, pmonitor);
+		monitor_send_authopt(pmonitor, 0); // 0 - trusted.
+		monitor_child_postauth(ssh, pmonitor);
+		/* NEVERREACHED */
+		exit(0);
+	}
+	/* child */
+	close(pmonitor->m_sendfd);
+	close(pmonitor->m_recvfd);
+	pmonitor->m_recvfd = PRIVSEP_MONITOR_FD;
+	fcntl(pmonitor->m_recvfd, F_SETFD, FD_CLOEXEC);
+	
+#ifdef WINDOWS
+	/*
+	 * Logs for authenticated child are sent to the monitor
+	 * to be written by parent process runing in SYSTEM.
+	 * That allows logs for non-admin child processes to be
+	 * recorded. 
+	 */
+	close(pmonitor->m_log_recvfd);
+	close(pmonitor->m_log_sendfd);
+	pmonitor->m_log_sendfd = PRIVSEP_LOG_FD;
+	fcntl(pmonitor->m_log_sendfd, F_SETFD, FD_CLOEXEC);
+
+	/* Arrange for logging to be sent to the monitor */
+	set_log_handler(mm_log_handler, pmonitor);
+#endif 
+
+	monitor_recv_keystate(pmonitor);
+
+	do_setusercontext(authctxt->pw);
+	monitor_apply_keystate(ssh, pmonitor);
+	monitor_recv_authopt(pmonitor);
+	ssh_packet_set_authenticated(ssh);
+skip:
+	return;
+
+#else
 	pmonitor->m_pid = fork();
 	if (pmonitor->m_pid == -1)
 		fatal("fork of unprivileged child failed");
@@ -588,6 +996,7 @@ privsep_postauth(struct ssh *ssh, Authctxt *authctxt)
 	 * this information is not part of the key state.
 	 */
 	ssh_packet_set_authenticated(ssh);
+#endif
 }
 
 static void
@@ -1279,6 +1688,11 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				close(startup_p[1]);
 				continue;
 			}
+			fcntl(startup_p[0], F_SETFD, FD_CLOEXEC);
+			fcntl(startup_p[1], F_SETFD, FD_CLOEXEC);
+			fcntl(config_s[0], F_SETFD, FD_CLOEXEC);
+			fcntl(config_s[1], F_SETFD, FD_CLOEXEC);
+
 
 			for (j = 0; j < options.max_startups; j++)
 				if (startup_pipes[j] == -1) {
@@ -1307,13 +1721,37 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 				startup_pipe = -1;
 				pid = getpid();
 				if (rexec_flag) {
+#ifndef WINDOWS
 					send_rexec_state(config_s[0], cfg);
+#endif
 					close(config_s[0]);
 				}
 				free(pfd);
 				return;
 			}
 
+#ifdef FORK_NOT_SUPPORTED
+			{
+				posix_spawn_file_actions_t actions;
+				posix_spawnattr_t attributes;
+				if (posix_spawn_file_actions_init(&actions) != 0 ||
+				    posix_spawn_file_actions_adddup2(&actions, *newsock, STDIN_FILENO) != 0 ||
+				    posix_spawn_file_actions_adddup2(&actions, *newsock, STDOUT_FILENO) != 0 ||
+				    posix_spawn_file_actions_adddup2(&actions, startup_p[1], REEXEC_STARTUP_PIPE_FD) != 0 ||
+				    posix_spawn_file_actions_adddup2(&actions, config_s[1], REEXEC_CONFIG_PASS_FD) != 0 ||
+				    posix_spawnattr_init(&attributes) != 0 ||
+				    posix_spawnattr_setflags(&attributes, POSIX_SPAWN_SETPGROUP) != 0 ||
+				    posix_spawnattr_setpgroup(&attributes, 0) != 0)
+					error("posix_spawn initialization failed");
+				else {
+					if (posix_spawn(&pid, rexec_argv[0], &actions, &attributes, rexec_argv, NULL) != 0)
+						error("%s, posix_spawn failed", __func__);
+					posix_spawn_file_actions_destroy(&actions);
+					posix_spawnattr_destroy(&attributes);
+				}
+
+			}
+#else
 			/*
 			 * Normal production daemon.  Fork, and have
 			 * the child process the connection. The
@@ -1364,6 +1802,7 @@ server_accept_loop(int *sock_in, int *sock_out, int *newsock, int *config_s)
 			else
 				debug("Forked child %ld.", (long)pid);
 
+#endif /* fork unsupported */
 			close(startup_p[1]);
 
 			if (rexec_flag) {
@@ -1574,7 +2013,7 @@ main(int ac, char **av)
 
 	/* Parse command-line arguments. */
 	while ((opt = getopt(ac, av,
-	    "C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrt")) != -1) {
+	    "C:E:b:c:f:g:h:k:o:p:u:46DQRTdeiqrtyz")) != -1) {
 		switch (opt) {
 		case '4':
 			options.address_family = AF_INET;
@@ -1675,6 +2114,18 @@ main(int ac, char **av)
 				exit(1);
 			free(line);
 			break;
+		case 'y':
+			privsep_unauth_child = 1;
+			rexec_flag = 0;
+			logfile = NULL;
+			//Sleep(10 * 1000);
+			break;
+		case 'z':
+			privsep_auth_child = 1;
+			rexec_flag = 0;
+			logfile = NULL;
+			//Sleep(10 * 1000);
+			break;
 		case '?':
 		default:
 			usage();
@@ -1683,10 +2134,14 @@ main(int ac, char **av)
 	}
 	if (rexeced_flag || inetd_flag)
 		rexec_flag = 0;
-	if (!test_flag && rexec_flag && !path_absolute(av[0]))
+	if (!test_flag && !debug_flag && rexec_flag && !path_absolute(av[0]))
 		fatal("sshd re-exec requires execution with an absolute path");
 	if (rexeced_flag)
 		closefrom(REEXEC_MIN_FREE_FD);
+	else if (privsep_unauth_child)
+		closefrom(PRIVSEP_UNAUTH_MIN_FREE_FD);
+	else if (privsep_auth_child)
+		closefrom(PRIVSEP_AUTH_MIN_FREE_FD);
 	else
 		closefrom(REEXEC_DEVCRYPTO_RESERVED_FD);
 
@@ -1736,7 +2191,10 @@ main(int ac, char **av)
 			 */
 			(void)atomicio(vwrite, startup_pipe, "\0", 1);
 		}
-	} else if (strcasecmp(config_file_name, "none") != 0)
+	}
+	else if (privsep_unauth_child || privsep_auth_child)
+		recv_config_state(PRIVSEP_MONITOR_FD, cfg); //TODO - should starup_pipe be closed as above ?
+	else if (strcasecmp(config_file_name, "none") != 0)
 		load_server_config(config_file_name, cfg);
 
 	parse_server_config(&options, rexeced_flag ? "rexec" : config_file_name,
@@ -1799,6 +2257,11 @@ main(int ac, char **av)
 		privsep_pw->pw_passwd = xstrdup("*");
 	}
 	endpwent();
+	
+	if (privsep_auth_child || privsep_unauth_child) {
+		recv_hostkeys_state(PRIVSEP_MONITOR_FD);
+		goto done_loading_hostkeys;
+	}
 
 	/* load host keys */
 	sensitive_data.host_keys = xcalloc(options.num_host_key_files,
@@ -1823,6 +2286,7 @@ main(int ac, char **av)
 
 		if (options.host_key_files[i] == NULL)
 			continue;
+		if (privsep_unauth_child || privsep_auth_child) key = NULL; else /*TODO - remove this*/
 		if ((r = sshkey_load_private(options.host_key_files[i], "",
 		    &key, NULL)) != 0 && r != SSH_ERR_SYSTEM_ERROR)
 			do_log2_r(r, ll, "Unable to load host key \"%s\"",
@@ -1942,7 +2406,7 @@ main(int ac, char **av)
 		debug("host certificate: #%u type %d %s", j, key->type,
 		    sshkey_type(key));
 	}
-
+done_loading_hostkeys:
 	if (privsep_chroot) {
 		struct stat st;
 
@@ -2042,6 +2506,11 @@ main(int ac, char **av)
 	/* Get a connection, either from inetd or a listening TCP socket */
 	if (inetd_flag) {
 		server_accept_inetd(&sock_in, &sock_out);
+	} else if (privsep_unauth_child || privsep_auth_child) {
+		sock_in = sock_out = dup(STDIN_FILENO);
+		close(STDIN_FILENO);
+		close(STDOUT_FILENO);
+		startup_pipe = -1;
 	} else {
 		platform_pre_listen();
 		server_listen();
@@ -2083,6 +2552,7 @@ main(int ac, char **av)
 	if (!debug_flag && !inetd_flag && setsid() == -1)
 		error("setsid: %.100s", strerror(errno));
 
+#ifndef FORK_NOT_SUPPORTED
 	if (rexec_flag) {
 		debug("rexec start in %d out %d newsock %d pipe %d sock %d",
 		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
@@ -2116,7 +2586,7 @@ main(int ac, char **av)
 		debug("rexec cleanup in %d out %d newsock %d pipe %d sock %d",
 		    sock_in, sock_out, newsock, startup_pipe, config_s[0]);
 	}
-
+#endif
 	/* Executed child processes don't need these. */
 	fcntl(sock_out, F_SETFD, FD_CLOEXEC);
 	fcntl(sock_in, F_SETFD, FD_CLOEXEC);
@@ -2133,8 +2603,18 @@ main(int ac, char **av)
 	 * Register our connection.  This turns encryption off because we do
 	 * not have a key.
 	 */
+	io_sock_in = sock_in;
+	io_sock_out = sock_out;
 	if ((ssh = ssh_packet_set_connection(NULL, sock_in, sock_out)) == NULL)
+#ifdef WINDOWS
+	{
+		send_sshd_connection_telemetry(
+			"connection failed: unable to create connection");
+		fatal("Unable to create connection");
+	}
+#else
 		fatal("Unable to create connection");
+#endif 
 	the_active_state = ssh;
 	ssh_packet_set_server(ssh);
 
@@ -2152,6 +2632,10 @@ main(int ac, char **av)
 
 	if ((remote_port = ssh_remote_port(ssh)) < 0) {
 		debug("ssh_remote_port failed");
+#ifdef WINDOWS
+		send_sshd_connection_telemetry(
+			"connection failed: ssh_remote_port failed");
+#endif
 		cleanup_exit(255);
 	}
 
@@ -2171,6 +2655,10 @@ main(int ac, char **av)
 
 	rdomain = ssh_packet_rdomain_in(ssh);
 
+	if (privsep_unauth_child || privsep_auth_child) {
+		recv_idexch_state(ssh, PRIVSEP_MONITOR_FD);
+		goto idexch_done;
+	}
 	/* Log the connection. */
 	laddr = get_local_ipaddr(sock_in);
 	verbose("Connection from %s port %d on %s port %d%s%s%s",
@@ -2178,6 +2666,9 @@ main(int ac, char **av)
 	    rdomain == NULL ? "" : " rdomain \"",
 	    rdomain == NULL ? "" : rdomain,
 	    rdomain == NULL ? "" : "\"");
+#ifdef WINDOWS
+	send_sshd_connection_telemetry("connection established");
+#endif
 	free(laddr);
 
 	/*
@@ -2195,7 +2686,7 @@ main(int ac, char **av)
 	if ((r = kex_exchange_identification(ssh, -1,
 	    options.version_addendum)) != 0)
 		sshpkt_fatal(ssh, r, "banner exchange");
-
+idexch_done:
 	ssh_packet_set_nonblocking(ssh);
 
 	/* allocate authentication context */
diff --git a/sshkey.c b/sshkey.c
index f1e92003b..2b8aa2c3f 100644
--- a/sshkey.c
+++ b/sshkey.c
@@ -63,6 +63,9 @@
 #include "sshkey-xmss.h"
 #include "xmss_fast.h"
 #endif
+#ifdef WINDOWS
+#include <lmcons.h>
+#endif
 
 #include "openbsd-compat/openssl-compat.h"
 
@@ -71,6 +74,12 @@
 #define MARK_END		"-----END OPENSSH PRIVATE KEY-----\n"
 #define MARK_BEGIN_LEN		(sizeof(MARK_BEGIN) - 1)
 #define MARK_END_LEN		(sizeof(MARK_END) - 1)
+#ifdef SUPPORT_CRLF
+#define MARK_BEGIN_CRLF		"-----BEGIN OPENSSH PRIVATE KEY-----\r\n"
+#define MARK_END_CRLF		"-----END OPENSSH PRIVATE KEY-----\r\n"
+#define MARK_BEGIN_LEN_CRLF		(sizeof(MARK_BEGIN_CRLF) - 1)
+#define MARK_END_LEN_CRLF		(sizeof(MARK_END_CRLF) - 1)
+#endif // SUPPORT_CRLF
 #define KDFNAME			"bcrypt"
 #define AUTH_MAGIC		"openssh-key-v1"
 #define SALT_LEN		16
@@ -3143,6 +3152,34 @@ sshkey_cert_check_authority(const struct sshkey *k,
 	} else if (name != NULL) {
 		principal_matches = 0;
 		for (i = 0; i < k->cert->nprincipals; i++) {
+
+#ifdef WINDOWS
+			char cert_principal_name_copy[UNLEN + DNLEN + 1 + 1] = { 0, };
+			strcpy_s(cert_principal_name_copy, _countof(cert_principal_name_copy), k->cert->principals[i]);
+
+			/*
+			* For domain user we need special handling.
+			* We support both "domain\user" and "domain/user" formats.
+			*/
+			if (strstr(name, "/") || strstr(name, "\\")) {
+				char *tmp = NULL;
+				if (tmp = strstr(cert_principal_name_copy, "/"))
+					*tmp = '\\';
+			}
+
+			/* In windows, usernames are case insensitive */
+			if (wildcard_pattern) {
+				/* Use match_pattern_list for case insensitive compairision */
+				if (match_pattern_list(cert_principal_name_copy,
+				    name, 1)) {
+					principal_matches = 1;
+					break;
+				}
+			} else if (_strcmpi(name, cert_principal_name_copy) == 0) {
+				principal_matches = 1;
+				break;
+			}
+#else
 			if (wildcard_pattern) {
 				if (match_pattern(k->cert->principals[i],
 				    name)) {
@@ -3153,6 +3190,7 @@ sshkey_cert_check_authority(const struct sshkey *k,
 				principal_matches = 1;
 				break;
 			}
+#endif
 		}
 		if (!principal_matches) {
 			*reason = "Certificate invalid: name is not a listed "
@@ -4058,8 +4096,16 @@ private2_uudecode(struct sshbuf *blob, struct sshbuf **decodedp)
 	/* check preamble */
 	cp = sshbuf_ptr(blob);
 	encoded_len = sshbuf_len(blob);
+	
+#ifdef SUPPORT_CRLF
+	if ((encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||
+	    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) &&
+	    (encoded_len < (MARK_BEGIN_LEN_CRLF + MARK_END_LEN_CRLF) ||
+	    memcmp(cp, MARK_BEGIN_CRLF, MARK_BEGIN_LEN_CRLF) != 0)) {
+#else  /* !SUPPORT_CRLF */
 	if (encoded_len < (MARK_BEGIN_LEN + MARK_END_LEN) ||
-	    memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {
+		memcmp(cp, MARK_BEGIN, MARK_BEGIN_LEN) != 0) {
+#endif /* !SUPPORT_CRLF */
 		r = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
@@ -4076,8 +4122,15 @@ private2_uudecode(struct sshbuf *blob, struct sshbuf **decodedp)
 		encoded_len--;
 		cp++;
 		if (last == '\n') {
+#ifdef SUPPORT_CRLF
+			if ((encoded_len >= MARK_END_LEN &&
+			    memcmp(cp, MARK_END, MARK_END_LEN) == 0) ||
+			    (encoded_len >= MARK_END_LEN_CRLF &&
+			    memcmp(cp, MARK_END_CRLF, MARK_END_LEN_CRLF) == 0)) {
+#else  /* !SUPPORT_CRLF */
 			if (encoded_len >= MARK_END_LEN &&
 			    memcmp(cp, MARK_END, MARK_END_LEN) == 0) {
+#endif /* !SUPPORT_CRLF */
 				/* \0 terminate */
 				if ((r = sshbuf_put_u8(encoded, 0)) != 0)
 					goto out;
diff --git a/sshsig.c b/sshsig.c
index 773613462..2e644fa59 100644
--- a/sshsig.c
+++ b/sshsig.c
@@ -32,6 +32,9 @@
 #include "sshsig.h"
 #include "ssherr.h"
 #include "sshkey.h"
+#ifdef WINDOWS
+#include "sk-api.h" /* XXX for SSH_SK_USER_VERIFICATION_REQD */
+#endif
 #include "match.h"
 #include "digest.h"
 
@@ -563,6 +566,10 @@ sshsig_sign_fd(struct sshkey *key, const char *hashalg,
 {
 	struct sshbuf *b = NULL;
 	int r = SSH_ERR_INTERNAL_ERROR;
+#ifdef WINDOWS
+	int retried = 0;
+	char *pin = NULL, *prompt = NULL;
+#endif
 
 	if (hashalg == NULL)
 		hashalg = HASHALG_DEFAULT;
@@ -572,12 +579,38 @@ sshsig_sign_fd(struct sshkey *key, const char *hashalg,
 		error_fr(r, "hash_file");
 		return r;
 	}
+#ifdef WINDOWS
+ retry:
+#endif
 	if ((r = sshsig_wrap_sign(key, hashalg, sk_provider, sk_pin, b,
-	    sig_namespace, out, signer, signer_ctx)) != 0)
+	    sig_namespace, out, signer, signer_ctx)) != 0) {
+#ifdef WINDOWS
+		if (r == SSH_ERR_KEY_WRONG_PASSPHRASE && signer == NULL &&
+		    sshkey_is_sk(key) && sk_pin == NULL && !retried &&
+		    (key->sk_flags & SSH_SK_USER_VERIFICATION_REQD)) {
+			xasprintf(&prompt, "Enter PIN for %s key: ",
+			    sshkey_type(key));
+			if ((pin = read_passphrase(prompt,
+			    RP_ALLOW_STDIN)) == NULL) {
+				debug_f("couldn't read PIN");
+				goto out;
+			}
+			sk_pin = pin;
+			retried = 1;
+			goto retry;
+		}
+		error_fr(r, "sshsig_wrap_sign");
+#endif
 		goto out;
+	}
 	/* success */
 	r = 0;
  out:
+#ifdef WINDOWS
+	free(prompt);
+	if (pin != NULL)
+		freezero(pin, strlen(pin));
+#endif
 	sshbuf_free(b);
 	return r;
 }
diff --git a/version.h b/version.h
index 09da52d0d..ac6a33820 100644
--- a/version.h
+++ b/version.h
@@ -1,6 +1,6 @@
 /* $OpenBSD: version.h,v 1.93 2022/02/23 11:07:09 djm Exp $ */
 
-#define SSH_VERSION	"OpenSSH_8.9"
+#define SSH_VERSION	"OpenSSH_for_Windows_8.9"
 
 #define SSH_PORTABLE	"p1"
 #define SSH_RELEASE	SSH_VERSION SSH_PORTABLE
-- 
2.25.1

