From b70d9fefb941d247e184502814a6212cefc2823b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marc-Andr=C3=A9=20Moreau?= <mamoreau@devolutions.net>
Date: Fri, 2 Feb 2024 09:28:51 -0500
Subject: [PATCH 1/7] Win32-OpenSSH v9.5.0 added files

---
 .azdo/ci.yml                                  |  224 ++
 .azdo/codeql.yml                              |   43 +
 NOTICE                                        |  489 ++++
 contrib/win32/install/client.wxs              |   32 +
 contrib/win32/install/openssh.wixproj         |   49 +
 contrib/win32/install/product.wxs             |   49 +
 contrib/win32/install/server.wxs              |   69 +
 contrib/win32/install/shared.wxs              |   89 +
 contrib/win32/openssh/AnalyzeCodeDiff.ps1     |  200 ++
 .../AzDOBuildTools/AzDOBuildTools.psd1        |   39 +
 .../AzDOBuildTools/AzDOBuildTools.psm1        |  513 ++++
 contrib/win32/openssh/BinSkimConfig.xml       |  126 +
 contrib/win32/openssh/CredScanSuppress.json   |   37 +
 contrib/win32/openssh/DockerFile              |   10 +
 .../win32/openssh/FixHostFilePermissions.ps1  |   60 +
 .../win32/openssh/FixUserFilePermissions.ps1  |   35 +
 contrib/win32/openssh/GetFIDO2.ps1            |   62 +
 contrib/win32/openssh/GetLibreSSL.ps1         |   61 +
 contrib/win32/openssh/GetZLib.ps1             |   60 +
 contrib/win32/openssh/MSG00001.bin            |  Bin 0 -> 188 bytes
 contrib/win32/openssh/MicrosoftTelemetry.h    |   87 +
 contrib/win32/openssh/NOTICE_for_release.txt  |  728 ++++++
 contrib/win32/openssh/OpenSSH-build.ps1       |   49 +
 contrib/win32/openssh/OpenSSHBuildHelper.psm1 |  787 ++++++
 contrib/win32/openssh/OpenSSHCommonUtils.psm1 |   65 +
 contrib/win32/openssh/OpenSSHTestHelper.psm1  |  832 +++++++
 contrib/win32/openssh/OpenSSHUtils.psd1       |   44 +
 contrib/win32/openssh/OpenSSHUtils.psm1       |  853 +++++++
 .../win32/openssh/OpenSSL-1.0.2d_build.cmd    |   45 +
 contrib/win32/openssh/Openssh-events.man      |   63 +
 contrib/win32/openssh/README.txt              |   62 +
 contrib/win32/openssh/SignConfig.xml          |   29 +
 contrib/win32/openssh/Win32-OpenSSH.sln       |  612 +++++
 .../win32/openssh/Win32-OpenSSh-design.pptx   |  Bin 0 -> 37646 bytes
 contrib/win32/openssh/bash_tests_iterator.ps1 |  303 +++
 contrib/win32/openssh/build.json              |  246 ++
 contrib/win32/openssh/config.h.vs             | 1770 ++++++++++++++
 contrib/win32/openssh/config.ps1              |   19 +
 contrib/win32/openssh/config.vcxproj          |  505 ++++
 contrib/win32/openssh/config.vcxproj.filters  |   17 +
 contrib/win32/openssh/etwgen.cmd              |    3 +
 contrib/win32/openssh/install-sshd.ps1        |  143 ++
 contrib/win32/openssh/keygen.vcxproj          |  421 ++++
 contrib/win32/openssh/keygen.vcxproj.filters  |   39 +
 contrib/win32/openssh/libssh.vcxproj          |  461 ++++
 contrib/win32/openssh/libssh.vcxproj.filters  |  285 +++
 contrib/win32/openssh/openbsd_compat.vcxproj  |  451 ++++
 .../openssh/openbsd_compat.vcxproj.filters    |  315 +++
 contrib/win32/openssh/openssh-events.rc       |    3 +
 contrib/win32/openssh/openssh-eventsTEMP.BIN  |  Bin 0 -> 1114 bytes
 contrib/win32/openssh/openssh_build.cmd       |    4 +
 contrib/win32/openssh/paths.targets           |   33 +
 contrib/win32/openssh/resource.h              |   15 +
 contrib/win32/openssh/scp.vcxproj             |  423 ++++
 contrib/win32/openssh/scp.vcxproj.filters     |   45 +
 contrib/win32/openssh/sftp-server.vcxproj     |  420 ++++
 .../win32/openssh/sftp-server.vcxproj.filters |   36 +
 contrib/win32/openssh/sftp.vcxproj            |  424 ++++
 contrib/win32/openssh/sftp.vcxproj.filters    |   48 +
 contrib/win32/openssh/ssh-add.vcxproj         |  423 ++++
 contrib/win32/openssh/ssh-add.vcxproj.filters |   41 +
 contrib/win32/openssh/ssh-agent.vcxproj       |  427 ++++
 contrib/win32/openssh/ssh-keyscan.vcxproj     |  414 ++++
 .../win32/openssh/ssh-keyscan.vcxproj.filters |   33 +
 .../win32/openssh/ssh-pkcs11-helper.vcxproj   |  415 ++++
 contrib/win32/openssh/ssh-shellhost.vcxproj   |  410 ++++
 contrib/win32/openssh/ssh-sk-helper.vcxproj   |  417 ++++
 contrib/win32/openssh/ssh.vcxproj             |  527 ++++
 contrib/win32/openssh/ssh.vcxproj.filters     |  329 +++
 contrib/win32/openssh/sshTelemetry.c          |  220 ++
 contrib/win32/openssh/sshTelemetry.h          |   35 +
 contrib/win32/openssh/sshTelemetryInternal.h  |    8 +
 contrib/win32/openssh/sshd.vcxproj            |  483 ++++
 contrib/win32/openssh/sshd.vcxproj.filters    |  168 ++
 contrib/win32/openssh/sshd_config             |   88 +
 contrib/win32/openssh/targetos.manifest       |   22 +
 contrib/win32/openssh/uninstall-sshd.ps1      |   37 +
 contrib/win32/openssh/unittest-bitmap.vcxproj |  418 ++++
 .../win32/openssh/unittest-hostkeys.vcxproj   |  431 ++++
 contrib/win32/openssh/unittest-kex.vcxproj    |  431 ++++
 contrib/win32/openssh/unittest-match.vcxproj  |  418 ++++
 contrib/win32/openssh/unittest-misc.vcxproj   |  437 ++++
 contrib/win32/openssh/unittest-sshbuf.vcxproj |  442 ++++
 contrib/win32/openssh/unittest-sshkey.vcxproj |  443 ++++
 contrib/win32/openssh/unittest-utf8.vcxproj   |  208 ++
 .../openssh/unittest-win32compat.vcxproj      |  439 ++++
 contrib/win32/openssh/updateSigning.ps1       |   37 +
 contrib/win32/openssh/version.rc              |   95 +
 contrib/win32/openssh/vstsbuild.ps1           |  139 ++
 contrib/win32/openssh/win32iocompat.vcxproj   |  380 +++
 .../openssh/win32iocompat.vcxproj.filters     |  180 ++
 contrib/win32/win32compat/Debug.h             |   15 +
 contrib/win32/win32compat/ansiprsr.c          |  772 ++++++
 contrib/win32/win32compat/ansiprsr.h          |   80 +
 contrib/win32/win32compat/console.c           | 1695 +++++++++++++
 contrib/win32/win32compat/console.h           |  152 ++
 contrib/win32/win32compat/fileio.c            | 1386 +++++++++++
 contrib/win32/win32compat/gss-sspi.c          | 1104 +++++++++
 contrib/win32/win32compat/inc/arpa/inet.h     |    6 +
 contrib/win32/win32compat/inc/arpa/nameser.h  |    6 +
 contrib/win32/win32compat/inc/crypto-wrap.h   |   76 +
 contrib/win32/win32compat/inc/ctype.h         |    5 +
 contrib/win32/win32compat/inc/dirent.h        |   26 +
 contrib/win32/win32compat/inc/dlfcn.h         |    9 +
 contrib/win32/win32compat/inc/fcntl.h         |   68 +
 contrib/win32/win32compat/inc/fnmatch.h       |    7 +
 contrib/win32/win32compat/inc/grp.h           |    4 +
 contrib/win32/win32compat/inc/gssapi.h        |  246 ++
 contrib/win32/win32compat/inc/libgen.h        |    3 +
 contrib/win32/win32compat/inc/net/if.h        |    1 +
 contrib/win32/win32compat/inc/netdb.h         |    6 +
 contrib/win32/win32compat/inc/netinet/in.h    |    6 +
 .../win32/win32compat/inc/netinet/in_systm.h  |    6 +
 contrib/win32/win32compat/inc/netinet/ip.h    |    6 +
 contrib/win32/win32compat/inc/netinet/tcp.h   |    7 +
 contrib/win32/win32compat/inc/poll.h          |    8 +
 contrib/win32/win32compat/inc/pwd.h           |   50 +
 contrib/win32/win32compat/inc/resolv.h        |    6 +
 contrib/win32/win32compat/inc/signal.h        |  110 +
 contrib/win32/win32compat/inc/spawn.h         |   77 +
 contrib/win32/win32compat/inc/stdio.h         |   22 +
 contrib/win32/win32compat/inc/stdlib.h        |    9 +
 contrib/win32/win32compat/inc/string.h        |   16 +
 contrib/win32/win32compat/inc/strings.h       |    6 +
 contrib/win32/win32compat/inc/sys/ioctl.h     |   17 +
 contrib/win32/win32compat/inc/sys/param.h     |    1 +
 contrib/win32/win32compat/inc/sys/resource.h  |    6 +
 contrib/win32/win32compat/inc/sys/select.h    |   34 +
 contrib/win32/win32compat/inc/sys/socket.h    |   75 +
 contrib/win32/win32compat/inc/sys/stat.h      |   62 +
 contrib/win32/win32compat/inc/sys/statvfs.h   |   26 +
 contrib/win32/win32compat/inc/sys/time.h      |    9 +
 contrib/win32/win32compat/inc/sys/types.h     |   24 +
 contrib/win32/win32compat/inc/sys/uio.h       |    7 +
 contrib/win32/win32compat/inc/sys/un.h        |    7 +
 contrib/win32/win32compat/inc/sys/wait.h      |   21 +
 contrib/win32/win32compat/inc/syslog.h        |   28 +
 contrib/win32/win32compat/inc/termios.h       |  110 +
 contrib/win32/win32compat/inc/time.h          |    9 +
 contrib/win32/win32compat/inc/unistd.h        |  110 +
 contrib/win32/win32compat/inc/utf.h           |   13 +
 contrib/win32/win32compat/libwin32compat.q    |    1 +
 contrib/win32/win32compat/lsa_missingdefs.h   |   55 +
 contrib/win32/win32compat/misc.c              | 2163 +++++++++++++++++
 contrib/win32/win32compat/misc_internal.h     |   85 +
 contrib/win32/win32compat/no-ops.c            |  118 +
 contrib/win32/win32compat/openssh-events.h    |  497 ++++
 contrib/win32/win32compat/pwd.c               |  472 ++++
 contrib/win32/win32compat/shell-host.c        | 1507 ++++++++++++
 contrib/win32/win32compat/signal.c            |  352 +++
 contrib/win32/win32compat/signal_internal.h   |   45 +
 contrib/win32/win32compat/signal_sigalrm.c    |   94 +
 contrib/win32/win32compat/signal_sigchld.c    |  251 ++
 contrib/win32/win32compat/signal_wait.c       |  234 ++
 contrib/win32/win32compat/socketio.c          | 1079 ++++++++
 contrib/win32/win32compat/spawn-ext.c         |   34 +
 contrib/win32/win32compat/spawn.c             |   97 +
 .../win32/win32compat/ssh-agent/agent-main.c  |  218 ++
 .../win32compat/ssh-agent/agent-request.h     |   25 +
 contrib/win32/win32compat/ssh-agent/agent.c   |  410 ++++
 contrib/win32/win32compat/ssh-agent/agent.h   |   65 +
 .../win32/win32compat/ssh-agent/connection.c  |  199 ++
 .../win32compat/ssh-agent/keyagent-request.c  | 1071 ++++++++
 .../win32/win32compat/ssh_config/ssh_config   |   50 +
 .../win32/win32compat/ssh_config/sshd_config  |  122 +
 contrib/win32/win32compat/termio.c            |  311 +++
 contrib/win32/win32compat/tncon.c             |  847 +++++++
 contrib/win32/win32compat/tncon.h             |  226 ++
 contrib/win32/win32compat/tnnet.c             |  133 +
 contrib/win32/win32compat/tnnet.h             |   40 +
 contrib/win32/win32compat/ttymodes_windows.c  |  201 ++
 contrib/win32/win32compat/utf.c               |   63 +
 contrib/win32/win32compat/w32-doexec.c        |  577 +++++
 contrib/win32/win32compat/w32-sshfileperm.c   |  261 ++
 contrib/win32/win32compat/w32api_proxies.c    |  278 +++
 contrib/win32/win32compat/w32api_proxies.h    |   24 +
 contrib/win32/win32compat/w32fd.c             | 1333 ++++++++++
 contrib/win32/win32compat/w32fd.h             |  170 ++
 contrib/win32/win32compat/w32log.c            |  206 ++
 contrib/win32/win32compat/win32-utf8.c        |  121 +
 contrib/win32/win32compat/win32_dirent.c      |  296 +++
 contrib/win32/win32compat/win32_groupaccess.c |  332 +++
 contrib/win32/win32compat/win32_pty.c         |  149 ++
 contrib/win32/win32compat/win32_sshpty.c      |   73 +
 contrib/win32/win32compat/win32_sshtty.c      |   30 +
 .../win32/win32compat/win32_usertoken_utils.c |  849 +++++++
 contrib/win32/win32compat/win32compat.vcproj  |  311 +++
 contrib/win32/win32compat/wmain_common.c      |   65 +
 contrib/win32/win32compat/wmain_sshd.c        |  286 +++
 pal_doexec.h                                  |    8 +
 regress/.gitattributes                        |    5 +
 .../AuthorizedKeysCommand.Tests.ps1           |   75 +
 .../Authorized_keys_fileperm.Tests.ps1        |  210 ++
 regress/pesterTests/CertAuth.Tests.ps1        |   93 +
 regress/pesterTests/Cfginclude.Tests.ps1      |  138 ++
 regress/pesterTests/CommonUtils.psm1          |  145 ++
 .../pesterTests/FileBasedLogging.tests.ps1    |  225 ++
 .../pesterTests/Hostkey_fileperm.Tests.ps1    |  152 ++
 regress/pesterTests/KeyUtils.Tests.ps1        |  471 ++++
 regress/pesterTests/Log_fileperm.Tests.ps1    |  110 +
 .../pesterTests/PlatformAbstractLayer.psm1    |  448 ++++
 regress/pesterTests/PortForwarding.Tests.ps1  |   44 +
 regress/pesterTests/PowerShell.SSH.Tests.ps1  |   81 +
 regress/pesterTests/README.md                 |   66 +
 regress/pesterTests/SCP.Tests.ps1             |  278 +++
 regress/pesterTests/SFTP.Tests.ps1            |  302 +++
 regress/pesterTests/SSH.Tests.ps1             |  371 +++
 regress/pesterTests/SSHDConfig.tests.ps1      |  368 +++
 regress/pesterTests/Setup.Tests.ps1           |  524 ++++
 regress/pesterTests/ShellHost.Tests.ps1       |   42 +
 regress/pesterTests/Uninstall.Tests.ps1       |  196 ++
 .../pesterTests/Userkey_fileperm.Tests.ps1    |  138 ++
 regress/pesterTests/data/SSHD_Config          |  129 +
 regress/pesterTests/data/known_hosts          |   10 +
 regress/pesterTests/data/ssh_config           |    9 +
 regress/pesterTests/data/sshtest_ca_userkeys  |    7 +
 .../pesterTests/data/sshtest_ca_userkeys.pub  |    1 +
 regress/pesterTests/data/sshtest_hostkey_dsa  |   12 +
 .../pesterTests/data/sshtest_hostkey_dsa.pub  |    1 +
 .../pesterTests/data/sshtest_hostkey_ecdsa    |    5 +
 .../data/sshtest_hostkey_ecdsa.pub            |    1 +
 .../pesterTests/data/sshtest_hostkey_ed25519  |    7 +
 .../data/sshtest_hostkey_ed25519.pub          |    1 +
 regress/pesterTests/data/sshtest_hostkey_rsa  |   27 +
 .../pesterTests/data/sshtest_hostkey_rsa.pub  |    1 +
 .../data/sshtest_userssokey_ed25519           |    7 +
 .../data/sshtest_userssokey_ed25519.pub       |    1 +
 .../utilities/askpass_util/README.txt         |    3 +
 .../utilities/askpass_util/askpass_util.cpp   |   13 +
 .../utilities/askpass_util/askpass_util.exe   |  Bin 0 -> 9728 bytes
 regress/unittests/win32compat/dir_tests.c     |  172 ++
 regress/unittests/win32compat/file_tests.c    |  702 ++++++
 .../win32compat/miscellaneous_tests.c         |  435 ++++
 regress/unittests/win32compat/signal_tests.c  |  175 ++
 regress/unittests/win32compat/socket_tests.c  |  711 ++++++
 regress/unittests/win32compat/string_tests.c  |   43 +
 regress/unittests/win32compat/tests.c         |   77 +
 regress/unittests/win32compat/tests.h         |   14 +
 sshfileperm.h                                 |   30 +
 239 files changed, 51992 insertions(+)
 create mode 100644 .azdo/ci.yml
 create mode 100644 .azdo/codeql.yml
 create mode 100644 NOTICE
 create mode 100644 contrib/win32/install/client.wxs
 create mode 100644 contrib/win32/install/openssh.wixproj
 create mode 100644 contrib/win32/install/product.wxs
 create mode 100644 contrib/win32/install/server.wxs
 create mode 100644 contrib/win32/install/shared.wxs
 create mode 100644 contrib/win32/openssh/AnalyzeCodeDiff.ps1
 create mode 100644 contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psd1
 create mode 100644 contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psm1
 create mode 100644 contrib/win32/openssh/BinSkimConfig.xml
 create mode 100644 contrib/win32/openssh/CredScanSuppress.json
 create mode 100644 contrib/win32/openssh/DockerFile
 create mode 100644 contrib/win32/openssh/FixHostFilePermissions.ps1
 create mode 100644 contrib/win32/openssh/FixUserFilePermissions.ps1
 create mode 100644 contrib/win32/openssh/GetFIDO2.ps1
 create mode 100644 contrib/win32/openssh/GetLibreSSL.ps1
 create mode 100644 contrib/win32/openssh/GetZLib.ps1
 create mode 100644 contrib/win32/openssh/MSG00001.bin
 create mode 100644 contrib/win32/openssh/MicrosoftTelemetry.h
 create mode 100644 contrib/win32/openssh/NOTICE_for_release.txt
 create mode 100644 contrib/win32/openssh/OpenSSH-build.ps1
 create mode 100644 contrib/win32/openssh/OpenSSHBuildHelper.psm1
 create mode 100644 contrib/win32/openssh/OpenSSHCommonUtils.psm1
 create mode 100644 contrib/win32/openssh/OpenSSHTestHelper.psm1
 create mode 100644 contrib/win32/openssh/OpenSSHUtils.psd1
 create mode 100644 contrib/win32/openssh/OpenSSHUtils.psm1
 create mode 100644 contrib/win32/openssh/OpenSSL-1.0.2d_build.cmd
 create mode 100644 contrib/win32/openssh/Openssh-events.man
 create mode 100644 contrib/win32/openssh/README.txt
 create mode 100644 contrib/win32/openssh/SignConfig.xml
 create mode 100644 contrib/win32/openssh/Win32-OpenSSH.sln
 create mode 100644 contrib/win32/openssh/Win32-OpenSSh-design.pptx
 create mode 100644 contrib/win32/openssh/bash_tests_iterator.ps1
 create mode 100644 contrib/win32/openssh/build.json
 create mode 100644 contrib/win32/openssh/config.h.vs
 create mode 100644 contrib/win32/openssh/config.ps1
 create mode 100644 contrib/win32/openssh/config.vcxproj
 create mode 100644 contrib/win32/openssh/config.vcxproj.filters
 create mode 100644 contrib/win32/openssh/etwgen.cmd
 create mode 100644 contrib/win32/openssh/install-sshd.ps1
 create mode 100644 contrib/win32/openssh/keygen.vcxproj
 create mode 100644 contrib/win32/openssh/keygen.vcxproj.filters
 create mode 100644 contrib/win32/openssh/libssh.vcxproj
 create mode 100644 contrib/win32/openssh/libssh.vcxproj.filters
 create mode 100644 contrib/win32/openssh/openbsd_compat.vcxproj
 create mode 100644 contrib/win32/openssh/openbsd_compat.vcxproj.filters
 create mode 100644 contrib/win32/openssh/openssh-events.rc
 create mode 100644 contrib/win32/openssh/openssh-eventsTEMP.BIN
 create mode 100644 contrib/win32/openssh/openssh_build.cmd
 create mode 100644 contrib/win32/openssh/paths.targets
 create mode 100644 contrib/win32/openssh/resource.h
 create mode 100644 contrib/win32/openssh/scp.vcxproj
 create mode 100644 contrib/win32/openssh/scp.vcxproj.filters
 create mode 100644 contrib/win32/openssh/sftp-server.vcxproj
 create mode 100644 contrib/win32/openssh/sftp-server.vcxproj.filters
 create mode 100644 contrib/win32/openssh/sftp.vcxproj
 create mode 100644 contrib/win32/openssh/sftp.vcxproj.filters
 create mode 100644 contrib/win32/openssh/ssh-add.vcxproj
 create mode 100644 contrib/win32/openssh/ssh-add.vcxproj.filters
 create mode 100644 contrib/win32/openssh/ssh-agent.vcxproj
 create mode 100644 contrib/win32/openssh/ssh-keyscan.vcxproj
 create mode 100644 contrib/win32/openssh/ssh-keyscan.vcxproj.filters
 create mode 100644 contrib/win32/openssh/ssh-pkcs11-helper.vcxproj
 create mode 100644 contrib/win32/openssh/ssh-shellhost.vcxproj
 create mode 100644 contrib/win32/openssh/ssh-sk-helper.vcxproj
 create mode 100644 contrib/win32/openssh/ssh.vcxproj
 create mode 100644 contrib/win32/openssh/ssh.vcxproj.filters
 create mode 100644 contrib/win32/openssh/sshTelemetry.c
 create mode 100644 contrib/win32/openssh/sshTelemetry.h
 create mode 100644 contrib/win32/openssh/sshTelemetryInternal.h
 create mode 100644 contrib/win32/openssh/sshd.vcxproj
 create mode 100644 contrib/win32/openssh/sshd.vcxproj.filters
 create mode 100644 contrib/win32/openssh/sshd_config
 create mode 100644 contrib/win32/openssh/targetos.manifest
 create mode 100644 contrib/win32/openssh/uninstall-sshd.ps1
 create mode 100644 contrib/win32/openssh/unittest-bitmap.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-hostkeys.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-kex.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-match.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-misc.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-sshbuf.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-sshkey.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-utf8.vcxproj
 create mode 100644 contrib/win32/openssh/unittest-win32compat.vcxproj
 create mode 100644 contrib/win32/openssh/updateSigning.ps1
 create mode 100644 contrib/win32/openssh/version.rc
 create mode 100644 contrib/win32/openssh/vstsbuild.ps1
 create mode 100644 contrib/win32/openssh/win32iocompat.vcxproj
 create mode 100644 contrib/win32/openssh/win32iocompat.vcxproj.filters
 create mode 100644 contrib/win32/win32compat/Debug.h
 create mode 100644 contrib/win32/win32compat/ansiprsr.c
 create mode 100644 contrib/win32/win32compat/ansiprsr.h
 create mode 100644 contrib/win32/win32compat/console.c
 create mode 100644 contrib/win32/win32compat/console.h
 create mode 100644 contrib/win32/win32compat/fileio.c
 create mode 100644 contrib/win32/win32compat/gss-sspi.c
 create mode 100644 contrib/win32/win32compat/inc/arpa/inet.h
 create mode 100644 contrib/win32/win32compat/inc/arpa/nameser.h
 create mode 100644 contrib/win32/win32compat/inc/crypto-wrap.h
 create mode 100644 contrib/win32/win32compat/inc/ctype.h
 create mode 100644 contrib/win32/win32compat/inc/dirent.h
 create mode 100644 contrib/win32/win32compat/inc/dlfcn.h
 create mode 100644 contrib/win32/win32compat/inc/fcntl.h
 create mode 100644 contrib/win32/win32compat/inc/fnmatch.h
 create mode 100644 contrib/win32/win32compat/inc/grp.h
 create mode 100644 contrib/win32/win32compat/inc/gssapi.h
 create mode 100644 contrib/win32/win32compat/inc/libgen.h
 create mode 100644 contrib/win32/win32compat/inc/net/if.h
 create mode 100644 contrib/win32/win32compat/inc/netdb.h
 create mode 100644 contrib/win32/win32compat/inc/netinet/in.h
 create mode 100644 contrib/win32/win32compat/inc/netinet/in_systm.h
 create mode 100644 contrib/win32/win32compat/inc/netinet/ip.h
 create mode 100644 contrib/win32/win32compat/inc/netinet/tcp.h
 create mode 100644 contrib/win32/win32compat/inc/poll.h
 create mode 100644 contrib/win32/win32compat/inc/pwd.h
 create mode 100644 contrib/win32/win32compat/inc/resolv.h
 create mode 100644 contrib/win32/win32compat/inc/signal.h
 create mode 100644 contrib/win32/win32compat/inc/spawn.h
 create mode 100644 contrib/win32/win32compat/inc/stdio.h
 create mode 100644 contrib/win32/win32compat/inc/stdlib.h
 create mode 100644 contrib/win32/win32compat/inc/string.h
 create mode 100644 contrib/win32/win32compat/inc/strings.h
 create mode 100644 contrib/win32/win32compat/inc/sys/ioctl.h
 create mode 100644 contrib/win32/win32compat/inc/sys/param.h
 create mode 100644 contrib/win32/win32compat/inc/sys/resource.h
 create mode 100644 contrib/win32/win32compat/inc/sys/select.h
 create mode 100644 contrib/win32/win32compat/inc/sys/socket.h
 create mode 100644 contrib/win32/win32compat/inc/sys/stat.h
 create mode 100644 contrib/win32/win32compat/inc/sys/statvfs.h
 create mode 100644 contrib/win32/win32compat/inc/sys/time.h
 create mode 100644 contrib/win32/win32compat/inc/sys/types.h
 create mode 100644 contrib/win32/win32compat/inc/sys/uio.h
 create mode 100644 contrib/win32/win32compat/inc/sys/un.h
 create mode 100644 contrib/win32/win32compat/inc/sys/wait.h
 create mode 100644 contrib/win32/win32compat/inc/syslog.h
 create mode 100644 contrib/win32/win32compat/inc/termios.h
 create mode 100644 contrib/win32/win32compat/inc/time.h
 create mode 100644 contrib/win32/win32compat/inc/unistd.h
 create mode 100644 contrib/win32/win32compat/inc/utf.h
 create mode 100644 contrib/win32/win32compat/libwin32compat.q
 create mode 100644 contrib/win32/win32compat/lsa_missingdefs.h
 create mode 100644 contrib/win32/win32compat/misc.c
 create mode 100644 contrib/win32/win32compat/misc_internal.h
 create mode 100644 contrib/win32/win32compat/no-ops.c
 create mode 100644 contrib/win32/win32compat/openssh-events.h
 create mode 100644 contrib/win32/win32compat/pwd.c
 create mode 100644 contrib/win32/win32compat/shell-host.c
 create mode 100644 contrib/win32/win32compat/signal.c
 create mode 100644 contrib/win32/win32compat/signal_internal.h
 create mode 100644 contrib/win32/win32compat/signal_sigalrm.c
 create mode 100644 contrib/win32/win32compat/signal_sigchld.c
 create mode 100644 contrib/win32/win32compat/signal_wait.c
 create mode 100644 contrib/win32/win32compat/socketio.c
 create mode 100644 contrib/win32/win32compat/spawn-ext.c
 create mode 100644 contrib/win32/win32compat/spawn.c
 create mode 100644 contrib/win32/win32compat/ssh-agent/agent-main.c
 create mode 100644 contrib/win32/win32compat/ssh-agent/agent-request.h
 create mode 100644 contrib/win32/win32compat/ssh-agent/agent.c
 create mode 100644 contrib/win32/win32compat/ssh-agent/agent.h
 create mode 100644 contrib/win32/win32compat/ssh-agent/connection.c
 create mode 100644 contrib/win32/win32compat/ssh-agent/keyagent-request.c
 create mode 100644 contrib/win32/win32compat/ssh_config/ssh_config
 create mode 100644 contrib/win32/win32compat/ssh_config/sshd_config
 create mode 100644 contrib/win32/win32compat/termio.c
 create mode 100644 contrib/win32/win32compat/tncon.c
 create mode 100644 contrib/win32/win32compat/tncon.h
 create mode 100644 contrib/win32/win32compat/tnnet.c
 create mode 100644 contrib/win32/win32compat/tnnet.h
 create mode 100644 contrib/win32/win32compat/ttymodes_windows.c
 create mode 100644 contrib/win32/win32compat/utf.c
 create mode 100644 contrib/win32/win32compat/w32-doexec.c
 create mode 100644 contrib/win32/win32compat/w32-sshfileperm.c
 create mode 100644 contrib/win32/win32compat/w32api_proxies.c
 create mode 100644 contrib/win32/win32compat/w32api_proxies.h
 create mode 100644 contrib/win32/win32compat/w32fd.c
 create mode 100644 contrib/win32/win32compat/w32fd.h
 create mode 100644 contrib/win32/win32compat/w32log.c
 create mode 100644 contrib/win32/win32compat/win32-utf8.c
 create mode 100644 contrib/win32/win32compat/win32_dirent.c
 create mode 100644 contrib/win32/win32compat/win32_groupaccess.c
 create mode 100644 contrib/win32/win32compat/win32_pty.c
 create mode 100644 contrib/win32/win32compat/win32_sshpty.c
 create mode 100644 contrib/win32/win32compat/win32_sshtty.c
 create mode 100644 contrib/win32/win32compat/win32_usertoken_utils.c
 create mode 100644 contrib/win32/win32compat/win32compat.vcproj
 create mode 100644 contrib/win32/win32compat/wmain_common.c
 create mode 100644 contrib/win32/win32compat/wmain_sshd.c
 create mode 100644 pal_doexec.h
 create mode 100644 regress/.gitattributes
 create mode 100644 regress/pesterTests/AuthorizedKeysCommand.Tests.ps1
 create mode 100644 regress/pesterTests/Authorized_keys_fileperm.Tests.ps1
 create mode 100644 regress/pesterTests/CertAuth.Tests.ps1
 create mode 100644 regress/pesterTests/Cfginclude.Tests.ps1
 create mode 100644 regress/pesterTests/CommonUtils.psm1
 create mode 100644 regress/pesterTests/FileBasedLogging.tests.ps1
 create mode 100644 regress/pesterTests/Hostkey_fileperm.Tests.ps1
 create mode 100644 regress/pesterTests/KeyUtils.Tests.ps1
 create mode 100644 regress/pesterTests/Log_fileperm.Tests.ps1
 create mode 100644 regress/pesterTests/PlatformAbstractLayer.psm1
 create mode 100644 regress/pesterTests/PortForwarding.Tests.ps1
 create mode 100644 regress/pesterTests/PowerShell.SSH.Tests.ps1
 create mode 100644 regress/pesterTests/README.md
 create mode 100644 regress/pesterTests/SCP.Tests.ps1
 create mode 100644 regress/pesterTests/SFTP.Tests.ps1
 create mode 100644 regress/pesterTests/SSH.Tests.ps1
 create mode 100644 regress/pesterTests/SSHDConfig.tests.ps1
 create mode 100644 regress/pesterTests/Setup.Tests.ps1
 create mode 100644 regress/pesterTests/ShellHost.Tests.ps1
 create mode 100644 regress/pesterTests/Uninstall.Tests.ps1
 create mode 100644 regress/pesterTests/Userkey_fileperm.Tests.ps1
 create mode 100644 regress/pesterTests/data/SSHD_Config
 create mode 100644 regress/pesterTests/data/known_hosts
 create mode 100644 regress/pesterTests/data/ssh_config
 create mode 100644 regress/pesterTests/data/sshtest_ca_userkeys
 create mode 100644 regress/pesterTests/data/sshtest_ca_userkeys.pub
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_dsa
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_dsa.pub
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_ecdsa
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_ecdsa.pub
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_ed25519
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_ed25519.pub
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_rsa
 create mode 100644 regress/pesterTests/data/sshtest_hostkey_rsa.pub
 create mode 100644 regress/pesterTests/data/sshtest_userssokey_ed25519
 create mode 100644 regress/pesterTests/data/sshtest_userssokey_ed25519.pub
 create mode 100644 regress/pesterTests/utilities/askpass_util/README.txt
 create mode 100644 regress/pesterTests/utilities/askpass_util/askpass_util.cpp
 create mode 100644 regress/pesterTests/utilities/askpass_util/askpass_util.exe
 create mode 100644 regress/unittests/win32compat/dir_tests.c
 create mode 100644 regress/unittests/win32compat/file_tests.c
 create mode 100644 regress/unittests/win32compat/miscellaneous_tests.c
 create mode 100644 regress/unittests/win32compat/signal_tests.c
 create mode 100644 regress/unittests/win32compat/socket_tests.c
 create mode 100644 regress/unittests/win32compat/string_tests.c
 create mode 100644 regress/unittests/win32compat/tests.c
 create mode 100644 regress/unittests/win32compat/tests.h
 create mode 100644 sshfileperm.h

diff --git a/.azdo/ci.yml b/.azdo/ci.yml
new file mode 100644
index 000000000..517abf335
--- /dev/null
+++ b/.azdo/ci.yml
@@ -0,0 +1,224 @@
+name: $(BuildDefinitionName)-$(date:yyMM).$(date:dd)$(rev:rrr)
+trigger:
+  # Batch merge builds together while a merge build is running
+  batch: true
+  branches:
+    include:
+    - latestw_all
+pr:
+  branches:
+    include:
+    - latestw_all
+
+resources:
+  repositories:
+  - repository: ComplianceRepo
+    type: github
+    endpoint: ComplianceGHRepo
+    name: PowerShell/compliance
+
+stages:
+- stage: Build
+  displayName: Build Win32-OpenSSH
+  jobs:
+  - job: BuildPkg
+    displayName: Build Package
+    pool:
+      name: PS-PowerShell-x64
+      demands:
+      - ImageOverride -equals PSMMS2022-OpenSSH-Secure
+
+    steps:
+    - powershell: |
+        $powerShellPath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath 'powershell'
+        Invoke-WebRequest -Uri https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.ps1 -outfile ./install-powershell.ps1
+        ./install-powershell.ps1 -Destination $powerShellPath
+        $vstsCommandString = "vso[task.setvariable variable=PATH]$powerShellPath;$env:PATH"
+        Write-Host "sending " + $vstsCommandString
+        Write-Host "##$vstsCommandString"
+      displayName: Install PowerShell Core
+    
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Invoke-AzDOBuild
+      displayName: Build Win32-OpenSSH
+
+    - pwsh: |
+        $BuildOutPath = "$(Build.SourcesDirectory)/bin"
+        $BuildOutx86Path = Join-Path -Path $BuildOutPath -ChildPath 'Win32/Release'
+        Get-ChildItem -Path $BuildOutx86Path
+        $BuildOutx64Path = Join-Path -Path $BuildOutPath -ChildPath 'x64/Release'
+        Get-ChildItem -Path $BuildOutx64Path
+      displayName: Capture build results
+
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        #
+        # Copy build artifacts
+        $BuildDestPath = "$(Build.SourcesDirectory)/Win32-OpenSSH"
+        if (Test-Path -Path $BuildDestPath) {
+          Remove-Item -Path $BuildDestPath -Recurse -Force -ErrorAction SilentlyContinue
+        }
+        $null = New-Item -ItemType Directory -Path $BuildDestPath -Force
+        $BuildDestx86Path = Join-Path -Path $BuildDestPath -ChildPath 'x86/Release'
+        Copy-BuildResults -BuildResultsPath $BuildDestx86Path -NativeHostArch x86 -Configuration Release
+        $BuildDestX64Path = Join-Path -Path $BuildDestPath -ChildPath 'x64/Release'
+        Copy-BuildResults -BuildResultsPath $BuildDestx64Path -NativeHostArch x64 -Configuration Release
+        #
+        # Upload build artifacts
+        Write-Verbose -Verbose -Message "Uploading build artifacts"
+        $artifactName = 'Win32-OpenSSH'
+        Write-Host "##vso[artifact.upload containerfolder=$artifactName;artifactname=$artifactName;]$BuildDestPath"
+        #
+        # Copy unit tests
+        $BuildOutPath = "$(Build.SourcesDirectory)/bin"
+        $UnitTestDestPath = "$(Build.SourcesDirectory)/UnitTests"
+        Copy-UnitTests -UnitTestsSrcDir $BuildOutPath -UnitTestsDestDir $UnitTestDestPath -NativeHostArch x86 -Configuration Release
+        Copy-UnitTests -UnitTestsSrcDir $BuildOutPath -UnitTestsDestDir $UnitTestDestPath -NativeHostArch x64 -Configuration Release
+        #
+        # Upload unit test artifacts
+        Write-Verbose -Verbose -Message "Uploading unit test artifacts"
+        $artifactName = 'UnitTests'
+        Write-Host "##vso[artifact.upload containerfolder=$artifactName;artifactname=$artifactName;]$UnitTestDestPath"
+        #
+        # Upload bash tests config.h file
+        Write-Verbose -Verbose -Message "Uploading config.h file for bash tests"
+        $artifactName = 'ConfigFile'
+        $configFilePath = "$(Build.SourcesDirectory)/config.h"
+        Write-Host "##vso[artifact.upload containerfolder=$artifactName;artifactname=$artifactName;]$configFilePath"
+      displayName: Upload Win32-OpenSSH build artifacts
+
+- stage: Compliance
+  displayName: Compliance
+  dependsOn: Build
+  jobs:
+  - job: ComplianceJob
+    pool:
+      vmImage: windows-latest
+    steps:
+    - checkout: self
+      clean: true
+    - checkout: ComplianceRepo
+      clean: true
+    - download: current
+      artifact: 'Win32-OpenSSH'
+    - template: ci-compliance.yml@ComplianceRepo
+      parameters:
+        # credscan
+        suppressionsFile: ''
+    # Documentation: https://eng.ms/docs/security-compliance-identity-and-management-scim/security/azure-security/cloudai-security-fundamentals-engineering/security-integration/guardian-wiki/sdl-azdo-extension/security-analysis-report-build-task
+    - task: securedevelopmentteam.vss-secure-development-tools.build-task-report.SdtReport@2
+      continueOnError: true
+      displayName: 'Guardian Export'
+      inputs:
+        GdnExportVstsConsole: true
+        GdnExportSarifFile: true
+        GdnExportHtmlFile: true
+        GdnExportAllTools: false
+        GdnExportGdnToolCredScan: true
+        #this didn't do anything GdnExportCustomLogsFolder: '$(Build.ArtifactStagingDirectory)/Guardian'
+
+- stage: Test
+  displayName: Test Win32-OpenSSH
+  dependsOn: Build
+  jobs:
+  - job: TestPkgWin32OpenSSH
+    pool:
+      vmImage: windows-latest
+    displayName: Win32-OpenSSH On Windows
+    steps:
+    - powershell: |
+        $powerShellPath = Join-Path -Path $env:AGENT_TEMPDIRECTORY -ChildPath 'powershell'
+        Invoke-WebRequest -Uri https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.ps1 -outfile ./install-powershell.ps1
+        ./install-powershell.ps1 -Destination $powerShellPath
+        $vstsCommandString = "vso[task.setvariable variable=PATH]$powerShellPath;$env:PATH"
+        Write-Host "sending " + $vstsCommandString
+        Write-Host "##$vstsCommandString"
+      displayName: 'Install PowerShell Core'
+
+    - task: DownloadBuildArtifacts@0
+      displayName: 'Download build artifacts'
+      inputs:
+        buildType: current
+        downloadType: single
+        artifactName: Win32-OpenSSH
+        downloadPath: '$(System.ArtifactsDirectory)'
+
+    - task: DownloadBuildArtifacts@0
+      displayName: 'Download unit test artifacts'
+      inputs:
+        buildType: current
+        downloadType: single
+        artifactName: UnitTests
+        downloadPath: '$(System.ArtifactsDirectory)'
+
+    - task: DownloadBuildArtifacts@0
+      displayName: 'Download bash test config file artifact'
+      inputs:
+        buildType: current
+        downloadType: single
+        artifactName: ConfigFile
+        downloadPath: '$(System.ArtifactsDirectory)'
+
+    - pwsh: |
+        $artifactDir = "$(System.ArtifactsDirectory)"
+        Write-Verbose -Verbose -Message "Artifacts directory: $artifactDir"
+        Get-ChildItem -Path $artifactDir -Recurse
+      displayName: Capture downloaded artifact directory
+
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Install-OpenSSH -SourceDir "$(System.ArtifactsDirectory)/Win32-OpenSSH/x64/Release" -OpenSSHDir "$env:SystemDrive/OpenSSH" -Verbose
+      displayName: Install Win32-OpenSSH
+
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Install-UnitTests -SourceDir "$(System.ArtifactsDirectory)/UnitTests/x64/Release" -OpenSSHDir "$env:SystemDrive/OpenSSH" -Verbose
+      displayName: Install Unit Tests
+
+    - pwsh: |
+        $configFileSrc = "$(System.ArtifactsDirectory)/ConfigFile/config.h"
+        $configFileDest = "$(Build.SourcesDirectory)"
+        Write-Verbose -Verbose -Message "Copying config file from: ${configFileSrc} to: ${configFileDest}"
+        Copy-Item -Path $configFileSrc -Dest $configFileDest -Force
+      displayName: Copy config file artifact for bash tests
+
+    - pwsh: |
+        $sourceDir = "$(Build.SourcesDirectory)"
+        Write-Verbose -Verbose -Message "Source repo directory: $sourceDir"
+        Get-ChildItem -Path $sourceDir
+      displayName: Capture source repo directory for test
+
+    - pwsh: |
+        $installedOpenSSHDir = "$env:SystemDrive/OpenSSH"
+        Write-Verbose -Verbose -Message "Installed OpenSSH directory: $installedOpenSSHDir"
+        Get-ChildItem -Path $installedOpenSSHDir -Recurse
+      displayName: Capture installed OpenSSH directory
+
+    - pwsh: |
+        # Run OpenSSH tests
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Invoke-OpenSSHTests -OpenSSHBinPath "$env:SystemDrive/OpenSSH"
+      displayName: Run tests
+
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        #
+        # Copy test results to results directory
+        $ResultsDirectory = "$(Build.SourcesDirectory)/Win32OpenSSHTestResults"
+        Copy-OpenSSHTestResults -ResultsPath $ResultsDirectory
+        #
+        # Upload test results artifact
+        if (Test-Path -Path $ResultsDirectory)
+        {
+          $artifactName = 'Win32-OpenSSH-TestResults'
+          Write-Host "##vso[artifact.upload containerfolder=$artifactName;artifactname=$artifactName;]$ResultsDirectory"
+        }
+      displayName: Upload test results
+      condition: always()
+
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Clear-TestEnvironmentSetup
+      displayName: Clean up OpenSSH test environment
+      condition: always()
diff --git a/.azdo/codeql.yml b/.azdo/codeql.yml
new file mode 100644
index 000000000..ac8a5532e
--- /dev/null
+++ b/.azdo/codeql.yml
@@ -0,0 +1,43 @@
+name: $(BuildDefinitionName)-$(date:yyMM).$(date:dd)$(rev:rrr)
+
+trigger: none
+
+schedules:
+- cron: "0 10 * * 1-5"
+  displayName: Daily CodeQL Build
+  branches:
+    include:
+    - latestw_all
+
+stages:
+- stage: Build
+  displayName: Build Win32-OpenSSH
+  jobs:
+  - job: BuildPkg
+    displayName: Build Package
+    pool:
+      name: PS-PowerShell-x64
+      demands:
+      - ImageOverride -equals PSMMS2022-OpenSSH-Secure
+    variables:
+      Codeql.Enabled: true
+      Codeql.Cadence: 23 # hours
+    steps:
+    - task: CodeQL3000Init@0
+      displayName: Initialize CodeQL
+    
+    - pwsh: |
+        Import-Module -Name "$(Build.SourcesDirectory)/contrib/win32/openssh/AzDOBuildTools" -Force
+        Invoke-AzDOBuild
+      displayName: Build Win32-OpenSSH
+
+    - task: CodeQL3000Finalize@0
+      displayName: Finalize CodeQL
+
+    - pwsh: |
+        $BuildOutPath = "$(Build.SourcesDirectory)/bin"
+        $BuildOutx86Path = Join-Path -Path $BuildOutPath -ChildPath 'Win32/Release'
+        Get-ChildItem -Path $BuildOutx86Path
+        $BuildOutx64Path = Join-Path -Path $BuildOutPath -ChildPath 'x64/Release'
+        Get-ChildItem -Path $BuildOutx64Path
+      displayName: Capture build results
diff --git a/NOTICE b/NOTICE
new file mode 100644
index 000000000..fd2dcb1c3
--- /dev/null
+++ b/NOTICE
@@ -0,0 +1,489 @@
+NOTICES
+
+This repository incorporates material as listed below or described in the code.
+
+Component
+OpenSSH
+
+Open Source License/Copyright Notice.
+
+The licences which components of this software fall under are as
+follows.  First, we will summarize and say that all components
+are under a BSD licence, or a licence more free than that.
+
+OpenSSH contains no GPL code.
+
+1)
+     * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
+     *                    All rights reserved
+     *
+     * As far as I am concerned, the code I have written for this software
+     * can be used freely for any purpose.  Any derived versions of this
+     * software must be clearly marked as such, and if the derived work is
+     * incompatible with the protocol description in the RFC file, it must be
+     * called by a name other than "ssh" or "Secure Shell".
+
+    [Tatu continues]
+     *  However, I am not implying to give any licenses to any patents or
+     * copyrights held by third parties, and the software includes parts that
+     * are not under my direct control.  As far as I know, all included
+     * source code is used in accordance with the relevant license agreements
+     * and can be used freely for any purpose (the GNU license being the most
+     * restrictive); see below for details.
+
+    [However, none of that term is relevant at this point in time.  All of
+    these restrictively licenced software components which he talks about
+    have been removed from OpenSSH, i.e.,
+
+     - RSA is no longer included, found in the OpenSSL library
+     - IDEA is no longer included, its use is deprecated
+     - DES is now external, in the OpenSSL library
+     - GMP is no longer used, and instead we call BN code from OpenSSL
+     - Zlib is now external, in a library
+     - The make-ssh-known-hosts script is no longer included
+     - TSS has been removed
+     - MD5 is now external, in the OpenSSL library
+     - RC4 support has been replaced with ARC4 support from OpenSSL
+     - Blowfish is now external, in the OpenSSL library
+
+    [The licence continues]
+
+    Note that any information and cryptographic algorithms used in this
+    software are publicly available on the Internet and at any major
+    bookstore, scientific library, and patent office worldwide.  More
+    information can be found e.g. at "http://www.cs.hut.fi/crypto".
+
+    The legal status of this program is some combination of all these
+    permissions and restrictions.  Use only at your own responsibility.
+    You will be responsible for any legal consequences yourself; I am not
+    making any claims whether possessing or using this is legal or not in
+    your country, and I am not taking any responsibility on your behalf.
+
+
+			    NO WARRANTY
+
+    BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+    FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+    PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+    OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+    TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+    PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+    REPAIR OR CORRECTION.
+
+    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+    OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+    TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+    YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+    PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGES.
+
+3)
+    ssh-keyscan was contributed by David Mazieres under a BSD-style
+    license.
+
+     * Copyright 1995, 1996 by David Mazieres <dm@lcs.mit.edu>.
+     *
+     * Modification and redistribution in source and binary forms is
+     * permitted provided that due credit is given to the author and the
+     * OpenBSD project by leaving this copyright notice intact.
+
+4)
+    The Rijndael implementation by Vincent Rijmen, Antoon Bosselaers
+    and Paulo Barreto is in the public domain and distributed
+    with the following license:
+
+     * @version 3.0 (December 2000)
+     *
+     * Optimised ANSI C code for the Rijndael cipher (now AES)
+     *
+     * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+     * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+     * @author Paulo Barreto <paulo.barreto@terra.com.br>
+     *
+     * This code is hereby placed in the public domain.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+     * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+     * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+     * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+5)
+    One component of the ssh source code is under a 3-clause BSD license,
+    held by the University of California, since we pulled these parts from
+    original Berkeley code.
+
+     * Copyright (c) 1983, 1990, 1992, 1993, 1995
+     *      The Regents of the University of California.  All rights reserved.
+     *
+     * Redistribution and use in source and binary forms, with or without
+     * modification, are permitted provided that the following conditions
+     * are met:
+     * 1. Redistributions of source code must retain the above copyright
+     *    notice, this list of conditions and the following disclaimer.
+     * 2. Redistributions in binary form must reproduce the above copyright
+     *    notice, this list of conditions and the following disclaimer in the
+     *    documentation and/or other materials provided with the distribution.
+     * 3. Neither the name of the University nor the names of its contributors
+     *    may be used to endorse or promote products derived from this software
+     *    without specific prior written permission.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+     * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+     * SUCH DAMAGE.
+
+6)
+    Remaining components of the software are provided under a standard
+    2-term BSD licence with the following names as copyright holders:
+
+	Markus Friedl
+	Theo de Raadt
+	Niels Provos
+	Dug Song
+	Aaron Campbell
+	Damien Miller
+	Kevin Steves
+	Daniel Kouril
+	Wesley Griffin
+	Per Allansson
+	Nils Nordman
+	Simon Wilkinson
+
+    Portable OpenSSH additionally includes code from the following copyright
+    holders, also under the 2-term BSD license:
+
+	Ben Lindstrom
+	Tim Rice
+	Andre Lucas
+	Chris Adams
+	Corinna Vinschen
+	Cray Inc.
+	Denis Parker
+	Gert Doering
+	Jakob Schlyter
+	Jason Downs
+	Juha Yrjölä
+	Michael Stone
+	Networks Associates Technology, Inc.
+	Solar Designer
+	Todd C. Miller
+	Wayne Schroeder
+	William Jones
+	Darren Tucker
+	Sun Microsystems
+	The SCO Group
+	Daniel Walsh
+	Red Hat, Inc
+	Simon Vallet / Genoscope
+
+     * Redistribution and use in source and binary forms, with or without
+     * modification, are permitted provided that the following conditions
+     * are met:
+     * 1. Redistributions of source code must retain the above copyright
+     *    notice, this list of conditions and the following disclaimer.
+     * 2. Redistributions in binary form must reproduce the above copyright
+     *    notice, this list of conditions and the following disclaimer in the
+     *    documentation and/or other materials provided with the distribution.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+     * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+     * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+     * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+     * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+8) Portable OpenSSH contains the following additional licenses:
+
+    a) md5crypt.c, md5crypt.h
+
+	 * "THE BEER-WARE LICENSE" (Revision 42):
+	 * <phk@login.dknet.dk> wrote this file.  As long as you retain this
+	 * notice you can do whatever you want with this stuff. If we meet
+	 * some day, and you think this stuff is worth it, you can buy me a
+	 * beer in return.   Poul-Henning Kamp
+
+    b) snprintf replacement
+
+	* Copyright Patrick Powell 1995
+	* This code is based on code written by Patrick Powell
+	* (papowell@astart.com) It may be used for any purpose as long as this
+	* notice remains intact on all source code distributions
+
+    c) Compatibility code (openbsd-compat)
+
+       Apart from the previously mentioned licenses, various pieces of code
+       in the openbsd-compat/ subdirectory are licensed as follows:
+
+       Some code is licensed under a 3-term BSD license, to the following
+       copyright holders:
+
+	Todd C. Miller
+	Theo de Raadt
+	Damien Miller
+	Eric P. Allman
+	The Regents of the University of California
+	Constantin S. Svintsoff
+
+	* Redistribution and use in source and binary forms, with or without
+	* modification, are permitted provided that the following conditions
+	* are met:
+	* 1. Redistributions of source code must retain the above copyright
+	*    notice, this list of conditions and the following disclaimer.
+	* 2. Redistributions in binary form must reproduce the above copyright
+	*    notice, this list of conditions and the following disclaimer in the
+	*    documentation and/or other materials provided with the distribution.
+	* 3. Neither the name of the University nor the names of its contributors
+	*    may be used to endorse or promote products derived from this software
+	*    without specific prior written permission.
+	*
+	* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+	* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+	* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+	* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+	* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+	* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+	* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+	* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+	* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+	* SUCH DAMAGE.
+
+       Some code is licensed under an ISC-style license, to the following
+       copyright holders:
+
+	Internet Software Consortium.
+	Todd C. Miller
+	Reyk Floeter
+	Chad Mynhier
+
+	* Permission to use, copy, modify, and distribute this software for any
+	* purpose with or without fee is hereby granted, provided that the above
+	* copyright notice and this permission notice appear in all copies.
+	*
+	* THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
+	* WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+	* OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
+	* FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+	* WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+	* OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+	* CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+       Some code is licensed under a MIT-style license to the following
+       copyright holders:
+
+	Free Software Foundation, Inc.
+
+	* Permission is hereby granted, free of charge, to any person obtaining a  *
+	* copy of this software and associated documentation files (the            *
+	* "Software"), to deal in the Software without restriction, including      *
+	* without limitation the rights to use, copy, modify, merge, publish,      *
+	* distribute, distribute with modifications, sublicense, and/or sell       *
+	* copies of the Software, and to permit persons to whom the Software is    *
+	* furnished to do so, subject to the following conditions:                 *
+	*                                                                          *
+	* The above copyright notice and this permission notice shall be included  *
+	* in all copies or substantial portions of the Software.                   *
+	*                                                                          *
+	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
+	* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
+	* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
+	* IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
+	* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
+	* OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
+	* THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
+	*                                                                          *
+	* Except as contained in this notice, the name(s) of the above copyright   *
+	* holders shall not be used in advertising or otherwise to promote the     *
+	* sale, use or other dealings in this Software without prior written       *
+	* authorization.                                                           *
+	****************************************************************************/
+
+       The Blowfish cipher implementation is licensed by Niels Provis under
+       a 4-clause BSD license:
+
+         * Blowfish - a fast block cipher designed by Bruce Schneier
+         *
+         * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
+         * All rights reserved.
+         *
+         * Redistribution and use in source and binary forms, with or without
+         * modification, are permitted provided that the following conditions
+         * are met:
+         * 1. Redistributions of source code must retain the above copyright
+         *    notice, this list of conditions and the following disclaimer.
+         * 2. Redistributions in binary form must reproduce the above copyright
+         *    notice, this list of conditions and the following disclaimer in the
+         *    documentation and/or other materials provided with the distribution.
+         * 3. All advertising materials mentioning features or use of this software
+         *    must display the following acknowledgement:
+         *      This product includes software developed by Niels Provos.
+         * 4. The name of the author may not be used to endorse or promote products
+         *    derived from this software without specific prior written permission.
+         *
+         * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+         * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+         * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+         * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+         * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+         * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+         * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+         * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+         * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+       Some replacement code is licensed by the NetBSD foundation under a
+       2-clause BSD license:
+
+         * Copyright (c) 2001 The NetBSD Foundation, Inc.
+         * All rights reserved.
+         *
+         * This code is derived from software contributed to The NetBSD Foundation
+         * by Todd Vierling.
+         *
+         * Redistribution and use in source and binary forms, with or without
+         * modification, are permitted provided that the following conditions
+         * are met:
+         * 1. Redistributions of source code must retain the above copyright
+         *    notice, this list of conditions and the following disclaimer.
+         * 2. Redistributions in binary form must reproduce the above copyright
+         *    notice, this list of conditions and the following disclaimer in the
+         *    documentation and/or other materials provided with the distribution.
+         *
+         * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+         * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+         * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+         * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+         * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+         * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+         * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+         * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+         * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+         * POSSIBILITY OF SUCH DAMAGE.
+
+------
+$OpenBSD: LICENCE,v 1.20 2017/04/30 23:26:16 djm Exp $
+
+Additional Attribution.
+
+Tatu Ylonen <ylo@cs.hut.fi> - Creator of SSH
+
+Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos,
+Theo de Raadt, and Dug Song - Creators of OpenSSH
+
+Ahsan Rashid <arms@sco.com> - UnixWare long passwords
+Alain St-Denis <Alain.St-Denis@ec.gc.ca> - Irix fix
+Alexandre Oliva <oliva@lsd.ic.unicamp.br> - AIX fixes
+Andre Lucas <andre@ae-35.com> - new login code, many fixes
+Andreas Steinmetz <ast@domdv.de> - Shadow password expiry support
+Andrew McGill <andrewm@datrix.co.za> - SCO fixes
+Andrew Morgan <morgan@transmeta.com> - PAM bugfixes
+Andrew Stribblehill <a.d.stribblehill@durham.ac.uk> - Bugfixes
+Andy Sloane <andy@guildsoftware.com> - bugfixes
+Aran Cox <acox@cv.telegroup.com> - SCO bugfixes
+Arkadiusz Miskiewicz <misiek@pld.org.pl> - IPv6 compat fixes
+Ben Lindstrom <mouring@eviladmin.org> - NeXT support
+Ben Taylor <bent@clark.net> - Solaris debugging and fixes
+Bratislav ILICH <bilic@zepter.ru> - Configure fix
+Charles Levert <charles@comm.polymtl.ca> - SunOS 4 & bug fixes
+Chip Salzenberg <chip@valinux.com> - Assorted patches
+Chris Adams <cmadams@hiwaay.net> - OSF SIA support
+Chris Saia <csaia@wtower.com> - SuSE packaging
+Chris, the Young One <cky@pobox.com> - Password auth fixes
+Christos Zoulas <christos@zoulas.com> - Autoconf fixes
+Chun-Chung Chen <cjj@u.washington.edu> - RPM fixes
+Corinna Vinschen <vinschen@redhat.com> - Cygwin support
+Chad Mynhier <mynhier@interstel.net> - Solaris Process Contract support
+Dan Brosemer <odin@linuxfreak.com> - Autoconf support, build fixes
+Darren Hall <dhall@virage.org> - AIX patches
+Darren Tucker <dtucker@zip.com.au> - AIX BFF package scripts
+David Agraz <dagraz@jahoopa.com> - Build fixes
+David Del Piero <David.DelPiero@qed.qld.gov.au> - bug fixes
+David Hesprich <darkgrue@gue-tech.org> - Configure fixes
+David Rankin <drankin@bohemians.lexington.ky.us> - libwrap, AIX, NetBSD fixes
+Dag-Erling Smørgrav <des at freebsd.org> - Challenge-Response PAM code.
+Dhiraj Gulati <dgulati@sco.com> - UnixWare long passwords
+Ed Eden <ede370@stl.rural.usda.gov> - configure fixes
+Garrick James <garrick@james.net> - configure fixes
+Gary E. Miller <gem@rellim.com> - SCO support
+Ged Lodder <lodder@yacc.com.au> - HPUX fixes and enhancements
+Gert Doering <gd@hilb1.medat.de> - bug and portability fixes
+HARUYAMA Seigo <haruyama@unixuser.org> - Translations & doc fixes
+Hideaki YOSHIFUJI <yoshfuji@ecei.tohoku.ac.jp> - IPv6 and bug fixes
+Hiroshi Takekawa <takekawa@sr3.t.u-tokyo.ac.jp> - Configure fixes
+Holger Trapp <Holger.Trapp@Informatik.TU-Chemnitz.DE> - KRB4/AFS config patch
+IWAMURO Motonori <iwa@mmp.fujitsu.co.jp> - bugfixes
+Jani Hakala <jahakala@cc.jyu.fi> - Patches
+Jarno Huuskonen <jhuuskon@hytti.uku.fi> - Bugfixes
+Jim Knoble <jmknoble@pobox.com> - Many patches
+Jonchen (email unknown) - the original author of PAM support of SSH
+Juergen Keil <jk@tools.de> - scp bugfixing
+KAMAHARA Junzo <kamahara@cc.kshosen.ac.jp> - Configure fixes
+Kees Cook <cook@cpoint.net> - scp fixes
+Kenji Miyake <kenji@miyake.org> - Configure fixes
+Kevin Cawlfield <cawlfiel@us.ibm.com> - AIX fixes.
+Kevin O'Connor <kevin_oconnor@standardandpoors.com> - RSAless operation
+Kevin Steves <stevesk@pobox.com> - HP support, bugfixes, improvements
+Kiyokazu SUTO <suto@ks-and-ks.ne.jp> - Bugfixes
+Larry Jones <larry.jones@sdrc.com> - Bugfixes
+Lutz Jaenicke <Lutz.Jaenicke@aet.TU-Cottbus.DE> - Bugfixes
+Marc G. Fournier <marc.fournier@acadiau.ca> - Solaris patches
+Mark D. Baushke <mdb@juniper.net> - bug fixes
+Martin Johansson <fatbob@acc.umu.se> - Linux fixes
+Mark D. Roth <roth+openssh@feep.net> - Features, bug fixes
+Mark Miller <markm@swoon.net> - Bugfixes
+Matt Richards <v2matt@btv.ibm.com> - AIX patches
+Michael Steffens <michael_steffens at hp.com> - HP-UX fixes
+Michael Stone <mstone@cs.loyola.edu> - Irix enhancements
+Nakaji Hiroyuki <nakaji@tutrp.tut.ac.jp> - Sony News-OS patch
+Nalin Dahyabhai <nalin.dahyabhai@pobox.com> - PAM environment patch
+Nate Itkin <nitkin@europa.com> - SunOS 4.1.x fixes
+Niels Kristian Bech Jensen <nkbj@image.dk> - Assorted patches
+Pavel Kankovsky <peak@argo.troja.mff.cuni.cz> - Security fixes
+Pavel Troller <patrol@omni.sinus.cz> - Bugfixes
+Pekka Savola <pekkas@netcore.fi> - Bugfixes
+Peter Kocks <peter.kocks@baygate.com> - Makefile fixes
+Peter Stuge <stuge@cdy.org> - mdoc2man.awk script
+Phil Hands <phil@hands.com> - Debian scripts, assorted patches
+Phil Karn <karn@ka9q.ampr.org> - Autoconf fixes
+Philippe WILLEM <Philippe.WILLEM@urssaf.fr> - Bugfixes
+Phill Camp <P.S.S.Camp@ukc.ac.uk> - login code fix
+Rip Loomis <loomisg@cist.saic.com> - Solaris package support, fixes
+Robert Dahlem <Robert.Dahlem at siemens.com> - Reliant Unix fixes
+Roumen Petrov <openssh@roumenpetrov.info> - Compile & configure fixes
+SAKAI Kiyotaka <ksakai@kso.netwk.ntt-at.co.jp> - Multiple bugfixes
+Simon Wilkinson <sxw@dcs.ed.ac.uk> - PAM fixes, Compat with MIT KrbV
+Solar Designer <solar@openwall.com> - many patches and technical assistance
+Svante Signell <svante.signell@telia.com> - Bugfixes
+Thomas Neumann <tom@smart.ruhr.de> - Shadow passwords
+Tim Rice <tim@multitalents.net> - Portability & SCO fixes
+Tobias Oetiker <oetiker@ee.ethz.ch> - Bugfixes
+Tom Bertelson's <tbert@abac.com> - AIX auth fixes
+Tor-Ake Fransson <torake@hotmail.com> - AIX support
+Tudor Bosman <tudorb@jm.nu> - MD5 password support
+Udo Schweigert <ust@cert.siemens.de> - ReliantUNIX support
+Wendy Palm <wendyp at cray.com> - Cray support.
+Zack Weinberg <zack@wolery.cumb.org> - GNOME askpass enhancement
diff --git a/contrib/win32/install/client.wxs b/contrib/win32/install/client.wxs
new file mode 100644
index 000000000..8918abd18
--- /dev/null
+++ b/contrib/win32/install/client.wxs
@@ -0,0 +1,32 @@
+<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
+    <Fragment>
+        <!-- KeyPath is necessary for multi-file components to identify the key file - preferrably versioned. -->
+        <ComponentGroup Id="Client" Directory="INSTALLFOLDER">
+            <ComponentGroupRef Id="Shared" />
+            <ComponentGroupRef Id="Manifest" />
+            <Component>
+                <File Name="ssh.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="sftp.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-add.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-keyscan.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-sk-helper.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-pkcs11-helper.exe" KeyPath="yes" />
+            </Component>
+            <Component Id="ClientPATH" Guid="F07FFA0C-B5CF-45A3-9013-A7420DDFD654">
+                <!-- Use same property condition as PowerShell. We can use a shared component GUID here because there should be only one installed on a system. -->
+                <Condition>ADD_PATH=1</Condition>
+                <Environment Id="ClientPATH" Name="PATH" Value="[INSTALLFOLDER]" Action="set" Part="first" System="yes" />
+            </Component>
+        </ComponentGroup>
+    </Fragment>
+</Wix>
diff --git a/contrib/win32/install/openssh.wixproj b/contrib/win32/install/openssh.wixproj
new file mode 100644
index 000000000..5f2d12d41
--- /dev/null
+++ b/contrib/win32/install/openssh.wixproj
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+    <PropertyGroup>
+        <Configuration Condition="'$(Configuration)' == ''">Debug</Configuration>
+        <Platform Condition="'$(Platform)' == ''">x64</Platform>
+        <!-- This ensures there is a default version if it is not defined as part of the release process with the actual product version -->
+        <ProductVersion Condition="'$(ProductVersion)' == ''">1.0.0</ProductVersion>
+        <OutputName>openssh</OutputName>
+        <OutputType>package</OutputType>
+        <OutputPath>bin\$(Platform)\$(Configuration)\</OutputPath>
+        <IntermediateOutputPath>obj\$(Platform)\$(Configuration)\</IntermediateOutputPath>
+        <DefineConstants>
+            $(DefineConstants);
+            ProductVersion=$(ProductVersion);
+        </DefineConstants>
+        <DefineSolutionProperties>false</DefineSolutionProperties>
+        <!-- Assumes WixToolPath is an input provided at runtime -->
+        <!-- If building x86/x64 MSI and have Wix 3.11 installed, can also try the below line instead -->
+        <!-- WixTargetsPath Condition="'$(WixTargetsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\WiX\v3.x\Wix.targets</WixTargetsPath -->
+        <WixTargetsPath>$(WixToolPath)Wix.targets</WixTargetsPath>
+        <WixTasksPath>$(WixToolPath)wixtasks.dll</WixTasksPath>
+    </PropertyGroup>
+
+    <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
+        <DefineConstants>
+            $(DefineConstants);
+            Debug;
+        </DefineConstants>
+    </PropertyGroup>
+
+    <ItemGroup>
+        <BindInputPaths Include="..\..\..\bin\$(Platform)\$(Configuration)" />
+    </ItemGroup>
+
+    <ItemGroup>
+        <Compile Include="product.wxs" />
+        <Compile Include="client.wxs" />
+        <Compile Include="server.wxs" />
+        <Compile Include="shared.wxs" />
+    </ItemGroup>
+
+    <ItemGroup>
+        <WixExtension Include="WixFirewallExtension" />
+        <WixExtension Include="WixUIExtension" />
+        <WixExtension Include="WixUtilExtension" />
+    </ItemGroup>
+
+    <Import Project="$(WixTargetsPath)" />
+</Project>
diff --git a/contrib/win32/install/product.wxs b/contrib/win32/install/product.wxs
new file mode 100644
index 000000000..9a47e4cb0
--- /dev/null
+++ b/contrib/win32/install/product.wxs
@@ -0,0 +1,49 @@
+<?xml version="1.0"?>
+
+<?ifndef ProductVersion?>
+<?error ProductVersion must be defined?>
+<?endif?>
+
+<!-- Currently support x86, x64 builds. Assumes only previews are built as MSIs. -->
+<?if $(var.Platform) = "x64"?>
+<?define ProgramFilesFolder = "ProgramFiles64Folder"?>
+<?define UpgradeCode = "9E9D0D93-E70D-4424-ADBD-AD3B226A226D"?>
+<?elseif $(var.Platform) = "x86"?>
+<?define ProgramFilesFolder = "ProgramFilesFolder"?>
+<?define UpgradeCode = "2A1799F1-5B26-4DDC-A0C7-03F75C4C08D2"?>
+<?elseif $(var.Platform) = "ARM64"?>
+<?define ProgramFilesFolder = "ProgramFiles64Folder"?>
+<?define UpgradeCode = "5D153A07-920A-4978-8B33-8447DD4C42F9"?>
+<?else?>
+<?error Platform $(var.Platform) is not supported?>
+<?endif?>
+
+<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
+    <Product Id="*" Name="OpenSSH" Version="$(var.ProductVersion)" Language="1033" Manufacturer="Microsoft Corporation" UpgradeCode="$(var.UpgradeCode)">
+        <Package Compressed="yes" InstallerVersion="200" InstallScope="perMachine"/>
+        <MediaTemplate EmbedCab="yes" />
+
+        <MajorUpgrade Schedule="afterInstallInitialize" DowngradeErrorMessage="A newer version of !(bind.property.ProductName) is already installed." />
+        <Condition Message="OpenSSH is supported only on Windows 7 and newer."><![CDATA[VersionNT >= 601]]></Condition>
+
+        <!-- assume user wants path to be updated when client binaries are installed, can be overridden during install with ADD_PATH=0 -->
+        <Property Id="ADD_PATH" Value="1" />
+
+        <Feature Id="Client" AllowAdvertise="no">
+            <ComponentGroupRef Id="Client" />
+        </Feature>
+        <Feature Id="Server" AllowAdvertise="no">
+            <ComponentGroupRef Id="Server" />
+        </Feature>
+
+        <Directory Id="TARGETDIR" Name="SourceDir">
+            <Directory Id="$(var.ProgramFilesFolder)" Name="Program Files">
+                <Directory Id="INSTALLFOLDER" Name="OpenSSH" >
+                    <Directory Id="MANIFESTFOLDER" Name="_manifest" >
+                        <Directory Id="SPDXFOLDER" Name="spdx_2.2" />
+                    </Directory>
+                </Directory>
+            </Directory>
+        </Directory>
+    </Product>
+</Wix>
diff --git a/contrib/win32/install/server.wxs b/contrib/win32/install/server.wxs
new file mode 100644
index 000000000..e63b36449
--- /dev/null
+++ b/contrib/win32/install/server.wxs
@@ -0,0 +1,69 @@
+<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi" xmlns:firewall="http://schemas.microsoft.com/wix/FirewallExtension" xmlns:util="http://schemas.microsoft.com/wix/UtilExtension">
+    <Fragment>
+        <!-- KeyPath is necessary for multi-file components to identify the key file - preferrably versioned. -->
+        <ComponentGroup Id="Server" Directory="INSTALLFOLDER">
+            <ComponentGroupRef Id="Shared" />
+            <ComponentGroupRef Id="Manifest" />
+            <Component>
+                <File Name="sftp-server.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-shellhost.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Id="sshd.exe" Name="sshd.exe" KeyPath="yes" />
+                <RegistryKey Root="HKLM" Key="SOFTWARE\OpenSSH" ForceCreateOnInstall="yes">
+                    <PermissionEx Sddl="O:BAG:SYD:P(A;OICI;KR;;;AU)(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)" />
+                    <!-- ssh-agent-associated key should only be created if the Server feature is installed. -->
+                    <RegistryKey Key="agent" ForceCreateOnInstall="yes">
+                        <PermissionEx Sddl="O:BAG:SYD:P(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)" />
+                    </RegistryKey>
+                </RegistryKey>
+                <ServiceInstall
+                    Name="sshd"
+                    DisplayName="OpenSSH SSH Server"
+                    Description="OpenSSH is a connectivity tool for remote login that uses the SSH protocol. It encrypts all traffic between client and server to eliminate eavesdropping, connection hijacking, and other attacks."
+                    Start="auto"
+                    Type="ownProcess"
+                    Interactive="no"
+                    ErrorControl="critical"
+                    Vital="yes">
+                    <util:ServiceConfig
+                        ResetPeriodInDays="1"
+                        FirstFailureActionType="restart"
+                        SecondFailureActionType="restart"
+                        ThirdFailureActionType="restart"
+                        />
+                </ServiceInstall>
+                <ServiceControl
+                    Id="ControlSshd"
+                    Name="sshd"
+                    Start="install"
+                    Stop="both"
+                    Remove="uninstall" />
+                <firewall:FirewallException
+                    Id="sshd_allow"
+                    Name="OpenSSH SSH Server Preview (sshd)"
+                    Description="Inbound rule for OpenSSH SSH Server (sshd)"
+                    Program="[#sshd.exe]"
+                    Protocol="tcp"
+                    Port="22"
+                    Scope="any"
+                    Profile="private"
+                    />
+            </Component>
+            <Component>
+                <File Name="sshd_config_default">
+                    <PermissionEx Sddl="O:BAG:SYD:PAI(A;;FA;;;SY)(A;;FA;;;BA)" />
+                </File>
+            </Component>
+        </ComponentGroup>
+
+        <!-- Automatically add custom actions if referencing the Server component group. -->
+        <SetProperty Id="SetPrivilegesOnSshd" Value="&quot;[SystemFolder]sc.exe&quot; privs sshd SeAssignPrimaryTokenPrivilege/SeTcbPrivilege/SeBackupPrivilege/SeRestorePrivilege/SeImpersonatePrivilege" Sequence="execute" Before="SetPrivilegesOnSshd" />
+        <CustomAction Id="SetPrivilegesOnSshd" BinaryKey="WixCA" DllEntry="WixQuietExec" Execute="deferred" Return="check" Impersonate="no" />
+        <InstallExecuteSequence>
+            <Custom Action="SetPrivilegesOnSshd" After="InstallServices"><![CDATA[&Server = 3]]></Custom>
+        </InstallExecuteSequence>
+    </Fragment>
+</Wix>
diff --git a/contrib/win32/install/shared.wxs b/contrib/win32/install/shared.wxs
new file mode 100644
index 000000000..d2b3793f1
--- /dev/null
+++ b/contrib/win32/install/shared.wxs
@@ -0,0 +1,89 @@
+<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi" xmlns:util="http://schemas.microsoft.com/wix/UtilExtension">
+    <Fragment>
+        <!-- KeyPath is necessary for multi-file components to identify the key file - preferrably versioned. -->
+        <ComponentGroup Id="Shared" Directory="INSTALLFOLDER">
+            <Component>
+                <File Name="libcrypto.dll" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="moduli">
+                    <PermissionEx Sddl="D:PAI(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;0x1200a9;;;WD)" />
+                </File>
+            </Component>
+            <Component>
+                <File Name="LICENSE.txt" />
+            </Component>
+            <Component>
+                <File Name="NOTICE.txt" />
+            </Component>
+            <Component>
+                <File Name="FixHostFilePermissions.ps1" />
+            </Component>
+            <Component>
+                <File Name="OpenSSHUtils.psd1" />
+            </Component>
+            <Component>
+                <File Name="FixUserFilePermissions.ps1" />
+            </Component>
+            <Component>
+                <File Name="OpenSSHUtils.psm1" />
+            </Component>
+            <Component>
+                <File Name="scp.exe" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="ssh-keygen.exe" KeyPath="yes" />
+            </Component>
+
+            <!-- ssh-agent is useful in both client and server scenarios. -->
+            <Component>
+                <File Name="openssh-events.man">
+                    <util:EventManifest ResourceFile="[#ssh_agent.exe]" />
+                </File>
+            </Component>
+            <Component>
+                <!-- Define the File/@Id to reference in util:EventManifest/@ResourceFile above. -->
+                <File Id="ssh_agent.exe" Name="ssh-agent.exe" KeyPath="yes" />
+                <ServiceInstall
+                    Name="ssh-agent"
+                    DisplayName="OpenSSH Authentication Agent"
+                    Description="Agent to hold private keys used for public key authentication."
+                    Start="auto"
+                    Type="ownProcess"
+                    Interactive="no"
+                    ErrorControl="critical"
+                    Vital="yes">
+                    <util:ServiceConfig
+                        ResetPeriodInDays="1"
+                        FirstFailureActionType="restart"
+                        SecondFailureActionType="restart"
+                        ThirdFailureActionType="restart"
+                        />
+                    <PermissionEx Sddl="D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;RP;;;AU)" />
+                </ServiceInstall>
+                <ServiceControl
+                    Id="ControlSshAgent"
+                    Name="ssh-agent"
+                    Start="install"
+                    Stop="both"
+                    Remove="uninstall" />
+            </Component>
+        </ComponentGroup>
+
+        <ComponentGroup Id="Manifest" Directory="SPDXFOLDER">
+             <Component>
+                <File Name="manifest.spdx.json" Source="_manifest\spdx_2.2\manifest.spdx.json" KeyPath="yes" />
+            </Component>
+            <Component>
+                <File Name="manifest.spdx.json.sha256" Source="_manifest\spdx_2.2\manifest.spdx.json.sha256" KeyPath="yes" />
+            </Component>
+        </ComponentGroup>
+
+        <!-- Automatically add custom actions if referencing the Shared component group. -->
+        <SetProperty Id="SetPrivilegesOnSshAgent" Value="&quot;[SystemFolder]sc.exe&quot; privs ssh-agent SeAssignPrimaryTokenPrivilege/SeTcbPrivilege/SeBackupPrivilege/SeRestorePrivilege/SeImpersonatePrivilege" Sequence="execute" Before="SetPrivilegesOnSshAgent" />
+        <CustomAction Id="SetPrivilegesOnSshAgent" BinaryKey="WixCA" DllEntry="WixQuietExec" Execute="deferred" Return="check" Impersonate="no" />
+        <InstallExecuteSequence>
+            <Custom Action="SetPrivilegesOnSshAgent" After="InstallServices"><![CDATA[&Server = 3]]></Custom>
+        </InstallExecuteSequence>
+    </Fragment>
+</Wix>
diff --git a/contrib/win32/openssh/AnalyzeCodeDiff.ps1 b/contrib/win32/openssh/AnalyzeCodeDiff.ps1
new file mode 100644
index 000000000..a4b4953be
--- /dev/null
+++ b/contrib/win32/openssh/AnalyzeCodeDiff.ps1
@@ -0,0 +1,200 @@
+﻿Set-StrictMode -Version Latest
+$Win32Macro = 'WIN32_FIXME'
+$sourceRoot = 'C:\openssh\Win32-OpenSSH'
+
+[int]$g_code = 0
+[int]$g_win32 = 0
+[int]$g_unix = 0
+
+function AnalyzeFile($file, [bool]$log)
+{
+    $file = Join-Path $sourceRoot $file
+    if ($log) {    Write-Host -ForegroundColor Gray $file }
+    $content = Get-Content $file
+    [int]$commentlines = 0    #comments
+    [int]$emptylines = 0      #emptylines
+    [int]$code = 0            #all code lines
+    [int]$win32 = 0           #win32 only lines
+    [int]$win32substituted = 0#lines in win32 block that have a corresponding Unix block (#ifdef with #else)
+    [int]$unix = 0;           #unix only lines
+    [int]$unixsubstituted = 0 #lines in unix block that have a corresponding Win32 block (#ifdef with #else)
+    [int]$total = 0           
+    [int]$nestedmacros = 0    #tracks nested macro blocks inside a win32 or a unix block
+    [bool]$incommentblock = $false
+    [bool]$inWin32block = $false
+    [bool]$inUnixblock = $false    
+    [int]$currentblockcode = 0
+    [bool]$insubstitutedblock = $false
+
+
+    foreach ($linestr in $content)
+    {
+        $total++
+       $line = [String]$linestr
+       $line = $line.Trim()
+       #skip if line is empty
+       if ($line.Length -gt 0)
+       {
+          if ($incommentblock) 
+          {
+            $commentlines++
+            if ($line.EndsWith('*/')) {$incommentblock = $false}
+          }
+          else
+          {
+             if ($line.StartsWith('//')) {$commentlines++}
+             elseif ($line.StartsWith('/*')) 
+             {
+                if (!($line.EndsWith('*/'))) { $incommentblock = $true }
+                $commentlines++
+             }            
+             else 
+             {
+                $code++
+                if ($inWin32block)
+                {
+                    $win32++
+                    $currentblockcode++
+                    #keep skipping inner #ifdefs
+                    if ($line.StartsWith('#ifdef')) {$nestedmacros++}
+
+                    if ($line.EndsWith('#endif') -or $line.EndsWith('#else'))
+                    {
+                        if ($nestedmacros -eq 0) 
+                        {
+                            $inWin32block = $false
+                            if ($line.EndsWith('#else')) 
+                            {
+                                $inUnixblock = $true
+                                $insubstitutedblock = $true
+                                $win32substituted += $currentblockcode
+                            }
+                            elseif ($insubstitutedblock)
+                            {
+                                $win32substituted += $currentblockcode
+                                $insubstitutedblock = $false
+                            }
+                            $currentblockcode = 0
+                        }
+                        else
+                        {
+                            if ($line.EndsWith('#endif')) {$nestedmacros--}                           
+                        }
+                    }
+                }
+                elseif ($inUnixblock)
+                {
+                    $unix++
+                    $currentblockcode++
+                    #keep skipping inner #ifdefs
+                    if ($line.StartsWith('#ifdef')) {$nestedmacros++}
+
+                    if ($line.EndsWith('#endif') -or $line.EndsWith('#else'))
+                    {
+                        if ($nestedmacros -eq 0) 
+                        {
+                            $inUnixblock = $false
+                            if ($line.EndsWith('#else')) 
+                            {
+                                $inWin32block = $true
+                                $insubstitutedblock = $true
+                                $unixsubstituted += $currentblockcode
+                            }
+                            elseif ($insubstitutedblock)
+                            {
+                                $unixsubstituted += $currentblockcode
+                                $insubstitutedblock = $false
+                            }
+
+                            $currentblockcode = 0
+                        }
+                        else
+                        {
+                            if ($line.EndsWith('#endif')) {$nestedmacros--}                           
+                        }
+                    }
+                }
+                else
+                {
+                    if ($line.StartsWith('#ifdef') -and $line.Contains($Win32Macro))
+                    {
+                        $inWin32block = $true
+                        $currentblockcode = 0
+                    }
+                    if ($line.StartsWith('#ifndef') -and $line.Contains($Win32Macro))
+                    {
+                        $inUnixblock = $true
+                        $currentblockcode = 0;
+                    }
+                }
+                
+             }
+          }
+       }
+       else {$emptylines++}
+    }
+    
+    if ($log) 
+    {
+        Write-Host -ForegroundColor Yellow "  Comments " $commentlines
+        Write-Host -ForegroundColor Green  "  Blank    " $emptylines
+        Write-Host -ForegroundColor Cyan        "  Code     " $code
+        Write-Host -ForegroundColor DarkMagenta "  Total    " $total "  check("($commentlines+$emptylines+$code)")"
+        Write-Host -ForegroundColor Cyan        "  Win32    " $win32    
+        Write-Host -ForegroundColor Cyan        "  Unix     " $unix
+        Write-Host -ForegroundColor Cyan        "  Win32sub " $win32substituted 
+        Write-Host -ForegroundColor Cyan        "  Unixsub  " $unixsubstituted
+    }
+
+    $global:g_code += $code
+    $global:g_win32 += $win32
+    $global:g_unix += $unix
+
+}
+
+
+function AnalyzeProject($project, [bool]$log)
+{
+    if ($log) {        Write-Host "Project: " $project}
+    $projectName = $project
+    $projectroot = Join-Path $sourceRoot 'contrib\win32\openssh'
+    $project = Join-Path $projectroot $project
+    $project = $project + '.vcxproj'
+
+    $global:g_code = 0
+    $global:g_win32 = 0
+    $global:g_unix = 0
+
+    $c = Get-Content $project
+    foreach ($ln in $c){
+        $l = [String]$ln
+        $l = $l.Trim()
+
+        if ($l.StartsWith('<ClCompile Include="$(OpenSSH-Src-Path)'))
+        {
+            $l = $l.Replace('<ClCompile Include="$(OpenSSH-Src-Path)','')  
+            $l = $l.Substring(0, $l.IndexOf('"'))
+            AnalyzeFile $l $log
+        }
+    }
+
+    if ($log) 
+    {
+        Write-Host "  Total Code     " $global:g_code
+        Write-Host "  Win32 Code     " $global:g_win32
+        Write-Host "  Unix  Code     " $global:g_unix
+    }
+
+    Write-Host $projectName "   "  (100 - ($global:g_unix*100/($global:g_code - $global:g_win32))) "%"
+
+}
+
+
+AnalyzeProject libssh
+AnalyzeProject scp
+AnalyzeProject sftp
+AnalyzeProject sftp-server
+AnalyzeProject ssh
+AnalyzeProject ssh-add
+AnalyzeProject ssh-agent
+AnalyzeProject sshd
\ No newline at end of file
diff --git a/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psd1 b/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psd1
new file mode 100644
index 000000000..e957fbc83
--- /dev/null
+++ b/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psd1
@@ -0,0 +1,39 @@
+##
+## Azure DevOps CI build tools
+## (TODO: Add appropriate copyright)
+##
+@{
+
+RootModule = './AzDOBuildTools.psm1'
+
+ModuleVersion = '1.0.0'
+
+GUID = '0b8fa798-ea71-40c7-b9ab-a417958bb3c4'
+
+Author = 'Microsoft Corporation'
+
+CompanyName = 'Microsoft Corporation'
+
+Copyright = '(c) Microsoft Corporation. All rights reserved.'
+
+Description = 'AzDO build tools for Win32-OpenSSH repository.'
+
+PowerShellVersion = '5.1'
+DotnetFrameworkVersion = '4.6.1'
+CLRVersion = '4.0.0'
+
+NestedModules = @(
+    '../OpenSSHCommonUtils.psm1',
+    '../OpenSSHBuildHelper.psm1',
+    '../OpenSSHTestHelper.psm1')
+
+FunctionsToExport = @(
+    'Invoke-AzDOBuild',
+    'Install-OpenSSH',
+    'Invoke-OpenSSHTests',
+    'Copy-OpenSSHTestResults',
+    'Copy-BuildResults',
+    'Copy-UnitTests',
+    'Install-UnitTests',
+    'Clear-TestEnvironmentSetup')
+}
diff --git a/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psm1 b/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psm1
new file mode 100644
index 000000000..e4f3eec1e
--- /dev/null
+++ b/contrib/win32/openssh/AzDOBuildTools/AzDOBuildTools.psm1
@@ -0,0 +1,513 @@
+﻿##
+## Azure DevOps CI build tools
+## [Add appropriate copyright]
+##
+
+$ErrorActionPreference = 'Stop'
+
+$repoRoot = Get-RepositoryRoot
+$script:messageFile = join-path $repoRoot.FullName "BuildMessage.log"
+
+function Write-BuildMessage
+{
+    param (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]
+        [string] $Message,
+
+        [ValidateNotNullOrEmpty()]
+        [string] $Category = "Information"
+    )
+
+    # Write message to verbose stream.
+    Write-Verbose -Verbose -Message "$Category--$Message"
+
+    # Write it to the log file, if present.
+    if (-not ([string]::IsNullOrEmpty($script:messageFile)))
+    {
+        Add-Content -Path $script:messageFile -Value "$Category--$Message"
+    }
+}
+
+<#
+    .Synopsis
+    Implements the AzDO build package step
+#>
+function Invoke-AzDOBuild
+{
+      Start-OpenSSHBuild -Configuration Release -NativeHostArch x64 -Verbose
+      Start-OpenSSHBuild -Configuration Release -NativeHostArch x86 -Verbose
+      Write-BuildMessage -Message "OpenSSH binaries build success!" -Category Information
+}
+
+<#
+    .Synopsis
+    Deploy all required files to a location and install the binaries
+#>
+function Install-OpenSSH
+{
+    [CmdletBinding()]
+    param ( 
+        [Parameter(Mandatory=$true)]
+        [string]$SourceDir,
+
+        [string]$OpenSSHDir = "$env:SystemDrive\OpenSSH"
+    )
+
+    UnInstall-OpenSSH -OpenSSHDir $OpenSSHDir
+
+    if (! (Test-Path -Path $OpenSSHDir)) {
+        $null = New-Item -Path $OpenSSHDir -ItemType Directory -Force
+    }
+
+    Copy-Item -Path "$SourceDir/*" -Destination $OpenSSHDir -Recurse -Force -Verbose
+
+    Push-Location $OpenSSHDir 
+
+    try
+    {
+        & "$OpenSSHDir\install-sshd.ps1"
+
+        $machinePath = [Environment]::GetEnvironmentVariable('Path', 'MACHINE')
+        $newMachineEnvironmentPath = $machinePath
+        if (-not ($machinePath.ToLower().Contains($OpenSSHDir.ToLower())))
+        {
+            $newMachineEnvironmentPath = "$OpenSSHDir;$newMachineEnvironmentPath"
+            $env:Path = "$OpenSSHDir;$env:Path"
+        }
+
+        # Update machine environment path
+        if ($newMachineEnvironmentPath -ne $machinePath)
+        {
+            [Environment]::SetEnvironmentVariable('Path', $newMachineEnvironmentPath, 'MACHINE')
+        }
+        
+        Start-Service -Name sshd 
+        Start-Service -Name ssh-agent
+    }
+    finally
+    {
+        Pop-Location
+    }
+
+    Write-BuildMessage -Message "OpenSSH installed!" -Category Information
+}
+
+<#
+    .Synopsis
+    Uninstalled sshd
+#>
+function UnInstall-OpenSSH
+{
+    [CmdletBinding()]
+    param ( 
+        [string]$OpenSSHDir = "$env:SystemDrive\OpenSSH"
+    )
+
+    if (-not (Test-Path $OpenSSHDir -PathType Container))
+    {
+        return
+    }
+
+    Push-Location $OpenSSHDir
+
+    try
+    {
+        if ((Get-Service ssh-agent -ErrorAction SilentlyContinue) -ne $null) {
+            Stop-Service ssh-agent -Force
+        }
+        & "$OpenSSHDir\uninstall-sshd.ps1"
+            
+        $machinePath = [Environment]::GetEnvironmentVariable('Path', 'MACHINE')
+        $newMachineEnvironmentPath = $machinePath
+        if ($machinePath.ToLower().Contains($OpenSSHDir.ToLower()))
+        {        
+            $newMachineEnvironmentPath = $newMachineEnvironmentPath.Replace("$OpenSSHDir;", '')
+            $env:Path = $env:Path.Replace("$OpenSSHDir;", '')
+        }
+        
+        if ($newMachineEnvironmentPath -ne $machinePath)
+        {
+            [Environment]::SetEnvironmentVariable('Path', $newMachineEnvironmentPath, 'MACHINE')
+        }
+    }
+    finally
+    {
+        Pop-Location
+    }
+
+    Remove-Item -Path $OpenSSHDir -Recurse -Force -ErrorAction SilentlyContinue    
+}
+
+#
+# Install CygWin from Chocolatey and fix up install directory if needed.
+#
+function Install-CygWin
+{
+    param (
+        [string] $InstallLocation
+    )
+
+    Write-Verbose -Verbose -Message "Installing CygWin from Chocolately to location: ${InstallLocation} ..."
+    choco install cygwin -y --force --params "/InstallDir:${InstallLocation} /NoStartMenu"
+}
+
+<#
+      .Synopsis
+      Runs the tests for this repo
+#>
+function Invoke-OpenSSHTests
+{
+    [CmdletBinding()]
+    param (
+        [Parameter(Mandatory=$true)]
+        [string] $OpenSSHBinPath
+    )
+
+    Set-BasicTestInfo -OpenSSHBinPath $OpenSSHBinPath -Confirm:$false
+
+    Write-Verbose -Verbose -Message "Running OpenSSH Set up Tests..."
+
+    $AllTestsPassed = $true
+
+    Invoke-OpenSSHSetupTest
+
+    if (($OpenSSHTestInfo -eq $null) -or (-not (Test-Path $OpenSSHTestInfo["SetupTestResultsFile"])))
+    {
+        Write-BuildMessage -Message "Test result file $OpenSSHTestInfo["SetupTestResultsFile"] not found after tests." -Category Error
+        $AllTestsPassed = $false
+        Write-Warning "Stop running further tests!"
+        return
+    }
+
+    $xml = [xml](Get-Content $OpenSSHTestInfo["SetupTestResultsFile"] | out-string)
+    if ([int]$xml.'test-results'.failures -gt 0) 
+    {
+        $errorMessage = "$($xml.'test-results'.failures) Setup Tests in regress\pesterTests failed. Detail test log is at $($OpenSSHTestInfo["SetupTestResultsFile"])."
+        Write-BuildMessage -Message $errorMessage -Category Error
+        $AllTestsPassed = $False
+        Write-Warning "Stop running further tests!"
+        return
+    }
+
+    Write-BuildMessage -Message "All Setup tests passed!" -Category Information
+    $AllTestsPassed = $true
+
+    # Unit test directories are installed in the same directory as Open SSH binaries.
+    #  OpenSSH Directory
+    #    unittest-bitmap
+    #    unittest-hostkeys
+    #    ...
+    #    FixHostFilePermissions.ps1
+    #    ...
+    Write-Verbose -Verbose -Message "Running Unit Tests..."
+    Write-Verbose -Verbose -Message "Unit test directory is: ${OpenSSHBinPath}"
+
+    $unitTestFailed = Invoke-OpenSSHUnitTest -UnitTestDirectory $OpenSSHBinPath
+
+    if($unitTestFailed)
+    {
+        Write-BuildMessage "At least one of the unit tests failed!" -Category Error
+        $AllTestsPassed = $false
+    }
+    else
+    {
+        Write-BuildMessage -Message "All Unit tests passed!" -Category Information
+    }
+
+    # Run all E2E tests.
+    Write-Verbose -Verbose -Message "Running E2E Tests..."
+    Set-OpenSSHTestEnvironment -Confirm:$false
+    Invoke-OpenSSHE2ETest
+    if (($OpenSSHTestInfo -eq $null) -or (-not (Test-Path $OpenSSHTestInfo["E2ETestResultsFile"])))
+    {
+        Write-BuildMessage -Message "Test result file $OpenSSHTestInfo["E2ETestResultsFile"] not found after tests." -Category Error
+        $AllTestsPassed =  $false
+    }
+    else
+    {
+        $xml = [xml](Get-Content $OpenSSHTestInfo["E2ETestResultsFile"] | out-string)
+        if ([int]$xml.'test-results'.failures -gt 0)
+        {
+            $errorMessage = "$($xml.'test-results'.failures) E2E tests in regress\pesterTests failed. Detail test log is at $($OpenSSHTestInfo["E2ETestResultsFile"])."
+            Write-BuildMessage -Message $errorMessage -Category Error
+            $AllTestsPassed = $false
+        }
+        else
+        {
+            Write-BuildMessage -Message "All E2E tests passed!" -Category Information
+        }
+    }
+
+    # Bash tests.
+    Write-Verbose -Verbose -Message "Running Bash Tests..."
+
+    # Ensure CygWin is installed, and install from Chocolatey if needed.
+    $cygwinInstalled = $true
+    $cygwinInstallLocation = "$env:SystemDrive/cygwin"
+    if (! (Test-Path -Path "$cygwinInstallLocation/bin/sh.exe"))
+    {
+        Write-Verbose -Verbose -Message "CygWin not found"
+        Install-CygWin -InstallLocation $cygwinInstallLocation
+
+        # Hack to fix up mangled CygWin directory, if needed.
+        $expectedCygWinPath = "$env:SystemDrive/cygwin/bin/sh.exe"
+        if (! (Test-Path -Path $expectedCygWinPath))
+        {
+            Write-Verbose -Verbose -Message "CygWin did not install correctly, missing expected path: ${expectedCygWinPath}"
+
+            $cygWinDirs = Get-Item -Path "$env:SystemDrive/cygwin*"
+            if ($cygWinDirs.Count -gt 1)
+            {
+                Write-Verbose -Verbose -Message "CygWin install failed with mangled folder locations: ${cygWinDirs}"
+                Write-Verbose -Verbose -Message 'TODO: Add hack to fix up CygWin folder.'
+            }
+
+            Write-BuildMessage -Message "All bash tests failed because CygWin install failed" -Category Error
+            $AllTestsPassed = $false
+            $cygwinInstalled = $false
+        }
+    }
+
+    # Run UNIX bash tests.
+    if ($cygwinInstalled)
+    {
+        Write-Verbose -Verbose -Message "Starting Bash Tests..."
+        Invoke-OpenSSHBashTests
+        if (-not $Global:bash_tests_summary)
+        {
+            $errorMessage = "Failed to start OpenSSH bash tests"
+            Write-BuildMessage -Message $errorMessage -Category Error
+            $AllTestsPassed = $false
+        }
+        else
+        {
+            if ($Global:bash_tests_summary["TotalBashTestsFailed"] -ne 0)
+            {
+                $total_bash_failed_tests = $Global:bash_tests_summary["TotalBashTestsFailed"]
+                $total_bash_tests = $Global:bash_tests_summary["TotalBashTests"]
+                $errorMessage = "At least one of the bash tests failed. [$total_bash_failed_tests of $total_bash_tests]"
+                Write-BuildMessage -Message $errorMessage -Category Error
+                $AllTestsPassed = $false
+            }
+
+            $OpenSSHTestInfo["BashTestSummaryFile"] = $Global:bash_tests_summary["BashTestSummaryFile"]
+            $OpenSSHTestInfo["BashTestLogFile"] = $Global:bash_tests_summary["BashTestLogFile"]
+        }
+    }
+
+    # OpenSSH Uninstall Tests
+    Invoke-OpenSSHUninstallTest
+    if (($OpenSSHTestInfo -eq $null) -or (-not (Test-Path $OpenSSHTestInfo["UninstallTestResultsFile"])))
+    {
+        Write-BuildMessage -Message "Test result file $OpenSSHTestInfo["UninstallTestResultsFile"] not found after tests." -Category Error
+        $AllTestsPassed = $false
+    }
+    else
+    {
+        $xml = [xml](Get-Content $OpenSSHTestInfo["UninstallTestResultsFile"] | out-string)
+        if ([int]$xml.'test-results'.failures -gt 0) 
+        {
+            $errorMessage = "$($xml.'test-results'.failures) uninstall tests in regress\pesterTests failed. Detail test log is at $($OpenSSHTestInfo["UninstallTestResultsFile"])."
+            Write-BuildMessage -Message $errorMessage -Category Error
+            $AllTestsPassed = $false
+        }
+    }
+
+    # Save OpenSSHTestInfo for later test results uploading.
+    $OpenSSHTestInfo | Export-Clixml -Path "$repoRoot/OpenSSHTestInfo.xml" -Depth 10
+
+    # Writing out warning when the $Error.Count is non-zero. Tests Should clean $Error after success.
+    if ($Error.Count -gt 0) 
+    {
+        Write-BuildMessage -Message "Tests Should always clean $Error variable after success." -Category Warning
+    }
+
+    if ($AllTestsPassed)
+    {
+        Write-BuildMessage -Message "All OpenSSH validation tests have passed!" -Category Information
+    }
+    else
+    {
+        Write-BuildMessage -Message "Some OpenSSH validation tests have failed." -Category Error
+        throw "OpenSSH validation tests failed!"
+    }
+}
+
+<#
+      .Synopsis
+      Collect OpenSSH pester test results into one directory
+#>
+function Copy-OpenSSHTestResults
+{ 
+    param (
+        [Parameter(Mandatory=$true)]
+        [string] $ResultsPath
+    )
+
+    if (Test-Path -Path $ResultsPath)
+    {
+        Remove-Item -Path $ResultsPath -Force -Recurse -ErrorAction Ignore
+    }
+
+    Write-Verbose -Verbose "Creating test results directory for artifacts upload: $ResultsPath"
+    $null = New-Item -Path $ResultsPath -ItemType Directory -Force
+    
+    if (! (Test-Path -Path $ResultsPath))
+    {
+        Write-BuildMessage -Message "Unable to write to test results path for test artifacts upload: $ResultsPath" -Category Error
+        return
+    }
+
+    $OpenSSHTestInfo = $null
+    $openSSHTestInfoFilePath = "$repoRoot/OpenSSHTestInfo.xml"
+    if (Test-Path -Path $openSSHTestInfoFilePath)
+    {
+        $OpenSSHTestInfo = Import-Clixml -Path $openSSHTestInfoFilePath
+    }
+
+    if (! $OpenSSHTestInfo)
+    {
+        Write-BuildMessage -Message "Unable to get OpenSSHTestInfo object from: ${openSSHTestInfoFilePath}"
+        return
+    }
+
+    try { $setupresultFile = Resolve-Path -Path $OpenSSHTestInfo["SetupTestResultsFile"] -ErrorAction Ignore } catch { }
+    if ($setupresultFile)
+    {
+        Write-Verbose -Verbose -Message "Copying set-up test results file, $setupresultFile, to results directory"
+        Copy-Item -Path $setupresultFile -Destination $ResultsPath
+    }
+
+    try { $E2EresultFile = Resolve-Path -Path $OpenSSHTestInfo["E2ETestResultsFile"] -ErrorAction Ignore } catch { }
+    if ($E2EresultFile)
+    {
+        Write-Verbose -Verbose -Message "Copying end-to-end test results file, $E2EresultFile, to results directory"
+        Copy-Item -Path $E2EresultFile -Destination $ResultsPath
+    }
+
+    try { $uninstallResultFile = Resolve-Path $OpenSSHTestInfo["UninstallTestResultsFile"] -ErrorAction Ignore } catch { }
+    if ($uninstallResultFile)
+    {
+        Write-Verbose -Verbose -Message "Copying uninstall test results file, $uninstallResultFile, to results directory"
+        Copy-Item -Path $uninstallResultFile -Destination $ResultsPath
+    }
+
+    try { $bashTestsSummaryFile = Resolve-Path -Path $OpenSSHTestInfo["BashTestSummaryFile"] -ErrorAction Ignore } catch { }
+    if ($bashTestsSummaryFile)
+    {
+        Write-Verbose -Verbose -Message "Copying bash tests summary file, $bashTestsSummaryFile, to results directory"
+        Copy-Item -Path $bashTestsSummaryFile -Destination $ResultsPath
+    }
+
+    try { $bashTestsLogFile = Resolve-Path -Path $OpenSSHTestInfo["BashTestLogFile"] -ErrorAction Ignore } catch { }
+    if ($bashTestsLogFile)
+    {
+        Write-Verbose -Verbose -Message "Copying bash tests log file, $bashTestsLogFile, to results directory"
+        Copy-Item -Path $bashTestsLogFile -Destination $ResultsPath
+    }
+}
+
+function Clear-TestEnvironmentSetup
+{
+    Write-Verbose -Verbose -Message "Running OpenSSH test environment cleanup..."
+
+    try
+    {
+        $null = Clear-OpenSSHTestEnvironment -ErrorAction Ignore
+        $null = UnInstall-OpenSSH -ErrorAction Ignore
+    }
+    catch
+    { }
+
+    Write-Verbose -Verbose -Message "OpenSSH test environment cleanup complete."
+}
+
+<#
+    .SYNOPSIS
+    Copy build results package to provided destination path.
+#>
+function Copy-BuildResults
+{
+    param (
+        [Parameter(Mandatory=$true)]
+        [string] $BuildResultsPath,
+
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release"
+    )
+
+    # Copy OpenSSH package to results directory
+    Start-OpenSSHPackage -DestinationPath $BuildResultsPath -NativeHostArch $NativeHostArch -Configuration $Configuration
+}
+
+<#
+    .SYNOPSIS
+    Copy build unit tests to provided destination path.
+#>
+function Copy-UnitTests
+{
+    param (
+        [Parameter(Mandatory=$true)]
+        [string] $UnitTestsSrcDir,
+
+        [Parameter(Mandatory=$true)]
+        [string] $UnitTestsDestDir,
+
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release"
+    )
+
+    if (! (Test-Path -Path $UnitTestsDestDir))
+    {
+      Write-Verbose -Verbose -Message "Creating Unit Test directory: $UnitTestsDestDir"
+      $null = New-Item -Path $UnitTestsDestDir -ItemType Directory -Force
+    }
+
+    if ($NativeHostArch -eq 'x86')
+    {
+        $unitTestsSrcPath = Join-Path -Path $UnitTestsSrcDir -ChildPath "Win32/${Configuration}"
+    }
+    else
+    {
+        $unitTestsSrcPath = Join-Path -Path $UnitTestsSrcDir -ChildPath "${NativeHostArch}/${Configuration}"
+    }
+
+    $unitTestsDestPath = Join-Path -Path $UnitTestsDestDir -ChildPath "${NativeHostArch}/${Configuration}"
+
+    if (! (Test-Path -Path $unitTestsDestPath))
+    {
+      Write-Verbose -Verbose -Message "Creating Unit Test directory: $unitTestsDestPath"
+      $null = New-Item -Path $unitTestsDestPath -ItemType Directory -Force
+    }
+
+    Write-Verbose -Verbose -Message "Copying unit tests from: ${unitTestsSrcPath} to: ${unitTestsDestPath}"
+    Copy-Item -Path "$unitTestsSrcPath/unittest-*" -Destination $unitTestsDestPath -Recurse -Force
+}
+
+<#
+    .SYNOPSIS
+    Install unit tests to provided destination.
+#>
+function Install-UnitTests
+{
+    [CmdletBinding()]
+    param ( 
+        [Parameter(Mandatory=$true)]
+        [string]$SourceDir,
+
+        [string]$OpenSSHDir = "$env:SystemDrive\OpenSSH"
+    )
+
+    if (! (Test-Path -Path $OpenSSHDir)) {
+        $null = New-Item -Path $OpenSSHDir -ItemType Directory -Force
+    }
+
+    Copy-Item -Path "$SourceDir/*" -Destination $OpenSSHDir -Recurse -Force
+}
diff --git a/contrib/win32/openssh/BinSkimConfig.xml b/contrib/win32/openssh/BinSkimConfig.xml
new file mode 100644
index 000000000..91ce27497
--- /dev/null
+++ b/contrib/win32/openssh/BinSkimConfig.xml
@@ -0,0 +1,126 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Properties Type="PropertiesDictionary">
+  <Properties Key="BA2001.LoadImageAboveFourGigabyteAddress.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2002.DoNotIncorporateVulnerableDependencies.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+    <Properties Key="VulnerableDependencies" Type="PropertiesDictionary">
+      <Properties Key="AtlVulnerability" Type="IL.Rules.VulnerableDependencyDescriptor">
+        <Property Key="FileHashes" Type="StringSet">
+          <Item>atlbase.h#31-F6-53-39-6A-51-B4-57-1E-F0-DD-C0-B3-54-8A-60</Item>
+          <Item>atlbase.h#FC-A7-3E-99-8B-D3-CC-E6-D6-28-75-F6-B4-27-DF-6E</Item>
+          <Item>atlcom.h#0B-C1-32-3B-3B-19-84-64-07-F5-3A-7A-48-36-43-B0</Item>
+          <Item>atlcom.h#95-EB-90-BE-CF-F8-DF-1B-3E-EC-79-0A-64-B4-96-54</Item>
+          <Item>atlcom.h#97-D2-E6-9A-A3-D5-F2-F1-BA-2A-51-A2-B6-C8-9A-4B</Item>
+          <Item>atlcom.h#AE-5D-A4-A5-23-42-EA-F8-46-74-93-91-1C-4F-3B-93</Item>
+          <Item>atlcomcli.h#56-42-D5-31-BE-31-25-9B-E9-69-9F-2F-1F-68-CD-C2</Item>
+          <Item>atlcomcli.h#76-FB-17-FE-79-86-B9-7D-0E-09-97-85-9A-20-E9-4C</Item>
+          <Item>atlcomcli.h#7B-C6-E4-10-50-D7-89-24-37-71-7F-1E-9D-97-84-B6</Item>
+          <Item>atlcomcli.h#A5-17-80-59-4D-4D-94-0C-68-0A-00-59-ED-6B-B3-1D</Item>
+          <Item>atlcomcli.h#AC-EB-62-06-96-F2-ED-92-F8-F9-14-A0-50-48-80-25</Item>
+          <Item>atlimpl.cpp#7C-4C-5D-BE-B6-EF-CB-DF-AF-8E-54-E5-0E-C0-2A-FB</Item>
+        </Property>
+        <Property Key="Id" Value="AtlVulnerability" />
+        <Property Key="Resolution" Value="compile your binary using an up-to-date copy of ATL." />
+        <Property Key="VulnerabilityDescription" Value="contains known remote execution bugs (see https://technet.microsoft.com/en-us/library/security/ms09-035.aspx)." />
+      </Properties>
+    </Properties>
+  </Properties>
+  <Properties Key="BA2005.DoNotShipVulnerableBinaries.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+    <Properties Key="VulnerableBinaries" Type="IL.Rules.StringToVersionMap">
+      <Property Key="msidcrl.dll" Value="7.0" Type="System.Version" />
+      <Property Key="msxml6.dll" Value="6.30" Type="System.Version" />
+      <Property Key="xmllite.dll" Value="1.3" Type="System.Version" />
+    </Properties>
+  </Properties>
+  <Properties Key="BA2006.BuildWithSecureTools.Options" Type="PropertiesDictionary">
+    <!---->
+    <Property Key="AdvancedMitigationsEnforced" Value="None" Type="AdvancedMitigations" />
+    <Properties Key="AllowedLibraries" Type="IL.Rules.StringToVersionMap" />
+    <Properties Key="MinimumToolVersions" Type="IL.Rules.StringToVersionMap">
+      <Property Key="C" Value="17.0.65501.17013" Type="System.Version" />
+      <Property Key="MinimumXboxCompilerVersion" Value="16.0.11886.0" Type="System.Version" />
+    </Properties>
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2007.EnableCriticalCompilerWarnings.Options" Type="PropertiesDictionary">
+    <!-- Valid values here are currently Default and Disabled. -->
+    <Property Key="RuleEnabled" Value="Disabled" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2008.EnableControlFlowGuard.Options" Type="PropertiesDictionary">
+    <!---->
+    <Property Key="MinimumRequiredLinkerVersion" Value="14.0" Type="System.Version" />
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2009.EnableAddressSpaceLayoutRandomization.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2010.DoNotMarkImportsSectionAsExecutable.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2011.EnableStackProtection.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2012.DoNotModifyStackProtectionCookie.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2013.InitializeStackProtection.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2014.DoNotDisableStackProtectionForFunctions.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+    <Property Key="StringSet" Type="StringSet">
+      <Item>__vcrt_trace_logging_provider::_TlgWrite</Item>
+      <Item>_TlgWrite</Item>
+    </Property>
+  </Properties>
+  <Properties Key="BA2015.EnableHighEntropyVirtualAddresses.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2016.MarkImageAsNXCompatible.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2018.EnableSafeSEH.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2019.DoNotMarkWritableSectionsAsShared.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2021.DoNotMarkWritableSectionsAsExecutable.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2022.SignSecurely.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA2024.EnableSpectreMitigations.Options" Type="PropertiesDictionary">
+    <Properties Key="AllowedLibraries" Type="IL.Rules.StringToVersionMap" />
+    <Properties Key="MitigatedCompilers" Type="PropertiesDictionary">
+      <Properties Key="Arm" Type="PropertiesDictionary" />
+      <Properties Key="X86" Type="PropertiesDictionary">
+        <Property Key="19.12.25830.2-19.12.*.*" Value="D2GuardSpecLoadAvailable" />
+        <Property Key="19.13.26029.0 - 19.13.26029.*" Value="D2GuardSpecLoadAvailable" />
+        <Property Key="19.14.0.0 - *.*.*.*" Value="QSpectreAvailable, D2GuardSpecLoadAvailable" />
+      </Properties>
+    </Properties>
+    <!---->
+    <Property Key="Reporting" Value="Default" Type="ReportingOptions" />
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA3001.EnablePIEOnExecutables.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA3002.DoNotMarkStackAsExecutable.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA3003.EnableStackProtector.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA3010.EnableReadOnlyRelocations.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+  <Properties Key="BA3030.UseCheckedFunctionsWithGCC.Options" Type="PropertiesDictionary">
+    <Property Key="RuleEnabled" Value="Default" Type="Driver.RuleEnabledState" />
+  </Properties>
+</Properties>
\ No newline at end of file
diff --git a/contrib/win32/openssh/CredScanSuppress.json b/contrib/win32/openssh/CredScanSuppress.json
new file mode 100644
index 000000000..ec06e378f
--- /dev/null
+++ b/contrib/win32/openssh/CredScanSuppress.json
@@ -0,0 +1,37 @@
+{
+    "tool": "Credential Scanner",
+    "suppressions": [
+      {
+        "file": "\\regress\\pesterTests\\SSHDConfig.tests.ps1",
+        "_justification": "password for testing purpose"
+      },
+      {
+        "file": "\\contrib\\win32\\openssh\\OpenSSHTestHelper.psm1",
+        "_justification": "password for testing purpose"
+      },
+      {
+        "file": "\\regress\\pesterTests\\PlatformAbstractLayer.psm1",
+        "_justification": "password for testing purpose"
+      },
+      {
+        "file": "auth.c",
+        "_justification": "upstream code uses fake password"
+      },
+      {
+        "file": "\\regress\\pesterTests\\data\\sshtest_hostkey_dsa",
+        "_justification": "ssh key for testing purpose"
+      },
+      {
+        "file": "\\regress\\pesterTests\\data\\sshtest_hostkey_ecdsa",
+        "_justification": "ssh key for testing purpose"
+      },
+      {
+        "file": "\\regress\\pesterTests\\data\\sshtest_hostkey_rsa",
+        "_justification": "ssh key for testing purpose"
+      },
+      {
+        "file": "\\regress\\keygen-convert.sh",
+        "_justification": "password for testing purpose"
+      }
+     ]  
+}
diff --git a/contrib/win32/openssh/DockerFile b/contrib/win32/openssh/DockerFile
new file mode 100644
index 000000000..639061284
--- /dev/null
+++ b/contrib/win32/openssh/DockerFile
@@ -0,0 +1,10 @@
+# escape=`
+#0.3.6 (no powershell 6)
+FROM balu1202/openssh-dockerbuildimage-ltsc2019-new:latest
+
+SHELL ["PowerShell.exe", "-command"]
+RUN Set-ExecutionPolicy Unrestricted
+
+COPY ./OpenSSH-build.ps1 /OpenSSH-build.ps1
+
+ENTRYPOINT ["powershell", "-executionpolicy", "unrestricted"]
diff --git a/contrib/win32/openssh/FixHostFilePermissions.ps1 b/contrib/win32/openssh/FixHostFilePermissions.ps1
new file mode 100644
index 000000000..c990a0d01
--- /dev/null
+++ b/contrib/win32/openssh/FixHostFilePermissions.ps1
@@ -0,0 +1,60 @@
+﻿[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+param ()
+Set-StrictMode -Version 2.0
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\OpenSSHUtils -Force
+
+#check sshd config file
+$sshdConfigPath = join-path $env:ProgramData\ssh "sshd_config"
+if(Test-Path $sshdConfigPath -PathType Leaf)
+{
+    Repair-SshdConfigPermission -FilePath $sshdConfigPath @psBoundParameters
+}
+else
+{
+    Write-host "$sshdConfigPath does not exist"  -ForegroundColor Yellow
+}
+ 
+#check host keys
+<#
+$warning = @"
+To keep the host private keys secure, it is recommended to register them with ssh-agent following
+steps in link https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH.
+If you choose not to register the keys with ssh-agent, please grant sshd read access to the private host keys after run this script.
+"@
+$prompt = "Did you register host private keys with ssh-agent?"
+$description = "Grant sshd read access to the private host keys"
+
+if($pscmdlet.ShouldProcess($description, $prompt, $warning))
+{
+    $warning = @"
+To keep the host private keys secure, it is recommended to register them with ssh-agent following
+steps in link https://github.com/PowerShell/Win32-OpenSSH/wiki/Install-Win32-OpenSSH.
+If you choose not to register the keys with ssh-agent, please grant sshd read access to the private host keys after run this script.
+"@
+    Write-Warning $warning
+    Write-Host " "
+}#>
+
+Get-ChildItem $env:ProgramData\ssh\ssh_host_*_key -ErrorAction SilentlyContinue | % {
+    Repair-SshdHostKeyPermission -FilePath $_.FullName @psBoundParameters
+}
+
+
+#check authorized_keys
+Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"  -ErrorAction SilentlyContinue | % {
+    $properties =  Get-ItemProperty $_.pspath  -ErrorAction SilentlyContinue
+    $userProfilePath = ""
+    if($properties)
+    {
+        $userProfilePath =  $properties.ProfileImagePath
+    }
+    $filePath = Join-Path $userProfilePath .ssh\authorized_keys
+    if(Test-Path $filePath -PathType Leaf)
+    {
+        Repair-AuthorizedKeyPermission -FilePath $filePath @psBoundParameters
+    }
+}
+
+Write-Host "   Done."
+Write-Host " "
diff --git a/contrib/win32/openssh/FixUserFilePermissions.ps1 b/contrib/win32/openssh/FixUserFilePermissions.ps1
new file mode 100644
index 000000000..1e370208f
--- /dev/null
+++ b/contrib/win32/openssh/FixUserFilePermissions.ps1
@@ -0,0 +1,35 @@
+﻿[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+param ()
+Set-StrictMode -Version 2.0
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+
+Import-Module $PSScriptRoot\OpenSSHUtils -Force
+
+if(Test-Path ~\.ssh\config -PathType Leaf)
+{
+    Repair-UserSshConfigPermission -FilePath ~\.ssh\config @psBoundParameters
+}
+
+Get-ChildItem ~\.ssh\* -Include "id_rsa","id_dsa","id_ecdsa","id_ed25519" -ErrorAction SilentlyContinue | ForEach-Object {
+    Repair-UserKeyPermission -FilePath $_.FullName @psBoundParameters
+}
+
+
+
+$sshdAdministratorsAuthorizedKeysPath = join-path $env:ProgramData\ssh "administrators_authorized_keys"
+if(Test-Path $sshdAdministratorsAuthorizedKeysPath -PathType Leaf) 
+{
+    if (([bool]([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")))
+    {
+        Repair-AdministratorsAuthorizedKeysPermission -FilePath $sshdAdministratorsAuthorizedKeysPath @psBoundParameters
+    }
+    else 
+    {
+        Write-host "To fix file permissions for $sshdAdministratorsAuthorizedKeysPath, run this script in elevated mode" -ForegroundColor Yellow
+    }
+}
+
+
+
+Write-Host "   Done."
+Write-Host " "
diff --git a/contrib/win32/openssh/GetFIDO2.ps1 b/contrib/win32/openssh/GetFIDO2.ps1
new file mode 100644
index 000000000..55195ec12
--- /dev/null
+++ b/contrib/win32/openssh/GetFIDO2.ps1
@@ -0,0 +1,62 @@
+param (
+    [string] $paths_target_file_path,
+    [string] $destDir,
+    [switch] $override
+)
+
+# Workaround that $PSScriptRoot is not support on ps version 2
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+
+if([string]::IsNullOrEmpty($paths_target_file_path))
+{
+    $paths_target_file_path = Join-Path $PSScriptRoot "paths.targets"
+}
+
+if([string]::IsNullOrEmpty($destDir))
+{
+    $destDir = $PSScriptRoot
+}
+
+if($override)
+{
+    Remove-Item (join-path $destDir "libfido2") -Recurse -Force -ErrorAction SilentlyContinue
+}
+elseif (Test-Path (Join-Path $destDir "libfido2") -PathType Container)
+{
+    return
+}
+
+[xml] $buildConfig = Get-Content $paths_target_file_path
+$version = $buildConfig.Project.PropertyGroup.fido2Version
+
+Write-Host "Downloading libfido2 version:$version"
+Write-Host "paths_target_file_path:$paths_target_file_path"
+Write-Host "destDir:$destDir"
+Write-Host "override:$override"
+
+$zip_path = Join-Path $PSScriptRoot "libfido2.zip"
+
+$release_url = "https://github.com/PowerShell/libfido2/releases/download/$version/libfido2.zip"
+Write-Host "release_url:$release_url"
+
+[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor `
+                                              [Net.SecurityProtocolType]::Tls11 -bor `
+                                              [Net.SecurityProtocolType]::Tls
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+Invoke-WebRequest -Uri $release_url -OutFile $zip_path -UseBasicParsing
+if(-not (Test-Path $zip_path))
+{
+    throw "failed to download libfido2 version:$version"
+}
+
+# XXX check pgp sig?
+Expand-Archive -Path $zip_path -DestinationPath $destDir\libfido2 -Force -ErrorAction SilentlyContinue -ErrorVariable e
+if($e -ne $null)
+{
+    throw "Error when expand zip file. libfido2 version:$version"
+}
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+
+Write-Host "Succesfully downloaded libfido2 version:$version"
diff --git a/contrib/win32/openssh/GetLibreSSL.ps1 b/contrib/win32/openssh/GetLibreSSL.ps1
new file mode 100644
index 000000000..35dfaa784
--- /dev/null
+++ b/contrib/win32/openssh/GetLibreSSL.ps1
@@ -0,0 +1,61 @@
+param (
+    [string] $paths_target_file_path,
+    [string] $destDir,
+    [switch] $override
+)
+
+# Workaround that $PSScriptRoot is not support on ps version 2
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+
+if([string]::IsNullOrEmpty($paths_target_file_path))
+{
+    $paths_target_file_path = Join-Path $PSScriptRoot "paths.targets"
+}
+
+if([string]::IsNullOrEmpty($destDir))
+{
+    $destDir = $PSScriptRoot
+}
+
+if($override)
+{
+    Remove-Item (join-path $destDir "LibreSSL") -Recurse -Force -ErrorAction SilentlyContinue
+}
+elseif (Test-Path (Join-Path $destDir "LibreSSL") -PathType Container)
+{
+    return
+}
+
+[xml] $buildConfig = Get-Content $paths_target_file_path
+$version = "V" + $buildConfig.Project.PropertyGroup.LibreSSLVersion
+
+Write-Host "Downloading LibreSSL version:$version"
+Write-Host "paths_target_file_path:$paths_target_file_path"
+Write-Host "destDir:$destDir"
+Write-Host "override:$override"
+
+$zip_path = Join-Path $PSScriptRoot "LibreSSL.zip"
+
+$release_url = "https://github.com/PowerShell/LibreSSL/releases/download/$version/LibreSSL.zip"
+Write-Host "release_url:$release_url"
+
+[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor `
+                                              [Net.SecurityProtocolType]::Tls11 -bor `
+                                              [Net.SecurityProtocolType]::Tls
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+Invoke-WebRequest -Uri $release_url -OutFile $zip_path -UseBasicParsing
+if(-not (Test-Path $zip_path))
+{
+    throw "failed to download LibreSSL version:$version"
+}
+
+Expand-Archive -Path $zip_path -DestinationPath $destDir -Force -ErrorAction SilentlyContinue -ErrorVariable e
+if($e -ne $null)
+{
+    throw "Error when expand zip file. LibreSSL version:$version"
+}
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+
+Write-Host "Succesfully downloaded LibreSSL version:$version"
diff --git a/contrib/win32/openssh/GetZLib.ps1 b/contrib/win32/openssh/GetZLib.ps1
new file mode 100644
index 000000000..f36f95a91
--- /dev/null
+++ b/contrib/win32/openssh/GetZLib.ps1
@@ -0,0 +1,60 @@
+param (
+    [string] $paths_target_file_path,
+    [string] $destDir,
+    [switch] $override
+)
+
+# Workaround that $PSScriptRoot is not support on ps version 2
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+
+if([string]::IsNullOrEmpty($paths_target_file_path))
+{
+    $paths_target_file_path = Join-Path $PSScriptRoot "paths.targets"
+}
+
+if([string]::IsNullOrEmpty($destDir))
+{
+    $destDir = $PSScriptRoot
+}
+
+if($override)
+{
+    Remove-Item (join-path $destDir "ZLib") -Recurse -Force -ErrorAction SilentlyContinue
+}
+elseif (Test-Path (Join-Path $destDir "ZLib") -PathType Container)
+{
+    return
+}
+
+[xml] $buildConfig = Get-Content $paths_target_file_path
+$version = "V" + $buildConfig.Project.PropertyGroup.ZLibVersion
+
+Write-Host "Downloading ZLIB version:$version"
+Write-Host "paths_target_file_path:$paths_target_file_path"
+Write-Host "destDir:$destDir"
+Write-Host "override:$override"
+
+$zip_path = Join-Path $PSScriptRoot "ZLib.zip"
+$release_url = "https://github.com/PowerShell/zlib/releases/download/$version/zlib.zip"
+Write-Host "release_url:$release_url"
+
+[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12 -bor `
+                                              [Net.SecurityProtocolType]::Tls11 -bor `
+                                              [Net.SecurityProtocolType]::Tls
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+Invoke-WebRequest -Uri $release_url -OutFile $zip_path -UseBasicParsing
+if(-not (Test-Path $zip_path))
+{
+    throw "failed to download ZLIB version:$version"
+}
+
+Expand-Archive -Path $zip_path -DestinationPath $destDir -Force -ErrorAction SilentlyContinue -ErrorVariable e
+if($e -ne $null)
+{
+    throw "Error when expand zip file. ZLIB version:$version"
+}
+
+Remove-Item $zip_path -Force -ErrorAction SilentlyContinue
+
+Write-Host "Succesfully downloaded ZLIB version:$version"
\ No newline at end of file
diff --git a/contrib/win32/openssh/MSG00001.bin b/contrib/win32/openssh/MSG00001.bin
new file mode 100644
index 0000000000000000000000000000000000000000..76d0d3f57be6e136f130bde4b407c7383f4a1434
GIT binary patch
literal 188
zcmZQ(U|?WmU<hCVVhtc$07!%I1c>+spxlNfK(-7}l`}&TLncEB5GOMvGUPDuGH?N9
z7#Ku=a;`wRB8Ge*hKNc4#lnHAiWu^M>hl=Vq2dZaaZeyW4Xid7r~+hOK2QXr4`h}L
aLn=cOLn&Mj$ShR`Lk24b1t4t%w-*5UvlPkz

literal 0
HcmV?d00001

diff --git a/contrib/win32/openssh/MicrosoftTelemetry.h b/contrib/win32/openssh/MicrosoftTelemetry.h
new file mode 100644
index 000000000..b5e6944af
--- /dev/null
+++ b/contrib/win32/openssh/MicrosoftTelemetry.h
@@ -0,0 +1,87 @@
+/* ++
+
+Copyright (c) Microsoft Corporation. All rights reserved.
+Licensed under the MIT License. See LICENSE in the project root for license information.
+
+Module Name:
+
+    TraceLoggingConfig.h
+
+Abstract:
+
+    Macro definitions used by this project's TraceLogging ETW providers:
+
+    - Configuration macros that select the ETW Provider Groups to be used by
+      this project.
+    - Constants for tags that are commonly used in Microsoft's
+      TraceLogging-based ETW.
+
+    Different versions of this file use different definitions for the
+    TraceLoggingOption configuration macros. The definitions in this file are
+    empty. As a result, providers using this configuration file will not join
+    any ETW Provider Groups and will not be given any special treatment by
+    group-sensitive ETW listeners.
+
+Environment:
+
+    User mode or kernel mode.
+
+--*/
+
+#pragma once
+
+// Configuration macro for use in TRACELOGGING_DEFINE_PROVIDER. The definition
+// in this file configures the provider as a normal (non-telemetry) provider.
+#define TraceLoggingOptionMicrosoftTelemetry() \
+    // Empty definition for TraceLoggingOptionMicrosoftTelemetry
+
+// Configuration macro for use in TRACELOGGING_DEFINE_PROVIDER. The definition
+// in this file configures the provider as a normal (non-telemetry) provider.
+#define TraceLoggingOptionWindowsCoreTelemetry() \
+    // Empty definition for TraceLoggingOptionWindowsCoreTelemetry
+
+// Event privacy tags. Use the PDT macro values for the tag parameter, e.g.:
+// TraceLoggingWrite(...,
+//   TelemetryPrivacyDataTag(PDT_BrowsingHistory | PDT_ProductAndServiceUsage),
+//   ...);
+#define TelemetryPrivacyDataTag(tag) TraceLoggingUInt64((tag), "PartA_PrivTags")
+#define PDT_BrowsingHistory                    0x0000000000000002u
+#define PDT_DeviceConnectivityAndConfiguration 0x0000000000000800u
+#define PDT_InkingTypingAndSpeechUtterance     0x0000000000020000u
+#define PDT_ProductAndServicePerformance       0x0000000001000000u
+#define PDT_ProductAndServiceUsage             0x0000000002000000u
+#define PDT_SoftwareSetupAndInventory          0x0000000080000000u
+
+// Event categories specified via keywords, e.g.:
+// TraceLoggingWrite(...,
+//     TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+//     ...);
+#define MICROSOFT_KEYWORD_CRITICAL_DATA 0x0000800000000000 // Bit 47
+#define MICROSOFT_KEYWORD_MEASURES      0x0000400000000000 // Bit 46
+#define MICROSOFT_KEYWORD_TELEMETRY     0x0000200000000000 // Bit 45
+#define MICROSOFT_KEYWORD_RESERVED_44   0x0000100000000000 // Bit 44 (reserved for future assignment)
+
+// Event categories specified via event tags, e.g.:
+// TraceLoggingWrite(...,
+//     TraceLoggingEventTag(MICROSOFT_EVENTTAG_REALTIME_LATENCY),
+//     ...);
+#define MICROSOFT_EVENTTAG_DROP_USER_IDS            0x00008000
+#define MICROSOFT_EVENTTAG_AGGREGATE                0x00010000
+#define MICROSOFT_EVENTTAG_DROP_PII_EXCEPT_IP       0x00020000
+#define MICROSOFT_EVENTTAG_COSTDEFERRED_LATENCY     0x00040000
+#define MICROSOFT_EVENTTAG_CORE_DATA                0x00080000
+#define MICROSOFT_EVENTTAG_INJECT_XTOKEN            0x00100000
+#define MICROSOFT_EVENTTAG_REALTIME_LATENCY         0x00200000
+#define MICROSOFT_EVENTTAG_NORMAL_LATENCY           0x00400000
+#define MICROSOFT_EVENTTAG_CRITICAL_PERSISTENCE     0x00800000
+#define MICROSOFT_EVENTTAG_NORMAL_PERSISTENCE       0x01000000
+#define MICROSOFT_EVENTTAG_DROP_PII                 0x02000000
+#define MICROSOFT_EVENTTAG_HASH_PII                 0x04000000
+#define MICROSOFT_EVENTTAG_MARK_PII                 0x08000000
+
+// Field categories specified via field tags, e.g.:
+// TraceLoggingWrite(...,
+//     TraceLoggingString(szUser, "UserName", "User's name", MICROSOFT_FIELDTAG_HASH_PII),
+//     ...);
+#define MICROSOFT_FIELDTAG_DROP_PII 0x04000000
+#define MICROSOFT_FIELDTAG_HASH_PII 0x08000000
diff --git a/contrib/win32/openssh/NOTICE_for_release.txt b/contrib/win32/openssh/NOTICE_for_release.txt
new file mode 100644
index 000000000..1b487e864
--- /dev/null
+++ b/contrib/win32/openssh/NOTICE_for_release.txt
@@ -0,0 +1,728 @@
+NOTICES AND INFORMATION
+Do Not Translate or Localize
+
+This software incorporates material from third parties. Microsoft makes certain
+open source code available at https://3rdpartysource.microsoft.com, or you may
+send a check or money order for US $5.00, including the product name, the open
+source component name, and version number, to:
+
+Source Code Compliance Team
+Microsoft Corporation
+One Microsoft Way
+Redmond, WA 98052
+USA
+
+Notwithstanding any other terms, you may reverse engineer this software to the
+extent required to debug changes to any libraries licensed under the GNU Lesser
+General Public License.
+
+
+Component
+OpenSSH
+
+Open Source License/Copyright Notice.
+
+The licences which components of this software fall under are as
+follows.  First, we will summarize and say that all components
+are under a BSD licence, or a licence more free than that.
+
+OpenSSH contains no GPL code.
+
+1)
+     * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland
+     *                    All rights reserved
+     *
+     * As far as I am concerned, the code I have written for this software
+     * can be used freely for any purpose.  Any derived versions of this
+     * software must be clearly marked as such, and if the derived work is
+     * incompatible with the protocol description in the RFC file, it must be
+     * called by a name other than "ssh" or "Secure Shell".
+
+    [Tatu continues]
+     *  However, I am not implying to give any licenses to any patents or
+     * copyrights held by third parties, and the software includes parts that
+     * are not under my direct control.  As far as I know, all included
+     * source code is used in accordance with the relevant license agreements
+     * and can be used freely for any purpose (the GNU license being the most
+     * restrictive); see below for details.
+
+    [However, none of that term is relevant at this point in time.  All of
+    these restrictively licenced software components which he talks about
+    have been removed from OpenSSH, i.e.,
+
+     - RSA is no longer included, found in the OpenSSL library
+     - IDEA is no longer included, its use is deprecated
+     - DES is now external, in the OpenSSL library
+     - GMP is no longer used, and instead we call BN code from OpenSSL
+     - Zlib is now external, in a library
+     - The make-ssh-known-hosts script is no longer included
+     - TSS has been removed
+     - MD5 is now external, in the OpenSSL library
+     - RC4 support has been replaced with ARC4 support from OpenSSL
+     - Blowfish is now external, in the OpenSSL library
+
+    [The licence continues]
+
+    Note that any information and cryptographic algorithms used in this
+    software are publicly available on the Internet and at any major
+    bookstore, scientific library, and patent office worldwide.  More
+    information can be found e.g. at "http://www.cs.hut.fi/crypto".
+
+    The legal status of this program is some combination of all these
+    permissions and restrictions.  Use only at your own responsibility.
+    You will be responsible for any legal consequences yourself; I am not
+    making any claims whether possessing or using this is legal or not in
+    your country, and I am not taking any responsibility on your behalf.
+
+
+			    NO WARRANTY
+
+    BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+    FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+    PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+    OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+    TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+    PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+    REPAIR OR CORRECTION.
+
+    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+    INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+    OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+    TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+    YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+    PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGES.
+
+3)
+    ssh-keyscan was contributed by David Mazieres under a BSD-style
+    license.
+
+     * Copyright 1995, 1996 by David Mazieres <dm@lcs.mit.edu>.
+     *
+     * Modification and redistribution in source and binary forms is
+     * permitted provided that due credit is given to the author and the
+     * OpenBSD project by leaving this copyright notice intact.
+
+4)
+    The Rijndael implementation by Vincent Rijmen, Antoon Bosselaers
+    and Paulo Barreto is in the public domain and distributed
+    with the following license:
+
+     * @version 3.0 (December 2000)
+     *
+     * Optimised ANSI C code for the Rijndael cipher (now AES)
+     *
+     * @author Vincent Rijmen <vincent.rijmen@esat.kuleuven.ac.be>
+     * @author Antoon Bosselaers <antoon.bosselaers@esat.kuleuven.ac.be>
+     * @author Paulo Barreto <paulo.barreto@terra.com.br>
+     *
+     * This code is hereby placed in the public domain.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ''AS IS'' AND ANY EXPRESS
+     * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+     * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+     * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
+     * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+     * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+     * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+     * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+     * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+     * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+     * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+5)
+    One component of the ssh source code is under a 3-clause BSD license,
+    held by the University of California, since we pulled these parts from
+    original Berkeley code.
+
+     * Copyright (c) 1983, 1990, 1992, 1993, 1995
+     *      The Regents of the University of California.  All rights reserved.
+     *
+     * Redistribution and use in source and binary forms, with or without
+     * modification, are permitted provided that the following conditions
+     * are met:
+     * 1. Redistributions of source code must retain the above copyright
+     *    notice, this list of conditions and the following disclaimer.
+     * 2. Redistributions in binary form must reproduce the above copyright
+     *    notice, this list of conditions and the following disclaimer in the
+     *    documentation and/or other materials provided with the distribution.
+     * 3. Neither the name of the University nor the names of its contributors
+     *    may be used to endorse or promote products derived from this software
+     *    without specific prior written permission.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+     * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+     * SUCH DAMAGE.
+
+6)
+    Remaining components of the software are provided under a standard
+    2-term BSD licence with the following names as copyright holders:
+
+	Markus Friedl
+	Theo de Raadt
+	Niels Provos
+	Dug Song
+	Aaron Campbell
+	Damien Miller
+	Kevin Steves
+	Daniel Kouril
+	Wesley Griffin
+	Per Allansson
+	Nils Nordman
+	Simon Wilkinson
+
+    Portable OpenSSH additionally includes code from the following copyright
+    holders, also under the 2-term BSD license:
+
+	Ben Lindstrom
+	Tim Rice
+	Andre Lucas
+	Chris Adams
+	Corinna Vinschen
+	Cray Inc.
+	Denis Parker
+	Gert Doering
+	Jakob Schlyter
+	Jason Downs
+	Juha Yrjölä
+	Michael Stone
+	Networks Associates Technology, Inc.
+	Solar Designer
+	Todd C. Miller
+	Wayne Schroeder
+	William Jones
+	Darren Tucker
+	Sun Microsystems
+	The SCO Group
+	Daniel Walsh
+	Red Hat, Inc
+	Simon Vallet / Genoscope
+
+     * Redistribution and use in source and binary forms, with or without
+     * modification, are permitted provided that the following conditions
+     * are met:
+     * 1. Redistributions of source code must retain the above copyright
+     *    notice, this list of conditions and the following disclaimer.
+     * 2. Redistributions in binary form must reproduce the above copyright
+     *    notice, this list of conditions and the following disclaimer in the
+     *    documentation and/or other materials provided with the distribution.
+     *
+     * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+     * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+     * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+     * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+     * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+     * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+     * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+8) Portable OpenSSH contains the following additional licenses:
+
+    a) md5crypt.c, md5crypt.h
+
+	 * "THE BEER-WARE LICENSE" (Revision 42):
+	 * <phk@login.dknet.dk> wrote this file.  As long as you retain this
+	 * notice you can do whatever you want with this stuff. If we meet
+	 * some day, and you think this stuff is worth it, you can buy me a
+	 * beer in return.   Poul-Henning Kamp
+
+    b) snprintf replacement
+
+	* Copyright Patrick Powell 1995
+	* This code is based on code written by Patrick Powell
+	* (papowell@astart.com) It may be used for any purpose as long as this
+	* notice remains intact on all source code distributions
+
+    c) Compatibility code (openbsd-compat)
+
+       Apart from the previously mentioned licenses, various pieces of code
+       in the openbsd-compat/ subdirectory are licensed as follows:
+
+       Some code is licensed under a 3-term BSD license, to the following
+       copyright holders:
+
+	Todd C. Miller
+	Theo de Raadt
+	Damien Miller
+	Eric P. Allman
+	The Regents of the University of California
+	Constantin S. Svintsoff
+
+	* Redistribution and use in source and binary forms, with or without
+	* modification, are permitted provided that the following conditions
+	* are met:
+	* 1. Redistributions of source code must retain the above copyright
+	*    notice, this list of conditions and the following disclaimer.
+	* 2. Redistributions in binary form must reproduce the above copyright
+	*    notice, this list of conditions and the following disclaimer in the
+	*    documentation and/or other materials provided with the distribution.
+	* 3. Neither the name of the University nor the names of its contributors
+	*    may be used to endorse or promote products derived from this software
+	*    without specific prior written permission.
+	*
+	* THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+	* ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+	* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+	* ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+	* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+	* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+	* OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+	* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+	* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+	* OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+	* SUCH DAMAGE.
+
+       Some code is licensed under an ISC-style license, to the following
+       copyright holders:
+
+	Internet Software Consortium.
+	Todd C. Miller
+	Reyk Floeter
+	Chad Mynhier
+
+	* Permission to use, copy, modify, and distribute this software for any
+	* purpose with or without fee is hereby granted, provided that the above
+	* copyright notice and this permission notice appear in all copies.
+	*
+	* THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
+	* WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+	* OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
+	* FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+	* WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+	* OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+	* CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+       Some code is licensed under a MIT-style license to the following
+       copyright holders:
+
+	Free Software Foundation, Inc.
+
+	* Permission is hereby granted, free of charge, to any person obtaining a  *
+	* copy of this software and associated documentation files (the            *
+	* "Software"), to deal in the Software without restriction, including      *
+	* without limitation the rights to use, copy, modify, merge, publish,      *
+	* distribute, distribute with modifications, sublicense, and/or sell       *
+	* copies of the Software, and to permit persons to whom the Software is    *
+	* furnished to do so, subject to the following conditions:                 *
+	*                                                                          *
+	* The above copyright notice and this permission notice shall be included  *
+	* in all copies or substantial portions of the Software.                   *
+	*                                                                          *
+	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
+	* OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
+	* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
+	* IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
+	* DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
+	* OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
+	* THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
+	*                                                                          *
+	* Except as contained in this notice, the name(s) of the above copyright   *
+	* holders shall not be used in advertising or otherwise to promote the     *
+	* sale, use or other dealings in this Software without prior written       *
+	* authorization.                                                           *
+	****************************************************************************/
+
+       The Blowfish cipher implementation is licensed by Niels Provis under
+       a 4-clause BSD license:
+
+         * Blowfish - a fast block cipher designed by Bruce Schneier
+         *
+         * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
+         * All rights reserved.
+         *
+         * Redistribution and use in source and binary forms, with or without
+         * modification, are permitted provided that the following conditions
+         * are met:
+         * 1. Redistributions of source code must retain the above copyright
+         *    notice, this list of conditions and the following disclaimer.
+         * 2. Redistributions in binary form must reproduce the above copyright
+         *    notice, this list of conditions and the following disclaimer in the
+         *    documentation and/or other materials provided with the distribution.
+         * 3. All advertising materials mentioning features or use of this software
+         *    must display the following acknowledgement:
+         *      This product includes software developed by Niels Provos.
+         * 4. The name of the author may not be used to endorse or promote products
+         *    derived from this software without specific prior written permission.
+         *
+         * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+         * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+         * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+         * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+         * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+         * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+         * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+         * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+         * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+       Some replacement code is licensed by the NetBSD foundation under a
+       2-clause BSD license:
+
+         * Copyright (c) 2001 The NetBSD Foundation, Inc.
+         * All rights reserved.
+         *
+         * This code is derived from software contributed to The NetBSD Foundation
+         * by Todd Vierling.
+         *
+         * Redistribution and use in source and binary forms, with or without
+         * modification, are permitted provided that the following conditions
+         * are met:
+         * 1. Redistributions of source code must retain the above copyright
+         *    notice, this list of conditions and the following disclaimer.
+         * 2. Redistributions in binary form must reproduce the above copyright
+         *    notice, this list of conditions and the following disclaimer in the
+         *    documentation and/or other materials provided with the distribution.
+         *
+         * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+         * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+         * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+         * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+         * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+         * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+         * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+         * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+         * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+         * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+         * POSSIBILITY OF SUCH DAMAGE.
+
+------
+$OpenBSD: LICENCE,v 1.20 2017/04/30 23:26:16 djm Exp $
+
+Additional Attribution.
+
+Tatu Ylonen <ylo@cs.hut.fi> - Creator of SSH
+
+Aaron Campbell, Bob Beck, Markus Friedl, Niels Provos,
+Theo de Raadt, and Dug Song - Creators of OpenSSH
+
+Ahsan Rashid <arms@sco.com> - UnixWare long passwords
+Alain St-Denis <Alain.St-Denis@ec.gc.ca> - Irix fix
+Alexandre Oliva <oliva@lsd.ic.unicamp.br> - AIX fixes
+Andre Lucas <andre@ae-35.com> - new login code, many fixes
+Andreas Steinmetz <ast@domdv.de> - Shadow password expiry support
+Andrew McGill <andrewm@datrix.co.za> - SCO fixes
+Andrew Morgan <morgan@transmeta.com> - PAM bugfixes
+Andrew Stribblehill <a.d.stribblehill@durham.ac.uk> - Bugfixes
+Andy Sloane <andy@guildsoftware.com> - bugfixes
+Aran Cox <acox@cv.telegroup.com> - SCO bugfixes
+Arkadiusz Miskiewicz <misiek@pld.org.pl> - IPv6 compat fixes
+Ben Lindstrom <mouring@eviladmin.org> - NeXT support
+Ben Taylor <bent@clark.net> - Solaris debugging and fixes
+Bratislav ILICH <bilic@zepter.ru> - Configure fix
+Charles Levert <charles@comm.polymtl.ca> - SunOS 4 & bug fixes
+Chip Salzenberg <chip@valinux.com> - Assorted patches
+Chris Adams <cmadams@hiwaay.net> - OSF SIA support
+Chris Saia <csaia@wtower.com> - SuSE packaging
+Chris, the Young One <cky@pobox.com> - Password auth fixes
+Christos Zoulas <christos@zoulas.com> - Autoconf fixes
+Chun-Chung Chen <cjj@u.washington.edu> - RPM fixes
+Corinna Vinschen <vinschen@redhat.com> - Cygwin support
+Chad Mynhier <mynhier@interstel.net> - Solaris Process Contract support
+Dan Brosemer <odin@linuxfreak.com> - Autoconf support, build fixes
+Darren Hall <dhall@virage.org> - AIX patches
+Darren Tucker <dtucker@zip.com.au> - AIX BFF package scripts
+David Agraz <dagraz@jahoopa.com> - Build fixes
+David Del Piero <David.DelPiero@qed.qld.gov.au> - bug fixes
+David Hesprich <darkgrue@gue-tech.org> - Configure fixes
+David Rankin <drankin@bohemians.lexington.ky.us> - libwrap, AIX, NetBSD fixes
+Dag-Erling Smørgrav <des at freebsd.org> - Challenge-Response PAM code.
+Dhiraj Gulati <dgulati@sco.com> - UnixWare long passwords
+Ed Eden <ede370@stl.rural.usda.gov> - configure fixes
+Garrick James <garrick@james.net> - configure fixes
+Gary E. Miller <gem@rellim.com> - SCO support
+Ged Lodder <lodder@yacc.com.au> - HPUX fixes and enhancements
+Gert Doering <gd@hilb1.medat.de> - bug and portability fixes
+HARUYAMA Seigo <haruyama@unixuser.org> - Translations & doc fixes
+Hideaki YOSHIFUJI <yoshfuji@ecei.tohoku.ac.jp> - IPv6 and bug fixes
+Hiroshi Takekawa <takekawa@sr3.t.u-tokyo.ac.jp> - Configure fixes
+Holger Trapp <Holger.Trapp@Informatik.TU-Chemnitz.DE> - KRB4/AFS config patch
+IWAMURO Motonori <iwa@mmp.fujitsu.co.jp> - bugfixes
+Jani Hakala <jahakala@cc.jyu.fi> - Patches
+Jarno Huuskonen <jhuuskon@hytti.uku.fi> - Bugfixes
+Jim Knoble <jmknoble@pobox.com> - Many patches
+Jonchen (email unknown) - the original author of PAM support of SSH
+Juergen Keil <jk@tools.de> - scp bugfixing
+KAMAHARA Junzo <kamahara@cc.kshosen.ac.jp> - Configure fixes
+Kees Cook <cook@cpoint.net> - scp fixes
+Kenji Miyake <kenji@miyake.org> - Configure fixes
+Kevin Cawlfield <cawlfiel@us.ibm.com> - AIX fixes.
+Kevin O'Connor <kevin_oconnor@standardandpoors.com> - RSAless operation
+Kevin Steves <stevesk@pobox.com> - HP support, bugfixes, improvements
+Kiyokazu SUTO <suto@ks-and-ks.ne.jp> - Bugfixes
+Larry Jones <larry.jones@sdrc.com> - Bugfixes
+Lutz Jaenicke <Lutz.Jaenicke@aet.TU-Cottbus.DE> - Bugfixes
+Marc G. Fournier <marc.fournier@acadiau.ca> - Solaris patches
+Mark D. Baushke <mdb@juniper.net> - bug fixes
+Martin Johansson <fatbob@acc.umu.se> - Linux fixes
+Mark D. Roth <roth+openssh@feep.net> - Features, bug fixes
+Mark Miller <markm@swoon.net> - Bugfixes
+Matt Richards <v2matt@btv.ibm.com> - AIX patches
+Michael Steffens <michael_steffens at hp.com> - HP-UX fixes
+Michael Stone <mstone@cs.loyola.edu> - Irix enhancements
+Nakaji Hiroyuki <nakaji@tutrp.tut.ac.jp> - Sony News-OS patch
+Nalin Dahyabhai <nalin.dahyabhai@pobox.com> - PAM environment patch
+Nate Itkin <nitkin@europa.com> - SunOS 4.1.x fixes
+Niels Kristian Bech Jensen <nkbj@image.dk> - Assorted patches
+Pavel Kankovsky <peak@argo.troja.mff.cuni.cz> - Security fixes
+Pavel Troller <patrol@omni.sinus.cz> - Bugfixes
+Pekka Savola <pekkas@netcore.fi> - Bugfixes
+Peter Kocks <peter.kocks@baygate.com> - Makefile fixes
+Peter Stuge <stuge@cdy.org> - mdoc2man.awk script
+Phil Hands <phil@hands.com> - Debian scripts, assorted patches
+Phil Karn <karn@ka9q.ampr.org> - Autoconf fixes
+Philippe WILLEM <Philippe.WILLEM@urssaf.fr> - Bugfixes
+Phill Camp <P.S.S.Camp@ukc.ac.uk> - login code fix
+Rip Loomis <loomisg@cist.saic.com> - Solaris package support, fixes
+Robert Dahlem <Robert.Dahlem at siemens.com> - Reliant Unix fixes
+Roumen Petrov <openssh@roumenpetrov.info> - Compile & configure fixes
+SAKAI Kiyotaka <ksakai@kso.netwk.ntt-at.co.jp> - Multiple bugfixes
+Simon Wilkinson <sxw@dcs.ed.ac.uk> - PAM fixes, Compat with MIT KrbV
+Solar Designer <solar@openwall.com> - many patches and technical assistance
+Svante Signell <svante.signell@telia.com> - Bugfixes
+Thomas Neumann <tom@smart.ruhr.de> - Shadow passwords
+Tim Rice <tim@multitalents.net> - Portability & SCO fixes
+Tobias Oetiker <oetiker@ee.ethz.ch> - Bugfixes
+Tom Bertelson's <tbert@abac.com> - AIX auth fixes
+Tor-Ake Fransson <torake@hotmail.com> - AIX support
+Tudor Bosman <tudorb@jm.nu> - MD5 password support
+Udo Schweigert <ust@cert.siemens.de> - ReliantUNIX support
+Wendy Palm <wendyp at cray.com> - Cray support.
+Zack Weinberg <zack@wolery.cumb.org> - GNOME askpass enhancement
+
+
+Component
+LibreSSL
+
+Open Source License/Copyright Notice.
+
+  LibReSSL files are retained under the copyright of the authors. New
+  additions are ISC licensed as per OpenBSD's normal licensing policy,
+  or are placed in the public domain. 
+
+  The OpenSSL code is distributed under the terms of the original OpenSSL
+  licenses which follow:
+
+  LICENSE ISSUES
+  ==============
+
+  The OpenSSL toolkit stays under a dual license, i.e. both the conditions of
+  the OpenSSL License and the original SSLeay license apply to the toolkit.
+  See below for the actual license texts.  In case of any license issues
+  related to OpenSSL please contact openssl-core@openssl.org.
+
+  OpenSSL License
+  ---------------
+
+/* ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+ Original SSLeay License
+ -----------------------
+
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+
+Component
+ZLib
+
+Open Source License/Copyright Notice.
+
+  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+Component
+libfido2
+
+Open Source License/Copyright Notice.
+
+Copyright (c) 2018-2022 Yubico AB. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in
+      the documentation and/or other materials provided with the
+      distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+Component
+libcbor
+
+Open Source License/Copyright Notice.
+
+MIT License
+
+Copyright (c) 2014-2017 Pavel Kalvoda
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/contrib/win32/openssh/OpenSSH-build.ps1 b/contrib/win32/openssh/OpenSSH-build.ps1
new file mode 100644
index 000000000..2cfeff5cf
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSH-build.ps1
@@ -0,0 +1,49 @@
+[cmdletbinding()]
+# PowerShell Script to clone, build and package PowerShell from specified fork and branch
+param (    
+    [string] $repolocation = "$pwd\openssh-portable",
+    [string] $destination = "$env:WORKSPACE",
+    [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+    [String]$NativeHostArch = 'x64',        
+    [ValidateSet('Debug', 'Release')]
+    [string]$Configuration = "Release",        
+    [switch]$NoOpenSSL,
+    [switch]$OneCore
+)
+
+try
+{
+    Push-location $repolocation
+    Import-Module "$repolocation\contrib\win32\openssh\OpenSSHBuildHelper.psm1" -Force
+    $UnitTestFolder = "Unittests-$NativeHostArch"
+    $Bucket = "OpenSSH-$NativeHostArch"
+    if($NativeHostArch -ieq 'x86') {
+        $Bucket = "OpenSSH-Win32"
+        $UnitTestFolder = "Unittests-Win32"
+    }
+    elseif($NativeHostArch -ieq 'x64') {
+        $Bucket = "OpenSSH-Win64"
+        $UnitTestFolder = "Unittests-Win64"
+    }
+    Write-Verbose "Start-OpenSSHBuild -NativeHostArch $NativeHostArch -Configuration $Configuration -NoOpenSSL:$NoOpenSSL -Onecore:$OneCore -Verbose " -Verbose
+    Start-OpenSSHBuild -NativeHostArch $NativeHostArch -Configuration $Configuration -NoOpenSSL:$NoOpenSSL -Onecore:$OneCore -Verbose
+    Write-Verbose "Start-OpenSSHPackage -NativeHostArch $NativeHostArch -Configuration $Configuration -NoOpenSSL:$NoOpenSSL -Onecore:$OneCore -DestinationPath $repolocation\$($Bucket)_symbols" -verbose
+    Start-OpenSSHPackage -NativeHostArch $NativeHostArch -Configuration $Configuration -NoOpenSSL:$NoOpenSSL -Onecore:$OneCore -DestinationPath "$repolocation\$($Bucket)_symbols"
+    Copy-OpenSSHUnitTests -NativeHostArch $NativeHostArch -Configuration $Configuration -DestinationPath "$repolocation\UnitTests"
+    if(-not (Test-Path $destination))
+    {
+        New-Item -Path $destination -ItemType Directory -Force -ErrorAction Stop| Out-Null
+    }
+    #copy the build log
+    $buildLog = Get-BuildLogFile -NativeHostArch $NativeHostArch -Configuration $Configuration -root $repolocation
+    Write-Verbose "Copying $buildLog to $repolocation\$($Bucket)_symbols" -verbose
+    Copy-Item -Path $buildLog -Destination "$($Bucket)_symbols\" -Force -ErrorAction SilentlyContinue
+
+    $unitTestPaths = Get-ChildItem "$repolocation\UnitTests\*" -Directory
+    Compress-Archive -path $unitTestPaths.FullName -DestinationPath "$repolocation\$($Bucket)_symbols\$UnitTestFolder" -Force
+    Compress-Archive -path "$repolocation\$($Bucket)_symbols\*" -DestinationPath "$destination\$($Bucket)_symbols" -Force
+}
+finally
+{
+    Pop-Location
+}
\ No newline at end of file
diff --git a/contrib/win32/openssh/OpenSSHBuildHelper.psm1 b/contrib/win32/openssh/OpenSSHBuildHelper.psm1
new file mode 100644
index 000000000..f4895ef8e
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSHBuildHelper.psm1
@@ -0,0 +1,787 @@
+Set-StrictMode -Version 2.0
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\OpenSSHCommonUtils.psm1 -Force
+
+[string] $script:vcPath = $null
+[System.IO.DirectoryInfo] $script:OpenSSHRoot = $null
+[System.IO.DirectoryInfo] $script:gitRoot = $null
+[bool] $script:Verbose = $false
+[string] $script:BuildLogFile = $null
+<#
+    Called by Write-BuildMsg to write to the build log, if it exists. 
+#>
+function Write-Log
+{
+    param
+    (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]
+        [string] $Message
+    )
+    # write it to the log file, if present.
+    if (-not ([string]::IsNullOrEmpty($script:BuildLogFile)))
+    {
+        Add-Content -Path $script:BuildLogFile -Value $Message
+    }  
+}
+
+<#
+.Synopsis
+    Writes a build message.
+.Parameter Message
+    The message to write.
+.Parameter AsInfo
+    Writes a user message using Write-Information.
+.Parameter AsVerbose
+    Writes a message using Write-Verbose and to the build log if -Verbose was specified to Start-DscBuild.
+.Parameter AsWarning
+    Writes a message using Write-Warning and to the build log.
+.Parameter AsError
+    Writes a message using Write-Error and to the build log.
+.Parameter Silent
+    Writes the message only to the log.
+.Parameter ErrorAction
+    Determines if the script is terminated when errors are written.
+    This parameter is ignored when -Silent is specified.
+.Example
+    Write-BuildMsg -AsInfo 'Starting the build'
+    Writes an informational message to the log and to the user
+.Example
+    Write-BuildMsg -AsError 'Terminating build' -Silent
+    Writes an error message only to the log
+.Example
+    Write-BuildMsg -AsError 'Terminating build' -ErrorAction Stop
+    Writes an error message to the log and the user and terminates the build.
+.Example
+    Write-BuildMsg -AsInfo 'Nuget is already installed' -Silent:(-not $script:Verbose)
+    Writes an informational message to the log. If -Verbose was specified, also
+    writes to message to the user.
+#>
+function Write-BuildMsg
+{
+    [CmdletBinding()]
+    param
+    (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]
+        [string] $Message,
+
+        [Parameter(ParameterSetName='Info')]
+        [switch] $AsInfo,
+
+        [Parameter(ParameterSetName='Verbose')]
+        [switch] $AsVerbose,
+
+        [Parameter(ParameterSetName='Warning')]
+        [switch] $AsWarning,
+
+        [Parameter(ParameterSetName='Error')]
+        [switch] $AsError,
+
+        [switch] $Silent
+    )
+
+    if($PSBoundParameters.ContainsKey("AsVerbose"))
+    {
+        if ($script:Verbose)
+        {
+            Write-Log -Message "VERBOSE: $message"
+            if (-not $Silent)
+            {
+                Write-Verbose -Message $message -Verbose
+            }
+        }
+        return
+    }
+
+    if($PSBoundParameters.ContainsKey("AsInfo"))    
+    {
+        Write-Log -Message "INFO: $message"
+        if (-not $Silent)
+        {
+            if(Get-Command "Write-Information" -ErrorAction SilentlyContinue )
+            {
+                Write-Information -MessageData $message -InformationAction Continue
+            }
+            else
+            {
+                Write-Verbose -Message $message -Verbose
+            }
+        }
+        return
+    }
+
+    if($PSBoundParameters.ContainsKey("AsWarning"))
+    {
+        Write-Log -Message "WARNING: $message"
+        if (-not $Silent)
+        {
+            Write-Warning -Message $message
+        }
+        return
+    }
+
+    if($PSBoundParameters.ContainsKey("AsError"))
+    {
+        Write-Log -Message "ERROR: $message"
+        if (-not $Silent)
+        {
+            Write-Error -Message $message
+        }
+        return
+    }
+
+    # if we reached here, no output type switch was specified.
+    Write-BuildMsg -AsError -ErrorAction Stop -Message 'Write-BuildMsg was called without selecting an output type.'
+}
+
+<#
+.Synopsis
+    Verifies all tools and dependencies required for building Open SSH are installed on the machine.
+#>
+function Start-OpenSSHBootstrap
+{
+    param(
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+        [switch]$OneCore)
+
+    [bool] $silent = -not $script:Verbose
+    Write-BuildMsg -AsInfo -Message "Checking tools and dependencies" -Silent:$silent
+
+    # Add git\cmd to the path
+    $machinePath = [Environment]::GetEnvironmentVariable('Path', 'MACHINE')
+    $newMachineEnvironmentPath = $machinePath 
+    $gitCmdPath = "$env:ProgramFiles\git\cmd"
+    if (-not ($machinePath.ToLower().Contains($gitCmdPath.ToLower())))
+    {
+        Write-BuildMsg -AsVerbose -Message "Adding $gitCmdPath to Path environment variable" -Silent:$silent
+        $newMachineEnvironmentPath = "$gitCmdPath;$newMachineEnvironmentPath"
+        if(-not ($env:Path.ToLower().Contains($gitCmdPath.ToLower())))
+        {
+            $env:Path = "$gitCmdPath;$env:Path"
+        }
+    }
+    else
+    {
+        Write-BuildMsg -AsVerbose -Message "$gitCmdPath already present in Path environment variable" -Silent:$silent
+    }
+
+    # Update machine environment path
+    if ($newMachineEnvironmentPath -ne $machinePath)
+    {
+        [Environment]::SetEnvironmentVariable('Path', $newMachineEnvironmentPath, 'MACHINE')
+    }    
+
+    $sdkVersion = Get-Windows10SDKVersion
+    if ($null -eq $sdkVersion) 
+    {
+        Get-Chocolatey
+        $packageName = "windows-sdk-10.1"
+        Write-BuildMsg -AsInfo -Message "$packageName not present. Installing $packageName ..."
+        choco install $packageName -y --force --limitoutput --execution-timeout 120 2>&1 >> $script:BuildLogFile
+        # check that sdk was properly installed
+        $sdkVersion = Get-Windows10SDKVersion
+        if($null -eq $sdkVersion)
+        {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "$packageName installation failed with error code $LASTEXITCODE."
+        }
+    }
+
+    $VisualStudioPath = Get-VisualStudioPath -NativeHostArch $NativeHostArch
+    Write-Host $VisualStudioPath
+    if ($null -ne $VisualStudioPath) {
+        $MSBuildPath = Get-MSBuildPath -VSInstallPath $VisualStudioPath
+    }
+    else {
+        $MSBuildPath = Get-VS2015BuildToolPath
+    }
+    if ($MSBuildPath | Select-String "2022") 
+    {
+        $env:vctargetspath = Join-Path $VisualStudioPath "MSBuild\Microsoft\VC\v170\"
+        if ($null -eq $env:VS170COMNTOOLS)
+        {
+            $env:VS170COMNTOOLS = Get-BuildToolPath -VSInstallPath $VisualStudioPath -version "2022"
+        }
+        elseif (-not (Test-Path $env:VS170COMNTOOLS))
+        {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "$env:VS170COMNTOOLS build tools path is invalid"   
+        }
+        $VSBuildToolsPath = Get-Item(Join-Path $VisualStudioPath 'vc/auxiliary/build')
+    }
+    elseif ($MSBuildPath | Select-String "2019") 
+    {
+        $env:vctargetspath = Join-Path $VisualStudioPath "Common7\IDE\VC\VCTargets"
+        Write-BuildMsg -AsVerbose -Message "Setting vctargetspath env var to ${env:vctargetspath}"
+        if ($null -eq $env:VS160COMNTOOLS)
+        {
+            $env:VS160COMNTOOLS = Get-BuildToolPath -VSInstallPath $VisualStudioPath -version "2019"
+        }
+        elseif (-not (Test-Path $env:VS160COMNTOOLS))
+        {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "$env:VS160COMNTOOLS build tools path is invalid"   
+        }
+        $VSBuildToolsPath = Get-Item(Join-Path $VisualStudioPath 'vc/auxiliary/build')
+    }
+    elseif ($MSBuildPath | Select-String "2017") 
+    {
+        $env:vctargetspath = Join-Path $VisualStudioPath "Common7\IDE\VC\VCTargets"
+        if ($null -eq $env:VS150COMNTOOLS)
+        {
+            $env:VS150COMNTOOLS = Get-BuildToolPath -VSInstallPath $VisualStudioPath -version "2017"
+        }
+        elseif (-not (Test-Path $env:VS150COMNTOOLS))
+        {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "$env:VS150COMNTOOLS build tools path is invalid"   
+        }
+        $VSBuildToolsPath = Get-Item(Join-Path $VisualStudioPath 'vc/auxiliary/build')
+    }
+    else 
+    {
+        if($NativeHostArch.ToLower().Startswith('arm'))
+        {
+            #TODO: Install VS2019 or VS2017 build tools
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "The required msbuild 15.0, or greater, is not installed on the machine."
+        }
+
+        $VSBuildToolsPath = Get-Item(Join-Path -Path $env:VS140COMNTOOLS -ChildPath '../../vc')
+        Write-BuildMsg -AsVerbose -Message 'VC++ 2015 Build Tools already present.'
+        
+        if (!$MSBuildPath -or ($null -eq $env:VS140COMNTOOLS)) {
+            Get-Chocolatey
+            $packageName = "vcbuildtools"
+            Write-BuildMsg -AsInfo -Message "$packageName not present. Installing $packageName ..."
+            choco install $packageName -ia "/InstallSelectableItems VisualCppBuildTools_ATLMFC_SDK;VisualCppBuildTools_NETFX_SDK" -y --force --limitoutput --execution-timeout 120 2>&1 >> $script:BuildLogFile
+            $errorCode = $LASTEXITCODE
+            if ($errorCode -eq 3010)
+            {
+                Write-Host "The recent package changes indicate a reboot is necessary. please reboot the machine, open a new powershell window and call Start-SSHBuild or Start-OpenSSHBootstrap again." -ForegroundColor Black -BackgroundColor Yellow
+                Do {
+                    $input = Read-Host -Prompt "Reboot the machine? [Yes] Y; [No] N (default is `"Y`")"
+                    if([string]::IsNullOrEmpty($input))
+                    {
+                        $input = 'Y'
+                    }
+                } until ($input -match "^(y(es)?|N(o)?)$")
+                [string]$ret = $Matches[0]
+                if ($ret -like 'y*')
+                {
+                    Write-BuildMsg -AsWarning -Message "restarting machine ..."
+                    Restart-Computer -Force
+                    exit
+                }
+                else
+                {
+                    Write-BuildMsg -AsError -ErrorAction Stop -Message "User choose not to restart the machine to apply the changes."
+                }
+            }
+            elseif($errorCode -ne 0)
+            {
+                Write-BuildMsg -AsError -ErrorAction Stop -Message "$packageName installation failed with error code $errorCode."
+            }
+            $VSBuildToolsPath = Get-Item(Join-Path -Path $env:VS140COMNTOOLS -ChildPath '../../vc')
+        }
+    }
+
+    $script:vcPath = $VSBuildToolsPath.FullName
+    Write-BuildMsg -AsVerbose -Message "vcPath: $script:vcPath" -Silent:$silent
+    if ((Test-Path -Path "$script:vcPath\vcvarsall.bat") -eq $false)
+    {
+        Write-BuildMsg -AsError -ErrorAction Stop -Message "Could not find Visual Studio vcvarsall.bat at $script:vcPath, which means some required develop kits are missing on the machine." 
+    }
+}
+
+function Start-OpenSSHPackage
+{
+    [CmdletBinding(SupportsShouldProcess=$false)]    
+    param
+    (        
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release",
+
+        # Copy payload to DestinationPath instead of packaging
+        [string]$DestinationPath = "",
+        [switch]$NoOpenSSL,
+        [switch]$OneCore
+    )
+
+    [System.IO.DirectoryInfo] $repositoryRoot = Get-RepositoryRoot
+    $repositoryRoot = Get-Item -Path $repositoryRoot.FullName
+    $folderName = $NativeHostArch
+    if($NativeHostArch -ieq 'x86')
+    {
+        $folderName = "Win32"
+    }    
+
+    $buildDir = Join-Path $repositoryRoot ("bin\" + $folderName + "\" + $Configuration)
+    $payload =  "sshd.exe", "ssh.exe", "ssh-agent.exe", "ssh-add.exe", "sftp.exe"
+    $payload += "sftp-server.exe", "scp.exe", "ssh-shellhost.exe", "ssh-keygen.exe", "ssh-keyscan.exe", "ssh-sk-helper.exe", "ssh-pkcs11-helper.exe"
+    $payload += "sshd_config_default", "install-sshd.ps1", "uninstall-sshd.ps1"
+    $payload += "FixHostFilePermissions.ps1", "FixUserFilePermissions.ps1", "OpenSSHUtils.psm1", "OpenSSHUtils.psd1"
+    $payload += "openssh-events.man", "moduli", "LICENSE.txt", "NOTICE.txt"
+
+    $packageName = "OpenSSH-Win64"
+    if ($NativeHostArch -ieq 'x86') {
+        $packageName = "OpenSSH-Win32"
+    }
+    elseif ($NativeHostArch -ieq 'arm64') {
+        $packageName = "OpenSSH-ARM64"
+    }
+    elseif ($NativeHostArch -ieq 'arm') {
+        $packageName = "OpenSSH-ARM"
+    }
+
+    while((($service = Get-Service ssh-agent -ErrorAction SilentlyContinue) -ne $null) -and ($service.Status -ine 'Stopped'))
+    {        
+        Stop-Service ssh-agent -Force
+        #sleep to wait the servicelog file write        
+        Start-Sleep 5
+    }
+
+    $packageDir = Join-Path $buildDir $packageName
+    Remove-Item $packageDir -Recurse -Force -ErrorAction SilentlyContinue
+    New-Item $packageDir -Type Directory | Out-Null
+    
+    $symbolsDir = Join-Path $buildDir ($packageName + '_Symbols')
+    Remove-Item $symbolsDir -Recurse -Force -ErrorAction SilentlyContinue
+    New-Item $symbolsDir -Type Directory | Out-Null
+       
+    foreach ($file in $payload) {
+        if ((-not(Test-Path (Join-Path $buildDir $file)))) {
+            Throw "Cannot find $file under $buildDir. Did you run Build-OpenSSH?"
+        }
+        Copy-Item (Join-Path $buildDir $file) $packageDir -Force
+        if ($file.EndsWith(".exe")) {
+            $pdb = $file.Replace(".exe", ".pdb")
+            Copy-Item (Join-Path $buildDir $pdb) $symbolsDir -Force
+        }
+        if ($file.EndsWith(".dll")) {
+            $pdb = $file.Replace(".dll", ".pdb")
+            Copy-Item (Join-Path $buildDir $pdb) $symbolsDir -Force
+        }
+    }
+
+    #copy libcrypto dll
+    $libreSSLPath = Join-Path $PSScriptRoot "LibreSSL"
+    if (-not $NoOpenSSL.IsPresent)
+    {        
+        if($OneCore)
+        {
+            Copy-Item -Path $(Join-Path $libreSSLPath "bin\onecore\$NativeHostArch\libcrypto.dll") -Destination $packageDir -Force -ErrorAction Stop
+            Copy-Item -Path $(Join-Path $libreSSLPath "bin\onecore\$NativeHostArch\libcrypto.pdb") -Destination $symbolsDir -Force -ErrorAction Stop
+        }
+        else
+        {
+            Copy-Item -Path $(Join-Path $libreSSLPath "bin\desktop\$NativeHostArch\libcrypto.dll") -Destination $packageDir -Force -ErrorAction Stop
+            Copy-Item -Path $(Join-Path $libreSSLPath "bin\desktop\$NativeHostArch\libcrypto.pdb") -Destination $symbolsDir -Force -ErrorAction Stop
+        }
+    }    
+
+    if ($DestinationPath -ne "") {
+        if (Test-Path $DestinationPath) {            
+            Remove-Item $DestinationPath\* -Force -Recurse -ErrorAction SilentlyContinue
+        }
+        else {
+            New-Item -ItemType Directory $DestinationPath -Force | Out-Null
+        }
+        Copy-Item -Path $packageDir\* -Destination $DestinationPath -Force -Recurse
+        Write-BuildMsg -AsInfo -Message "Copied payload to $DestinationPath."
+    }
+    else {
+        Remove-Item ($packageDir + '.zip') -Force -ErrorAction SilentlyContinue
+        if(get-command Compress-Archive -ErrorAction SilentlyContinue)
+        {
+            Compress-Archive -Path $packageDir -DestinationPath ($packageDir + '.zip')
+            Write-BuildMsg -AsInfo -Message "Packaged Payload - '$packageDir.zip'"
+        }
+        else
+        {
+            Write-BuildMsg -AsInfo -Message "Packaged Payload not compressed."
+        }
+    }
+    Remove-Item $packageDir -Recurse -Force -ErrorAction SilentlyContinue
+    
+    if ($DestinationPath -ne "") {
+        Copy-Item -Path $symbolsDir\* -Destination $DestinationPath -Force -Recurse
+        Write-BuildMsg -AsInfo -Message "Copied symbols to $DestinationPath"
+    }
+    else {
+        Remove-Item ($symbolsDir + '.zip') -Force -ErrorAction SilentlyContinue
+        if(get-command Compress-Archive -ErrorAction SilentlyContinue)
+        {
+            Compress-Archive -Path $symbolsDir -DestinationPath ($symbolsDir + '.zip')
+            Write-BuildMsg -AsInfo -Message "Packaged Symbols - '$symbolsDir.zip'"
+        }
+        else
+        {
+            Write-BuildMsg -AsInfo -Message "Packaged Symbols not compressed."
+        }
+    }
+    Remove-Item $symbolsDir -Recurse -Force -ErrorAction SilentlyContinue
+}
+
+function Copy-OpenSSHUnitTests
+{
+    [CmdletBinding(SupportsShouldProcess=$false)]    
+    param
+    (        
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release",
+
+        # Copy unittests to DestinationPath
+        [string]$DestinationPath = ""
+    )
+
+    [System.IO.DirectoryInfo] $repositoryRoot = Get-RepositoryRoot
+    $repositoryRoot = Get-Item -Path $repositoryRoot.FullName
+    $folderName = $NativeHostArch
+    if($NativeHostArch -ieq 'x86')
+    {
+        $folderName = "Win32"
+    }
+    $buildDir = Join-Path $repositoryRoot ("bin\" + $folderName + "\" + $Configuration)
+    $unittestsDir = Join-Path $buildDir "unittests"
+    $unitTestFolders = Get-ChildItem -Directory $buildDir\unittest-*    
+    
+    if ($DestinationPath -ne "") {
+        if (-not (Test-Path $DestinationPath -PathType Container)) {
+            New-Item -ItemType Directory $DestinationPath -Force | Out-Null
+        }
+        foreach ($folder in $unitTestFolders) {
+            Copy-Item $folder.FullName $DestinationPath\$($folder.Name) -Recurse -Force
+            Write-BuildMsg -AsInfo -Message "Copied $($folder.FullName) to $DestinationPath\$($folder.Name)."
+        }        
+    }
+    else {        
+        if(Test-Path ($unittestsDir + '.zip') -PathType Leaf) {
+            Remove-Item ($unittestsDir + '.zip') -Force -ErrorAction SilentlyContinue
+        }
+        if(get-command Compress-Archive -ErrorAction SilentlyContinue)
+        {
+            Compress-Archive -Path $unitTestFolders.FullName -DestinationPath ($unittestsDir + '.zip')
+            Write-BuildMsg -AsInfo -Message "Packaged unittests - '$unittestsDir.zip'"
+        }
+        else
+        {
+            Write-BuildMsg -AsInfo -Message "Packaged unittests not compressed."
+        }
+    }
+}
+
+function Start-OpenSSHBuild
+{
+    [CmdletBinding(SupportsShouldProcess=$false)]    
+    param
+    (        
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release",
+
+        [switch]$NoOpenSSL,
+
+        [switch]$OneCore
+    )    
+    $script:BuildLogFile = $null
+
+    [System.IO.DirectoryInfo] $repositoryRoot = Get-RepositoryRoot
+
+    # Get openssh-portable root
+    $script:OpenSSHRoot = Get-Item -Path $repositoryRoot.FullName
+    $script:gitRoot = split-path $script:OpenSSHRoot
+
+    if($PSBoundParameters.ContainsKey("Verbose"))
+    {
+        $script:Verbose =  ($PSBoundParameters['Verbose']).IsPresent
+    }
+    [bool] $silent = -not $script:Verbose
+
+    $script:BuildLogFile = Get-BuildLogFile -root $repositoryRoot.FullName -Configuration $Configuration -NativeHostArch $NativeHostArch
+    if (Test-Path -Path $script:BuildLogFile)
+    {
+        Remove-Item -Path $script:BuildLogFile -force
+    }
+
+    Start-OpenSSHBootstrap -NativeHostArch $NativeHostArch -OneCore:$OneCore
+
+    $PathTargets = Join-Path -Path $PSScriptRoot -ChildPath 'paths.targets'
+    if ($NoOpenSSL) 
+    {        
+        [XML]$xml = Get-Content $PathTargets
+        $xml.Project.PropertyGroup.UseOpenSSL = 'false'
+        $xml.Project.PropertyGroup.SSLLib = [string]::Empty
+        $xml.Save($PathTargets)
+        $f = Join-Path $PSScriptRoot config.h.vs
+        (Get-Content $f).Replace('#define WITH_OPENSSL 1','') | Set-Content $f
+        (Get-Content $f).Replace('#define OPENSSL_HAS_ECC 1','') | Set-Content $f
+        (Get-Content $f).Replace('#define OPENSSL_HAS_NISTP521 1','') | Set-Content $f
+    }
+    
+    $win10SDKVer = Get-Windows10SDKVersion
+    [XML]$xml = Get-Content $PathTargets
+    $xml.Project.PropertyGroup.WindowsSDKVersion = $win10SDKVer.ToString()
+    
+    if($NativeHostArch.ToLower().Startswith('arm'))
+    {
+        $arch = $NativeHostArch.ToUpper()
+        $nodeName = "WindowsSDKDesktop$($arch)Support"
+        $node = $xml.Project.PropertyGroup.ChildNodes | where {$_.Name -eq $nodeName}
+        if($null -eq $node)
+        {
+            $newElement =$xml.CreateElement($nodeName, $xml.Project.xmlns)
+            $newNode = $xml.Project.PropertyGroup.AppendChild($newElement)
+            $null = $newNode.AppendChild($xml.CreateTextNode("true"))
+        } 
+        else
+        {
+            $node.InnerText = "true"
+        }
+    }
+    $xml.Save($PathTargets)
+
+    if($OneCore)
+    {
+        $win10SDKVer = Get-Windows10SDKVersion
+        [XML]$xml = Get-Content $PathTargets
+        $xml.Project.PropertyGroup.WindowsSDKVersion = $win10SDKVer
+        $xml.Project.PropertyGroup.AdditionalDependentLibs = 'onecore.lib;shlwapi.lib'
+        $xml.Project.PropertyGroup.MinimalCoreWin = 'true'
+        
+        #Use onecore libcrypto binaries
+        $xml.Project.PropertyGroup."LibreSSL-x86-Path" = '$(SolutionDir)\LibreSSL\bin\onecore\x86\'
+        $xml.Project.PropertyGroup."LibreSSL-x64-Path" = '$(SolutionDir)\LibreSSL\bin\onecore\x64\'
+        $xml.Project.PropertyGroup."LibreSSL-arm-Path" = '$(SolutionDir)\LibreSSL\bin\onecore\arm\'
+        $xml.Project.PropertyGroup."LibreSSL-arm64-Path" = '$(SolutionDir)\LibreSSL\bin\onecore\arm64\'
+        
+        $xml.Save($PathTargets)
+    }
+    
+    $solutionFile = Get-SolutionFile -root $repositoryRoot.FullName
+    $cmdMsg = @("${solutionFile}", "/t:Rebuild", "/p:Platform=${NativeHostArch}", "/p:Configuration=${Configuration}", "/m", "/nologo", "/fl", "/flp:LogFile=${script:BuildLogFile}`;Append`;Verbosity=diagnostic")    
+    if($silent)
+    {
+        $cmdMsg += "/noconlog"
+    }
+
+    $VisualStudioPath = Get-VisualStudioPath -NativeHostArch $NativeHostArch
+    if ($null -ne $VisualStudioPath) {
+        $msbuildCmd = Get-MSBuildPath -VSInstallPath $VisualStudioPath
+    }
+    else {
+        $msbuildCmd = Get-VS2015BuildToolPath
+    }
+    Write-BuildMsg -AsInfo -Message "Using MSBuild path: $msbuildCmd"
+
+    Write-BuildMsg -AsInfo -Message "Starting Open SSH build; Build Log: $($script:BuildLogFile)."
+    Write-BuildMsg -AsInfo -Message "$msbuildCmd $cmdMsg"
+
+    & "$msbuildCmd" $cmdMsg
+    $errorCode = $LASTEXITCODE
+
+    if ($errorCode -ne 0)
+    {
+        Write-BuildMsg -AsError -ErrorAction Stop -Message "Build failed for OpenSSH.`nExitCode: $errorCode."
+    }    
+
+    Write-BuildMsg -AsInfo -Message "SSH build successful."
+}
+
+function Get-VS2015BuildToolPath
+{
+    $searchPath = "${env:ProgramFiles(x86)}\MSBuild\14.0\Bin"
+    if($env:PROCESSOR_ARCHITECTURE -ieq "AMD64")
+    {
+        $searchPath += "\amd64"
+    }
+    $toolAvailable = @()
+    $toolAvailable = Get-ChildItem -path $searchPath\* -Filter "MSBuild.exe" -ErrorAction SilentlyContinue
+    if($null -eq $toolAvailable)
+    {
+        return $null
+    }
+    return $toolAvailable[0].FullName
+}
+
+function Get-VisualStudioPath {
+    param(
+        [Parameter(Mandatory = $true)]
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch
+    )
+    $vsWherePath = "${env:ProgramFiles(x86)}\Microsoft Visual Studio\Installer\vswhere.exe"
+    if (Test-Path $vsWherePath) {
+        $requiredVCtools = 'Microsoft.VisualStudio.Component.VC.Tools.x86.x64'
+        if ($NativeHostArch -eq 'arm') {
+            $requiredVCtools = 'Microsoft.VisualStudio.Component.VC.Tools.ARM'
+        }
+        elseif ($NativeHostArch -eq 'arm64') {
+            $requiredVCtools = 'Microsoft.VisualStudio.Component.VC.Tools.ARM64'
+        }
+        write-host "$vsWherePath -products * -requires $requiredVCtools -property installationPath"
+        $VSPaths = (& $vsWherePath -products * -requires $requiredVCtools -property installationPath)
+        # for some reason, VSWhere does not seem to find MSBuild so check manually
+        if ($null -ne $VSPaths) {
+            foreach ($VSPath in $VSPaths) {
+                if (Get-MSBuildPath -VSInstallPath $VSPath) {
+                    return $VSPath
+                }
+            }
+            # if none of the VS installs have MSBuild, then build cannot proceed
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "Visual Studio with required components not found, please ensure Microsoft.VisualStudio.Workload.MSBuildTools are installed"
+        }
+        else {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "Visual Studio with required components not found, please ensure $requiredVCtools are installed"
+        }
+    }
+    else {
+        Write-BuildMsg -AsWarning -Message "VSWhere not found - please install VS 2017 Update 2, or newer, defaulting to Visual Studio 2015"
+        return $null
+    }
+}
+function Get-MSBuildPath {
+    param(
+        [Parameter(Mandatory = $true)]
+        [string]$VSInstallPath
+    )
+    $searchPath = "MSBuild\**\Bin\"
+    if($env:PROCESSOR_ARCHITECTURE -ieq "AMD64")
+    {
+        $searchPath += "\amd64"
+    }
+    $fullSearchPath = Join-Path $VSInstallPath $searchPath
+    $toolAvailable = Get-ChildItem -path $fullSearchPath\* -Filter "MSBuild.exe" -ErrorAction SilentlyContinue
+    if($null -eq $toolAvailable)
+    {
+        return $null
+    }
+    return $toolAvailable[0].FullName
+}
+
+function Get-BuildToolPath
+{
+    param (
+        [string]$VSInstallPath,
+        [string]$version
+    )
+
+    $buildToolsPath = Get-Item(Join-Path $VSInstallPath 'Common7/Tools/') | % {$_.FullName}
+    if (-not (Test-Path $buildToolsPath))
+    {
+        Get-Chocolatey
+        # assumes package name follows this format, as 2019 and 2017 both do
+        $packageName = "visualstudio" + $version + "-workload-vctools"
+        Write-BuildMsg -AsInfo -Message "$packageName not present. Installing $packageName ..."
+        choco install $packageName --force --limitoutput --execution-timeout 120 2>&1 >> $script:BuildLogFile
+        $buildToolsPath = Get-Item(Join-Path -Path $VSInstallPath -ChildPath '../../../../../../BuildTools/Common7/Tools/') | % {$.FullName}
+        if (-not (Test-Path($buildToolsPath)))
+        {
+            Write-BuildMsg -AsError -ErrorAction Stop -Message "$packageName installation failed with error code $LASTEXITCODE."
+        } 
+    }   
+    return $buildToolsPath
+}
+
+function Get-Windows10SDKVersion
+{  
+    ## Search for latest windows sdk available on the machine
+    $windowsSDKPath = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\Lib"
+    $minSDKVersion = [version]"10.0.17763.0"
+    $versionsAvailable = @()
+    $versionsAvailable = Get-ChildItem $windowsSDKPath | ? {$_.Name.StartsWith("10.")} | % {$version = [version]$_.Name; if(($version.CompareTo($minSDKVersion) -ge 0)) {$version.ToString()}}
+    if($null -eq $versionsAvailable)
+    {
+         return $null
+    }
+    $versionsAvailable = $versionsAvailable | Sort-Object -Descending
+    foreach ($version in $versionsAvailable) {
+        $windowsSDKPath = Join-Path ${env:ProgramFiles(x86)} "Windows Kits\10\bin\$version\x86\register_app.vbs"
+        if (test-path $windowsSDKPath) {
+            return $version
+        }
+    }
+    return $null
+}
+
+function Get-BuildLogFile
+{
+    param
+    (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNull()]
+        [System.IO.DirectoryInfo] $root,
+
+        [ValidateSet('x86', 'x64', 'arm64', 'arm')]
+        [string]$NativeHostArch = "x64",
+                
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release"
+    )
+    if ($root.FullName -ieq $PSScriptRoot)
+    {
+        return Join-Path -Path $PSScriptRoot -ChildPath "OpenSSH$($Configuration)$($NativeHostArch).log"
+    } else {
+        return Join-Path -Path $root -ChildPath "contrib\win32\openssh\OpenSSH$($Configuration)$($NativeHostArch).log"
+    }
+}
+
+function Get-SolutionFile
+{
+    param
+    (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNull()]
+        [System.IO.DirectoryInfo] $root
+    )    
+    if ($root.FullName -ieq $PSScriptRoot)
+    {
+        return Join-Path -Path $PSScriptRoot -ChildPath "Win32-OpenSSH.sln"
+    } else {
+        return Join-Path -Path $root -ChildPath "contrib\win32\openssh\Win32-OpenSSH.sln"
+    }
+}
+
+function Get-Chocolatey {
+    # Install chocolatey
+    $chocolateyPath = "$env:AllUsersProfile\chocolatey\bin"
+    if(Get-Command choco -ErrorAction SilentlyContinue)
+    {
+        Write-BuildMsg -AsVerbose -Message "Chocolatey is already installed. Skipping installation." -Silent:$silent
+    }
+    else
+    {
+        Write-BuildMsg -AsInfo -Message "Chocolatey not present. Installing chocolatey." -Silent:$silent
+        Invoke-Expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) 2>&1 >> $script:BuildLogFile
+    }
+
+    $machinePath = [Environment]::GetEnvironmentVariable('Path', 'MACHINE')
+    $newMachineEnvironmentPath = $machinePath   
+
+    if (-not ($machinePath.ToLower().Contains($chocolateyPath.ToLower())))
+    {
+        Write-BuildMsg -AsVerbose -Message "Adding $chocolateyPath to Path environment variable" -Silent:$silent
+        $newMachineEnvironmentPath = "$chocolateyPath;$newMachineEnvironmentPath"
+        if(-not ($env:Path.ToLower().Contains($chocolateyPath.ToLower())))
+        {
+            $env:Path = "$chocolateyPath;$env:Path"
+        }
+    }
+    else
+    {
+        Write-BuildMsg -AsVerbose -Message "$chocolateyPath already present in Path environment variable" -Silent:$silent
+    }
+
+    # Update machine environment path
+    if ($newMachineEnvironmentPath -ne $machinePath)
+    {
+        [Environment]::SetEnvironmentVariable('Path', $newMachineEnvironmentPath, 'MACHINE')
+    }    
+}
+
+Export-ModuleMember -Function Start-OpenSSHBuild, Get-BuildLogFile, Start-OpenSSHPackage, Copy-OpenSSHUnitTests
diff --git a/contrib/win32/openssh/OpenSSHCommonUtils.psm1 b/contrib/win32/openssh/OpenSSHCommonUtils.psm1
new file mode 100644
index 000000000..3a5897196
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSHCommonUtils.psm1
@@ -0,0 +1,65 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\OpenSSHUtils -Force
+<#
+.Synopsis
+    Finds the root of the git repository
+
+.Outputs
+    A System.IO.DirectoryInfo for the location of the root if root is found; otherwise, script root.
+
+.Inputs
+    None
+#>
+function Get-RepositoryRoot
+{    
+    $start = $currentDir = (Get-Item -Path $PSScriptRoot)
+    while ($null -ne $currentDir.Parent)
+    {
+        $path = Join-Path -Path $currentDir.FullName -ChildPath '.git'
+        if (Test-Path -Path $path)
+        {
+            return $currentDir
+        }
+        $currentDir = $currentDir.Parent
+    }
+    return $start
+}
+
+<#
+.Synopsis
+    add a file permission to an account
+
+.Outputs
+    N/A
+
+.Inputs
+    FilePath - The path to the file    
+    User - account name
+    Perms - The permission to grant.
+#>
+function Add-PermissionToFileACL
+{
+        param (
+        [parameter(Mandatory=$true)]
+        [string]$FilePath,
+        [parameter(Mandatory=$true)]
+        [System.Security.Principal.NTAccount] $User,
+        [parameter(Mandatory=$true)]
+        [System.Security.AccessControl.FileSystemRights[]]$Perms
+    )    
+
+    $myACL = Get-ACL $FilePath
+        
+    if($Perms)
+    {
+        $Perms | % { 
+            $userACE = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                ($User, $_, "None", "None", "Allow")
+            $myACL.AddAccessRule($userACE)
+        }
+    }    
+    Enable-Privilege SeRestorePrivilege | out-null
+    Set-Acl -Path $FilePath -AclObject $myACL
+}
+
+Export-ModuleMember -Function Get-RepositoryRoot, Add-PermissionToFileACL
\ No newline at end of file
diff --git a/contrib/win32/openssh/OpenSSHTestHelper.psm1 b/contrib/win32/openssh/OpenSSHTestHelper.psm1
new file mode 100644
index 000000000..2d5b2118d
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSHTestHelper.psm1
@@ -0,0 +1,832 @@
+﻿$ErrorActionPreference = 'Stop'
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\OpenSSHCommonUtils.psm1 -Force
+Import-Module $PSScriptRoot\OpenSSHUtils -Force
+
+[System.IO.DirectoryInfo] $repositoryRoot = Get-RepositoryRoot
+# test environment parameters initialized with defaults
+$SetupTestResultsFileName = "setupTestResults.xml"
+$UninstallTestResultsFileName = "UninstallTestResults.xml"
+$E2ETestResultsFileName = "E2ETestResults.xml"
+$UnitTestResultsFileName = "UnitTestResults.txt"
+$TestSetupLogFileName = "TestSetupLog.txt"
+$SSOUser = "sshtest_ssouser"
+$PubKeyUser = "sshtest_pubkeyuser"
+$PasswdUser = "sshtest_passwduser"
+$AdminUser = "sshtest_adminuser"
+$NonAdminUser = "sshtest_nonadminuser"
+$OpenSSHTestAccountsPassword = "Bulldog_123456"
+$OpenSSHTestAccounts = $Script:SSOUser, $Script:PubKeyUser, $Script:PasswdUser, $Script:AdminUser, $Script:NonAdminUser
+$SSHDTestSvcName = "sshdTestSvc"
+
+$Script:TestDataPath = "$env:SystemDrive\OpenSSHTests"
+$Script:SetupTestResultsFile = Join-Path $TestDataPath $SetupTestResultsFileName
+$Script:UninstallTestResultsFile = Join-Path $TestDataPath $UninstallTestResultsFileName
+$Script:E2ETestResultsFile = Join-Path $TestDataPath $E2ETestResultsFileName
+$Script:UnitTestResultsFile = Join-Path $TestDataPath $UnitTestResultsFileName
+$Script:TestSetupLogFile = Join-Path $TestDataPath $TestSetupLogFileName
+$Script:E2ETestDirectory = Join-Path $repositoryRoot.FullName -ChildPath "regress\pesterTests"
+$Script:E2ETestDataDirectory = Join-Path $Script:E2ETestDirectory data
+$Script:WindowsInBox = $false
+$Script:NoLibreSSL = $false
+$Script:EnableAppVerifier = $true
+$Script:PostmortemDebugging = $false
+
+<#
+    .Synopsis
+    Set-OpenSSHTestEnvironment
+    TODO - split these steps into client and server side 
+#>
+function Set-OpenSSHTestEnvironment
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param
+    (   
+        [string] $OpenSSHBinPath,
+        [string] $TestDataPath = "$env:SystemDrive\OpenSSHTests",
+        [Switch] $DebugMode,
+        [Switch] $NoAppVerifier,
+        [Switch] $PostmortemDebugging,
+        [Switch] $NoLibreSSL
+    )
+
+    $params = $PSBoundParameters
+    $params.Remove("DebugMode") | Out-Null
+    $params.Remove("NoAppVerifier") | Out-Null
+    $params.Remove("PostmortemDebugging") | Out-Null
+    
+    if($PSBoundParameters.ContainsKey("Verbose"))
+    {
+        $verboseInfo =  ($PSBoundParameters['Verbose']).IsPresent
+    }
+
+    Set-BasicTestInfo @params
+
+    $Global:OpenSSHTestInfo.Add("Target", "localhost")                                 # test listener name
+    $Global:OpenSSHTestInfo.Add("Port", "47002")                                       # test listener port
+    $Global:OpenSSHTestInfo.Add("SSOUser", $SSOUser)                                   # test user with single sign on capability
+    $Global:OpenSSHTestInfo.Add("PubKeyUser", $PubKeyUser)                             # test user to be used with explicit key for key auth
+    $Global:OpenSSHTestInfo.Add("PasswdUser", $PasswdUser)                             # test user to be used for password auth
+    $Global:OpenSSHTestInfo.Add("AdminUser", $AdminUser)                               # test user to be used for admin logging tests
+    $Global:OpenSSHTestInfo.Add("NonAdminUser", $NonAdminUser)                         # test user to be used for non-admin logging tests
+    $Global:OpenSSHTestInfo.Add("TestAccountPW", $OpenSSHTestAccountsPassword)         # common password for all test accounts
+    $Global:OpenSSHTestInfo.Add("DebugMode", $DebugMode.IsPresent)                     # run openssh E2E in debug mode
+    $Global:OpenSSHTestInfo.Add("DelayTime", 3)                                        # delay between stoppig sshd service and trying to access log files
+
+    $Script:EnableAppVerifier = -not ($NoAppVerifier.IsPresent)
+    if($Script:WindowsInBox = $true)
+    {
+        $Script:EnableAppVerifier = $false
+    }
+    $Global:OpenSSHTestInfo.Add("EnableAppVerifier", $Script:EnableAppVerifier)
+
+    if($Script:EnableAppVerifier)
+    {
+        $Script:PostmortemDebugging = $PostmortemDebugging.IsPresent
+    }    
+    $Global:OpenSSHTestInfo.Add("PostmortemDebugging", $Script:PostmortemDebugging)
+
+    $description = @"
+WARNING: Following changes will be made to OpenSSH configuration
+   - $HOME\.ssh\known_hosts will be amended with test endpoint entries
+   - $HOME\.ssh\config will be amended with test endpoint entries
+   - sshd test listener will be on port 47002
+   - test accounts - ssouser, pubkeyuser, and passwduser will be added
+   - Setup single signon for ssouser
+   - To cleanup - Run Clear-OpenSSHTestEnvironment
+"@  
+    
+    $prompt = "Are you sure you want to perform the above operations?"
+    $caption = $description
+    if(-not $pscmdlet.ShouldProcess($description, $prompt, $caption))
+    {
+        Write-Host "User decided not to make the changes."
+        return
+    }
+
+    Install-OpenSSHTestDependencies
+
+    ##### START: install sshd test service
+    #delete service if exists
+    if (Get-Service $SSHDTestSvcName -ErrorAction SilentlyContinue) 
+    {
+       Stop-Service $SSHDTestSvcName
+       sc.exe delete $SSHDTestSvcName 1>$null
+    }
+
+    #prepare config directory
+    $testSvcConfigDir = Join-Path $Global:OpenSSHTestInfo["TestDataPath"] "serviceconfig"
+    Remove-Item $testSvcConfigDir -Force -Recurse -ErrorAction SilentlyContinue
+    New-Item -ItemType Directory -Path $testSvcConfigDir
+    $Global:OpenSSHTestInfo["ServiceConfigDir"] = $testSvcConfigDir
+    
+    #copy sshd_config
+    $testSshdConfig = Join-Path $testSvcConfigDir sshd_config
+    Copy-Item (Join-Path $Script:E2ETestDataDirectory sshd_config) $testSshdConfig -Force
+    $con = (Get-Content $testSshdConfig | Out-String).Replace("___TEST_SERVICE_CONFIG_DIR___", $testSvcConfigDir)
+    Set-Content -Path $testSshdConfig -Value "$con" -Force            
+    if($DebugMode) {
+        $con = (Get-Content $testSshdConfig | Out-String).Replace("#SyslogFacility AUTH","SyslogFacility LOCAL0")
+        Set-Content -Path $testSshdConfig -Value "$con" -Force    
+    }
+
+    #copy sshtest keys
+    Copy-Item "$($Script:E2ETestDataDirectory)\sshtest*hostkey*" $testSvcConfigDir -Force  
+       
+    #copy ca pubkey to ssh config path
+    Copy-Item "$($Script:E2ETestDataDirectory)\sshtest_ca_userkeys.pub"  $testSvcConfigDir -Force 
+
+    $acl = New-Object System.Security.AccessControl.DirectorySecurity
+    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("Administrators","FullControl","Allow")
+    $acl.AddAccessRule($rule)
+    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule("System","FullControl","Allow")
+    $acl.AddAccessRule($rule)
+    $acl.SetAccessRuleProtection($true, $true)
+
+    Get-ChildItem $testSvcConfigDir | foreach {$acl | set-acl $_.FullName}
+
+
+    $SSHDTestSvcNameCmdLine = (Join-Path $script:OpenSSHBinPath 'sshd.exe') + " -f " + $testSshdConfig
+    New-Service -Name $SSHDTestSvcName -DisplayName "OpenSSH SSH Test Server for E2E tests" -BinaryPathName $SSHDTestSvcNameCmdLine -StartupType Manual | Out-Null
+    sc.exe privs $SSHDTestSvcName SeAssignPrimaryTokenPrivilege/SeTcbPrivilege/SeBackupPrivilege/SeRestorePrivilege/SeImpersonatePrivilege
+
+    Start-Service $SSHDTestSvcName
+    ##### END: install sshd test service
+
+
+    #copy ca private key to test dir
+    $ca_priv_key = (Join-Path $Global:OpenSSHTestInfo["TestDataPath"] sshtest_ca_userkeys)
+    Copy-Item (Join-Path $Script:E2ETestDataDirectory sshtest_ca_userkeys) $ca_priv_key -Force 
+    Repair-UserSshConfigPermission -FilePath $ca_priv_key -confirm:$false
+    $Global:OpenSSHTestInfo["CA_Private_Key"] = $ca_priv_key
+
+    $sshAgentSvc = Get-service ssh-agent
+    if($sshAgentSvc.StartType -eq [System.ServiceProcess.ServiceStartMode]::Disabled)
+    {
+        Set-service ssh-agent -StartupType Manual
+    }
+    Start-Service ssh-agent
+
+    #Prepare user config - known_hosts and ssh_config
+    $dotSshDirectoryPath = Join-Path $home .ssh
+    if(-not (Test-Path $dotSshDirectoryPath -PathType Container))
+    {
+        New-Item -ItemType Directory -Path $dotSshDirectoryPath -Force -ErrorAction SilentlyContinue | out-null
+    }
+
+    $knowHostsFilePath = Join-Path $dotSshDirectoryPath known_hosts
+    if (-not (Test-Path $knowHostsFilePath -PathType Leaf)) {
+        Copy-Item (Join-Path $Script:E2ETestDataDirectory known_hosts) $knowHostsFilePath -Force
+    }
+    $con = Get-Content $knowHostsFilePath
+    if (($con -eq $null) -or (-not($con.Contains("###OpenSSHE2ETests")))) {
+        Get-Content (Join-Path $Script:E2ETestDataDirectory known_hosts) | Add-Content $knowHostsFilePath 
+    }
+
+    $sshConfigFilePath = Join-Path $dotSshDirectoryPath config
+    if (-not (Test-Path (Join-Path $dotSshDirectoryPath config) -PathType Leaf)) {
+        Copy-Item (Join-Path $Script:E2ETestDataDirectory ssh_config) $sshConfigFilePath -Force    
+    }
+    $con = Get-Content $sshConfigFilePath
+    if (($con -eq $null) -or (-not($con.Contains("###OpenSSHE2ETests")))) {
+        Get-Content (Join-Path $Script:E2ETestDataDirectory ssh_config) | Add-Content $sshConfigFilePath 
+    }
+
+    Copy-Item (Join-Path $Script:E2ETestDataDirectory ssh_config) $sshConfigFilePath -Force
+    Repair-UserSshConfigPermission -FilePath $sshConfigFilePath -confirm:$false
+
+    # create test accounts
+    #TODO - this is Windows specific. Need to be in PAL
+    foreach ($user in $OpenSSHTestAccounts)
+    {
+        try
+        {
+            $objUser = New-Object System.Security.Principal.NTAccount($user)
+            $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
+        }
+        catch
+        {
+            #only add the local user when it does not exists on the machine        
+            net user $user $Script:OpenSSHTestAccountsPassword /ADD 2>&1 >> $Script:TestSetupLogFile
+        }
+    }
+
+    #setup single sign on for ssouser
+    $ssouserProfile = Get-LocalUserProfile -User $SSOUser
+    $Global:OpenSSHTestInfo.Add("SSOUserProfile", $ssouserProfile)
+
+    $PubKeyUserProfile = Get-LocalUserProfile -User $PubKeyUser
+    $Global:OpenSSHTestInfo.Add("PubKeyUserProfile", $PubKeyUserProfile)
+
+    $AdminUserProfile = Get-LocalUserProfile -User $AdminUser
+    $Global:OpenSSHTestInfo.Add("AdminUserProfile", $AdminUserProfile)
+
+    $NonAdminUserProfile = Get-LocalUserProfile -User $NonAdminUser
+    $Global:OpenSSHTestInfo.Add("NonAdminUserProfile", $NonAdminUserProfile)
+
+    #make $AdminUser admin
+    net localgroup Administrators $AdminUser /add
+
+    New-Item -ItemType Directory -Path (Join-Path $ssouserProfile .ssh) -Force -ErrorAction SilentlyContinue  | out-null
+    $authorizedKeyPath = Join-Path $ssouserProfile .ssh\authorized_keys
+    $testPubKeyPath = Join-Path $Script:E2ETestDataDirectory sshtest_userssokey_ed25519.pub
+    Copy-Item $testPubKeyPath $authorizedKeyPath -Force -ErrorAction SilentlyContinue
+    Repair-AuthorizedKeyPermission -FilePath $authorizedKeyPath -confirm:$false 
+    
+    copy-item (Join-Path $Script:E2ETestDataDirectory sshtest_userssokey_ed25519) $Global:OpenSSHTestInfo["TestDataPath"]
+    $testPriKeypath = Join-Path $Global:OpenSSHTestInfo["TestDataPath"] sshtest_userssokey_ed25519    
+    cmd /c "ssh-add -D 2>&1 >> $Script:TestSetupLogFile"
+    Repair-UserKeyPermission -FilePath $testPriKeypath -confirm:$false
+    cmd /c "ssh-add $testPriKeypath 2>&1 >> $Script:TestSetupLogFile"
+
+    #Enable AppVerifier
+    if($Script:EnableAppVerifier)
+    {        
+        # clear all applications in application verifier first
+        &  $env:windir\System32\appverif.exe -disable * -for *  | out-null
+        Get-ChildItem "$($script:OpenSSHBinPath)\*.exe" | % {
+            & $env:windir\System32\appverif.exe -verify $_.Name  | out-null
+        }
+
+        if($Script:PostmortemDebugging -and (Test-path $Script:WindbgPath))
+        {            
+            # enable Postmortem debugger            
+            New-ItemProperty "HKLM:Software\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Debugger -Type String -Value "`"$Script:WindbgPath`" -p %ld -e %ld -g" -Force -ErrorAction SilentlyContinue | Out-Null
+            New-ItemProperty "HKLM:Software\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Auto -Type String -Value "1" -Force -ErrorAction SilentlyContinue | Out-Null
+        }
+    }
+}
+
+function Set-BasicTestInfo
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param
+    (   
+        [string] $OpenSSHBinPath,
+        [string] $TestDataPath = "$env:SystemDrive\OpenSSHTests", 
+        [Switch] $NoLibreSSL
+    )
+
+    if($Global:OpenSSHTestInfo -ne $null)
+    {
+        $Global:OpenSSHTestInfo.Clear()
+        $Global:OpenSSHTestInfo = $null
+    }
+    $Script:TestDataPath = $TestDataPath;
+    $Script:E2ETestResultsFile = Join-Path $TestDataPath $E2ETestResultsFileName
+    $Script:SetupTestResultsFile = Join-Path $TestDataPath $SetupTestResultsFileName
+    $Script:UninstallTestResultsFile = Join-Path $TestDataPath $UninstallTestResultsFileName
+    $Script:UnitTestResultsFile = Join-Path $TestDataPath $UnitTestResultsFileName        
+    $Script:TestSetupLogFile = Join-Path $TestDataPath $TestSetupLogFileName
+    $Script:UnitTestDirectory = Get-UnitTestDirectory
+    $Script:NoLibreSSL = $NoLibreSSL.IsPresent
+
+    $Global:OpenSSHTestInfo = @{
+        "TestDataPath" = $TestDataPath;                                     # openssh tests path
+        "TestSetupLogFile" = $Script:TestSetupLogFile;                      # openssh test setup log file
+        "E2ETestResultsFile" = $Script:E2ETestResultsFile;                  # openssh E2E test results file
+        "SetupTestResultsFile" = $Script:SetupTestResultsFile;              # openssh setup test test results file
+        "UninstallTestResultsFile" = $Script:UninstallTestResultsFile;      # openssh Uninstall test test results file
+        "UnitTestResultsFile" = $Script:UnitTestResultsFile;                # openssh unittest test results file
+        "E2ETestDirectory" = $Script:E2ETestDirectory                       # the directory of E2E tests
+        "UnitTestDirectory" = $Script:UnitTestDirectory                     # the directory of unit tests
+        "NoLibreSSL" = $Script:NoLibreSSL
+        "WindowsInBox" = $Script:WindowsInBox
+        }
+    #if user does not set path, pick it up
+    if([string]::IsNullOrEmpty($OpenSSHBinPath))
+    {
+        $sshcmd = get-command ssh.exe -ErrorAction SilentlyContinue       
+        if($sshcmd -eq $null)
+        {
+            Throw "Cannot find ssh.exe. Please specify -OpenSSHBinPath to the OpenSSH installed location."
+        }
+        else
+        {
+            $dirToCheck = split-path $sshcmd.Path
+            $description = "Pick up ssh.exe from $dirToCheck."
+            $prompt = "Are you sure you want to pick up ssh.exe from $($dirToCheck)?"           
+            $caption = "Found ssh.exe from $dirToCheck"
+            if(-not $pscmdlet.ShouldProcess($description, $prompt, $caption))
+            {
+                Write-Host "User decided not to pick up ssh.exe from $dirToCheck. Please specify -OpenSSHBinPath to the OpenSSH installed location."
+                return
+            }
+            $script:OpenSSHBinPath = $dirToCheck
+        }        
+    }
+    else
+    {
+        $script:OpenSSHBinPath = (Resolve-Path -Path $OpenSSHBinPath -ErrorAction Stop).Path
+
+        if (-not (Test-Path (Join-Path $script:OpenSSHBinPath ssh.exe) -PathType Leaf))
+        {
+            Throw "Cannot find OpenSSH binaries under $OpenSSHBinPath. Please specify -OpenSSHBinPath to the OpenSSH installed location"
+        }
+    }
+
+    $Global:OpenSSHTestInfo.Add("OpenSSHBinPath", $script:OpenSSHBinPath)
+    if (-not ($env:Path.ToLower().Contains($script:OpenSSHBinPath.ToLower())))
+    {
+        $env:Path = "$($script:OpenSSHBinPath);$($env:path)"
+    }
+
+    $acl = get-acl (join-path $script:OpenSSHBinPath "ssh.exe")
+    
+    if($acl.Owner -ieq "NT SERVICE\TrustedInstaller")
+    {
+        $Script:WindowsInBox = $true
+        $Global:OpenSSHTestInfo["WindowsInBox"]= $true
+    }
+
+    Install-OpenSSHTestDependencies -TestHarness
+    if(-not (Test-path $TestDataPath -PathType Container))
+    {
+       New-Item -ItemType Directory -Path $TestDataPath -Force -ErrorAction SilentlyContinue | out-null
+    }
+}
+
+#TODO - this is Windows specific. Need to be in PAL
+function Get-LocalUserProfile
+{
+    param([string]$User)
+    $sid = Get-UserSID -User $User
+    $userProfileRegistry = Join-Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList" $sid
+    if (-not (Test-Path $userProfileRegistry) ) {        
+        #create profile
+        if (-not($env:DISPLAY)) { $env:DISPLAY = 1 }
+        $askpass_util = Join-Path $Script:E2ETestDirectory "utilities\askpass_util\askpass_util.exe"
+        $env:SSH_ASKPASS=$askpass_util
+        $env:ASKPASS_PASSWORD=$OpenSSHTestAccountsPassword
+        $env:SSH_ASKPASS_REQUIRE="prefer"
+        $ret = ssh -p 47002 "$User@localhost" echo %userprofile%
+        if ($env:DISPLAY -eq 1) { Remove-Item env:\DISPLAY }
+        Remove-item "env:SSH_ASKPASS" -ErrorAction SilentlyContinue
+        Remove-item "env:ASKPASS_PASSWORD" -ErrorAction SilentlyContinue
+        Remove-item "env:SSH_ASKPASS_REQUIRE" -ErrorAction SilentlyContinue
+    }   
+    
+    (Get-ItemProperty -Path $userProfileRegistry -Name 'ProfileImagePath').ProfileImagePath    
+}
+
+
+<#
+      .SYNOPSIS
+      This function installs the tools required by our tests
+      1) Pester for running the tests
+      2) Windbg for postmortem debugging
+#>
+function Install-OpenSSHTestDependencies
+{
+    [CmdletBinding()]
+    param ([Switch] $TestHarness)
+    
+    #$isOpenSSHUtilsAvailable = Get-Module 'OpenSSHUtils' -ListAvailable
+    #if (-not ($isOpenSSHUtilsAvailable))
+    #{      
+        Write-Log -Message "Installing Module OpenSSHUtils..."
+        Install-OpenSSHUtilsModule -SourceDir $PSScriptRoot
+    #}
+    Import-Module OpensshUtils -Force
+
+    if($Script:WindowsInBox)
+    {
+        return
+    }
+
+    # Install chocolatey
+    if(-not (Get-Command "choco" -ErrorAction SilentlyContinue))
+    {
+        Write-Log -Message "Chocolatey not present. Installing chocolatey."
+        Invoke-Expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1')) 2>&1 >> $Script:TestSetupLogFile
+    }
+
+    # Pester 5.x is not compatible with tests.
+    $InstalledPesters = Get-Module -Name 'Pester' -ListAvailable | Where-Object { $_.Version -lt '5.0' }
+    if ($InstalledPesters.Count -eq 0)
+    {      
+        Write-Log -Message "Installing Pester..." 
+        # Install-Module -Name 'Pester' -RequiredVersion 3.4.6
+        choco install Pester --version 3.4.6 -y --force --limitoutput 2>&1 >> $Script:TestSetupLogFile
+    }
+
+    if($TestHarness)
+    {
+        return
+    }
+
+    if($Script:PostmortemDebugging -or (($OpenSSHTestInfo -ne $null) -and ($OpenSSHTestInfo["PostmortemDebugging"])))
+    {
+        $folderName = "x86"
+        $pathroot = $env:ProgramFiles
+        if($env:PROCESSOR_ARCHITECTURE -ieq "AMD64")
+        {
+            $folderName = "x64"
+            $pathroot = ${env:ProgramFiles(x86)}
+        }
+        $Script:WindbgPath = "$pathroot\Windows Kits\8.1\Debuggers\$folderName\windbg.exe"
+        if(-not (Test-Path $Script:WindbgPath))
+        {
+            $Script:WindbgPath = "$pathroot\Windows Kits\10\Debuggers\$folderName\windbg.exe"
+            if(-not (Test-Path $Script:WindbgPath))
+            {
+                choco install windbg -y --force --limitoutput 2>&1 >> $Script:TestSetupLogFile
+            }            
+        }        
+    }
+
+    if(($Script:EnableAppVerifier -or (($OpenSSHTestInfo -ne $null) -and ($OpenSSHTestInfo["EnableAppVerifier"]))) -and (-not (Test-path $env:windir\System32\appverif.exe)))
+    {
+        choco install appverifier -y --force --limitoutput 2>&1 >> $Script:TestSetupLogFile
+    }
+}
+
+function Install-OpenSSHUtilsModule
+{
+    [CmdletBinding()]
+    param(   
+        [string]$TargetDir = (Join-Path -Path $env:ProgramFiles -ChildPath "WindowsPowerShell\Modules\OpenSSHUtils"),
+        [string]$SourceDir)
+    
+    $manifestFile = Join-Path -Path $SourceDir -ChildPath OpenSSHUtils.psd1   
+    $moduleFile    = Join-Path -Path $SourceDir -ChildPath OpenSSHUtils.psm1
+    $targetDirectory = $TargetDir
+    $manifest = Test-ModuleManifest -Path $manifestFile -WarningAction SilentlyContinue -ErrorAction Stop
+    if ($PSVersionTable.PSVersion.Major -ge 5)
+    {   
+        $targetDirectory = Join-Path -Path $targetDir -ChildPath $manifest.Version.ToString()
+    }
+    
+    $modulePath = Join-Path -Path $env:ProgramFiles -ChildPath WindowsPowerShell\Modules
+    if(-not (Test-Path "$targetDirectory" -PathType Container))
+    {
+        New-Item -ItemType Directory -Path "$targetDirectory" -Force -ErrorAction SilentlyContinue | out-null
+    }
+    Copy-item "$manifestFile" -Destination "$targetDirectory" -Force -ErrorAction SilentlyContinue | out-null
+    Copy-item "$moduleFile" -Destination "$targetDirectory" -Force -ErrorAction SilentlyContinue | out-null
+    
+    if ($PSVersionTable.PSVersion.Major -lt 4)
+    {
+        $modulePaths = [Environment]::GetEnvironmentVariable('PSModulePath', 'Machine') -split ';'
+        if ($modulePaths -notcontains $modulePath)
+        {
+            Write-Verbose -Message "Adding '$modulePath' to PSModulePath."
+
+            $modulePaths = @(
+                $modulePath
+                $modulePaths
+            )
+
+            $newModulePath = $modulePaths -join ';'
+
+            [Environment]::SetEnvironmentVariable('PSModulePath', $newModulePath, 'Machine')
+            $env:PSModulePath += ";$modulePath"
+        }
+    }
+}
+
+function Uninstall-OpenSSHUtilsModule
+{
+    [CmdletBinding()]
+    param([string]$TargetDir = (Join-Path -Path $env:ProgramFiles -ChildPath "WindowsPowerShell\Modules\OpenSSHUtils"))    
+    
+    if(Test-Path $TargetDir -PathType Container)
+    {
+        Remove-item $TargetDir -Recurse -Force -ErrorAction SilentlyContinue | out-null
+    }    
+}
+
+<#
+    .Synopsis
+    Get-UserSID
+#>
+function Get-UserSID
+{
+    param
+        (             
+            [string]$Domain,            
+            [string]$User
+        )
+    if([string]::IsNullOrEmpty($Domain))
+    {
+        $objUser = New-Object System.Security.Principal.NTAccount($User)        
+    }
+    else
+    {
+        $objUser = New-Object System.Security.Principal.NTAccount($Domain, $User)
+    }
+    $strSID = $objUser.Translate([System.Security.Principal.SecurityIdentifier])
+    $strSID.Value
+}
+
+<#
+    .Synopsis
+    Clear-OpenSSHTestEnvironment
+#>
+function Clear-OpenSSHTestEnvironment
+{
+    Write-Verbose -Verbose -Message "Running Clear-OpenSSHTestEnvironment..."
+
+    if ($Global:OpenSSHTestInfo -eq $null) {
+        throw "OpenSSHTestInfo is not set. Did you run Set-OpenSShTestEnvironment?"
+    }
+
+    $sshBinPath = $Global:OpenSSHTestInfo["OpenSSHBinPath"]
+
+    # .exe - Windows specific. TODO - PAL 
+    if (-not (Test-Path (Join-Path $sshBinPath ssh.exe) -PathType Leaf))
+    {
+        Throw "Cannot find OpenSSH binaries under $script:OpenSSHBinPath. "
+    }
+    
+    if($Global:OpenSSHTestInfo["EnableAppVerifier"] -and (Test-path $env:windir\System32\appverif.exe))
+    {
+        # clear all applications in application verifier
+        &  $env:windir\System32\appverif.exe -disable * -for * | out-null
+    }
+
+    if($Global:OpenSSHTestInfo["PostmortemDebugging"])
+    {
+        Remove-ItemProperty "HKLM:Software\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Debugger -ErrorAction SilentlyContinue -Force | Out-Null
+        Remove-ItemProperty "HKLM:Software\Microsoft\Windows NT\CurrentVersion\AeDebug" -Name Auto -ErrorAction SilentlyContinue -Force | Out-Null
+    }
+
+    #delete service if exists
+    if (Get-Service $SSHDTestSvcName -ErrorAction SilentlyContinue) 
+    {
+       Stop-Service $SSHDTestSvcName
+       sc.exe delete $SSHDTestSvcName 1>$null
+    }
+    
+    #Delete accounts
+    foreach ($user in $OpenSSHTestAccounts)
+    {
+        net user $user /delete
+    }
+    
+    # remove registered keys    
+    cmd /c "ssh-add -d (Join-Path $Script:E2ETestDataDirectory sshtest_userssokey_ed25519) 2>&1 >> $Script:TestSetupLogFile"
+
+    if($Global:OpenSSHTestInfo -ne $null)
+    {
+        $Global:OpenSSHTestInfo.Clear()
+        $Global:OpenSSHTestInfo = $null
+    }
+    
+    $isOpenSSHUtilsAvailable = Get-Module 'OpenSSHUtils' -ListAvailable
+    if ($isOpenSSHUtilsAvailable)
+    {      
+        Write-Log -Message "Uninstalling Module OpenSSHUtils..."
+        Uninstall-OpenSSHUtilsModule
+    }
+}
+
+<#
+    .Synopsis
+    Get-UnitTestDirectory.
+#>
+function Get-UnitTestDirectory
+{
+    [CmdletBinding()]
+    param
+    (
+        [ValidateSet('Debug', 'Release')]
+        [string]$Configuration = "Release",
+
+        [ValidateSet('x86', 'x64', '')]
+        [string]$NativeHostArch = ""
+    )
+
+    [string] $platform = $env:PROCESSOR_ARCHITECTURE
+    if(-not [String]::IsNullOrEmpty($NativeHostArch))
+    {
+        $folderName = $NativeHostArch
+        if($NativeHostArch -eq 'x86')
+        {
+            $folderName = "Win32"
+        }
+    }
+    else
+    {
+        if($platform -ieq "AMD64")
+        {
+            $folderName = "x64"
+        }
+        else
+        {
+            $folderName = "Win32"
+        }
+    }
+
+    if([String]::IsNullOrEmpty($Configuration))
+    {
+        if( $folderName -ieq "Win32" )
+        {
+            $RealConfiguration = "Debug"
+        }
+        else
+        {
+            $RealConfiguration = "Release"
+        }
+    }
+    else
+    {
+        $RealConfiguration = $Configuration
+    }    
+    $unitTestdir = Join-Path $repositoryRoot.FullName -ChildPath "bin\$folderName\$RealConfiguration"
+    $unitTestDir
+}
+
+<#
+    .Synopsis
+    Run OpenSSH Setup tests.
+#>
+function Invoke-OpenSSHSetupTest
+{
+    # Tests are not compatible with latest Pester 5.x.
+    Import-Module -Name 'Pester' -MaximumVersion 4.9.9 -Force -Global
+
+    # Discover all CI tests and run them.
+    Push-Location $Script:E2ETestDirectory
+    Write-Log -Message "Running OpenSSH Setup tests..."
+    $testFolders = @(Get-ChildItem *.tests.ps1 -Recurse | ForEach-Object{ Split-Path $_.FullName} | Sort-Object -Unique)
+    Invoke-Pester $testFolders -OutputFormat NUnitXml -OutputFile $Script:SetupTestResultsFile -Tag 'Setup' -PassThru
+    Pop-Location
+}
+
+<#
+    .Synopsis
+    Run OpenSSH uninstall tests.
+#>
+function Invoke-OpenSSHUninstallTest
+{
+    # Tests are not compatible with latest Pester 5.x.
+    Import-Module -Name 'Pester' -MaximumVersion 4.9.9 -Force -Global
+
+    # Discover all CI tests and run them.
+    Push-Location $Script:E2ETestDirectory
+    Write-Log -Message "Running OpenSSH Uninstall tests..."
+    $testFolders = @(Get-ChildItem *.tests.ps1 -Recurse | ForEach-Object{ Split-Path $_.FullName} | Sort-Object -Unique)
+    Invoke-Pester $testFolders -OutputFormat NUnitXml -OutputFile $Script:UninstallTestResultsFile -Tag 'Uninstall' -PassThru
+    Pop-Location
+}
+
+<#
+    .Synopsis
+    Run OpenSSH pester tests.
+#>
+function Invoke-OpenSSHE2ETest
+{
+    [CmdletBinding()]
+    param (
+        [ValidateSet('CI', 'Scenario')]
+        [string]$pri = "CI"
+    )
+
+    # Tests are not compatible with latest Pester 5.x.
+    Import-Module -Name 'Pester' -MaximumVersion 4.9.9 -Force -Global
+
+    # Discover all CI tests and run them.
+    Push-Location $Script:E2ETestDirectory
+    Write-Log -Message "Running OpenSSH E2E tests..."
+    $testFolders = @(Get-ChildItem *.tests.ps1 -Recurse | ForEach-Object{ Split-Path $_.FullName} | Sort-Object -Unique)
+    Invoke-Pester $testFolders -OutputFormat NUnitXml -OutputFile $Script:E2ETestResultsFile -Tag $pri -PassThru
+    Pop-Location
+}
+
+<#
+    .Synopsis
+    Run UNIX bash tests using CYGWIN.
+#>
+function Invoke-OpenSSHBashTests
+{
+    [string]$bashPath = [string]::Empty
+    # Check for cygwin
+    if (Test-Path $env:SystemDrive\cygwin\bin\sh.exe) {
+        $bashPath = "$env:SystemDrive\cygwin\bin\sh.exe"
+    } elseif (Test-Path $env:SystemDrive\cygwin64\bin\sh.exe) {
+        $bashPath = "$env:SystemDrive\cygwin64\bin\sh.exe"
+    } elseif (Test-Path $env:SystemDrive\tools\cygwin\bin\sh.exe) {
+        $bashPath = "$env:SystemDrive\tools\cygwin\bin\sh.exe"
+    } else {
+        # Install cygwin
+        Write-Host "Installing cygwin using chocolatey to $env:SystemDrive\cygwin folder"
+        choco install cygwin -y --params "/InstallDir:$env:SystemDrive\cygwin\ /NoStartMenu"
+
+        if (Test-Path $env:SystemDrive\cygwin\bin\sh.exe) {
+            $bashPath = "$env:SystemDrive\cygwin\bin\sh.exe"
+        } else {
+            Write-Error "Failed to install cygwin to $env:SystemDrive\cygwin folder" -ErrorAction Stop
+            return
+        }
+    }
+
+    $bashTestDirectory = Join-Path $repositoryRoot.FullName -ChildPath "regress"
+
+    & "$PSScriptRoot\bash_tests_iterator.ps1" -OpenSSHBinPath $Script:OpenSSHBinPath -BashTestsPath $bashTestDirectory -ShellPath $bashPath -ArtifactsDirectoryPath $bashTestDirectory
+}
+
+<#
+    .Synopsis
+    Run openssh unit tests.
+#>
+function Invoke-OpenSSHUnitTest
+{
+    param (
+        [string] $UnitTestDirectory = ""
+    )
+
+    # Discover all CI tests and run them.
+    if (! [string]::IsNullOrEmpty($UnitTestDirectory) -and (Test-Path -Path $UnitTestDirectory))
+    {
+        $Script:UnitTestDirectory = $UnitTestDirectory
+        $OpenSSHTestInfo["UnitTestDirectory"] = $UnitTestDirectory
+    }
+    elseif ([string]::Isnullorempty($Script:UnitTestDirectory))
+    {
+        $Script:UnitTestDirectory = $OpenSSHTestInfo["UnitTestDirectory"]
+    }
+    
+    Push-Location $Script:UnitTestDirectory
+    Write-Log -Message "Running OpenSSH unit tests..."
+    if (Test-Path $Script:UnitTestResultsFile)
+    {
+        $null = Remove-Item -Path $Script:UnitTestResultsFile -Force -ErrorAction SilentlyContinue
+    }
+    $testFolders = Get-ChildItem -filter unittest-*.exe -Recurse |
+                 ForEach-Object{ Split-Path $_.FullName} |
+                 Sort-Object -Unique
+    $testfailed = $false
+    if ($testFolders -ne $null)
+    {
+        $testFolders | % {
+            $unittestFile = "$(Split-Path $_ -Leaf).exe"
+            $unittestFilePath = join-path $_ $unittestFile
+            if(Test-Path $unittestFilePath -pathtype leaf)
+            {                
+                $pinfo = New-Object System.Diagnostics.ProcessStartInfo
+                $pinfo.FileName = "$unittestFilePath"
+                $pinfo.RedirectStandardError = $true
+                $pinfo.RedirectStandardOutput = $true
+                $pinfo.UseShellExecute = $false
+                $pinfo.WorkingDirectory = "$_"
+                $p = New-Object System.Diagnostics.Process
+                $p.StartInfo = $pinfo
+                $p.Start() | Out-Null
+                $stdout = $p.StandardOutput.ReadToEnd()
+                $stderr = $p.StandardError.ReadToEnd()
+                $p.WaitForExit()
+                $errorCode = $p.ExitCode
+                Write-Host "Running unit test: $unittestFile ..."
+                if(-not [String]::IsNullOrWhiteSpace($stdout))
+                {
+                    Add-Content $Script:UnitTestResultsFile $stdout
+                }
+                if(-not [String]::IsNullOrWhiteSpace($stderr))
+                {
+                    Add-Content $Script:UnitTestResultsFile $stderr
+                }
+                if ($errorCode -ne 0)
+                {
+                    $testfailed = $true
+                    $errorMessage = "$unittestFile failed.`nExitCode: $errorCode. Detail test log is at $($Script:UnitTestResultsFile)."
+                    Write-Warning $errorMessage                         
+                }
+                else
+                {
+                    Write-Host "$unittestFile passed!"
+                }
+            }            
+        }
+    }
+    Pop-Location
+    $testfailed
+}
+
+<#
+    Write-Log 
+#>
+function Write-Log
+{
+    param
+    (
+        [Parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]
+        [string] $Message
+    )
+
+    if (-not (Test-Path (Split-Path $Script:TestSetupLogFile) -PathType Container))
+    {
+        $null = New-Item -ItemType Directory -Path (Split-Path $Script:TestSetupLogFile) -Force -ErrorAction SilentlyContinue | out-null
+    }
+
+    if (-not ([string]::IsNullOrEmpty($Script:TestSetupLogFile)))
+    {
+        Add-Content -Path $Script:TestSetupLogFile -Value $Message
+    }
+
+    # Write message to verbose stream.
+    Write-Verbose -Verbose -Message $Message
+}
+
+Export-ModuleMember -Function Set-BasicTestInfo, Set-OpenSSHTestEnvironment, Clear-OpenSSHTestEnvironment, Invoke-OpenSSHSetupTest, Invoke-OpenSSHUnitTest, Invoke-OpenSSHE2ETest, Invoke-OpenSSHUninstallTest, Invoke-OpenSSHBashTests
\ No newline at end of file
diff --git a/contrib/win32/openssh/OpenSSHUtils.psd1 b/contrib/win32/openssh/OpenSSHUtils.psd1
new file mode 100644
index 000000000..bc96eb18e
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSHUtils.psd1
@@ -0,0 +1,44 @@
+#
+# Module manifest for module 'OpenSSHUtils'
+#
+# Generated on: 6/9/2017
+#
+
+@{
+
+# Script module or binary module file associated with this manifest
+ModuleToProcess = 'OpenSSHUtils.psm1'
+
+# Version number of this module.
+ModuleVersion = '1.0.0.1'
+
+# ID used to uniquely identify this module
+GUID = '08285dee-3d08-476b-8948-1a7e2562c079'
+
+# Author of this module
+Author = 'Yanbing Wang'
+
+# Company or vendor of this module
+CompanyName = ''
+
+# Copyright statement for this module
+Copyright = ''
+
+# Description of the functionality provided by this module
+Description = 'Configure OpenSSH for Windows related security settings like file owner and permissions.'
+
+# Functions to export from this module
+FunctionsToExport = '*'
+
+# Cmdlets to export from this module
+CmdletsToExport = '*'
+
+# Variables to export from this module
+VariablesToExport = '*'
+
+# Aliases to export from this module
+AliasesToExport = '*'
+
+# Minimum version of the Windows PowerShell engine required by this module
+PowerShellVersion = '2.0'
+}
diff --git a/contrib/win32/openssh/OpenSSHUtils.psm1 b/contrib/win32/openssh/OpenSSHUtils.psm1
new file mode 100644
index 000000000..70f4af6e1
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSHUtils.psm1
@@ -0,0 +1,853 @@
+﻿Set-StrictMode -Version 2.0
+
+<#
+    .Synopsis
+    Get-UserSID
+#>
+function Get-UserSID
+{       
+    [CmdletBinding(DefaultParameterSetName='User')]
+    param
+        (   [parameter(Mandatory=$true, ParameterSetName="User")]
+            [ValidateNotNull()]
+            [System.Security.Principal.NTAccount]$User,
+            [parameter(Mandatory=$true, ParameterSetName="WellKnownSidType")]
+            [ValidateNotNull()]
+            [System.Security.Principal.WellKnownSidType]$WellKnownSidType
+        )
+    try
+    {   
+        if($PSBoundParameters.ContainsKey("User"))
+        {
+            $sid = $User.Translate([System.Security.Principal.SecurityIdentifier])
+        }
+        elseif($PSBoundParameters.ContainsKey("WellKnownSidType"))
+        {
+            $sid = New-Object System.Security.Principal.SecurityIdentifier($WellKnownSidType, $null)
+        }
+        $sid        
+    }
+    catch {
+        return $null
+    }
+}
+
+# get the local System user
+$systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+
+# get the Administrators group
+$adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)
+
+# get the everyone
+$everyoneSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::WorldSid)
+
+$currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+
+$authenticatedUserSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::AuthenticatedUserSid)
+
+#Taken from P/Invoke.NET with minor adjustments.
+ $definition = @'
+using System;
+using System.Runtime.InteropServices;
+  
+public class AdjPriv
+{
+    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
+    internal static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall,
+    ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen);
+    [DllImport("kernel32.dll", ExactSpelling = true, SetLastError = true)]
+    internal static extern IntPtr GetCurrentProcess();
+    [DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]
+    internal static extern bool OpenProcessToken(IntPtr h, int acc, ref IntPtr phtok);
+    [DllImport("advapi32.dll", SetLastError = true)]
+    internal static extern bool LookupPrivilegeValue(string host, string name, ref long pluid);
+    [StructLayout(LayoutKind.Sequential, Pack = 1)]
+    internal struct TokPriv1Luid
+    {
+        public int Count;
+        public long Luid;
+        public int Attr;
+    }
+  
+    internal const int SE_PRIVILEGE_ENABLED = 0x00000002;
+    internal const int SE_PRIVILEGE_DISABLED = 0x00000000;
+    internal const int TOKEN_QUERY = 0x00000008;
+    internal const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;
+    public static bool EnablePrivilege(string privilege, bool disable)
+    {
+        bool retVal;
+        TokPriv1Luid tp;
+        IntPtr hproc = GetCurrentProcess();
+        IntPtr htok = IntPtr.Zero;
+        retVal = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref htok);
+        tp.Count = 1;
+        tp.Luid = 0;
+        if(disable)
+        {
+            tp.Attr = SE_PRIVILEGE_DISABLED;
+        }
+        else
+        {
+            tp.Attr = SE_PRIVILEGE_ENABLED;
+        }
+        retVal = LookupPrivilegeValue(null, privilege, ref tp.Luid);
+        retVal = AdjustTokenPrivileges(htok, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero);
+        return retVal;
+    }
+}
+'@
+ 
+try
+{
+    $type = Add-Type $definition -PassThru -ErrorAction SilentlyContinue
+}
+catch
+{
+    # Powershell 7 does not add a type if it already exists
+    $type = [AdjPriv]
+}
+
+<#
+    .Synopsis
+    Repair-SshdConfigPermission
+    Repair the file owner and Permission of sshd_config
+#>
+function Repair-SshdConfigPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath)
+
+        Repair-FilePermission -Owners $systemSid,$adminsSid -FullAccessNeeded $systemSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-SshdHostKeyPermission
+    Repair the file owner and Permission of host private and public key
+    -FilePath: The path of the private host key
+#>
+function Repair-SshdHostKeyPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]
+        [string]$FilePath)
+        
+        if($PSBoundParameters["FilePath"].EndsWith(".pub"))
+        {
+            $PSBoundParameters["FilePath"] = $PSBoundParameters["FilePath"].Replace(".pub", "")
+        }
+
+        Repair-FilePermission -Owners $systemSid,$adminsSid @psBoundParameters
+        
+        $PSBoundParameters["FilePath"] += ".pub"
+        Repair-FilePermission -Owners $systemSid,$adminsSid -ReadAccessOK $everyoneSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-AuthorizedKeyPermission
+    Repair the file owner and Permission of authorized_keys
+#>
+function Repair-AuthorizedKeyPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath)        
+
+        if(-not (Test-Path $FilePath -PathType Leaf))
+        {
+            Write-host "$FilePath not found" -ForegroundColor Yellow
+            return
+        }
+        $fullPath = (Resolve-Path $FilePath).Path
+        $profileListPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList"
+        $profileItem = Get-ChildItem $profileListPath  -ErrorAction SilentlyContinue | ? {
+            $properties =  Get-ItemProperty $_.pspath  -ErrorAction SilentlyContinue
+            $userProfilePath = $null
+            if($properties)
+            {
+                $userProfilePath =  $properties.ProfileImagePath
+            }
+            $userProfilePath = $userProfilePath.Replace("\", "\\")
+            if ( $properties.PSChildName -notmatch '\.bak$') {
+                $fullPath -match "^$userProfilePath\\[\\|\W|\w]+authorized_keys$"
+            }
+        }
+        if($profileItem)
+        {
+            $userSid = $profileItem.PSChildName            
+            Repair-FilePermission -Owners $userSid,$adminsSid,$systemSid -AnyAccessOK $userSid -FullAccessNeeded $systemSid @psBoundParameters
+            
+        }
+        else
+        {
+            Write-host "$fullPath is not in the profile folder of any user. Skip checking..." -ForegroundColor Yellow
+        }
+}
+
+<#
+    .Synopsis
+    Repair-AdministratorsAuthorizedKeysPermission
+    Repair the file owner and Permission of administrators_authorized_keys
+#>
+
+function Repair-AdministratorsAuthorizedKeysPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath) 
+
+        Repair-FilePermission -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -ReadAccessOK $everyoneSid @psBoundParameters        
+
+}
+
+<#
+    .Synopsis
+    Repair-ModuliFilePermission
+    Repair the file owner and Permission of moduli file 
+#>
+
+function Repair-ModuliFilePermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath) 
+
+        Repair-FilePermission -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -ReadAccessOK $everyoneSid @psBoundParameters        
+
+}
+
+<#
+    .Synopsis
+    Repair-UserKeyPermission
+    Repair the file owner and Permission of user config
+    -FilePath: The path of the private user key
+    -User: The user associated with this ssh config
+#>
+function Repair-UserKeyPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true, Position = 0)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath,
+        [System.Security.Principal.SecurityIdentifier] $UserSid = $currentUserSid)
+
+        if($PSBoundParameters["FilePath"].EndsWith(".pub"))
+        {
+            $PSBoundParameters["FilePath"] = $PSBoundParameters["FilePath"].Replace(".pub", "")
+        }
+        Repair-FilePermission -Owners $UserSid, $adminsSid,$systemSid -AnyAccessOK $UserSid @psBoundParameters
+        
+        $PSBoundParameters["FilePath"] += ".pub"
+        Repair-FilePermission -Owners $UserSid, $adminsSid,$systemSid -AnyAccessOK $UserSid -ReadAccessOK $everyoneSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-UserSSHConfigPermission
+    Repair the file owner and Permission of user config
+#>
+function Repair-UserSshConfigPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath,
+        [System.Security.Principal.SecurityIdentifier] $UserSid = $currentUserSid)
+        Repair-FilePermission -Owners $UserSid,$adminsSid,$systemSid -AnyAccessOK $UserSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-SSHFolderPermission
+    Repair the folder owner and permission of ProgramData\ssh folder
+#>
+function Repair-SSHFolderPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath)
+
+    Repair-FilePermission -Owners $adminsSid, $systemSid -FullAccessNeeded $adminsSid,$systemSid -ReadAndExecuteAccessOK $authenticatedUserSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-SSHFolderFilePermission
+    Repair the file owner and permission of general files inside ProgramData\ssh folder
+#>
+function Repair-SSHFolderFilePermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath)
+
+    Repair-FilePermission -Owners $adminsSid, $systemSid -FullAccessNeeded $adminsSid, $systemSid -ReadAndExecuteAccessOK $authenticatedUserSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-SSHFolderPrivateKeyPermission
+    Repair the file owner and permission of private key files inside ProgramData\ssh folder
+#>
+function Repair-SSHFolderPrivateKeyPermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath)
+
+    Repair-FilePermission -Owners $adminsSid, $systemSid -FullAccessNeeded $systemSid, $adminsSid @psBoundParameters
+}
+
+<#
+    .Synopsis
+    Repair-FilePermissionInternal
+    Only validate owner and ACEs of the file
+#>
+function Repair-FilePermission
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (        
+        [parameter(Mandatory=$true, Position = 0)]
+        [ValidateNotNullOrEmpty()]        
+        [string]$FilePath,
+        [ValidateNotNull()]
+        [System.Security.Principal.SecurityIdentifier[]] $Owners = $currentUserSid,
+        [System.Security.Principal.SecurityIdentifier[]] $AnyAccessOK = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $FullAccessNeeded = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAccessOK = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAccessNeeded = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAndExecuteAccessOK = $null
+    )
+
+    if(-not (Test-Path $FilePath))
+    {
+        Write-host "$FilePath not found" -ForegroundColor Yellow
+        return
+    }
+    
+    Write-host "  [*] $FilePath"
+    $return = Repair-FilePermissionInternal @PSBoundParameters
+
+    if($return -contains $true) 
+    {
+        #Write-host "Re-check the health of file $FilePath"
+        Repair-FilePermissionInternal @PSBoundParameters
+    }
+}
+
+<#
+    .Synopsis
+    Repair-FilePermissionInternal
+#>
+function Repair-FilePermissionInternal {
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true, Position = 0)]
+        [ValidateNotNullOrEmpty()]
+        [string]$FilePath,
+        [ValidateNotNull()]
+        [System.Security.Principal.SecurityIdentifier[]] $Owners = $currentUserSid,
+        [System.Security.Principal.SecurityIdentifier[]] $AnyAccessOK = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $FullAccessNeeded = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAccessOK = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAccessNeeded = $null,
+        [System.Security.Principal.SecurityIdentifier[]] $ReadAndExecuteAccessOK = $null
+    )
+
+    $acl = Get-Acl $FilePath
+    $needChange = $false
+    $health = $true
+    $paras = @{}
+    $PSBoundParameters.GetEnumerator() | % { if((-not $_.key.Contains("Owners")) -and (-not $_.key.Contains("Access"))) { $paras.Add($_.key,$_.Value) } }
+        
+    $currentOwnerSid = Get-UserSid -User $acl.owner
+    if($owners -notcontains $currentOwnerSid)
+    {
+        $newOwner = Get-UserAccount -User $Owners[0]
+        $caption = "Current owner: '$($acl.Owner)'. '$newOwner' should own '$FilePath'."
+        $prompt = "Shall I set the file owner?"
+        $description = "Set '$newOwner' as owner of '$FilePath'."
+        if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+        {
+            Enable-Privilege SeRestorePrivilege | out-null
+            $acl.SetOwner($newOwner)
+            Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+        }
+        else
+        {
+            $health = $false
+            if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+            {
+                Write-Host "The owner is still set to '$($acl.Owner)'." -ForegroundColor Yellow
+            }
+        }
+    }
+
+    $ReadAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Read.value__) -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+    $ReadAndExecuteAccessPerm = $ReadAccessPerm -bor ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)
+    $FullControlPerm = [System.UInt32] [System.Security.AccessControl.FileSystemRights]::FullControl.value__
+
+    #system and admin groups can have any access to the file; plus the account in the AnyAccessOK list
+    $realAnyAccessOKList = @($systemSid, $adminsSid)
+    if($AnyAccessOK)
+    {
+        $realAnyAccessOKList += $AnyAccessOK
+    }
+    
+    $realFullAccessNeeded = $FullAccessNeeded
+    $realReadAccessNeeded = $ReadAccessNeeded
+    if($realFullAccessNeeded -contains $everyoneSid)
+    {
+        $realFullAccessNeeded = @($everyoneSid)
+        $realReadAccessNeeded = $null
+    }    
+    
+    if($realReadAccessNeeded -contains $everyoneSid)
+    {
+        $realReadAccessNeeded = @($everyoneSid)
+    }
+    #this is original list requested by the user, the account will be removed from the list if they already part of the dacl
+    if($realReadAccessNeeded)
+    {
+        $realReadAccessNeeded = $realReadAccessNeeded | ? { ($_ -ne $null) -and ($realFullAccessNeeded -notcontains $_) }
+    }    
+    
+    #if accounts in the ReadAccessNeeded or $realFullAccessNeeded already part of dacl, they are okay;
+    #need to make sure they have read access only
+    $realReadAcessOKList = $ReadAccessOK + $realReadAccessNeeded
+
+    foreach($a in $acl.Access)
+    {
+        if ($a.IdentityReference -is [System.Security.Principal.SecurityIdentifier]) 
+        {
+            $IdentityReferenceSid = $a.IdentityReference
+        }
+        Else 
+        {
+            $IdentityReferenceSid = Get-UserSid -User $a.IdentityReference
+        }
+        if($IdentityReferenceSid -eq $null)
+        {
+            $idRefShortValue = ($a.IdentityReference.Value).split('\')[-1]
+            $IdentityReferenceSid = Get-UserSID -User $idRefShortValue
+            if($IdentityReferenceSid -eq $null)            
+            {
+                Write-Warning "Can't translate '$idRefShortValue'. "
+                continue
+            }                    
+        }
+        
+        if($realFullAccessNeeded -contains ($IdentityReferenceSid))
+        {
+            $realFullAccessNeeded = $realFullAccessNeeded | ? { ($_ -ne $null) -and (-not $_.Equals($IdentityReferenceSid)) }
+            if($realReadAccessNeeded)
+            {
+                $realReadAccessNeeded = $realReadAccessNeeded | ? { ($_ -ne $null) -and (-not $_.Equals($IdentityReferenceSid)) }
+            }
+            if (($a.AccessControlType.Equals([System.Security.AccessControl.AccessControlType]::Allow)) -and `
+            ((([System.UInt32]$a.FileSystemRights.value__) -band $FullControlPerm) -eq $FullControlPerm))
+            {   
+                continue;
+            }
+            #update the account to full control
+            if($a.IsInherited)
+            {
+                if($needChange)    
+                {
+                    Enable-Privilege SeRestorePrivilege | out-null
+                    Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+                }
+                
+                return Remove-RuleProtection @paras
+            }
+            $caption = "'$($a.IdentityReference)' has the following access to '$FilePath': '$($a.AccessControlType)'-'$($a.FileSystemRights)'."
+            $prompt = "Shall I make it Allow FullControl?"
+            $description = "Grant '$($a.IdentityReference)' FullControl access to '$FilePath'. "
+
+            if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+            {
+                $needChange = $true
+                $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                        ($IdentityReferenceSid, "FullControl", "None", "None", "Allow")
+                                
+                $acl.SetAccessRule($ace)
+                Write-Host "'$($a.IdentityReference)' now has FullControl access to '$FilePath'. " -ForegroundColor Green
+            }
+            else
+            {
+                $health = $false
+                if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                {
+                    Write-Host "'$($a.IdentityReference)' still has these access to '$FilePath': '$($a.AccessControlType)'-'$($a.FileSystemRights)'." -ForegroundColor Yellow
+                }
+            }
+        } 
+        elseif(($realAnyAccessOKList -contains $everyoneSid) -or ($realAnyAccessOKList -contains $IdentityReferenceSid))
+        {
+            #ignore those accounts listed in the AnyAccessOK list.
+            continue;
+        }
+        # Handle ReadAndExecuteAccessOK list and make sure they are only granted Read or ReadAndExecute & Synchronize access
+        elseif($ReadAndExecuteAccessOK -contains $IdentityReferenceSid)
+        {
+            # checks if user access is already either: Read or ReadAndExecute & Synchronize
+            if (-not ($a.AccessControlType.Equals([System.Security.AccessControl.AccessControlType]::Allow)) -or `
+            (-not (([System.UInt32]$a.FileSystemRights.value__) -band (-bnot $ReadAndExecuteAccessPerm))))
+            {
+                continue;
+            }
+            
+            if($a.IsInherited)
+            {
+                if($needChange)    
+                {
+                    Enable-Privilege SeRestorePrivilege | out-null
+                    Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+                }
+                
+                return Remove-RuleProtection @paras
+            }
+            $caption = "'$($a.IdentityReference)' has the following access to '$FilePath': '$($a.FileSystemRights)'."
+            $prompt = "Shall I make it ReadAndExecute, and Synchronize only?"
+            $description = "Set'$($a.IdentityReference)' Read access only to '$FilePath'. "
+
+            if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+            {
+                $needChange = $true
+                $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                    ($IdentityReferenceSid, "ReadAndExecute, Synchronize", "None", "None", "Allow")
+                          
+                $acl.SetAccessRule($ace)
+                Write-Host "'$($a.IdentityReference)' now has ReadAndExecute, Synchronize access to '$FilePath'. " -ForegroundColor Green
+            }
+            else
+            {
+                $health = $false
+                if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                {
+                    Write-Host "'$($a.IdentityReference)' still has these access to '$FilePath': '$($a.FileSystemRights)'." -ForegroundColor Yellow
+                }
+            }
+        }
+        #If everyone is in the ReadAccessOK list, any user can have read access;
+        # below block make sure they are granted Read access only
+        elseif(($realReadAcessOKList -contains $everyoneSid) -or ($realReadAcessOKList -contains $IdentityReferenceSid))
+        {
+            if($realReadAccessNeeded -and ($IdentityReferenceSid.Equals($everyoneSid)))
+            {
+                $realReadAccessNeeded= $null
+            }
+            elseif($realReadAccessNeeded)
+            {
+                $realReadAccessNeeded = $realReadAccessNeeded | ? { ($_ -ne $null ) -and (-not $_.Equals($IdentityReferenceSid)) }
+            }
+
+            if (-not ($a.AccessControlType.Equals([System.Security.AccessControl.AccessControlType]::Allow)) -or `
+            (-not (([System.UInt32]$a.FileSystemRights.value__) -band (-bnot $ReadAccessPerm))))
+            {
+                continue;
+            }
+            
+            if($a.IsInherited)
+            {
+                if($needChange)    
+                {
+                    Enable-Privilege SeRestorePrivilege | out-null
+                    Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+                }
+                
+                return Remove-RuleProtection @paras
+            }
+            $caption = "'$($a.IdentityReference)' has the following access to '$FilePath': '$($a.FileSystemRights)'."
+            $prompt = "Shall I make it Read only?"
+            $description = "Set'$($a.IdentityReference)' Read access only to '$FilePath'. "
+
+            if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+            {
+                $needChange = $true
+                $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                    ($IdentityReferenceSid, "Read", "None", "None", "Allow")
+                          
+                $acl.SetAccessRule($ace)
+                Write-Host "'$($a.IdentityReference)' now has Read access to '$FilePath'. " -ForegroundColor Green
+            }
+            else
+            {
+                $health = $false
+                if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                {
+                    Write-Host "'$($a.IdentityReference)' still has these access to '$FilePath': '$($a.FileSystemRights)'." -ForegroundColor Yellow
+                }
+            }
+        }
+        #other than AnyAccessOK and ReadAccessOK list, if any other account is allowed, they should be removed from the dacl
+        elseif($a.AccessControlType.Equals([System.Security.AccessControl.AccessControlType]::Allow))
+        {            
+            $caption = "'$($a.IdentityReference)' should not have access to '$FilePath'." 
+            if($a.IsInherited)
+            {
+                if($needChange)    
+                {
+                    Enable-Privilege SeRestorePrivilege | out-null
+                    Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+                }
+                return Remove-RuleProtection @paras
+            }
+            
+            $prompt = "Shall I remove this access?"
+            $description = "Remove access rule of '$($a.IdentityReference)' from '$FilePath'."
+
+            if($pscmdlet.ShouldProcess($description, $prompt, "$caption."))
+            {  
+                $needChange = $true                
+                $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                            ($IdentityReferenceSid, $a.FileSystemRights, $a.InheritanceFlags, $a.PropagationFlags, $a.AccessControlType)
+
+                if(-not ($acl.RemoveAccessRule($ace)))
+                {
+                    Write-Warning "Failed to remove access of '$($a.IdentityReference)' from '$FilePath'."
+                }
+                else
+                {
+                    Write-Host "'$($a.IdentityReference)' has no more access to '$FilePath'." -ForegroundColor Green
+                }
+            }
+            else
+            {
+                $health = $false
+                if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                {
+                    Write-Host "'$($a.IdentityReference)' still has access to '$FilePath'." -ForegroundColor Yellow                
+                }        
+            }
+        }
+    }
+    
+    if($realFullAccessNeeded)
+    {
+        $realFullAccessNeeded | % {
+            $account = Get-UserAccount -UserSid $_
+            if($account -eq $null)
+            {
+                Write-Warning "'$_' needs FullControl access to '$FilePath', but it can't be translated on the machine."
+            }
+            else
+            {
+                $caption = "'$account' needs FullControl access to '$FilePath'."
+                $prompt = "Shall I make the above change?"
+                $description = "Set '$account' FullControl access to '$FilePath'. "
+
+                if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+	            {
+                    $needChange = $true
+                    $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                            ($_, "FullControl", "None", "None", "Allow")
+                    $acl.AddAccessRule($ace)
+                    Write-Host "'$account' now has FullControl to '$FilePath'." -ForegroundColor Green
+                }
+                else
+                {
+                    $health = $false
+                    if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                    {
+                        Write-Host "'$account' does not have FullControl to '$FilePath'." -ForegroundColor Yellow
+                    }
+                }
+            }
+        }
+    }
+
+    #This is the real account list we need to add read access to the file
+    if($realReadAccessNeeded)
+    {
+        $realReadAccessNeeded | % {
+            $account = Get-UserAccount -UserSid $_
+            if($account -eq $null)
+            {
+                Write-Warning "'$_' needs Read access to '$FilePath', but it can't be translated on the machine."
+            }
+            else
+            {
+                $caption = "'$account' needs Read access to '$FilePath'."
+                $prompt = "Shall I make the above change?"
+                $description = "Set '$account' Read only access to '$FilePath'. "
+
+                if($pscmdlet.ShouldProcess($description, $prompt, $caption))
+	            {
+                    $needChange = $true
+                    $ace = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                            ($_, "Read", "None", "None", "Allow")
+                    $acl.AddAccessRule($ace)
+                    Write-Host "'$account' now has Read access to '$FilePath'." -ForegroundColor Green
+                }
+                else
+                {
+                    $health = $false
+                    if(-not $PSBoundParameters.ContainsKey("WhatIf"))
+                    {
+                        Write-Host "'$account' does not have Read access to '$FilePath'." -ForegroundColor Yellow
+                    }
+                }
+            }
+        }
+    }
+
+    if($needChange)    
+    {
+        Enable-Privilege SeRestorePrivilege | out-null
+        Set-Acl -Path $FilePath -AclObject $acl -Confirm:$false
+    }
+    if($health)
+    {
+        if ($needChange) 
+        {
+            Write-Host "      Repaired permissions" -ForegroundColor Yellow
+        }
+        else
+        {
+            Write-Host "      looks good"  -ForegroundColor Green
+        }
+    }
+    Write-host " "
+}
+
+<#
+    .Synopsis
+    Remove-RuleProtection
+#>
+function Remove-RuleProtection
+{
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param (
+        [parameter(Mandatory=$true)]
+        [string]$FilePath
+    )
+    $message = "Need to remove the inheritance before repair the rules."
+    $prompt = "Shall I remove the inheritance?"
+    $description = "Remove inheritance of '$FilePath'."
+
+    if($pscmdlet.ShouldProcess($description, $prompt, $message))
+	{
+        $acl = Get-acl -Path $FilePath
+        $acl.SetAccessRuleProtection($True, $True)
+        Enable-Privilege SeRestorePrivilege | out-null
+        Set-Acl -Path $FilePath -AclObject $acl -ErrorVariable e -Confirm:$false
+        if($e)
+        {
+            Write-Warning "Remove-RuleProtection failed with error: $($e[0].ToString())."
+        }
+              
+        Write-Host "Inheritance is removed from '$FilePath'."  -ForegroundColor Green
+        return $true
+    }
+    elseif(-not $PSBoundParameters.ContainsKey("WhatIf"))
+    {        
+        Write-Host "inheritance is not removed from '$FilePath'. Skip Checking FilePath."  -ForegroundColor Yellow
+        return $false
+    }
+}
+
+<#
+    .Synopsis
+    Get-UserAccount
+#>
+function Get-UserAccount
+{
+    [CmdletBinding(DefaultParameterSetName='Sid')]
+    param
+        (   [parameter(Mandatory=$true, ParameterSetName="Sid")]
+            [ValidateNotNull()]
+            [System.Security.Principal.SecurityIdentifier]$UserSid,
+            [parameter(Mandatory=$true, ParameterSetName="WellKnownSidType")]
+            [ValidateNotNull()]
+            [System.Security.Principal.WellKnownSidType]$WellKnownSidType
+        )
+    try
+    {
+        if($PSBoundParameters.ContainsKey("UserSid"))
+        {            
+            $objUser = $UserSid.Translate([System.Security.Principal.NTAccount])
+        }
+        elseif($PSBoundParameters.ContainsKey("WellKnownSidType"))
+        {
+            $objSID = New-Object System.Security.Principal.SecurityIdentifier($WellKnownSidType, $null)
+            $objUser = $objSID.Translate( [System.Security.Principal.NTAccount])
+        }
+        $objUser
+    }
+    catch {
+        return $null
+    }
+}
+
+<#
+    .Synopsis
+    Enable-Privilege
+#>
+function Enable-Privilege {
+    param(
+    #The privilege to adjust. This set is taken from
+    #http://msdn.microsoft.com/en-us/library/bb530716(VS.85).aspx
+    [ValidateSet(
+       "SeAssignPrimaryTokenPrivilege", "SeAuditPrivilege", "SeBackupPrivilege",
+       "SeChangeNotifyPrivilege", "SeCreateGlobalPrivilege", "SeCreatePagefilePrivilege",
+       "SeCreatePermanentPrivilege", "SeCreateSymbolicLinkPrivilege", "SeCreateTokenPrivilege",
+       "SeDebugPrivilege", "SeEnableDelegationPrivilege", "SeImpersonatePrivilege", "SeIncreaseBasePriorityPrivilege",
+       "SeIncreaseQuotaPrivilege", "SeIncreaseWorkingSetPrivilege", "SeLoadDriverPrivilege",
+       "SeLockMemoryPrivilege", "SeMachineAccountPrivilege", "SeManageVolumePrivilege",
+       "SeProfileSingleProcessPrivilege", "SeRelabelPrivilege", "SeRemoteShutdownPrivilege",
+       "SeRestorePrivilege", "SeSecurityPrivilege", "SeShutdownPrivilege", "SeSyncAgentPrivilege",
+       "SeSystemEnvironmentPrivilege", "SeSystemProfilePrivilege", "SeSystemtimePrivilege",
+       "SeTakeOwnershipPrivilege", "SeTcbPrivilege", "SeTimeZonePrivilege", "SeTrustedCredManAccessPrivilege",
+       "SeUndockPrivilege", "SeUnsolicitedInputPrivilege")]
+    $Privilege,
+    # Switch to disable the privilege, rather than enable it.
+    [Switch] $Disable
+ )
+
+    $type[0]::EnablePrivilege($Privilege, $Disable)
+}
+
+Function Add-MachinePath {
+    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+    param
+    (
+        [parameter(Mandatory=$true)]
+        [string]$FilePath
+    )
+
+    if (Test-Path $FilePath) {
+        $machinePath = (Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).Path
+        if (-not ($machinePath.ToLower().Contains("$FilePath;".ToLower()) -or $machinePath.ToLower().Contains("$FilePath\;".ToLower())))
+        {
+            $newPath = $FilePath + ’;’ + $machinePath 
+            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH –Value $newPath
+            if ((Get-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Session Manager\Environment' -Name PATH).Path -eq $newPath) {
+                Write-Host "Updated Machine PATH to include OpenSSH directory, restart/re-login required to take effect globally" -ForegroundColor Yellow
+            }
+        }
+    }
+}
+
+Export-ModuleMember -Function Repair-FilePermission, Repair-SshdConfigPermission, Repair-SshdHostKeyPermission, Repair-AuthorizedKeyPermission, Repair-UserKeyPermission, Repair-UserSshConfigPermission, Enable-Privilege, Get-UserAccount, Get-UserSID, Repair-AdministratorsAuthorizedKeysPermission, Repair-ModuliFilePermission, Repair-SSHFolderPermission, Repair-SSHFolderFilePermission, Repair-SSHFolderPrivateKeyPermission, Add-MachinePath
diff --git a/contrib/win32/openssh/OpenSSL-1.0.2d_build.cmd b/contrib/win32/openssh/OpenSSL-1.0.2d_build.cmd
new file mode 100644
index 000000000..daca44b11
--- /dev/null
+++ b/contrib/win32/openssh/OpenSSL-1.0.2d_build.cmd
@@ -0,0 +1,45 @@
+set OPENSSL_VERSION=1.0.2d
+set PerlPath=c:\perl\bin
+set NASMPath=c:\nasm
+
+set VS2013="C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\vcvars32.bat"
+set VS2013_AMD64="C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\bin\amd64\vcvars64.bat"
+set VS2015="C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\vcvars32.bat"
+set VS2015_AMD64="C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin\amd64\vcvars64.bat"
+
+set path=%NASMPath%;%PerlPath%;%path%
+
+
+CALL %VS2015%
+
+cd \Dev\OpenSSL\openssl-%OPENSSL_VERSION%-src-x86
+perl Configure VC-WIN32 --prefix=C:\dev\OpenSSL\%OPENSSL_VERSION%\VS2015\Win32\Release
+call ms\do_ms.bat
+call ms\do_nasm.bat
+nmake -f ms\nt.mak clean
+nmake -f ms\nt.mak
+nmake -f ms\nt.mak install
+
+cd \Dev\OpenSSL\openssl-%OPENSSL_VERSION%-src-x86
+perl Configure debug-VC-WIN32 --prefix=C:\dev\OpenSSL\%OPENSSL_VERSION%\VS2015\Win32\Debug
+call ms\do_ms.bat
+call ms\do_nasm.bat
+nmake -f ms\nt.mak clean
+nmake -f ms\nt.mak
+nmake -f ms\nt.mak install
+
+CALL %VS2015_AMD64%
+
+cd \Dev\OpenSSL\openssl-%OPENSSL_VERSION%-src-x64
+perl Configure VC-WIN64A --prefix=C:\dev\OpenSSL\%OPENSSL_VERSION%\VS2015\x64\Release
+call ms\do_win64a.bat
+nmake -f ms\nt.mak clean
+nmake -f ms\nt.mak
+nmake -f ms\nt.mak install
+
+cd \Dev\OpenSSL\openssl-%OPENSSL_VERSION%-src-x64
+perl Configure debug-VC-WIN64A --prefix=C:\dev\OpenSSL\%OPENSSL_VERSION%\VS2015\x64\Debug
+call ms\do_win64a.bat
+nmake -f ms\nt.mak clean
+nmake -f ms\nt.mak
+nmake -f ms\nt.mak install
diff --git a/contrib/win32/openssh/Openssh-events.man b/contrib/win32/openssh/Openssh-events.man
new file mode 100644
index 000000000..edbf8e913
--- /dev/null
+++ b/contrib/win32/openssh/Openssh-events.man
@@ -0,0 +1,63 @@
+<?xml version="1.0" encoding="utf-8"?>
+<instrumentationManifest xsi:schemaLocation="http://schemas.microsoft.com/win/2004/08/events eventman.xsd" xmlns="http://schemas.microsoft.com/win/2004/08/events" xmlns:win="http://manifests.microsoft.com/win/2004/08/windows/events" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:trace="http://schemas.microsoft.com/win/2004/08/events/trace">
+	<instrumentation>
+		<events>
+			<provider name="OpenSSH" guid="{C4B57D35-0636-4BC3-A262-370F249F9802}" symbol="OpenSSH" resourceFileName="%windir%\system32\openssh\ssh-agent.exe" messageFileName="%windir%\system32\openssh\ssh-agent.exe">
+				<events>
+					<event symbol="CRITICAL_Event" value="1" version="0" channel="OpenSSH/Admin" level="win:Critical" template="2StrTemplate" message="$(string.OpenSSH.event.message)">
+					</event>
+					<event symbol="ERROR_Event" value="2" version="0" channel="OpenSSH/Admin" level="win:Error" template="2StrTemplate" message="$(string.OpenSSH.event.message)">
+					</event>
+					<event symbol="WARNING_Event" value="3" version="0" channel="OpenSSH/Operational" level="win:Warning" template="2StrTemplate" message="$(string.OpenSSH.event.message)">
+					</event>
+					<event symbol="INFO_Event" value="4" version="0" channel="OpenSSH/Operational" level="win:Informational" template="2StrTemplate" message="$(string.OpenSSH.event.message)">
+					</event>
+					<event symbol="DEBUG_Event" value="6" version="0" channel="OpenSSH/Debug" level="Debug" template="2StrTemplate" message="$(string.OpenSSH.event.message)">
+					</event>
+				</events>
+				<levels>
+					<level name="Debug" symbol="Debug" value="16" message="$(string.OpenSSH.level.Debug.message)">
+					</level>
+				</levels>
+				<channels>
+					<channel name="OpenSSH/Admin" chid="OpenSSH/Admin" symbol="OpenSSH_Admin" type="Admin" enabled="true">
+					</channel>
+					<channel name="OpenSSH/Operational" chid="OpenSSH/Operational" symbol="OpenSSH_Operational" type="Operational" enabled="true">
+					</channel>
+					<channel
+						access="O:BAG:BAD:(A;;0x2;;;BU)(A;;0x2;;;S-1-15-2-1)(A;;0x2;;;S-1-15-3-1024-3153509613-960666767-3724611135-2725662640-12138253-543910227-1950414635-4190290187)(A;;0xf0007;;;SY)(A;;0x7;;;BA)(A;;0x7;;;SO)(A;;0x3;;;IU)(A;;0x3;;;SU)(A;;0x3;;;S-1-5-3)(A;;0x3;;;S-1-5-33)(A;;0x1;;;S-1-5-32-573)"
+						isolation="Custom" name="OpenSSH/Debug" chid="OpenSSH/Debug" symbol="OpenSSH_Debug" type="Debug" enabled="false">
+					</channel>
+				</channels>
+				<templates>
+					<template tid="2StrTemplate">
+						<data name="process" inType="win:UnicodeString" outType="xs:string">
+						</data>
+						<data name="payload" inType="win:UnicodeString" outType="xs:string">
+						</data>
+					</template>
+				</templates>
+			</provider>
+		</events>
+	</instrumentation>
+	<localization>
+		<resources culture="en-US">
+			<stringTable>
+				<string id="level.Warning" value="Warning">
+				</string>
+				<string id="level.Verbose" value="Verbose">
+				</string>
+				<string id="level.Informational" value="Information">
+				</string>
+				<string id="level.Error" value="Error">
+				</string>
+				<string id="level.Critical" value="Critical">
+				</string>
+				<string id="OpenSSH.level.Debug.message" value="Debug">
+				</string>
+				<string id="OpenSSH.event.message" value="%1: %2">
+				</string>
+			</stringTable>
+		</resources>
+	</localization>
+</instrumentationManifest>
diff --git a/contrib/win32/openssh/README.txt b/contrib/win32/openssh/README.txt
new file mode 100644
index 000000000..14b250eb6
--- /dev/null
+++ b/contrib/win32/openssh/README.txt
@@ -0,0 +1,62 @@
+Custom paths for the visual studio projects are defined in paths.targets.  
+
+All projects import this targets file, and it should be in the same directory as the project.
+
+The custom paths are:
+
+OpenSSH-Src-Path            =  The directory path of the OpenSSH root source directory (with trailing slash)
+OpenSSH-Bin-Path            =  The directory path of the location to which binaries are placed.  This is the output of the binary projects
+OpenSSH-Lib-Path            =  The directory path of the location to which libraries are placed.  This is the output of the libary projects
+LibreSSL-x86-Path           =  The directory path of LibreSSL statically compiled for x86 platform.
+LibreSSL-x64-Path           =  The directory path of LibreSSL statically compiled for x64 platform.
+
+Notes on FIDO2 support
+----------------------
+
+* How to build:
+
+  - Open Windows PowerShell.
+
+  - Build OpenSSH for Windows:
+
+    $ cd \path\to\openssh-portable\..
+    $ .\openssh-portable\contrib\win32\openssh\OpenSSH-build.ps1
+
+* What has been tested:
+
+  * Using a Yubico Security Key.
+
+  - Create a new SSH key:
+
+    $ ssh-keygen.exe -t ecdsa-sk
+
+    * Save the key material in SSH's default paths without an associated passphrase.
+
+  - Add the SSH key to your GitHub account.
+
+  - Tell git to use our SSH build:
+
+    $ $Env:GIT_SSH = '\path\to\ssh.exe'
+
+  - Clone a repository using the SSH key for authentication:
+
+    $ git clone ssh://git@github.com/org/some-private-repo
+
+* WSL2:
+
+  - Export GIT_SSH:
+
+    $ export GIT_SSH=/mnt/c/.../path/to/ssh.exe
+
+  - Optionally, alias ssh:
+
+    $ alias ssh=/mnt/c/.../path/to/ssh.exe
+
+* Note: FIDO2 keys are supported by ssh-agent.
+
+* What definitely doesn't work:
+
+  * ssh-keygen -O no-touch-required:
+    - there does not appear to be a way to toggle user presence in WEBAUTHN_AUTHENTICATOR_GET_ASSERTION_OPTIONS.
+  * ssh-keygen -K, ssh-add -K:
+    - these use Credential Management to reconstruct the SSH private key.
diff --git a/contrib/win32/openssh/SignConfig.xml b/contrib/win32/openssh/SignConfig.xml
new file mode 100644
index 000000000..b39d2a622
--- /dev/null
+++ b/contrib/win32/openssh/SignConfig.xml
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="utf-8" ?>
+<SignConfigXML>
+  <!-- ****Begin**** BothDual - Dual (Sha256 and Sha1) AuthenticodeDual) and should be StrongName  ******** -->
+ <job platform="" configuration="" dest="__OUTPATHROOT__\signed" jobname="OpenSSH" approvers="gstolt,vigarg">
+    <file src="__INPATHROOT__\libcrypto.dll" signType="AuthenticodeDual" dest="__OUTPATHROOT__\libcrypto.dll" />
+    <file src="__INPATHROOT__\scp.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\scp.exe" />
+    <file src="__INPATHROOT__\sftp-server.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\sftp-server.exe" />
+    <file src="__INPATHROOT__\sftp.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\sftp.exe" />
+    <file src="__INPATHROOT__\ssh-add.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh-add.exe" />
+    <file src="__INPATHROOT__\ssh-agent.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh-agent.exe" />
+    <file src="__INPATHROOT__\ssh-keygen.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh-keygen.exe" />
+    <file src="__INPATHROOT__\ssh-keyscan.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh-keyscan.exe" />
+    <file src="__INPATHROOT__\ssh-shellhost.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh-shellhost.exe" />
+    <file src="__INPATHROOT__\ssh.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\ssh.exe" />
+    <file src="__INPATHROOT__\sshd.exe" signType="AuthenticodeDual" dest="__OUTPATHROOT__\sshd.exe" />
+
+    <!-- ****Begin**** Authenticode - Authenticode SHA256 ************* -->
+    <!-- PowerShell script files cannot be dual signed, so we will sign them only with a SHA256 cert -->
+    <file src="__INPATHROOT__\FixHostFilePermissions.ps1" signType="Authenticode" dest="__OUTPATHROOT__\FixHostFilePermissions.ps1" />
+    <file src="__INPATHROOT__\FixUserFilePermissions.ps1" signType="Authenticode" dest="__OUTPATHROOT__\FixUserFilePermissions.ps1" />
+    <file src="__INPATHROOT__\install-sshd.ps1" signType="Authenticode" dest="__OUTPATHROOT__\install-sshd.ps1" />
+    <file src="__INPATHROOT__\uninstall-sshd.ps1" signType="Authenticode" dest="__OUTPATHROOT__\uninstall-sshd.ps1" />
+    <file src="__INPATHROOT__\OpenSSHUtils.psd1" signType="Authenticode" dest="__OUTPATHROOT__\OpenSSHUtils.psd1" />
+    <file src="__INPATHROOT__\OpenSSHUtils.psm1" signType="Authenticode" dest="__OUTPATHROOT__\OpenSSHUtils.psm1" />
+   <!-- not actually a code file, don't sign for now
+    <file src="__INPATHROOT__\sshd_config_default" signType="Authenticode" dest="__OUTPATHROOT__\sshd_config_default" />
+    -->
+  </job>
+</SignConfigXML>
diff --git a/contrib/win32/openssh/Win32-OpenSSH.sln b/contrib/win32/openssh/Win32-OpenSSH.sln
new file mode 100644
index 000000000..41eb2b6c4
--- /dev/null
+++ b/contrib/win32/openssh/Win32-OpenSSH.sln
@@ -0,0 +1,612 @@
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 15
+VisualStudioVersion = 15.0.27027.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh", "ssh.vcxproj", "{74E69D5E-A1EF-46EA-9173-19A412774104}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libssh", "libssh.vcxproj", "{05E1115F-8529-46D0-AAAF-52A404CE79A7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "openbsd_compat", "openbsd_compat.vcxproj", "{DD483F7D-C553-4740-BC1A-903805AD0174}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-keygen", "keygen.vcxproj", "{47496135-131B-41D6-BF2B-EE7144873DD0}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sftp", "sftp.vcxproj", "{BBEFF9D7-0BC3-41D1-908B-8052158B5052}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sftp-server", "sftp-server.vcxproj", "{6657614F-7821-4D55-96EF-7C3C4B551880}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sshd", "sshd.vcxproj", "{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "config", "config.vcxproj", "{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "posix_compat", "win32iocompat.vcxproj", "{0D02F0F0-013B-4EE3-906D-86517F3822C0}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-shellhost", "ssh-shellhost.vcxproj", "{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}"
+	ProjectSection(ProjectDependencies) = postProject
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-agent", "ssh-agent.vcxproj", "{F6644EC5-D6B6-42A1-828C-75E2977470E0}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-add", "ssh-add.vcxproj", "{029797FF-C986-43DE-95CD-2E771E86AEBC}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "scp", "scp.vcxproj", "{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-bitmap", "unittest-bitmap.vcxproj", "{D901596E-76C7-4608-9CFA-2B42A9FD7250}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-kex", "unittest-kex.vcxproj", "{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-sshbuf", "unittest-sshbuf.vcxproj", "{CD9740CE-C96E-49B3-823F-012E09D17806}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-win32compat", "unittest-win32compat.vcxproj", "{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-hostkeys", "unittest-hostkeys.vcxproj", "{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-sshkey", "unittest-sshkey.vcxproj", "{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "core", "core", "{17322AAF-808F-4646-AD37-5B0EDDCB8F3E}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "test", "test", "{A8096E32-E084-4FA0-AE01-A8D909EB2BB4}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-match", "unittest-match.vcxproj", "{484A8CDE-B949-4BDA-B447-74685C8E032F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "unittest-misc", "unittest-misc.vcxproj", "{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-keyscan", "ssh-keyscan.vcxproj", "{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-sk-helper", "ssh-sk-helper.vcxproj", "{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ssh-pkcs11-helper", "ssh-pkcs11-helper.vcxproj", "{21D772C3-0EB0-47B7-A93C-FF624675A58D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {05E1115F-8529-46D0-AAAF-52A404CE79A7}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {DD483F7D-C553-4740-BC1A-903805AD0174}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {0D02F0F0-013B-4EE3-906D-86517F3822C0}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|ARM = Debug|ARM
+		Debug|ARM64 = Debug|ARM64
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|ARM = Release|ARM
+		Release|ARM64 = Release|ARM64
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|ARM.ActiveCfg = Debug|ARM
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|ARM.Build.0 = Debug|ARM
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|ARM64.Build.0 = Debug|ARM64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|x64.ActiveCfg = Debug|x64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|x64.Build.0 = Debug|x64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|x86.ActiveCfg = Debug|Win32
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Debug|x86.Build.0 = Debug|Win32
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|ARM.ActiveCfg = Release|ARM
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|ARM.Build.0 = Release|ARM
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|ARM64.ActiveCfg = Release|ARM64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|ARM64.Build.0 = Release|ARM64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|x64.ActiveCfg = Release|x64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|x64.Build.0 = Release|x64
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|x86.ActiveCfg = Release|Win32
+		{74E69D5E-A1EF-46EA-9173-19A412774104}.Release|x86.Build.0 = Release|Win32
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|ARM.ActiveCfg = Debug|ARM
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|ARM.Build.0 = Debug|ARM
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|ARM64.Build.0 = Debug|ARM64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|x64.ActiveCfg = Debug|x64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|x64.Build.0 = Debug|x64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|x86.ActiveCfg = Debug|Win32
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Debug|x86.Build.0 = Debug|Win32
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|ARM.ActiveCfg = Release|ARM
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|ARM.Build.0 = Release|ARM
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|ARM64.ActiveCfg = Release|ARM64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|ARM64.Build.0 = Release|ARM64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|x64.ActiveCfg = Release|x64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|x64.Build.0 = Release|x64
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|x86.ActiveCfg = Release|Win32
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7}.Release|x86.Build.0 = Release|Win32
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|ARM.ActiveCfg = Debug|ARM
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|ARM.Build.0 = Debug|ARM
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|ARM64.Build.0 = Debug|ARM64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|x64.ActiveCfg = Debug|x64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|x64.Build.0 = Debug|x64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|x86.ActiveCfg = Debug|Win32
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Debug|x86.Build.0 = Debug|Win32
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|ARM.ActiveCfg = Release|ARM
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|ARM.Build.0 = Release|ARM
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|ARM64.ActiveCfg = Release|ARM64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|ARM64.Build.0 = Release|ARM64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|x64.ActiveCfg = Release|x64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|x64.Build.0 = Release|x64
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|x86.ActiveCfg = Release|Win32
+		{DD483F7D-C553-4740-BC1A-903805AD0174}.Release|x86.Build.0 = Release|Win32
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|ARM.ActiveCfg = Debug|ARM
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|ARM.Build.0 = Debug|ARM
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|ARM64.Build.0 = Debug|ARM64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|x64.ActiveCfg = Debug|x64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|x64.Build.0 = Debug|x64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|x86.ActiveCfg = Debug|Win32
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Debug|x86.Build.0 = Debug|Win32
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|ARM.ActiveCfg = Release|ARM
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|ARM.Build.0 = Release|ARM
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|ARM64.ActiveCfg = Release|ARM64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|ARM64.Build.0 = Release|ARM64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|x64.ActiveCfg = Release|x64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|x64.Build.0 = Release|x64
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|x86.ActiveCfg = Release|Win32
+		{47496135-131B-41D6-BF2B-EE7144873DD0}.Release|x86.Build.0 = Release|Win32
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|ARM.ActiveCfg = Debug|ARM
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|ARM.Build.0 = Debug|ARM
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|ARM64.Build.0 = Debug|ARM64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|x64.ActiveCfg = Debug|x64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|x64.Build.0 = Debug|x64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|x86.ActiveCfg = Debug|Win32
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Debug|x86.Build.0 = Debug|Win32
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|ARM.ActiveCfg = Release|ARM
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|ARM.Build.0 = Release|ARM
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|ARM64.ActiveCfg = Release|ARM64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|ARM64.Build.0 = Release|ARM64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|x64.ActiveCfg = Release|x64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|x64.Build.0 = Release|x64
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|x86.ActiveCfg = Release|Win32
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052}.Release|x86.Build.0 = Release|Win32
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|ARM.ActiveCfg = Debug|ARM
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|ARM.Build.0 = Debug|ARM
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|ARM64.Build.0 = Debug|ARM64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|x64.ActiveCfg = Debug|x64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|x64.Build.0 = Debug|x64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|x86.ActiveCfg = Debug|Win32
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Debug|x86.Build.0 = Debug|Win32
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|ARM.ActiveCfg = Release|ARM
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|ARM.Build.0 = Release|ARM
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|ARM64.ActiveCfg = Release|ARM64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|ARM64.Build.0 = Release|ARM64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|x64.ActiveCfg = Release|x64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|x64.Build.0 = Release|x64
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|x86.ActiveCfg = Release|Win32
+		{6657614F-7821-4D55-96EF-7C3C4B551880}.Release|x86.Build.0 = Release|Win32
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|ARM.ActiveCfg = Debug|ARM
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|ARM.Build.0 = Debug|ARM
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|ARM64.Build.0 = Debug|ARM64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|x64.ActiveCfg = Debug|x64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|x64.Build.0 = Debug|x64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|x86.ActiveCfg = Debug|Win32
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Debug|x86.Build.0 = Debug|Win32
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|ARM.ActiveCfg = Release|ARM
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|ARM.Build.0 = Release|ARM
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|ARM64.ActiveCfg = Release|ARM64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|ARM64.Build.0 = Release|ARM64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|x64.ActiveCfg = Release|x64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|x64.Build.0 = Release|x64
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|x86.ActiveCfg = Release|Win32
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}.Release|x86.Build.0 = Release|Win32
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|ARM.ActiveCfg = Debug|ARM
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|ARM.Build.0 = Debug|ARM
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|ARM64.Build.0 = Debug|ARM64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|x64.ActiveCfg = Debug|x64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|x64.Build.0 = Debug|x64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|x86.ActiveCfg = Debug|Win32
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Debug|x86.Build.0 = Debug|Win32
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|ARM.ActiveCfg = Release|ARM
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|ARM.Build.0 = Release|ARM
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|ARM64.ActiveCfg = Release|ARM64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|ARM64.Build.0 = Release|ARM64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|x64.ActiveCfg = Release|x64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|x64.Build.0 = Release|x64
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|x86.ActiveCfg = Release|Win32
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}.Release|x86.Build.0 = Release|Win32
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|ARM.ActiveCfg = Debug|ARM
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|ARM.Build.0 = Debug|ARM
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|ARM64.Build.0 = Debug|ARM64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|x64.ActiveCfg = Debug|x64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|x64.Build.0 = Debug|x64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|x86.ActiveCfg = Debug|Win32
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Debug|x86.Build.0 = Debug|Win32
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|ARM.ActiveCfg = Release|ARM
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|ARM.Build.0 = Release|ARM
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|ARM64.ActiveCfg = Release|ARM64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|ARM64.Build.0 = Release|ARM64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|x64.ActiveCfg = Release|x64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|x64.Build.0 = Release|x64
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|x86.ActiveCfg = Release|Win32
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0}.Release|x86.Build.0 = Release|Win32
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|ARM.ActiveCfg = Debug|ARM
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|ARM.Build.0 = Debug|ARM
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|ARM64.Build.0 = Debug|ARM64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|x64.ActiveCfg = Debug|x64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|x64.Build.0 = Debug|x64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|x86.ActiveCfg = Debug|Win32
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Debug|x86.Build.0 = Debug|Win32
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|ARM.ActiveCfg = Release|ARM
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|ARM.Build.0 = Release|ARM
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|ARM64.ActiveCfg = Release|ARM64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|ARM64.Build.0 = Release|ARM64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|x64.ActiveCfg = Release|x64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|x64.Build.0 = Release|x64
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|x86.ActiveCfg = Release|Win32
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}.Release|x86.Build.0 = Release|Win32
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|ARM.ActiveCfg = Debug|ARM
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|ARM.Build.0 = Debug|ARM
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|ARM64.Build.0 = Debug|ARM64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|x64.ActiveCfg = Debug|x64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|x64.Build.0 = Debug|x64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|x86.ActiveCfg = Debug|Win32
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Debug|x86.Build.0 = Debug|Win32
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|ARM.ActiveCfg = Release|ARM
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|ARM.Build.0 = Release|ARM
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|ARM64.ActiveCfg = Release|ARM64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|ARM64.Build.0 = Release|ARM64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|x64.ActiveCfg = Release|x64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|x64.Build.0 = Release|x64
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|x86.ActiveCfg = Release|Win32
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0}.Release|x86.Build.0 = Release|Win32
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|ARM.ActiveCfg = Debug|ARM
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|ARM.Build.0 = Debug|ARM
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|ARM64.Build.0 = Debug|ARM64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|x64.ActiveCfg = Debug|x64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|x64.Build.0 = Debug|x64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|x86.ActiveCfg = Debug|Win32
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Debug|x86.Build.0 = Debug|Win32
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|ARM.ActiveCfg = Release|ARM
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|ARM.Build.0 = Release|ARM
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|ARM64.ActiveCfg = Release|ARM64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|ARM64.Build.0 = Release|ARM64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|x64.ActiveCfg = Release|x64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|x64.Build.0 = Release|x64
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|x86.ActiveCfg = Release|Win32
+		{029797FF-C986-43DE-95CD-2E771E86AEBC}.Release|x86.Build.0 = Release|Win32
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|ARM.ActiveCfg = Debug|ARM
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|ARM.Build.0 = Debug|ARM
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|ARM64.Build.0 = Debug|ARM64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|x64.ActiveCfg = Debug|x64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|x64.Build.0 = Debug|x64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|x86.ActiveCfg = Debug|Win32
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Debug|x86.Build.0 = Debug|Win32
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|ARM.ActiveCfg = Release|ARM
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|ARM.Build.0 = Release|ARM
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|ARM64.ActiveCfg = Release|ARM64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|ARM64.Build.0 = Release|ARM64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|x64.ActiveCfg = Release|x64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|x64.Build.0 = Release|x64
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|x86.ActiveCfg = Release|Win32
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}.Release|x86.Build.0 = Release|Win32
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|ARM.ActiveCfg = Debug|ARM
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|ARM.Build.0 = Debug|ARM
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|ARM64.Build.0 = Debug|ARM64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|x64.ActiveCfg = Debug|x64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|x64.Build.0 = Debug|x64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|x86.ActiveCfg = Debug|Win32
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Debug|x86.Build.0 = Debug|Win32
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|ARM.ActiveCfg = Release|ARM
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|ARM.Build.0 = Release|ARM
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|ARM64.ActiveCfg = Release|ARM64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|ARM64.Build.0 = Release|ARM64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|x64.ActiveCfg = Release|x64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|x64.Build.0 = Release|x64
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|x86.ActiveCfg = Release|Win32
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250}.Release|x86.Build.0 = Release|Win32
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|ARM.ActiveCfg = Debug|ARM
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|ARM.Build.0 = Debug|ARM
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|ARM64.Build.0 = Debug|ARM64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|x64.ActiveCfg = Debug|x64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|x64.Build.0 = Debug|x64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|x86.ActiveCfg = Debug|Win32
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Debug|x86.Build.0 = Debug|Win32
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|ARM.ActiveCfg = Release|ARM
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|ARM.Build.0 = Release|ARM
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|ARM64.ActiveCfg = Release|ARM64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|ARM64.Build.0 = Release|ARM64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|x64.ActiveCfg = Release|x64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|x64.Build.0 = Release|x64
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|x86.ActiveCfg = Release|Win32
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}.Release|x86.Build.0 = Release|Win32
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|ARM.ActiveCfg = Debug|ARM
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|ARM.Build.0 = Debug|ARM
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|ARM64.Build.0 = Debug|ARM64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|x64.ActiveCfg = Debug|x64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|x64.Build.0 = Debug|x64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|x86.ActiveCfg = Debug|Win32
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Debug|x86.Build.0 = Debug|Win32
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|ARM.ActiveCfg = Release|ARM
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|ARM.Build.0 = Release|ARM
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|ARM64.ActiveCfg = Release|ARM64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|ARM64.Build.0 = Release|ARM64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|x64.ActiveCfg = Release|x64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|x64.Build.0 = Release|x64
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|x86.ActiveCfg = Release|Win32
+		{CD9740CE-C96E-49B3-823F-012E09D17806}.Release|x86.Build.0 = Release|Win32
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|ARM.ActiveCfg = Debug|ARM
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|ARM.Build.0 = Debug|ARM
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|ARM64.Build.0 = Debug|ARM64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|x64.ActiveCfg = Debug|x64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|x64.Build.0 = Debug|x64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|x86.ActiveCfg = Debug|Win32
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Debug|x86.Build.0 = Debug|Win32
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|ARM.ActiveCfg = Release|ARM
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|ARM.Build.0 = Release|ARM
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|ARM64.ActiveCfg = Release|ARM64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|ARM64.Build.0 = Release|ARM64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|x64.ActiveCfg = Release|x64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|x64.Build.0 = Release|x64
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|x86.ActiveCfg = Release|Win32
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}.Release|x86.Build.0 = Release|Win32
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|ARM.ActiveCfg = Debug|ARM
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|ARM.Build.0 = Debug|ARM
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|ARM64.Build.0 = Debug|ARM64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|x64.ActiveCfg = Debug|x64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|x64.Build.0 = Debug|x64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|x86.ActiveCfg = Debug|Win32
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Debug|x86.Build.0 = Debug|Win32
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|ARM.ActiveCfg = Release|ARM
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|ARM.Build.0 = Release|ARM
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|ARM64.ActiveCfg = Release|ARM64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|ARM64.Build.0 = Release|ARM64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|x64.ActiveCfg = Release|x64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|x64.Build.0 = Release|x64
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|x86.ActiveCfg = Release|Win32
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}.Release|x86.Build.0 = Release|Win32
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|ARM.ActiveCfg = Debug|ARM
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|ARM.Build.0 = Debug|ARM
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|ARM64.Build.0 = Debug|ARM64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|x64.ActiveCfg = Debug|x64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|x64.Build.0 = Debug|x64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|x86.ActiveCfg = Debug|Win32
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Debug|x86.Build.0 = Debug|Win32
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|ARM.ActiveCfg = Release|ARM
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|ARM.Build.0 = Release|ARM
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|ARM64.ActiveCfg = Release|ARM64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|ARM64.Build.0 = Release|ARM64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|x64.ActiveCfg = Release|x64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|x64.Build.0 = Release|x64
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|x86.ActiveCfg = Release|Win32
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}.Release|x86.Build.0 = Release|Win32
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|ARM.ActiveCfg = Debug|ARM
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|ARM.Build.0 = Debug|ARM
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|ARM64.Build.0 = Debug|ARM64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|x64.ActiveCfg = Debug|x64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|x64.Build.0 = Debug|x64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|x86.ActiveCfg = Debug|Win32
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Debug|x86.Build.0 = Debug|Win32
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|ARM.ActiveCfg = Release|ARM
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|ARM.Build.0 = Release|ARM
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|ARM64.ActiveCfg = Release|ARM64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|ARM64.Build.0 = Release|ARM64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|x64.ActiveCfg = Release|x64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|x64.Build.0 = Release|x64
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|x86.ActiveCfg = Release|Win32
+		{484A8CDE-B949-4BDA-B447-74685C8E032F}.Release|x86.Build.0 = Release|Win32
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|ARM.ActiveCfg = Debug|ARM
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|ARM.Build.0 = Debug|ARM
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|ARM64.Build.0 = Debug|ARM64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|x64.ActiveCfg = Debug|x64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|x64.Build.0 = Debug|x64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|x86.ActiveCfg = Debug|Win32
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Debug|x86.Build.0 = Debug|Win32
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|ARM.ActiveCfg = Release|ARM
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|ARM.Build.0 = Release|ARM
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|ARM64.ActiveCfg = Release|ARM64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|ARM64.Build.0 = Release|ARM64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|x64.ActiveCfg = Release|x64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|x64.Build.0 = Release|x64
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|x86.ActiveCfg = Release|Win32
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}.Release|x86.Build.0 = Release|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|ARM.ActiveCfg = Debug|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|ARM.Build.0 = Debug|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|ARM64.Build.0 = Debug|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|x64.ActiveCfg = Debug|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|x64.Build.0 = Debug|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|x86.ActiveCfg = Debug|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Debug|x86.Build.0 = Debug|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|ARM.ActiveCfg = Release|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|ARM.Build.0 = Release|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|ARM64.ActiveCfg = Release|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|ARM64.Build.0 = Release|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|x64.ActiveCfg = Release|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|x64.Build.0 = Release|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|x86.ActiveCfg = Release|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}.Release|x86.Build.0 = Release|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|ARM.ActiveCfg = Debug|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|ARM.Build.0 = Debug|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|ARM64.Build.0 = Debug|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|x64.ActiveCfg = Debug|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|x64.Build.0 = Debug|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|x86.ActiveCfg = Debug|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Debug|x86.Build.0 = Debug|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|ARM.ActiveCfg = Release|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|ARM.Build.0 = Release|ARM
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|ARM64.ActiveCfg = Release|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|ARM64.Build.0 = Release|ARM64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|x64.ActiveCfg = Release|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|x64.Build.0 = Release|x64
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|x86.ActiveCfg = Release|Win32
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}.Release|x86.Build.0 = Release|Win32
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|ARM.ActiveCfg = Debug|ARM
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|ARM.Build.0 = Debug|ARM
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|ARM64.ActiveCfg = Debug|ARM64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|ARM64.Build.0 = Debug|ARM64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|x64.ActiveCfg = Debug|x64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|x64.Build.0 = Debug|x64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|x86.ActiveCfg = Debug|Win32
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Debug|x86.Build.0 = Debug|Win32
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|ARM.ActiveCfg = Release|ARM
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|ARM.Build.0 = Release|ARM
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|ARM64.ActiveCfg = Release|ARM64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|ARM64.Build.0 = Release|ARM64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|x64.ActiveCfg = Release|x64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|x64.Build.0 = Release|x64
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|x86.ActiveCfg = Release|Win32
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{74E69D5E-A1EF-46EA-9173-19A412774104} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{05E1115F-8529-46D0-AAAF-52A404CE79A7} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{DD483F7D-C553-4740-BC1A-903805AD0174} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{47496135-131B-41D6-BF2B-EE7144873DD0} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{BBEFF9D7-0BC3-41D1-908B-8052158B5052} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{6657614F-7821-4D55-96EF-7C3C4B551880} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{F58FF6BA-098B-4DB9-9609-A030DFB4D03F} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{0D02F0F0-013B-4EE3-906D-86517F3822C0} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{F6644EC5-D6B6-42A1-828C-75E2977470E0} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{029797FF-C986-43DE-95CD-2E771E86AEBC} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{D901596E-76C7-4608-9CFA-2B42A9FD7250} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{8EC56B06-5A9A-4D6D-804D-037FE26FD43E} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{CD9740CE-C96E-49B3-823F-012E09D17806} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{BF295BA9-4BF8-43F8-8CBF-FAE84815466C} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{890C6129-286F-4CD8-8252-FB8D3B4E6E1B} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{484A8CDE-B949-4BDA-B447-74685C8E032F} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{0B527504-2AF5-4E6E-A84F-10BADFAEDA88} = {A8096E32-E084-4FA0-AE01-A8D909EB2BB4}
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+		{21D772C3-0EB0-47B7-A93C-FF624675A58D} = {17322AAF-808F-4646-AD37-5B0EDDCB8F3E}
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {0AC224E8-C215-4270-954A-A2ACEE06DE58}
+	EndGlobalSection
+EndGlobal
diff --git a/contrib/win32/openssh/Win32-OpenSSh-design.pptx b/contrib/win32/openssh/Win32-OpenSSh-design.pptx
new file mode 100644
index 0000000000000000000000000000000000000000..bbc01fda8026e98123e9818ac03522ac80fb077e
GIT binary patch
literal 37646
zcmeFZRd6I*k}WD$i5W`F%*-k=OC@GzW@eU3Dls!NGcz+YGc)7UIj84#&+WE1bAM+#
z!z?3WN2I0gmA>44dHBws62KtH0AK*$0002+0i-xgqvrtu07zf~0FVH_0jUdETR9k7
zIcO`m+8Ekv(zsY!;N^e-k!1k@eck`>*Z*P!#u8Vhcj@4RE~8z7hZ>7))ln0Kq?!R9
ze#L@t`LHH8EO0a!%0PL#lZZj7Dx@T^sBH=+yBvJ-l3ttIT&I+pfK5o`A}xfqQURr>
zNS@gCWMq0dPpIt49!Zkr;_KR9o$0x_(7B|jUm+-(XI4Sva38J}A`Jyb{sxtzCfv32
zMQ)*QBzUJB=z3khAeZ?qJhjx#?+*j6Oou2RIDJpaT_K7^HkmU@QGF$zRHZbmfLDK;
zJi*iKfC@{mn85BuP|lkJGN8<XOs$Pcb#ie$&z8)0hljNhnpV?PKU5AZ<7jBrrez9R
z^8L2~WU^Qxdwic`wZ=QrKy#Gaa%iPaTTXCe525FP+tezns+2on0jLxwmK4Ye-qXH%
zF{pcCu_-G(N<7?z%H{yCJR~c^7*Sgt{}s)epbwMC56AU)`8bB(5j&B7B59OM?v>^<
zn7>0X=~?A9!ow&`j2#qKHVsd}ha9l*W+MTTrGX4MV4{wVeI$(m8QvkIiWgxJPP`}f
z>J=Ryhuw1(>(?H*lvdj!U!9zk^Y1wDN@!Sd9qMeVxO;BSekwRqLHG(Zdx?2F6CJ0&
zLibk_`CF)8I-E@Jajq&eP>#8}j$n3tasKlY7~toB@&+G5)4>2=SN6Wh4)x^?wCxNn
z>}hHKc>lK-_+L!@f0%k%jFbd0{g)T;`@|n>=Uk;Am|52nJd!ea2NYm<<zvMqk~jTq
zuf}WnxrpO7wwF#i39V`k>!g5-HM^w=I+_F0FYV6QRN?n{V0itF0)ky2*IA=G8p+~h
zHT51dlBk*dUO<#WUZW%n4MHYF?9qZ8g{NwiwLCI`2v<MY_b!5CKv9)P=WX1_tw%v!
zo^LIM^XEAI6|u!;ga3hX<zqs6nk&#V-WhbNP)IZHNK~OLOn*c^(C)oC4QU?yuW&Ff
z>$;Y;qf682nkanyIi8!gNo7506W4JRDI{JN{BJ=+<Y+R-?Afp8kjI{g)}PB$<hSJk
zv7M^kUzGS~!Yl#%nJ;{yGx0?lysy2DjRUQ{g{gs|J?&rI`SXPSk1+Zti^`(u&HLz}
z10VT6{in4!o3rEWCaCwfwhA6zfWym)3PLTYG)+G|*Yk;N1cD>n++H?-&*8Lh^LVOl
zBn`6XVaSLw`SZGaUiY7_Kz{Yh+Q<{sRpIq!w|1^}?(F5^T%$9VisLuX{n|6uUy5Yo
zTp%Z$m&zPD%Zo6iTYiRP&01z2&m}hpbHFU%0EOB|cFLlW80f5$-xP_Y9o9A`YDUl{
zgSc5m239Je1pWnDu6(mHb20*M->USQS^q?OahBi^FI5@eLI2Lem`dxg`8DHz#)Oyp
zdj`fA9>yR50Js3(0RO<`FEDKE4DG*i3tb0OYpeeQ$(LgR{7NsrKJdT$RTkGR-uFj%
z^}B>Wu$rxC`DM|9hVXzFQUMobS!hWo#gC}``VgdO-a^$c5OHgKFgeJJUwUs$JB(9~
zq()CxgY~UMe38E%TB{Kbt?@_NVab6Ur2$=*zoV;HgPZWMC%RoaT?7c)KDxt3DyO*S
zyzZoC0ZfU_jLE7!uK224Zz<~rf#%+G%*qn*NGR#@9Q0X12S^Pz^v9q&>+hl~E#*sY
z3hy1rk~)#cp>z>Ui)PDd#*jWSk!Vowtioz5IX%~o*ry%v?>*Sn1h%jS(TIIwvb(rF
z*>AGOvt%&>ShVDbq}a78qj?gLwX!V1H|lAIP13_vXiwJ$^`RNVWaE4q`2lpO>j-^h
z@BCB4k3YS>Y~r8Ii%q*iJmrgw?l1rV$X_P&hk5<qhIN*BYPCX#?DHwJ!YTN{nUAjw
zM4(`(Ss*6KpYI94N>5y(FVc`bWqR4M+t(bYB#(>NS>+iqxqsWuuBDMFZiXEi1!@do
zS4lENK(*`Ioq>2~let1)lh;Ev7{?fs#Tb3$_Iy8@lcMY=+JmfAH4nrnIbrMfAg*XX
z7`>bkr=oTJi!SQCiLBbM*u~DySG&tY4BMI^Gz}3AI{AHv@%7nC*<dfhI2dt_RTw1O
z5z9_np{8ERb6|xotPx+#gJ`ukmxy9tQY_0qA*vzo*_sLkq4TC*0gX~AnsmtC-xU5;
z7T~N;qtd5OXu@vWqb}W6Xzz2ujj)6MW*U|5&1tO<QP>}^jVC1g;$eP7Ix6#U0?(Vw
z_be@o3|61pw#6k}jk2iT$O_&;jeU6=Sn+W$ui->;*v|KU#fWh1$cm8am!m0y5wFFm
zNf5=I=sKi>IMo6K5LyxspQ@aJ?*zBkT1Nv8KDm%Nir=CIamM|%O3SyTWIq$QimVwH
z@Py)nrxr3I6+3;)!{l$8&rvSaiD{^=YCqLv9M+>Q6;wo^H|C1j`=QELO7kaB@-n-<
z_tb|iO6o{5kUa45nh*?b_@jn#2Ga+&9k`$|Dn*b2<gu@Y3WM~Xp13nndxk^==so;0
zB2Q)3O+e=4=zV$svzEe6k3@c?`~pP2_u-<AIH~OVCMr+wQvm#9whQ<2DB|nFqYqR1
zb<9N(`j1+`EV8tSL<f=l3ysajq<O4?g2cdRM|dH>k2g{4nfSxk2cjE!&MT#C>|T+{
zjP(L9jFwVNXS-YF$6Ko+&aKQ~0#cnkPxhwm)<ywU13!rldFAi4<Ai<1Pf!Rbv?tCX
zr_8j$1%p8<E1Mh~hv#9Y&v5_BmceSqSQOy_00PYc0Z{&C%YO?We-9jIn(Ef8!l+)_
zI-kJVg_>C<?8*}$j!+UcDOpw+g2NAn+9tnhmVV|X<arG1`F=#L^Db)F*yEF*7%hil
zOizdbBqIhVCbQp;J5QvsAGYFJ8CTn58@a}j6k^|%uiEwyi4MxzIj*>VS}mbqlhVE!
zoDG^HW;k8+wB7bTdcTi4-=ev4InB+Bef032ONQxv?CcT26>N`9c1j)U=1fS<SRA08
zm^(Q#OuS(_E~<L?X(ncly^$TqEgHi$^Q24W;9=!;>!Feawu_+-cx7*JWeVT6wXDA3
zJEt1!R#@p*Xu0NJDvtZfaxHk@KDSaq-^<#)>$BjFZyFrjou0BLBmGu%cTDTcEH*k$
ziz6M;J21Digq2>P=`4YLM{A6=DEKUCVQ(zNo_}(FxfT3G-9VMr@rF+51e?`vh=VCO
zR2R=wfMYY|Qdk`6STk}oQA}^t&3bvGfW=l=EOR^b@QMb*wIdaKl~*L;8m+lA!g$%$
zXbdj5*7T@HNU+YradEx1=TMrwK@(b8o<Udn*+a}QpGSkH;8qIbpA^hy)X?MSnpD29
z;!Qt!volDS&i=Ah7h9~BO!~Zt=BgW}BqTXL!-fHu%f_NzQ#$IE#=hv~v2qLp_V(7+
z_9|Y@Hk~O}(z!bOfOa2q@_qi4rsk;b);g5V(OtzUSi?n=Bd?5-TiHRA$UUZ2VW#_v
z_XQNelm7R>E?sj-OcjQHh}F<N6=V&Q3~7HO9|tA4DDy;|C}AU(A!|u>)nQA)O{@8F
ziubA+d)O~J`yG=4j24=`&Z%~<jPP;WZINnj9#v0od)E1H^V+jiq)OlF=#U%R9XtxH
zZHqrBx__GFahRtV;m)TTcVJ9BccOZsI;A}+<^)I*h{q?P9Y86*S9BPRGbWBR4(lz*
z=rbz36a94NJ_iv}@;pXM#%4UWxIjZ2Ho-Z{iN9)VeV?B^$bUjU+1D=2E#`%56pN-d
z?^yYTemxW>Yl{|K5PEPRFmH2UjCN3cvQ^F=Qt9~WoJJ;Fu9PIe+aW&Uj2#^7{IP$e
zuPUIq*^>bG9+sErNjDhFL_RSll;~BVF5#<Q!&MGm8WYAEMnnf!HB(Aq0q%H3LRN;J
zRe;VUao02KwydU>VmwJAeB~TRIjKbxx7Oau3}fGn?pX#GT!L|*xM(&*-hXPhywYHK
z9&9!N7pBT2;T>in@#1y>8GG>>ZPmMz^USR*6%u9DC9%48U~ju3HfMh)m?(tH|88jz
z5vO5tT}z6@?cO&%c$MEQ+GvY)OfKvBT|`y)=Od5kQ=BiFGzny##rV9ZLnKH4I#=40
zubZ8A`=lYNV_I`&Ub7d<8LVaj&%O5v;(PIgun-;gOD&nwrRW@7_uS;ol&G(e!lz7=
zX%wr~OD?~wVndmp5ogtt7n9rZ-L7b8TP$^qU})j);RFF3qvjZY5IF|PF00o;r>BQ?
zn9^MX*jd%Z<<5e1T;$1FE!E9#yw-8E*$mlh|K0e8*7P@x#yo5ZurNw!mMRZkk*!oL
zU!32BE|5E>;|N^adeB&aY(O?3Ti?16GT=nev3|jD$ud+qu7H&Rd~GWIzk(2}fxgq}
z>GXAlEVJl+JiT{TZnEdnwJN!F^WJN`4qko&@3-cUG#15Oc4V@>xfHlE`_Uf?pBu$N
zCRQodry}V6kTYM`VDKA%URQJ8It@&e)0_cU-mS^`cw!AKtzF_hFWRuDi+B3Il}GcY
z1DbwsVEwcG8`)7-mcQSJ0eJuj*fa^IR}@L?(aF!cZ0z(`4;6ol8Zbt8oIqyyfWWya
zD-~e0HFd@X#!!tQ@rA9DVTZ`_kL@yF>R^&8FddjK3?F6yb2bX|Cvq`sMB|hLA=tX?
z^g6)#jo&G(L%G*rzTXk{33z*PjCXL%{R<=D%q-!%Fnw47tN}Iv+P0frfw^RRz7D_q
zIm&A`P<TxF0?o;|uv+Vn0c02Cdp|@1gc4N7X1&F#B#0BxBDAjWK8zlYY1^I^Klcl-
zV8df9^I^(zV9>Vnjyir<6a?xQ`T7rCvw;YO$6@*D$uv1wRx)(^<(lClq9BKkR5bYu
z_LVpl*d4?>-$Kk0A-g5lB0m^?Z&MnuidhlkFw>o>xtmJHfI03eJ-K6Ny!W)|k3Zbe
zn4;-_Ym->-&T?lto29`eh=du++QiLLY{=Q%zFi)9XU0wOPGz=^iZ}ts!~VgMQH{i6
z^IOFB_oA+CtPyTn=e};$5Wi<65yY-FmZHbY@7UmG*pVDzO|?8ejL-Idt>wwYP>@Em
zJ$0+8#b8X2ybZW=wK40eXs;3uMzWbPK4B?VwD`uQ5ZKwK`gAxdS{o8uCT~@I+kKDn
zs7ZPG@@)+MpDh={`Ci*vV$A3wGpqWQL!)Swn@c=agJ34B#rxrwZbFW^CkX9GZD6DE
z$<&KO*0i3O(h8-=p36>hn(<(~-;hs~5p~5+<&cO`?gNS8nlF25-sGZi>}@>*U2A%_
zUUpRTz`7bRsREm*tj(>>%OQ-2`P~hNS7{|A3O@yg5VQRdD)-9G<n~V^-f#xvkHhFC
zAI~$uWzE9K<~fC&!e(ZW?xJ(*a-N#h>X)g1po=wv5t@sFLbxF!D!9X3Cg9~>dKQ2{
z1cg$zuOlk-L{97faLEX|(rHt6xnii%@PxYO4}8(H%4Sb>Ro9=dc1jtj#o^d}*S8#q
z{YBQY^a~SJ(#F(iF24zafF42VK-6>)FqE^U@4Vrgo}37gINC597U$@YAPoNN3<)0*
zXkp!rngL>YFbRQMEimOYjPCHm#P8&a%!;+%1T=)hw~zgPVD*=~a&Rx6`u%~Ep#^j*
zA00ptsI5$6z&8g8co03d24;A!=Z?KAm#q+$=xv#3#VF}0=`X{!M#llzz)P=sfSp=j
zQG8Mk)ld64P~`~SnL6gM_I9MX#QWx&+758dAU|9%e(9nPK}0Ia(25bH>08vAQ3E1R
zLPT!qg>y(#>T%t50M5c&^$d6mP>(PtjE<AV;^zS50_@Uz1#ks+1$GSb^&Yeh*b5v4
z4h^S5@7Fz@gF-0EbPp;5a|E18R>z6T%%=so54hh5i_WdZlJmRA#WZ;aAOi*bp{!_^
z((<~DO)tlppibZ4sSIx{-%dZZI*h2;sf3UuYC{z?0%c1DFam`R#rGZZOqq^L#}YOV
zsSC3U^N()>u>SjG|D5g)D5cg)rLIFFT6RN}wHu4az}uVPq6q-o9~(}K!Ud_b587Yb
z>s3!v&hxHn9Dp7cB)wi2lnu36v$<?Kg^;mFy{bYaPD--PqR^wE$Nk(jA7h8o22a#A
z3PXoqBfNnJD1(~<0|!R?+lYO;-v*>8plCHNxgS%qpmG#?%lI+6qfw@3XfSLPzqPp;
zzR(3k4huaYLV(-Y&v)Sgw4izl-8sl`&|n9pa~T?i!|Bx;Y@_5Kmtoey(E$>=Lcj6F
zuU@>+1Da;IT$*u%2m<;uB$cXg!5(^jf}q+^+HSfoA%ehN_I>~JuOLI}WA%*yWEXT`
zG?P<HI^23I`2ohEAv{@x18aE2rIl%gru<WT?fe^K04TGt`W~cXQvw2xE>ZP`i+(+G
zLcJ$nxYAjDsyPrP%M!LUKPBS4RqK)GDKH%U?}mN^afY!6CF?=GHQlwW6lz-*g9?$*
zBR3pEP4S6!D;en5^;({tHO|X>_e1k{cPj%DUP-h?Ad{dG{&_1V>`k(7^FY!`eM4Kt
zTC279mJ<Q0YHt`Q^7=Fz)!`1Viuo#~)*C86DU@jzN}T}gThfU$0_ZjMx03nGbrmw&
zChIx`Oerp3RKiJGI?U0f#5n0v$juyig@L*L+IY2HgrzdyciFi_j~OZ*%D4T*6ig}N
z2RmK@@u5c6;@vgPaW1MS6H?G!&in^?o)|rti$TJJNzmUGEtz<UkH=pIq-?CbPTEf-
zXWNFlo14cc#z8I}tw;(Yqz;W{5&z`8R)s@Td9&)SEZn`X)}sdrmPCO%|Kg^hf(qJ%
zu#3}x%YOI?K~FTu<Y9t44^oY3k}Bk4;=yO%J==j&4_)>}kTo~|*ly7r02dnh`qQli
zW9wnahECVyr0)W7Ik*~JSmzHuxF)1U_EtH>OM@^X*_q>~=Mw@tB0tU_l&SFE!2~bx
zMEhNQa(7az0<B#5bV6%0G(pIvYPGFE=Rhl<bx<Z~Q#4tcKU#g9xNU*W)8FhGeI1j5
z?Mr>*ar?SjIEMnV5baIBfA6jsOjeDvreo;Q)O}96(&%{%r~sBYy{0aA42L+^*F8%S
z!GBe-^~ASS5tIzsV>#P?s0z_wu$!t1c?6GbBIN-(Z|-4(_EQ5e11tiCKZCCG1HPJn
zZ01M#7XEEj1CSDc^1(GA(0Pk}&Z@s*1EN{IT9X1t9Yy^dPEP^9w|+cqzEIG0#O(%m
zq%?$rSkPtcgz#5_e)Yj^c6!JCPQWttag8_xfK+373Qaj9fQ7Jp-ry+skK*9y3F$0Q
z7zm;@$3p_Y{6T}`u7S9cCTD#bLHPiaUs>qD%Yi-`@HgLrz(Mwa{=+S8!EC|IKxCK!
ztVcF7!fm9ryY2^wMXisA*_<6Qm-Jc)^8BO~81&jX&~NvvqTayG+M3S6?Sl5S4jBP{
zwFmmB^K<03s)Q|%{cWi_!KRfaTXBnN&RC;4VUw@9;=d2AGU2liorR=>;J*xK0jq-m
zd<^pS)qncKF3dcn1V(_C$hNd=hH<Dr@BG2{=dLT0wj*sih7BaGIqs<K2MH|TK@T%M
zD;_LhAHL5$#1?o}<CFQ$j2gKg8;Fi9;8&vN!v-S54GXxA8|-7%hfk-Ci^5*{y?co`
zLzx^YV-Tcx2Q6+SfRw%1Bb%$Q1T_c`$P$L2>x7C;O-g7GDuOyND}!oR9)3^UnHrh!
z5&obFnYu)N?}r@!lsumd=mo^uZL{rU=KFKoT8u%0w@+{bV<%Xt09PYH`S%_bH<mpb
zxmuD#5_&Dh&Y%~?;Cz+_D__S1?x9M+K7bHFDjVKx(2IKyB-|cOV_8941wq}7G0y6x
zwHYWe#1+F{T}SxNbQY|J@cqRQ;^lC3RnXYCJthdsW#i;hB>7~qIl?}5895>15~VOr
z8pC>jXh|+h=4%%>X>&tFrT~Z-kMV$zs2ABdu_>QCKr!GLFrxGCu}njT_aG)I4HReD
zrWvj~g;e$BM0o^hwKD<uC~*4b8*W`4YQr55BXG-6nL&F=qL-QE?2>xNvaMbuT#j`K
zR*<f4%_>l^glT8@H*@}<UaHe~{&<m=-RtM=Iv1#ug&pt7yI?rV%3Mt7pdmZ3vP{%B
zG*ANTBq-F3BE;(F<kG)ha~99>InHK$?^=unCRzl9$<819R5R1e8#t6LXovVgM@(<b
zG-~Fb1(r{^+97IPF^Gj?t5SZE4N!pe&$vCND3^XHVKJch>oel*oEdw6jMhgx-&6G~
zy&e=c8}&3C)r3^Ev|N0CRT=)drZztvbKUlJh4riAM)i+%2uWR6Ye$FwRLuTsi1q)}
zZ^I|sA$#cH!LKy0uzSu)%Kbx_91*&^h3)_&_Ex}FiS}}iR#T__{C7RyKQwB+rE*>5
z^w8RZ)RgdsQgzZVnb#@?=TSk7?@$M~#ClWFAI|NjHB9<6B3x{ug=D$R(d{BQ^OvBR
z@JHc?6UESG0-EEBl@Z3V-Q`Y8R*LQ{e{eGP51WaSs{1!}5WedNSJ(%^c5{*3Jc|VE
zOsjGb8jA<^&&e;~?K^unD2yTkmRQc6tv>+&D-=v~wDD2C5Eumizfh3UwRbSI`%ftR
zHT3twe&4*5SuY(t=$2=;GhJ;YF=uFO+|Y6We^zM>&JUGcTr&w_IdRX|UkUusx+eHp
zzq?}Y4|Xl<cs*b}Z+sUVg`tMzU?EOMilkYAHYO&+sEH;d$_=cUAd{xLvpqbPI`wEh
zoAy?$9K=MYrGK2hKlLS*s$u0xjE8Wf%?-fL1k0>e$tqpe@Fm!5(YdDs?o%<clLJ2F
z^}O9O?P%9XX*#3eNI8E0`HD%Hbjle>YsY|wtCw#%1tmIr`o1i)$`lUZq}~utt}a(2
zCAl0FWBAN%%Cpx0{lxvyc${od^ZTbI87by3azai@y%ETo+NS*I@^bx|1p{*~GxM~X
za=jU)I14oShS&J&<y-ZCUAX;!H!}ABfkyU^C{X{ms76osKM)4-N=NpYujzMw@r~kd
zFj!eT7~0GK<I}UhkNll!Wl_~;!1T~TkNlh6CXt?r_;HBZ335YG`FU_U7VGK5=@wMP
zMAq5@62p8!u-Nw!FL&AJ7aTGteu4S~P~}!X@Sl+hU{HA?FH6yWQbqWsB4!6-GMu#>
z7M_DkOP?S{($|(C>p|s;dNBvRht%q)GsvCa6^}`qse;9(^ELyHx0tdNtTAS()6Mg!
zkiAxcIkp+TL2=%D-aRF}xeCXClS0eT>wvZ}WT{NOa6X&XwE%T<J(zsX`p4kmVnHPY
zj%#+Hzc4d~H9Bj5&HMk~7yma6<nQ48&vC~8$dmtGNcuMlf5d8r|AEfp|J@c?{*A(y
zEinHZg)bDC{*A&H3XK0o;R^+}|A8pLlH@mMeKkaAf&I~M^H)Q}-xDW$+P@$F86nFQ
zR;_mE;61fXKf6cVQ$YBAihlBum5Q&U#y<dS3`Ut?ubN{*ww`oeE{SC+*Q?zVXM`U*
zO}HG~St!%j<%=i!MYbIg-NEk*?h$K8wzaM{^Ik=<BpoI}NQ-P_m|a@Dy{{HaHq$8(
zULA7u6IRj*7w~0?@llq^1ms~|DDf*Ubycc?H}}B7H|p_`LdRzH5I<sg-+%Y6R*Mgq
z09jUuOXUd3fyOM-M9ZJEWO`0Ek&}hdO?#}38Swc{rD`QZZH<zzw6lsUPP5P7d|G<W
zpUnV1z}069+ULS&Kb_R9-Qmc8)#JJTi*3DJ!BD0v$cYf{XmizC$I-zUzBqobh`9eA
zvmuYoyO+ZR2}CAFO~KK&a@#?TO+x7aSyRD9YT8eiAFA7~<flW|GQrf1T$DD3E#NnE
z{=VOIzvEDnDvt#v#M4TQcDJ<T4P;dDY7?VWYu|FzScC4%ks|sV(-!D9z-KMHHJTG&
zkcAKR(Q%dCXm8rVlbu9vA5Y_pm!-P94{9Q$L*)y`XU@Jm^3FJ>A3~K~!T9JbN#pN-
ztk)bDICQUyW^UnmZA_I)Il^6K%1ysRQe>IJV<`1!MnAgy$7h!q7I=kd^N;`9hn?H>
z;vLq}arc^$AmD}NMDkwBbbQxMN|WJSCz3GQ&UG$=iLx)62>MBDBGkh0JvRxLWH_8~
zw9eL}@(klCGovYY9h+__afJzSr3evEvamNV7N+2X>DQqb7v{tJFxT<(trlxU?Xgab
z<0S4m&99v}vXg~5p$(cQGOzlbk{Gh={*g3zS>{%Ts2yJla`8r*+^Xef^)Vd|H(9oC
zzI_dyKh@n^%q&M!nMIRcLig_%xZy;>&d1Zldw8t12B-TTmZaC7{xIEt&W2l5$zx}}
z)H*&i006<?jQh{li2tZe{KE<TpY~m+v>vg;g5F*^=Ug>&D(NK#q^1%LpqRg$F01Q)
zDK(~3j#Sv7o2{7dS^i-AAoj8>rURyua4c!P)A#K0mTu4U+2-0x{e1-<pS&_C!Fg9L
zM1h^w<esjMhswxF55L$(QD=aXq0UKA&02)_<Ej8hRB3GoTbmLDJsxW-yI!sYhb>}E
zIj`>~Xfe;vTY^TsY)hVtEwC#Su+<>qvL#wxPfhjQ#dh4KLt`dQ(xrn&EFS}&4_zs$
zQ)61q$>g5dq#h4ZXY8nuyjT;)f)Bku>sPd`B2@z_!?hl;H<vjG;-0-y7G&boHD<sJ
z7Nfxq0$C8ML8)X?8JZvbyOO0B>U~=Wn$g|sc>9mKDHG~n`*pl4bhoOOV`278Z`tns
z{^xRWEufB5PA0ygobL_}xJ14;1&q9R2c@ly)z4;bBrC@xHaJoxs?5XbGuNCPA~`PZ
zZkjta9sAFup%k!vb+9m#o`M2ejrS$@f~I6pwtU^q1369#NM>5F>=`Izq3>0fEOY)v
zhtKVWYR}P`NuO%|T05>{QCO7IKNf-OrCh6Lb9wopAdkX>P`gt+fJgIEO0fwKau?uY
z<9u|2?)eGh-*q?oN@NF2J|M^=MEOwMg7XQ0zAscE0ty*tOVXs213JK(CXLaoBBib5
zhHf&Z#iAI4N*;Cw$*V;Y=IVT$>s~QJLm__pY1?82bblTzmzS?pz4JHkZQfN|atQ3E
zaOtnoH%;#|Jf-bnHJ}Q!1Zeu2c(jE#smR)L>s)zueb<JnZ^58%1B#}h1>mWC>aBPp
zRf#5Lwk~R~JAf*(eFjhCPNHr#vu2sLPH0WOZ=&dw4VGZDW(wnNXA<izLtBZ)lsTsh
z*K<D;(s#!ii1kYOy~~vGF^{be`ctuvi1DQgb<e6?CSSffno4otTg8K7g)ld%&9=(j
zj{ilJpQ@XpZ6xT&{ap3uj(DZL;Xtz%YosSV=#89qf;iK_TgL#9(NWv;gwh?BwU%;p
zk-Wi#3E$MK<MXvBS}k~o0$Nia;GL@J*v9pUA!fvTR%SoaDt2%*wwsnw;RaJxp>0B6
z#p-RZSPQLsak6sMdj0&%{pcpI=ljhh<y?triv;G`cB5RqwFxyDyx6SQp0OC@aWEri
z+MVwEcuofQDX4Bz{xBPq&U-gHE!Li266OJ|kTdIjPwc9xn0+^~c1dbl;yLqT@v||3
zne@2SqWx;?G1%$vC77J0V1davUwyk%wb*hNuZm}Z(LPR%O-sq>xC4U`No5%2>jq(1
z{1kWRdfa!Yf8`M@x_klnzAAL*^na{h`G=O<|ESXa=@I^+K6j>eYPH*d_~Gqy3+p#A
z*<-F*6!zN@ay4`nbjETj5AKIVU3pM}1KEmH16kFi-Nw${ms{Y#if%~j+sJE$BJ$Pk
z$_dJyw&}1ALVG=bWR<umOD+qOgVy-`eaIncV5k-H-1UBMHY284sHCtLm*@wxrmobw
znfdmrZC&a$ew%4hp5)LKRP^ewMH5%@vTl`5y%e)xJ@O0UC^g<r3}tP^l{N9sxvG6{
zz3X=8A_ldGd2)1+OMAjdXh3?@qTYa?S(s>7!T0k%r^w8_+%3Fbyar=zYnGEHz3Zt)
zBIESbVZ-CI$4EMQ^G6)lBsk29$f(6wer<urmh@rAD!1z@^GHEHZbd2OaFSK%JzPyo
z84Xd#_WKLJpA_9OhaU}o#|nTGI&&L}xrM_e7f++qN@wzLeh0q`))oBEw)ss>YJJv`
zVGP}dc%!gP+^KO?V>lD%bEuZ`#1mQOiFI6QonU)KvWYY(X~qUJS6Gd1`0R@N_KJzo
zvlb^o2>sb?lc1JqlYz?0`5xIulqAKKvT1XU>T1Wc?xH+h$Zxwgy=*uBCagRiXwR}`
zD0f}&bRjuxYu|a!m1~rEtL%=C2D;*@<cC07cq$ch%@n5!2VzSqt%MD|N|_670?GJB
zx^Kheylk*Pr00Me50QW_m0SdJh<q@YFOo0r$arYjdjy5RoWQIKh+YVMwtC|!j03NW
zT=Oq>>RS{V)3%!^-vjj^U~NknGeRdS6Qxw<hLg~i>vP3}_XF)DEA)@DiF{Bj)weO3
z08FY{u_+=x=%jjJq?o`g6F{{6iQU#J#FlCC!!p5SJ(8%2!r$m5GkMiBB%{Rb^?y(1
zT*2#3tZ+^H@~6zfUF}ua_8nGTOC-b-IJ2oUetZiX%IZa}L=E(4<D&u%hLIkLR|peP
zCyK068G}XlP-{R)wJcOPUogO0Ni<Tg(8<37R1tq3Gr-onlBuPE&3+ShKB&UO$EP^T
zTSdJ_Q^>YuV;Qe%Kj<g`*|%5mwRK=IuGRjL*L!@rO+Z9Udn4BU3`_~<I7=m}fUiI(
zMle}x|0vwtyt;C{!m2yVHdCh#OJHiuC4%_A9XW&WT_g|5eONU(itQNs-DT-}%w8QU
z23)MH-9w={JD{X|e~i?xXYra$Wf)}V=8HKA=7aEGQqi)cvaEMH+y|uUE0cG2&_#GR
zP!z=xlj#A^q+$rmc}a2kH0tMdU2ktQbxD8+-}bzf6?!lw&6uFV3iH6Odyo%PJ)8MF
zGV?0gS<iqDpA82W_YExAT_HN?4&Tk#+j}KJ9wd?>URmkh;n|~~WJ*`7FR_UZOKI08
z<5N<5q=NXCFi8ustwncWk;80__c8<1YYoy!GSEQx9O}r|>Wwl0oVXgaykDL^KRsTa
z7L|(@T&h<Mv*5C<)h5JI>7u5K(7<;cKrUj%g3}&!z*72TjS&L_!bOg4uzH|DCZF;$
z#ez~_otwE)uZG+GeGQ|BYiNv5q?BmJAp{yJyp3xpptuaKxb5Y9;h$yU^KH}ISVp^8
z-G!_jcanSk!$&hs_9YK_#?B!do_*NH!WO4eCV;7->Zqm|Os1*y`F(>-Rm60NG1I5S
z`6=<0_{)fDVur-^D19+%w*s4jbdJJK$HYJM39HHr27bh|6*lgRw~xXgQj66tKZ^0s
z(2;NtrFSF@IX5pKT+aS>$WYa+U0y9cZFCrybF8$Qnqj_u)LO5~H>Wt!(wv$3&6|r^
z?+`nAG(fGn#)C5@rPk6uc~oFYMJEAAb_rlC=85a#=%1fI(7*$>)EeZN#i2QUybms~
zn_BXVIDXomK4#HnFF*1;pgFJt6gh-{j8=(2z6F;$Y?Q*Br0I-+k-6s3(%e8@HxF*z
zNs%?*VU|;~omQx}+fwm#VA!1Gp8QCkvXOp$p$A_VA-&sy+on_fV_|z_EbvYmJojL(
zykj<ce&E4h(Tnv3Wy1Y2OGVBV79M;&r5gU{1bz`Vr3;T}@ruIyLfaycxm?d!)9;C&
zsK{*<MP%kp_dwPlP;fxXufCGyknz+c4yrcoO8|TgSv5vxjM`Gl`cYXfTV5|uox&?Q
z0zOd3)_maAk+6EW*nPSjI*d#FIE4rtpFnt#8Av;uWdI&ReavHE*EV5nXRrL&w}g8#
z0a*SIWB7|~m_uSvc0Op0@*+c-AkCkMCoKcZKXB>`>}bW|2MG5n;p~3b`f^$E;XLo<
zQ*A~>@gn>=V9K{4fpHlb)yXr&JOOs&0OcwQgnjpQ|DTuJ7X7%Sc6V>i<M}IWtv+7s
zxf6?D^3~{?+4Fr#X)yGXrq_9~HcQTMjy;fK+Un4GJ??yYx3G3=AG5l^w$U@WTTkew
zF;De<9?tpRnM9{wzmCq9Y%qAiOg=vbKH#>{v$$IUZ5~zf;L6i?$=Fek*W-=cZ9_kc
zs(9yEI(J#Thq<3I|5g0G|B3v2;432+{#r5mpW^So$jJXJy__kp+pVx6cWfqmg8zP8
zp>Np7P2vZ~JUWwHF+hC*_(kp4ShFYY*LC4gP&v;dotYP7A%IAR50ThjZE$=v%f9)1
z_jqvLLZlPeOoo20ejzjnlw?Fjdt|x!!j`&J4H_WGBoZLI*2towVh!&7ab0i%5u=?0
zqb{CBS9Fx!Q6E)v!X7b%+9bH+r<hdI!M;lzbCS5p!7kzq*-8|#cpM-d3Tei?`%J#O
z?4f1g(pO^`T3p7*Mj}e_*`HG+7^al&r({co9RB@%inzI0q3$L^bN$U6P=8Rlq`w}F
z;?6?c?uTqKhLJOLUbr}@ev2UUF8V2kX8Z1ZUCV({U+_FLxKIT`N_4`k1C!A~VufVC
zE7My;dCrF0goGvqNmq+?ae(FB;<Tj;HJ=izQR{+*tz#F9dN`a4=Q+qkyO^Uwz5VO9
zizQnvKO*#+r9ydUPK&`ZDIl5r_0iSoRRgNySW6iy^*KgKbt$Km;i05Jf(9wo=8>3{
zf+>b<<Tv(sOuuoNeBJ?=iZ^1>QVjXm-MWJxuyS$+nLY*phk+oM(NRgjjGZy<{L=xV
z0$~q5035BM=?Tf&x4VsROay?7Acij8q7@`JT7wBsGND+}&G|-Zm*L)g%YfH?US&+y
z3flu(@NV4#*q~NtK`TE_fnR)2U$6D!=cY(Wb7x#tqRXKpiH$vYNmoc?5pD5EBfDWx
z2D=N{^qIgxD(Tn(r}IwOb}VGCW&z&|0ZA=}_je2gU4ZoHd4Zm|414uQSf<mZmV@4m
z$vGVeFB|K;C0-3@VAV_`qx#?+EU{eApA#g^tuHHNHfz(I?H$>tW#2AIY=LG0R&+@*
zR^fx9xgC15xdWz)QuBJrLI<>0TBR%a<Ap*=`_E%`OY=J>&SGH%$>seJ)=M;Cfd(&&
zT4OQKU6g5(`h{=J`=)tczq^Ym^{`MP4cxUfXQI`%Xs0GN?>Xx6&>|=^)-}8C=y*z7
zO^k}pF)$DdMRW%ny55E)USYKrrFQu7h>jz1-i8@K1!rtZ<wmc6@0kj!NL>l#d^op_
z8;~tTa<PfCFr;+YQ*d=IQS<hAe^`vH+?>o(l&@>_tPj?PT%PNSL8FKwIu6ppARX~!
ztKKduUDzaoJ`>v#NFuqWyPtoN*VkAYWn-C)>b!jb-0f*6l~grIgJ4NS`%anK7$slL
zIYz0JbQra2ibF@4H~EV$q8&a+vzCx^ps|5z<D^f<@vVgDjk}~mNth^~Jy~v6q4-fP
zH#$8uqTTZo#_M0Mdkc+iD!2Vw-}U;nc;UZt0)JK>$5d9Wc3I#(X{Ws5=ZuAN1T`(n
zYO4%eHStnG93OzuLn8v`%ZbkG)sdGrPrN3)h9`c;>>Jb;ucGs5jfEKn86QBi=WVvF
zqc&G>^BXC$GYlu|W3)+@Fi~C#9|Wg1qa+6@lu4>;#d{cBG%;;ve7?=5x{=-9`JI>4
zGjs`)2U{3a#FYd$P{*RsCUKRTY4tQ35<?c~kX@W9RLSVH4p}bR0=4R>nl`-bpud|n
zk0J7u$2fLN%%dZ48AD!;Dk_amsCkChtJy#p)jfEMnkoA?#*lW}CZq(RB4Z{I9I!uS
zP~FUtsRANFWn{JZ`e__h)^s4G=~u43QJe^QQrFGwAE=?L{t{L*oVDVu({od?av1c=
z@>+CUwrNEMZGeZ-=Vb7$!~R%d8*CgAO&QM1lu}ZT93m-QCY*6<^zp1BbDQ^h-N0_N
zKO~W7XC2xog{>^3E!oRu8i9P{d&GQvK>R(qv{1@&2Psu=H!iY%+|7j%Iz$+~*(Azu
z4DUAmo&`Th>a|t3(Gq<br1dm)IN-#suqqaR@$(&3?J7QgxWtdC-7@?@j(U#fu%&ZY
z42pbzbdyizgPlP)pC-p0@C=u1;VJhXglr%B5u3IgF3bqV5$90#X8LD*_pIdi%VY%&
zbPkRx`tENS3M&@+Z3{dOOZA*GwTI`+y=0n)RNJK#!5S=U^6;V6jJo*YANEgqUQAiO
zkI0#Q&RB@p<A;%=OpqircL_ry$PwUYX65(9X})TwKKh9q<HoA{svMIy8gN%r+qN{}
zFr)aXjV@LIvZ}=?$y1m1`m}4|Zk$eyGw;YVnvEjj?^FHgSfFT$p5#p-)q$t?HsAqz
zV-bE5IcNc4=;}>%!4hpzN64IzwBjAeS|H0i_i$IjRspi^o-POmVXQ~jEmnDx!;8Ua
zd<`zWz-{>V5gS&tzy3JO#i8}%_UddW`r}jBSX(e}SB@8~AkQv<B6oOIohsalQ^vuL
zSWw9{yEn^@X-<wFBgmb~gO1Z4R@gG}#e^Mt&o!loQs2B)rtV8*lr*`g5HxxMG1{NP
zBy%8sdzyhtv(=Kp@S98eRWlcCJJ5v=ZWE=wuWL@p+b9}>W*R%2cULZm-@egZ1yL!a
z*(+T<%N}-|v)gQw>f$>4WL=^fx{ZVMLc4cueCqaJsw69;FnA3?af8xI5M$_ls4xOj
zI;_2o8lHCA*sp|uXbPfM%{JLK(^%p5_45j8Y`H=f;KKawSj=FvJYKp7vt_GKqlcjq
z7qyTY8ml$Z#R`nrZFS&SE-V+El=$In(cty|Hc6|^>&?zraZ=!((Q|B%uei#%KmaU4
z63e$WFb%Rb+bmQFyySh`)p*b$V#*adP!0YH=kN`i#P786wzbaP5$R>UwRH$lcG#?V
zBBsOy_sU7rb0?>Q;XQ~{`t@YNxb_s3PcV%SzK#j7p<>=7`U&&}&XQ)M_QfnWHgC$<
ztgP^)tj*j$4~=iLm6v+rkA{MOE+f92A;$ZDB`uI&C58XWU;X(6wM=Q-YLx~4gIDMB
zM^Pt=SOe9v@Oe+nx$ch@5c?N^a6usr@@PWS`Hi1he<dv<;x)5GqiqA;g1<Pt+Fmbq
zkF`3N6``30DMn6{ku;uQ2^<IP)i%e|9$C$u&+zhX)Aa|;8SEbf*{u&cKW@|{QATO6
zGpw0`!qud%$H?nZ<tOD;#VE>Xn(&xCD4WWvf|Okk_Yu88&VIQ9Z$`F3&aNCkjLJXU
z=45?Wy|GY_R%^tIp)2e5R+P(jW3q)zi4p`1Uw_Y)aHGXj^Lj1xFN?O=VzxPecW%&S
zFR=xMVpU-D^TCe0Q3H-){<$NJsAuGOn~IESOMTwqJYFxz#LBkrHF(P7VDwOLb=K!z
z^<I&=b6gP>|J@h5E|op1w%ygu==T}Z$V&fNQ%bzD%#zXm350niZ&#~xQD}+dg)N&u
zPg+967QEtRC1N7iYu3+kd>kY%%#H4x-^<}SXGx1-CAH?fE5p;t5mfCGE*-4FYdt1t
z*Ky?S)9%7&VRUe(K_K4WS$at7U%h7SvJS~}m%;Pc3E1b4sFhMg4JN_&fq&r(s;h;g
zp-yq)oZXMTaq{+NWJ(hqrEG`CrS02HZ5dijdpI+(1IzZ<%vJddW)NCAX42+zN+i1Z
zRR(V@Y#(;B67AYlqMLr>1e~6E;@XiC+duZ{{RGpvEuY&T4%vnXsdE9l`Yfh7Q*7)@
zdBbDJT#=wPsn{O8VntRRgDi~IRp*(==>;+?3*E`Y`%bFM0l7XDsceNVT;2LDC$RO~
z?mm$ink`}_&;30|@K5IQp_C0v;^vhUx3?sVJc@J%zf=E_dyhRB&!SI0k3DRSD$x3g
z%IZFEu8E~d1H(CE!|~>3*2h~t(3_byWVMFSXY(-Pw5h{`aOR!1a6xWDOksP!4a?G1
z@V4-YZYT#zfOjJ12B$RDhHX8%w7lz?do<m>Aik&;v8t~XjBMD09lRI;qkDMjh6I(}
zt@86P=eLQ<n>^m!{z~Uljg&uoY2z=9Oeo1gVu)f*q9TxNcr{wL?SLMwv45}Ko1h1o
zGHB%qG<jE%ek)8SYKVW~zD%vc^Oy@#WQx_e=GQi8J9%N3xr!8ol(v*Wd(uQ&(7CPr
zmg9mIPU0_?NODz<Ti!@=jfun?F4@t)Q&LS(e3nUGF9GB>Ax$WPgyg>2JJI>Y(tqZ!
zDd<Az=~upig8pCg_s^%^XGyDeUrzyiE;(nNubLJksMUG8ENXzkIMRnnl6!c3^uo3(
zsGDQ(rlgG@>Q@GrNsEbA)A&`uj}-0w4OCz5GVeZxad~LM)>L!`7{x23Z1$7DNFbyb
zZyYSY7S5FoF*W@l5@IKQTG7z8@@jj&4u&&KJUpgWn{K8f^1q^KVKL^9(_B3mhDHm~
zo<>A^wh~wM4e&6KaT=MbH9%`V=aAMxBO^3w&!|_GDV(M122L4+k`x5hWfS2anKV`%
z##CDlQeqe*7Ovbt5i1ifE_W%2-QP>z;QcVdaAQy(($(1zeUG)xzyLw9!z&O9RT&_k
zwsv9HMK8rseH$CGeeSyRYwZVStWf|w2`td;EGj$}shPrdw|<tN6<XhqLn(=0pi5XR
za99z4UonHG4UAUsA2wo2UdK&J9SZ_CS{(;_SSS!L6>myBY5L6(E4jA>U|x>l>gp;H
zOS^`raFRP$Ij25Z<e+59ZZ28*^S<pQ|H2}G-6VAAG(a{_@eT;L>7zo*XBU{)#>~+7
z@WpHEyi_B5v_j><v_)<d*RWL6uZ0~=zj~zFi)=m;)n80vPc;3zWZC4dnX)a?S60yv
zKi6eS5-t-0H3nUt%%u>M^MK;!oSzA{lKQ)zYLNP}oVrrMV@TG|m`P@z=7Kma3z>Ca
zc*NoG2?zuMAU>aUBC6tBFIkxfLbDdQN%Cq_&kv$x*<?B#N`qaLb?v<$G>njaR*o9R
zMDfNNj?6k<q)5qH@jJ(rb_AaS!gLCJ*Goms1#>@~fdjmbN}9`yCL~Ju=M}64&H;*u
zO$0!v|2%EV2BHPwSW(x#AJZ(;n^*CM!fcLC*jD&DUefV*Tqm0X<3uS{VP;wD37RrL
zuNF}0FR7jeD@{7rbOQJqZ>SCYN+GBc$(80eIgmJHi>3Ag9B+6Nnu1oJ#j#b=E1s60
zAz7X&3Is*po#YZG;0g<=45Pn~6gu{l#0-Z*jNW5!LOhlXO84COeS5KcaP8miydLJ!
zSUqR+2uBi^BOHWEYs53##UYh8`fd(aX5LG`6*7^WR8P`_+GpVg^3*W&pk3al7B#A%
zhqBW-i4cqbQ^fWD{w9G8?#I!I$CI081XtEXx4WiS<>;m3v$t%bzrLetV)yOIjn&M|
z_v^j9dvVJRakb0(=XMrr5$7erM*xU6q?K-BGkc1Xk+%D5h?1~4WdV)L6$aQs*OK}t
zq`O?6a8Hx3Os5VHn!gm>FJs<+J8L%5U6&W@V_riuUrsR^#U+k={Ch_xRC?vZZ_6wG
zK6YUP?ERgAM(#l;Y<R0P8lkD+-+6E$`0)o1Tu#4~a|S30#pj!sA0%8LIwe6l?}kA-
z?BlOdH#HUr(gz53xg@G>S!r<|&vNWnnw_>?DW<`tZqs?CNCT<QhOLL#uvDbsz)(T(
z8eVjcRD0<n_y?~w*^VlE6DY?+<0>rcyk1`(Wi~rL?0r?{rR;4f?VqU894C`%B`Ibu
zoq<>*UgSL3YPPZnCpXEi%A+s&&>wTP&W3ME7Xg-}&=(p<I`hUonS5xi^1`Te<7SJS
z#7$(iEmw&>2g>r2JJ!LZJ#pKAP}EB70-}qNo3V;5rzlC3V(}`yjItPK{&ek};*&cX
zK|al9Ae3<ow<sW6Pd$B0_5PQc4*AxF0rr;<jsE(7um393`Lj!^Olkd(|4Qh{taGla
zIc0)C2P*m*4KSPcku}ZZlbVD$U(LPxbBU?AvYuNy(_l~<NOM(ezEA25E3@;GbC8{#
zdo=;tvS=o7OMsRGf?Lp)<i>9krakpEdGj`kCEzdsLOOUO;;Sv-?z*=a%OoK)HeCf1
zgr^B7D!Y+E7}oEHF{K)!CjrsEO#^ZX5t!DzW)$TOK!*fsT~8HeT;7(JW#xuGZNex)
zE>d*4#E8_spsX<TUZry2+;7%r9P6*%0IRh7P4eV)kh%i8a4p-0+bDTOOnBjqZ&Sul
z353$(@EYpWdvj-@35&nvT6a??#cB35*!@SxHL?jBVa)_+i{Q+dA4gcNklN@v%^M7=
zG)rbGx<FT8xyhC%cz`K$)%|P4ld$uaPflRgEtow8I8A^+CjHbD6zwXv>oC|*;HGgD
zV=EI530fCJpt|(8m9HK!P>fnf=IwXP+fSw}VTb1ok}U~t(qZhNN|9m!XN`27!duWx
zacN*cpBeOCQ|vyCWNmeX$ti2x4M1{Sb*Dh5gDCcP1a|$=BtmTKmZ;Ktx8T`KlAc+4
z&x0}{=#j_24<CtFVdd0C@F`kt1$hNqky;${{U9?|K)E5Cqs|_u{)H<$BVn`B?Zp~i
z$TP6Mge$UM%{y?NmzlTA7Fx)g8WszzARp(Tv{sJNu7-J84vD9k5+~d9NNp;do`u~b
z6utv|8RchgnK2nkpsk&F?Oo!RS~3<;h2pK1_&|SB!&E{s*2pXipIt1a?;fy%l^8AE
zJLHGLE|hqB^8iZwgx=P*1h8l=w|mhWy^0#Ce(r@K^JWv?$`g?@CzE5knmJ%f3)?FV
zB@^ShY8I9z;B<MuP&lZanStYto2|S)0}cE1E7M&5a!L&afJp3RU1>!E&y(x+IuGvA
zdg1)3RvL4c>G=07%NlQ0=oOy)+;|<WD<cfyn;A}mP(c8ygndkC4NjRaGMs{#Y|}DE
z;62kCJlLk|x4DyxS2PB5rNmO|*Pfi<_+lu6N|p*C@kb%4bkUxpO3uA3y=c}>#9ZEg
z*^FS4sL-47#jPJ-D&oIvM)<R9yG*G&;!8%fqaE?WpQus}Cs0))a8?<#l2r}Um=!t;
z=O_u1MH8F$OUvSQ&U;CB<Ozt^I4`D_$379r&0X0ZjPIIgwQu}QMie7yJpWBb$fP@`
z#&bGF%`{EW?=mNIxaXuT)@FLU5tIDdXLXru!~hg7CviE6Qws|{EG{ELQBu~3!stNJ
zP*UkFZF{r}<ppx;Z}YwU4;f+qmyEdjCm8|zHyN=++>QoM4WG-(39iby+$Fv>hIeN%
zZl|ydiOTYaj=;MEN1ugeti$KD9FJQP<sU1v@`~4^zQ|jDZ)lDUIRGmcux+~#FgDUY
z9guD#UA=rI&p3lrO-4}RYb^#IUQI1DUg&~|s}EbYWu~;wtR5fPXI#+o_Icd;iKKYC
zX8Na=i2F-Ru>P}_kjsKmFkbYki_K-kR&`6f^00<=h0E3KLn^payZl~F+rw3ciTGx?
zM3y#p(dszrn~@)Ggd24bvZs*Cs$xnI&5c_DkcG})m*4NA3)sHftu;Be`279hjVlJS
zMW2n3*q9xQwF$&H2oT&>jBm9(1e?v<dF_o_Fy#b*3<R@Ky+qm+C1^Sb8{{5wd^Gqh
z<%zoa<hxU*pZcRVn09P<uckpB{u#8O#N%j4YRt$jVDKkg(~f%aXe~l7BfRM~&{m@<
z(;0J1R|;250nE8bezHIEJZaH*5=uMSs-AuHspbz&7TGrxqFo}%+$rqm>lv6{*|Q1%
z>9zFW>m3fULt8}J&x=tH*laVkXq5I%al2OL`PaC=3k<58Af7iCzo#M2CY@31^iADR
zZ{G2xM+4%M+M1oUwbWqOYM|%ozXXQ;UjoCOVnEr>UR79_o6!6ZjbT;#DB}`J(+$PM
z4)9L(r7<*A8n!*?+N5^_PbYh$F~RswNV@HgXm%a2UcH#Up$+pjj0kG^J0F(Zj~;q^
zJ>NWULYd6NdfEdszX=~(1vSL*<B8dEW903EtidT;H8lmjHev`}P+$b<ri33J!(ZT@
zLG*}`gr0YKjlOPBf0Jox{ACnFsdZEuuB?f91o06q+Fg7O0^E7Jjsb1R_-jy~7t&8Q
zk=W)-W7Lvdnj`UiX^ifjhH8xBv&cU*2FJWK!I#Ex+kBq*_?H?Z;Z1`y=}TjrBK+5p
z^UswjZAqtAxopUTot1T$K1-9x&<CheoZ_N2YQ?iku@k^eTTCWjRni#)CCYL0bDjyV
zVJytpAC=3<=ZQK)?7XjO`k(Y4SGK9fD?v3J)M576>8dTlVNH@VJ0BXKcATt0nx*XI
zh%xb?+>6e23%puyFQdU`3dY0#UwdaAmPfMXVI;UqfIx6}cXxMpC%C)2OYmU90wic~
zcefDS-66R9e#z`zGTgbdv;S{D572beFV$bwsqU&e=lqCg6D>-Cb3co2XzAMNL`hXf
zt1^*ZsH=~HJZdIUk-oK_ZBC&(1^U6oXf=2`l>RBG^nRB9annAf$5EqaKOL>fk1iDn
ze!Wc9Ou4pd4@0Bd6b@r|5f^z`8PO`Sr&d!t-oz3V;k`F-Y;OeBD0EzBKpNAQg-CTs
zLRnR)l0T8v-d>VCg+}+5iwboi7KwHl3#*hQik|}HqLL38qnoCsQK#pI_cBYrX`@kn
zoq$NyK|OrXe3-5xSFUDh_i*R+F_VrquOU{M$%tB-6@*EFB9by=UBT*%6<aO&$mifo
z`RetOqCtj74GUqYlhEU|<4ZK@p*4*XrQ3Qw^2ROMSvJ_MS*cetI}m=bNR2!bRhcNH
zj+XN$X=<_W)CY2~>;y|iJUPkZGmcvVD1{`#U6nh8nk_!452Je~%g-(uiNTR&502<*
z`2;M%pEvuNy1b=4A$-7KGZrf5(!kI~lg7O#7#O=Q>XD2hA)n@nO;ybAUuYY96$)e@
zX0?(SnT_2DyL~aoZgns>>lq*Wp>%-CFZu^Q1r&^UNNEkk{`&rIP8)w=mi~(2`~mue
zU<-8x6-+qj@(E^yA@r@n>+1BclJx{*1i(Rv(!13yAa4?MY*5u%4nQTOyK`Ngzi&c?
zuCYVtgwpY(l2To90n2lFuHg5gN34ovO@cv(gEV04=|K=gqxkyg_$~pP&ij!L$p8V4
z-(qLQ7;paC1&7GW!q!c|k&{EE`vJr~&09|9f7&$houD2+60%m*z#-gurTH-8V&*mc
zJIGbUL8au?60sU3OakKF2^W8>`W6iY+9uR=Abj-VCsnxE2pc{){$}PUZ#aJLC@em~
z@82=UAmFp`y;gvJ-)Skv2SEV8liskHPgZxCCO}JHsG2xhs;(<Jm4Z65Q9ni;h(9K6
z2uNLMBIBx<R^8-Z>Vu_OMG+7>K~H^!^0t2Fn99dQ@5fCKhMS>b<bxSoSkGfu=EI`*
zdm=;%SqBc;BmGS0=B<jP7?iR}_810<a4)axAPWvO&lS9<_bwP6$48)LB?C=V!rhHd
zvGWyIQ^x)3iXV8V1NjlGtd?ff9+T%_(~w$+`v@da3bjkl8b#esg8N`Rqd{+HCz?)L
zxXk9($`1l#d6|ppFJU9)jHJE~(VKXqUMFqNxpDvk<urtJ+IFHdN_bnI&gNr|p5W<J
zH}f7)Auj5R>&?w9k_7PL#dl`q>HJpL>-`Gwi(BirF&(Dc*-~Gv_xW8w@Ib~Gh-|92
z<BEF>_#VeQ1an2Ht0zl(qb1jKe5ETo^{Xh9+Drkfm>};AHZl-Io+E=@_<Ca=YiLns
zUzKwVgT$-Fcp0WNjm0i*|K&@pr&3;bb1ESO3X+G1n8OLmUrn9J#E3BV0=hMH<o~@}
z`{f?pq^1d2szH6A{mu=!SDS-=@s+;6E$JYKj|6IO2n4WFGZ8D4n8SUE3TC2tU~fX)
z{7I;FZ6+N1ytg3^0m1DEAA#8Wx{k`;ieD{b^i-p^j7po(SSr5Qvt^2xS0++!+B|yj
z)pixp^lkXWZEsqp&#m0WK39D=CC4_VZGsc7?mqdp@-ovt8!=dEnW?bEwT+0nANxYZ
zJ4XF$N?Y{$U9}_|G&ahM8t(nEkKatxr9_xMqJP?egCb<#qI={RF4QPj)}EmdG0%!E
zaS7>CeQhL}`RJ;(ml{|O#`X0AtB>pBR+!2f2#!$IMq8HGuxp`k9kLX%qH0VeB2r?6
zt~zrG&Ie2PT30=dB*?-f0oHk5jSo%K=nQmMsk}vqSILYjp_EEOnmYS<3ljIKYj4!;
zsjYE((hBU{eSokE)<I1bo%F1oC@RdsuNbgJ^Ugk;q?=xHP%<wyG~}HmYfzGJ5RTc5
zX%eQUcUMcypE~eQuBGxCe|<C5E)i%=3n`dFa0>F>v6jSo#OW=oseQHApgGd~8`dG^
zOxh48^{^>f+aM{sHwCC9dy1VY)1CvW?6D^Vwe!HlMwgtv`!?U_gT3GoPgFW3?)#i!
zF*ntUxfC!n3jn<u$w1|GM9&wIxJZjk+hM42BP%^KkTATBxElO2BY5*43>oWl^%9)S
zX}I=p;}f=^95=M`jgqKX-yagVJMYYugg4XiMb{SP*g!;+l_((v`R%iY(opE&Wx!@6
ztC24BPyhuU0#nWX{J8@(_3P&nc`*pzPG$$-Q2WnajE_Hen-yokZB5OT43w!(tM#!p
zDb^2O6KsWR;a&K>u8^fE*s(h$4>L<KWmkXS1e&YG*82u`Jkp8OQ5HpJC%s){A`!_+
zZ^%Rxa(Ro<v{@9=tVUWS-+9*=U!|6&KqdSvWl1eYX?5YDv%D!wyQIt#&)RezCyTZU
zr=;zN%3+&&iZ5t{Tuth7yG62Pb+vt0=|v%9HNeekI?ARu_Hv<UbAMJWtKsB;ZTn+q
zwPy`hA5#MoP9?uE21mB-DkJ1oQw6bO`gioNfL&N+Byh1q@^^@b_12PPGYt{;L#eN`
zkHFrApZeTg&8PP&eq-!N|G^eh)h3xix=QQWYi)j3c+#g6GZ)Yl`#QaSJGgI+)&m1x
zegnU=*1z2EJuU|5Jm3p8(!J9Z5jNmtd2gNAPsvT?z4#^9yAAJec}aIc(|i7+?CqNx
zxZdk2rC_*%&R@T9!t%T8rEuv5ccacI9s!c_<P8KWWM9|NoLU_!Xq%)ncigl0!n(`N
zrMu#KMX(%c#_}l}rM`n2J>2RZ*U`Se`V8aQ0D93rmOeu}l3HWBQrAp|@n#C>2E5{+
z4`a@78UsQeLoI1LYt)w8$|BYcDtDhl)5r5^I~jNR$t$Fuf_ASGdttj~%j(mxI(Qgt
z2={VW2R<yWG%V9z`)%6wNBR@3z#M(HP%Sl|?>!<9ACTNik2P~-h%C?7q;mQUL@YSg
zRq3hcI^imFbfJn&Nk&*Li@0Oe^iDcVI+vg|3yK!Ndh$!{s|2pU^x>AW-vt)k1*H=O
zoll7I6jq$pXAokA_Gx49EZhTpL;rmOxqu%o^$@U>Z4Nm5zfFt$ifu1eUbRl611tcU
z0p9IwpkINAPke$VN+EHws;WX*@i&u;I+&G7wM?Cup2I1St*C4_n|4<4*+5|FUA$>I
z;>0a@*BH#ENo6#=GXp0JGTmOKXDn^gdw4O~fmIi+6q*!D7v6h_BY9<cdeTXbE3WV{
zmwTQJ!d{MDz|f@x75AovYO0R^G|*0JRkK?t0JSMxvlVp*$DXz82#kM?^>e;8I_(n5
zNMRw(apdbXaK%Xyqz`yt7lTg2dBZ)+@lh~T_)%exwM5n1zL&vx?%Nza(w6Or4Jdp%
z#bUd16TbM2ICEq-iEU~}JC~I!lr5+|R|bu!GTM7HG(8uM2pMT^d770cx`E4c)R+ep
zqdTw3Y@H3!6Xx~{%B)-q(sP*6WTy<gZh~#fKenzO%!A&)1H7AB0pcjmsnXvl%%~$P
ztuPZ3qsh1enMx+#r@wX?%ZAM|BhmN-5rfvEbJLL9qV(OBmrqED0v$fkzOzPd-;zbv
z$(gHAyJw)8=Nw$cP>7IVQsMxLg;tA~LQXFC`i)5d)wjFy<X5{35$i-3`T7hO`F0#w
zCO1sOV>h((2*iBKP66l_2O=wjQT9$Wz>$1dZ9(l5jXL~`Q3FsS=X~|4=MQAQkI;(J
zRSb@TP$C=}G_ickIz(o~tKj+F8=BmYWfDfp>U8;h5!(&t(b<xDLX<;SaLBg)lRZ5+
z{Aue9$eJQ5pJ>V*%FV2Gj*+ng&_4vfzm+zJJrcE^cb$s}cH=nnH%oW5!`RY6`$lN<
zaVvlc^0wJE342b(d;_)6!={#p=l=2h`gj|%*&K}%Lti38a`GTO>NBud5?s6vPhZx(
z>uPr;{z9wp*cI9XS@fAD-7sOD4<brWu7Dn6VQYeOU&u)j{qjVRUYzpYCq3z_)?@a@
zUjNFudxnlItW!;)m7Y({wjYEZ+GNl_50~a^P~S_eha`rUh3Z;M$G7R@*;`A!eKgaK
z;i@<Naf!=*1DMJ9cVp4IO^T%hyfQ%k0~fD9Vv3Tre|mTHF2kI|``;FeC45G}vY@4!
zrGYkz&-#Yro3x{*CZQxgXHiS`b=o|pl63cdoB?Nl{>^cOxZ*|(;~8nlMo3I!xVk2V
zQU88y6b;vWj?=e@iWaQdOq*>P15Jh42E52=N28-JRlLzYkGq153B`3p9xd`{bmr_t
zgdQbIjE>qVWoE(~U^b?3%PLw*LhZVC+i3otV9woI%Vz|&1jbe_>)nz)XOo3Py9wKA
z;Zub{kOQG0cbg5CMzR(<0v4|led%*$r4{bLo0RhmCTgTu%Y(p;V%pC<+o6j{UNbH1
z;Y|4_f-z?rIZ%>KR=eL7nW7Cx(Gix`uy#<uNbiWuSzl%En><cwD%#<~w(b`h)oF%F
zBqKsvuvYMwH9tBzVJ(tV+F+dtTC}uy=h(D-<Q|<rAhnGlnbfK7;dbslS~LUoJ8a%N
zNE{{}X%#ElT8VLPbvkMh-LIrcb3(t+f)d<ss9BcY)EkL!=gW@aE^|V`Uq;ATVWI;K
zoQI#&=M`J)^Vo16v<@~;J~b#4rOkfjBA!vkPBmscXasQU_$aTq%rLP-^P`mIa=xKD
zt7th}{*k?cklTV&e!8{<mmc%MunCzi6sZ~5?7&l}YW#~`&%k{|UY&4+f_i4Cl9HN9
zPzO9%C^$uc)oPSoflH_BWm6J=*``6IW&I=jMnak~C8<=7uzPYb|Hh5ZdoDuC@D94@
z$W7YVix3SJA+6M5`6;jsNJZ{Rm->4DbW<Qv1q)4F39G_KzwpkP>B|;0uZnP{GC>Fk
zN300dTzUJ*sV4X+1XI*5F`Eynl?aW+pw2&zLo=?!SXR9(;eO1F`W@Vb&H5Y}TIlsg
z$IQ^fFA;2#Yl3n*+v`~zr&V$31CHaoEzkW<)OuCUd@L0vb;-WXRS$brZz+LVZH>{t
zn_3A%!XVn=;h>Rii4x7MU&K>ZZFi$@z*xzX<~4+i()@aXwhG-Rn@QXb&4BcDEhWGX
zl@kS3IvpyyAb=^Y%Z%%;v9$zsrI3P>gZ7BUU&kh4^duWHsaUCp?8{LZi22(FKZsgf
zRNOUqk`Jhw=&VAB)K8$q%Q+G=MGV_o5#GfxJRvlcYE2>^cv*znV4GQ<9Cn&S(#}MP
z8h9NpUXL}*DGfr{L5<jhSAu+(4bJB#A8E8a=|TWk=W=R-ihdg@xAn;sjjfVR(qJUu
z%rkWf5YoY2*4~g@I(4-Cc(Zv|>of9IMS4_sW|hT`Tv@e}CFhmsm?PqidYu1_>*2~S
z(B(20bcP#-UV2_X5scnbJ4RqgebyHKiRLITKce?J<d*?0+kVwOf^FriR6DH4#PHzc
zE&hO}L#PU3smzEIAW?mvW32hxF}0!~UDKy*qcs$>(pr;PC6W@8{4aj!s<k5U+Eqsn
zFxK~f9pjZyM<9$22wqIYe9q|XXliU_O#AEmuO8-y`e?*F3x*Hw4<AHt*>$3t__xD}
zUE*^GhjU|%&gb&wuQj7A!Nltu<)CxD<_7h?M>WG<)`ZZjsOcNi-WkGc)Evfqpy~}v
zB;#zz&;3e*D0zBxcRqe4&f9-7X|W9jTo7s}H6E?pXrKv{2MlM2=~UcE+9@#zqSeL}
z7?}Ura2Tn!^uXtSRJo4SAOR2WK(PgaQ-!L_u}ovr&ocNPIwMDE2}?1F55I`2Fc|iu
zcq`PGDXaM+62t;DF@1u?CCnH*-!}2Bu{qjwgwT6&un|m<j%dbdu}ZlaTZKUy&u?BG
zZRAAQl9woBl_-uhRD5{ory{)-lf8w9x+OGGp)&@W6<CEM9oG7YGJ6Bj!nt|b>vhr7
z+PA7e1T1y|TWwgbl0MKt0esO++X_7m&CX><G+&A3beOIWS?{7!gK2MUELR$>FDH+o
z6VNl@?rnF<4Aek2g{KkYO%`34ngF{tpvzT_UIkxPUz3rrWmsleO<P=dn<l@fCuWU2
zuGxo8y8!bHDoip_wayH;a-jA@Aj6XIm7qao12f<eHpCE1M}WeihlRI89Sma)BHyf-
zEd}Hj!}qBy%ax!YutjK(b6P?@j>?ZjSOM--94+Tb)G0yU*o;6&kIB^Kdc0WckB{i(
zrM+FMY6KqtY<YDXQucUz=y1GEyWHx1Tm5Ea@LHAE>twHX`KiD8yQ$aNkIA!lw5<=P
zF}RtSE85_q#@A3Xh!Cu!Z|Ve5*!ct@OuLqb)`)`ZEJvjY;T1p3VtfZhve-#;5X%Cd
z7Ic4mL{E-RvT`vC8g*<pWCDWa3t^W7979ITJrHTg(RWKBs-GmX^=-B|vJrIk%NH9T
z>cN0nrEeaV_Pf1exo&BF37wF6V!l6cGVqM(8e_`QrU~ED4eYA<-eH{Mu>^0tim95d
zVrcL~NlC5`%NnXhOUw1h5)JG3!p+zdt7pNZuNM-6S$ASXp`&LAh9W0K$PSezirJ?6
z4)QH%$T1KSECA8Yx}v^&3v&^aoN=oPH`XnOFr^Iz<rGmtL*#O|D@LDz*}lh2tH-;8
z)IMCmHVv8(s<7;RG0hp!c*$-{NNm#K;Pj<7x!@L5++qs-cpRUSZj1v%uo!z;>8`u~
zxTLVR^wQ#!$kKAk*CU;=Mp&%riH7$!oh5^{vg)DBJ{O0b>h4(mU}yYIyrEZ5@=diR
z+l!Ky5_yw$Eo@bkto>6c_ZTSlR9mmG?emVb;A!6uh$zd83_=8(QAI=?GHG>XQGkkc
zzf<e#rB5HQHZKebrPUIBD@C5n8EDROtHL=%#h#<Tq*3&G<ntI%xN_ryez<czZdlW#
zMJY~C(xEc70>Utu-_WJBSOUkmI1?;Us_;57(L|qfM~;===)i)FaW+jvao+`m-sM&B
z{zl}6XTYl<^^f*<1dW^{=QVnJouyd8)8Fb2Nyah5#vI4R6Y}+81*?{t0O_4o$tQP=
zvu8eyS~f>$y(6f|ha;M_Sdl8N52jpvWjj~ib81Nz(XVv7o?<P4oQF+`7{T|1Wt_r5
zbNjxRU21WlH&f3K1CK4%p*bBquC#7)Z`d;Oh`he$;Zayddq7-dogTU?DM?v*X)puh
zsD+rV=z9v0*V~YHdO{{Y;1m4p)2gX_@wW`#3?o*KZRiNwNtdEY%HJJXRtw>$^w^f?
zCUkR!6rIM&n7s|(z5RTCYe1JvCOM{g)R2r-61J5DM>Nkoe0y@pa)VrycxX{<zpFFd
z;GFF=?;KXUj3_aol3_N%&;xEhe;JL911YgcU9eTdZ7|)~ep@`u61t}K#T<*4d}qfm
z{l?2pD+8(h><Q@GCZoUZeRDdcpE>o!rk3xUPVD{c183~k!`s)5oA4Aeo#m9&wez1H
zwQJ?E>X;jsi+JPsk?a&4&RRlF-GYbEkMxx8dOSXSVl&Z&GF8aid#k0~v&St}((=F!
z+s43v(0u!K(e$cGqHz>kCEdGB+3ZfIZ0zdZ#AoJeQN`oB52OJ4ha*<YI-JJqvaP$<
zy_Jl&CC+)f6Z_f)vsQ5Fhq=PVn|%=$NIKmXPd0zKK36rO_NE?ih6u1S{;!-dzoOs&
z6&m=548?DUemz@$DRV@Qv;)$Z!Gf<eu5czSSk+<+86D6N{Gd1kmPmH$E}^!1eRYZE
zY`4-bi3jzBuE2WaMnDTY$~Kt&2@J7n;G)MI{_4=34LD4EPDkb&K?oQjlR;~d4O@SL
zpdAxWT=7hwzEpqan+WqRb&)-;xu!Q-AB+dAz7I)WyvI~mMioVCfkVWKui_5*eo6e^
z`s6z1Ah?~ZiR~hNG#{5#Z9sh}3l<XvLSnjKgEEy{FUKTpx$7^-xwlPn{9nO<fC8|e
z$GN}V?|)|l_&qvO?dYeY;}ehG5uPb7#N;jQ>}SO;nFVmM`79Y+-y~B_NMUoL0}^cL
z^Xi)3-S{73v5(1APK-8c@;>D<z3Z{}CoTnN+&*@iDDT4RKVuv;wlgj}(NU|ZkE$<w
z`EZ}wPa`3ZA|r{|EjM>|c-ftv$&RGq7$Zkai-`?k9}5U0TrAcnNSBQxb-$e!<1&QH
zr(-d05<%9vDOR*U2X31FgmUXW_eEY<n=$i<F;lug*>6Ox{4;$bAl4o#&K88e3{$_E
z`OejX4Q)kaWNB^;D*Y=)yaG3A<>eLjM-F8-7`7X4Ahgc~-0S$O-;iTlI8(r^w>R8+
zF|fp?(T16O)x;fd;#k+W!uMY<QI)Y>ze+9@l!t?)gm7>Bu&dfIA@J_q?NIn<7tYOU
zcMvZ4ABcx1G7ruP@XHbfritAennTMxdYVHcxL*%vz&NlX3Kgr<8hz5g<7~ecAx7K?
z&jJ~FBVW-YhBZGNu@(24wIdrAzTm6rNJE7wu-u5rVP7No{WnSYq5ByZA5A=XR3=3Y
zPU>RTdR_s2Rv7!`bS{}ws*&307<V}IQ(}|q+`yJWJA7soKw5&nsfpAbuc{(eZZ}T7
z&5VllHWWGktbiMb9^MA{`mCHI=K!|gygcu)c&b437IubN%vhtozP(pMedSGrYJ-x<
zZ58kYjF9FzSE_5foO0w{AbR!eiRG4?a0pT0K}o8igv?QRi3oHTOEJSkBAMSlO5mQ`
zi3lYjy%Srb<_Qd05hT|}Nn0KYBpX?03iU?iIW9QWmyqy^Z$*%m1ukoE!^-Of4Ao1I
zHn(TnBF3y;(SqE#xFmV%FAY{2jFs2rnKf<ioku%5UBos+HQ=E{9G!sN;v5NZ8SLMG
zSrlt7_#)94Vq#*M!cL+bmJxwDTmyyam63(lY&a&?$!-aq84lj}71sldoOUlo|7&!J
zje%_{X=)zd7+xr0Yx4+mR6Lukq2zks$he-<y6hUgf6UWof=|YnPCR7D#w&`3oj@YY
z=8L7gF}}M|>MorUc2SS2?W=eizL_nWVh_V=XIicIFk!Ui=kB@C`P2s8A$^|EIR~=(
zl7z!^1!ItS=kXizn0YO@wP?%o99p^+5~1%8RnRcsFIE{bjJm0d_a-zbWaB5$mVcA9
z>al#VW}imCt~;Zr!Jx+WPyX;@RsLN_FSpJJWlO8zaC|Rz^o;-D%@PiCN$Xm9D$maG
z_x9wu6)gIEYa7PfI6<LhrNfDAt79|Bk8&|vhynU~r5i^@?|(euIu{9X-pD{tST@4C
zR(>Ys3=~J;$GDyd*biaLy}8~PxDYk^#!G8lNrl~!-X$5&bZo%Ob<r@ZzTxz6?ujU}
zOUHetnpZ5>m1XO8r}9;o=jmiHdBg`N%X<=GUch%gXplaxa^>|~Bf6dZRXSYP06ZMG
z6Lr=z8Bw#fs5r9dkbrwfj0_(I?I^s%*KhZOdxgz3iTORt)D=|0-uX*!R{Bro?~j?y
zKn!82?Dj~mq#Z`l9InxcJy1z7V!isxdN<LiY^RS&0k&Euzb<70EYup9s=nl}wB*Z_
z5+s36q5atrFFU7A$v+6Gn4~H-QQC+(cCt$aMN`^<Ic)Ni3aD-b`<ER!-)x*xM&k|T
zqOS^RAdW}-IOG;xw3;AkO<O?BWur#-qjD{I^(^f>aq!nskG)x`suN8e?{BZ<MrSAe
zYkY8V*6JJr>dj}!Z*)eR#}h$pkI)ytT2vRBT%syyEk9J}<HVBqWMu$HN_mL=fJN=N
zwsxt*cGrNN{=Or}yJpBoe=TI;Nd+nDiAn~Z=^7=AX#CzN8t9D@EMGr3pWBE1qX#6s
zpm1O^ZBW!;x57C>QC}ts@GMKvEUM^ecK4rWbU{CTXD8Wx4LE!V&Sw^f9e)m;c$v8%
z(rl_b?>*M9`<G8Vmh_1a-GHIf2;N@~oqoBp|4<)}z+y#hMZe{Rb#S?7UXMW}oiXH0
zGh$V*NK1HIUBi{D#>f!YgoOe^%zmLj_9-t}z=k_vj1Ls9`8)=SsA?B?lr-w#&1~wH
z1qz5Z?M&R()kkmlqut$-t&ThodZ%c5^gv?lTKCd54z@St^x_@S9{aXx=JnC<$=(nS
zATQXVtJNjbct6g9IqHb8^}zR$u5s<v#U@mqZB}5k(;;uqz>*$YcDP0oIl8IgI5>j1
z8)}p)Q$*QEimh=#h4UXo^#?|Nb@;5*fUY_Kf!cyhKG7C>3Yv$Bg^bDhQDrhlE!5Y3
z8)GyY<}7lyAHRiEJA?p#mA|)SCq}cyHM<Edr-F}#lyxFAZ$UwitHg{Q2d4y#d*ljp
zvDzCh%N~o>6dp66M<WwFYZOu?)xO{GL8o#0DtYEDnU#j)Roa95WZU-nbnUUW?!y~b
zIEl0+G;cOo2COYUv+>%QPwFsSpk@4KmE}P;Dh*y`W-H8OIYcSe*_7V7IK?WB!BQBD
z<sI`atd>(r$FR!ZgjFdr`*PGGMzwoFfWChdjw6cJ8ajRz1%!?#5zS`jERMmyGA!5e
z3RcxTQ9loUd2eK#+6u`LCpX=Zg9%wvFg%7(Bz?%Jw;5Vv@$E);<+~AF9<RsatL+#Z
zZlCLY`$MaG?1VtKdcaWWYy?4<!{_O8y{LD2?t~!5=Vnlq_UZbpbwV;=%0*U($Ln<M
zuI%adrW|Z(bB7Fpmxvzio0I3-f)PC+8X1^p&4$zt13xZ#ha{U1N`V3GoKFP&_7+6m
zsQu!rS?~PYu^>2CH}7dYPsEdYBD9riG8SKt$Wfg2DQ0a&hs_c?S%JF^&yT%}LOU}o
zE?-wS+daYUWGyKIAhDRP$m`w)v9*uMkIbMNM$BLfz&0MnA_4k~PYxk$+(N}9>_nm>
zOvVD7MBuGdmap2EgRL&DIk`ow_U^7{ggTb^Ci0OLJ0p`vwQ^<#FuIvy7K9lpV!70g
zWA$zE+sE<qhu%b%BeJAmdFp>}1~=<DyyR{G46l-n%moh#dQSUz(!i0z->G~f3Ok*l
zG=RnrPxm4zA^K1+sDyj(8z<nhOfqA8wSRR<EhcygBrm(QP(w_|c(v{?gIGg;bUGte
zt}RnMI+_+DVtQmCH424k_+z2LptCYX|19!+60%|dzGildg27Pv0);9|MWH*YyIcqZ
z-@{i>rR|+fd8{iMSr`)Sn5UO{@DNaR!whDbBNMX%`KtN&ocID_d3lRK$sH0yhr~q?
zw+{Nk@p9S^`uFvB@C?@_#(3qe<yP=W%p`pvTZsIL`jWMH26enB^7G;m!zK184&x@)
zWHzYW^x`_2z*ZAHkG)^Kc+@5xZZBlyC1#85!)?>5rQ5DQc;4no;||Ar!4~wZ8#}1X
z-s4iH<ve(*jHFL8zPlI_EqYghETa3Wq|~D-sqXmjod6m4dzf&SAR6yiKORmH!JR~5
zO3G4AkeHIk-_*S)Ty$oO*F}7TEo2Hlu5<yLtyTyh#ApaIK+0`7Su$AW*3{dxYg*mV
zu=om?sM3zCRb^eSxZkmAbg1-XYR`#wV!DJ9MB>s)Y=eYRe1e)NwWxji{dY>v*JxHS
z5lITVeF9HZ%^)H10TbPIM|qKW3wWP;2V}q84>T4W?h+WL4wkAXO{-|h_Kt&xY1O3=
z+3RDpua>iW4zyUmqha15SF{{At>FnQQ%0WcgJYui_y+Z(z5&5p#B|Dz^f(5EY5mO(
z3WXv*CJD9+QF5?%@({ziz-4Tx!Uyk!QeF~dhmbf71MVa6RHKE$>U@oLQi)RSn{%oH
zpHrEhcqp8H|JY)f5e4F@f+HvuY!-+yh|%jV_8bRq6u<0y6XiFyQh{2U4pOc(b&QnO
zpNckBn3fuhG*L&@1CvN4cv1>%7j?$_O9UAgwGwA_X|~9eWZaJwuPy|z#4A^T<O}k-
zeLU*~d3q@Z@4$<goNTrlE-9v8XCNQ>;B9<1j(;<OY6w%EQ@M@`<G<jz|DB41Q09(l
zCQ`$RuXs;lao)XoIQmdv<0@MtLy>$8rouzc8=?q3-i+jXZqW~WSq=voj>CuW<qQ8*
z+yn}0AGy;#oxF+D#tVh%tNlqo-I8;UY6v~lH{Hs-86J>NKgPRH51Mh7-2-sTBn})1
z(UMb20|qtJS^-gM;ma$Wuc#ba<*{n^4|H-TN?k&T%a$z?=lF9~_gMV_<2;0Wz&NkX
zDVlj^e+smW-ZT+&5|7L+Dm-V|JULaTWa=VyajI>fM{N#MrR7#TMfI%Vn)WXrdqBW<
ztU-W59y!2~3*fEwO9Rf?%-BWF-p1D9XNtE-g?5=vI@o5y69oCg@9=7V=8LZcY-fSZ
z0z492wdK-;>{uGSxUJ`+WY*iLYnDB{M+S_hCSK3`i&{yyi%yfj)BB`6mjL#p)}q60
z8_bVEOkt6=!pX;zrlTXJ)iQbfaQFraV@SAt8o!Q9T&^@5&D9DUBekTsOgL*SIqY;T
zEpVTrUVNPDOAt%b_TAI*fq5QrlUn_k_CT2~L1K`U-fCx8Ifo~C2b}jt1b1Cy2^}eD
zYF^Gr(^E&8LAr=ZGI9|j)9wfqAmT)72<GrbZML$ko>JrV?+j3W#NW>8k+}}U<2#yZ
z3-K%&tG^{KxYM9g(P+0JM^D@v&O)*_TW(S*v3+|PPpzJiLlBWW(_8aFMkpGN@qpu7
zD5J!>%--R*#{Sq%`+cV`a2C)!Et{62--|=eVKn9H@iQG@A685&<2m5;ErGNIP{8ZK
z!(<nuIWz@}0;ZOE#!b%<H$G#Jc+@m}f}u%&e~zC*bm}F->&sZr$;Fv?m@Mn_mvuJt
z5EWAlI8y`o0ywJtsxwD@150B?M>k93U$q81Bo6OShrzen9Oh#B=tV6kPlVcmN9nQ$
zOp$=U%V(O4yuN6Ba~elG%qx+TtoFl*3G`_N7`cIY@e>4ij7NYW-;~{=omrLMS7;cw
zn&mt$J6Sh}B2?A=@A;-_w&1xA4g#T8qS<xaAJlgaE==SXtm<JuX<mDbCldK>V~4H9
zgHMEgY-cU>$IGc|D;V4iH4_8Xa%bwXQ<|Er|MEaV<;_>|*Pg)`Fi2S8fCfqTTZ8;5
zO87qwvUqGbe4Y*wXvHJ@NY7FA+;BEbI$by#mF!$@;1W2Hnlz`zh{)JQa<@^{sY0?Q
z?`y(G5rLr{EVCLH+3^qDrnr%naCnrk3|5@eSRR&b$#<X&zEncS9?Tp?SjW;3wzVEl
z)|}Io)BN+F4I~~mDwX<zHJDdW*R=>y8{$7Isnx5`JF>9xe)&-I80ubzGY&Q$O4dW1
znoz!ydbAvO6x{BpQFq8i+?E$Qy-ol{${4b3ex_NtczF_DB`LjEa82K}Pr>Oi?t5gf
zeQ4axMrGF$5=jR=FH!Rql}Oi6imqTEx3vPQ$ODCA^9~`N!+bW4Oi5{kt>bY;I{%EO
z4!@LxRr^k;(qqEg*~BbyW#5DQb2%_Z)*>2p-Lyz7O0?v_YQvmupS=eE5;X99l1+HU
zr#igr?#~cTIO_(el{Yb55>L=vp#nH;=!k>OfyI5q#VqW8#g=AE1E}`Sz-Ue`3Oq|5
zlU~w_XX*$g&<#HNXipuVYNhNWnz}Z}M~?(s?x6l^snY}8;}8ts7hnsRO#$ei0~^^G
z{;D%tLnjAE8>^pv$^Q$K0<0CVbtUQ+rO{!896{W{uX!<vSDTx8Ott2IjjnKRq^58A
zXkto0av(D@<D$EuE_-6W!Vj*4fxOIx@VI1jf2@S|4a}T6A-%4vvlKM0NUE<l?C#>L
zNcp~Lr%?|yvHqG4e<Q;9)lpBQhO!(M@LW0Zr;l}{hJ~?57T*4GW+O6^obg2sMm_NR
zqPm;)D_@oFwfvcQx?Ok9Dp?AJCN0>n@|JcC8j^-kZFbIUJF6=$^4D9t%VcygW2F}|
z2W`u>g4u)|6R8l}jiTfDk@4ReN^Luq%a|1DmMStweAyRM(YQG9uH^JKAV=-x%8G;o
z315Rmkmp;+$a{kiImQGZPt?V<)thK!2As0^WFR7ZA(-aw{&|G%@@T!>$IydtGmCOl
z2V<rRpD>lwE`5s(XX_PM;3gS9l`vC;YcN#*7~Y;R!4Aa<*l7}fJeE~JC&en%O&mIw
zEzCP#RvR1-p6L}kWfqJ3CzH3%k5+nH(@75fpKiYm><N;)mQ)Q$=T5_19K%gWnq+lL
z)0Z~}n))KViuvpXLfg)kqaSI@)KP~X^tq_x-JNp86QS5=^-&n(g+zN5<)9TGfo1>2
zrHa*|RB&6Ct1VmSvc=H|$+4TaUJQ7QebMs|x3&xZ>|ZY3m^tUMx;Tz?>Y!Tuj`+>>
zyM#YDZ$A(MKRy(uKLQ4s|L!O-!3sP81F#-Kz>Fi}@7AMlYy1DE^M~2|{QgNv-e!&t
z(L1y1NpG{6O$oNTudeVj27<9LLDh)0C;n6<_N?mE;q-`|n6E#F)8M#^i!M(l&vMFQ
zlQq+<|JgvQ-Plnc6mY!emm&A`;)>mFWdSZ|!k`-Po_?(BjbNXL4zzD7D{_9M{2kYJ
z3Ir;I5?(qTBG)=(X>#Pn^N_IFnu?mJ6d{~xt(I+g%~Ip|L8`9^`E`^s^v1}dYp%<3
z#<rY%9_c-b{Bho;2xl`^1ADtYP&XSmX6ngKiI3dvGUvh>)hg#H)6ltgY*V;Q&4cs{
za)na;ptXf5f@N?QgN^n@!0s}|#M+RR@E^hU)jyX?p$<f`AT1m_Tg8*R#Mj)r)m?h$
z7&3zpA)Nzkng8ikWl?@4PPZjbrm1qb0L&}{Iwnawh7RNbzL*OX3#h#AtpFMN2hF!u
z_@euvs;!;X2q>piTocaG@g=qr7*d!TC_=@QG10Om{IV)IM7i1w9fF7WDxf@}fj~S&
zEE?(`z^((GpHSvTdE&??R-T?hF@$hId7SIm*Rmm9qJ0>-F2Bz#RykmuU+8;ar$Ux|
z%((q5ayZ%0RT+7-2G+fGzub7jOW!JZ*Nqoa>AhyK-^&Scn0T|Rs%&!fN`Nz~7myPm
z2=t9}Gu8@CyGc7mfyLt|R1>(0&2+RqFdxe$t|i>dvEy!SYln-9ni!;~zl=HX0J=dn
z1H3m>0gMRgcLOrCu{ZvI3wpL7&p2(14m#9ez{3ZD_{u63%_*U#0--4tZ>YSy@jVW+
z<{5vS`oooEQAtBT9_uRCc7Iy@#(2i(0BVduK(8NWfa+^hxMr`NHN8pIB<Sa)q*A4V
z3|$2gk-vE${mro_!7oT2Gjd%I)FzI_uz?S2+cCJ@7z=Si<m3C6It3BA?OKy4W@BAP
zIJU5LdbAZ&VeIY_x`_ZJ?8Mht3AghT8CeDx=7@M1-9!Y}T^w{BI#xRr?>?<qm#tFF
zp+mU8y8&X6MqxG!xxIhYI+Cf|P!z0HQ)%Ek&}5LZUK(tljY$X7od<&kUMwq>f$JO%
zkz<?!yq7?}tyDO&qGPI|I7;u8m*Fa1l6KdtZuc4IvURnUZ{AREaDJLvd=9^phxgl_
zEr^m|tD*A;F<m!F+{`3KB@+5KA$EJy3}KalMnpHJo!aM_fomUDeAbB~MfEXh`-v>_
zav2S2$r`(opNj7Rt?-Wy9vFlgAgm1z1PCAnxJpWMn8i*4&XE9o!G6BB|9R6Cw6S&s
zNV@APx!D>!X#Z@na*}@rJPMD7{8V?}05oxcx7lwSJix{5j}^IJD{wC_oB{Q>m;(Iy
zH^9Yszg-3d#0z*?`zibVE7RwnWO<&~^Ip>atV;hoP7!dU|BFWbOV~>d@@HHH^dGR7
zisUZ|FO{F43Elu*^WSdn*FFBat(S<GstC^raGc)||4PgD$0z*@_fo>?CHbWg(lZ$r
z;KB1hh5PfW>M!zd3yXhQr~kRk7I?pr|6`e-6@gxs`FHY9*_7wa4*#E!e^c3ciGHb7
z^Ne;S_yhf%V*OvO@%hMqZj%4G$Z>@KsL1~e{c|P!c}pSsN9doH{C}*$OyYk+e%2>>
z`7!_gas0W=c_jaY{H*!$&&frk|AhRkqw&wl<z)Ya{H#s!&&jpq|AhQ2>)QXZ2Acs&
zO#fru|Ir4YH56W!`K1!UbF1s5{Db^#7XPM8@Dlbi^ZPR_i{>wi`CG^KM;`c>yq9^S
zpLrDwzw!RnslDvZUgBP+!F<LsaQue**QfYf@qX3$OWezZde1mkp1;Tas_2)vm-()q
zaoYlakNahxFL5u^?>yrQME)N4%XD7iUgoHH#*Iq;J?@u{zr?)^%YVjE%l<v?k52z3
z?`0tHGY>}b?|Hu-PcLyV1Mr@4YpQ>b`(<e_aW5lTo^d-`e~<eW*YXng(%1hP_ge4o
zaew(z^3s?085d~u2kxb3@5=&Jy>Q}sCJdYZLHLtD)8Dvsy(GW%jd~`3xA+V4Z~x{m
zZ}sKc`!lZ9?%!_pFU{)ZGR8BZ#`O=vpB6P<-p|V!_2<jY-T%7)f1Y1|33xec{R|NG
z_yh2#Iqa90|9S58`C`DH7ZA{2%%r{q{CWE5cL0y?Z-D=vOnQ0spU2L>U+oj{+tvRX
ZNy|xs0p_rNstr;A&B6kta)N*U_Fuh}yXpV{

literal 0
HcmV?d00001

diff --git a/contrib/win32/openssh/bash_tests_iterator.ps1 b/contrib/win32/openssh/bash_tests_iterator.ps1
new file mode 100644
index 000000000..570173df7
--- /dev/null
+++ b/contrib/win32/openssh/bash_tests_iterator.ps1
@@ -0,0 +1,303 @@
+param (
+	# Path to openssh binaries
+	[Parameter(Mandatory=$true)] [string] $OpenSSHBinPath,
+	# Path of regress folder which has all the bash testcases.
+	[Parameter(Mandatory=$true)] [string] $BashTestsPath,
+	# Path to CYGWIN / WSL.
+	[Parameter(Mandatory=$true)] [string] $ShellPath,
+	# Individual bash test file (Ex - connect.sh, scp.sh)
+	[Parameter(Mandatory=$false)] [string[]] $TestFilePath,
+	[Parameter(Mandatory=$false)] [string] $ArtifactsDirectoryPath=".",
+	[switch] $SkipCleanup,
+	[switch] $SkipInstallSSHD
+)
+
+$ErrorActionPreference = 'Continue'
+
+# Resolve the relative paths
+$OpenSSHBinPath = Resolve-Path $OpenSSHBinPath -ErrorAction Stop | select -ExpandProperty Path
+$BashTestsPath = Resolve-Path $BashTestsPath -ErrorAction Stop | select -ExpandProperty Path
+$ShellPath = Resolve-Path $ShellPath -ErrorAction Stop | select -ExpandProperty Path
+$ArtifactsDirectoryPath = Resolve-Path $ArtifactsDirectoryPath -ErrorAction Stop | select -ExpandProperty Path
+if ($TestFilePath) {
+	$TestFilePath = Resolve-Path $TestFilePath -ErrorAction Stop | select -ExpandProperty Path
+	# convert to bash format
+	$TestFilePath = $TestFilePath -replace "\\","/"
+}
+$OriginalSystemPath = [System.Environment]::GetEnvironmentVariable('Path', [System.EnvironmentVariableTarget]::Machine)
+
+# Make sure config.h exists. It is used in some bashstests (Ex - sftp-glob.sh, cfgparse.sh)
+# first check in $BashTestsPath folder. If not then it's parent folder. If not then in the $OpenSSHBinPath
+if(Test-Path "$BashTestsPath\config.h" -PathType Leaf) {
+	$configPath = "$BashTestsPath\config.h"
+} elseif(Test-Path "$BashTestsPath\..\config.h" -PathType Leaf) {
+	$configPath = Resolve-Path "$BashTestsPath\..\config.h" -ErrorAction Stop | select -ExpandProperty Path
+} elseif(Test-Path "$OpenSSHBinPath\config.h" -PathType Leaf) {
+	$configPath = "$OpenSSHBinPath\config.h"
+} else {
+	Write-Error "Couldn't find config.h"
+	exit
+}
+
+$user_pwd = pwd | select -ExpandProperty Path
+
+# If we are using a SKU with desired OpenSSH binaries then we can skip these steps.
+if(!$SkipInstallSSHD) {
+	# Make sure install-sshd.ps1 exists.
+	# This is required only for ssh-agent related bash tests.
+	if(!(Test-Path "$PSScriptRoot\install-sshd.ps1" -PathType Leaf)) {
+		Write-Error "$PSScriptRoot\install-sshd.ps1 doesn't exists"
+		exit
+	}
+
+	# Make sure uninstall-sshd.ps1 exists.
+	if(!(Test-Path "$PSScriptRoot\uninstall-sshd.ps1" -PathType Leaf)) {
+		Write-Error "$PSScriptRoot\uninstall-sshd.ps1 doesn't exists"
+		exit
+	}
+
+	#copy to binary folder and execute install-sshd.ps1
+	Copy-Item $PSScriptRoot\install-sshd.ps1 -Force $OpenSSHBinPath
+	Copy-Item $PSScriptRoot\uninstall-sshd.ps1 -Force $OpenSSHBinPath
+
+	# We need ssh-agent to be installed as service to run some bash tests.
+	& "$OpenSSHBinPath\install-sshd.ps1"
+}
+
+try
+{
+	# set the default shell
+	$registryPath = "HKLM:\Software\OpenSSH"
+	$dfltShell = "DefaultShell"
+	# Fetch the user configured default shell.
+	$out = (Get-ItemProperty -Path $registryPath -Name $dfltShell -ErrorAction SilentlyContinue)
+	if ($out) {
+		$user_default_shell = $out.$dfltShell
+		Write-Output "User configured default shell: $user_default_shell"
+	}
+
+	if ($user_default_shell -ne $ShellPath)
+	{
+		if (!(Test-Path $registryPath)) {
+			# start and stop the sshd so that "HKLM:\Software\OpenSSH" registry path is created.
+			Start-Service sshd -ErrorAction Stop
+			Stop-Service sshd -ErrorAction SilentlyContinue
+		}
+
+		Set-ItemProperty -Path $registryPath -Name $dfltShell -Value $ShellPath -Force
+		$out = (Get-ItemProperty -Path $registryPath -Name $dfltShell -ErrorAction SilentlyContinue)
+		if ($out.$dfltShell -ne $ShellPath) {
+			Write-Error "Failed to set HKLM:\Software\OpenSSH\DefaultShell to $ShellPath"
+			exit
+		}
+
+		Write-Output "Successfully set the default shell (HKLM:\Software\OpenSSH\DefaultShell) to $ShellPath"
+	}
+
+	# Prepend shell path to PATH. This is required to make the shell commands (like sleep, cat, etc) work properly.
+	$env:TEST_SHELL_PATH = $ShellPath -replace "\\","/"
+	$TEST_SHELL_DIR = split-path $ShellPath
+	if(!$env:path.StartsWith($TEST_SHELL_DIR, "CurrentCultureIgnoreCase"))
+	{
+		$env:path = $TEST_SHELL_DIR + ";" + $env:path
+	}
+
+	# Prepend shell path to User PATH in the registry so that SSHD authenticated child process can inherit it.
+	# We can probably delete the logic above to add it to the process PATH, but there is no need.
+	[System.Environment]::SetEnvironmentVariable('Path', $TEST_SHELL_DIR + ";" + $OpenSSHBinPath + ";" + $OriginalSystemPath, [System.EnvironmentVariableTarget]::Machine)
+
+	# set SSH askpass 
+	$TEST_SSH_ASKPASS = Join-Path $BashTestsPath "pesterTests\utilities\askpass_util\askpass_util.exe" 
+	if (!(Test-Path $TEST_SSH_ASKPASS)) {
+		Write-Error "SSHAskpass:$TEST_SSH_ASKPASS doesn't exist"
+		exit
+	}
+
+	$BashTestsPath = $BashTestsPath -replace "\\","/"
+	Push-location $BashTestsPath
+
+	# BUILDDIR: config.h location. 
+	# BUILDDIR is used by bashstests (Ex - sftp-glob.sh, cfgparse.sh)
+	$BUILDDIR = Resolve-Path(split-path $configpath) | select -ExpandProperty Path
+	$tmp = &$ShellPath -c pwd
+	if ($tmp.StartsWith("/cygdrive/")) {
+		$shell_drv_fmt = "/cygdrive/" # cygwin
+		$BUILDDIR = &$ShellPath -c "cygpath -u '$BUILDDIR'"
+		$OpenSSHBinPath_shell_fmt=&$ShellPath -c "cygpath -u '$OpenSSHBinPath'"
+		$BashTestsPath = &$ShellPath -c "cygpath -u '$BashTestsPath'"
+	} elseif ($tmp.StartsWith("/mnt/")) {
+		$shell_drv_fmt = "/mnt/" # WSL bash
+		$BUILDDIR = &$ShellPath -c "wslpath -u '$BUILDDIR'"
+		$OpenSSHBinPath_shell_fmt=&$ShellPath -c "wslpath -u '$OpenSSHBinPath'"
+		$BashTestsPath = &$ShellPath -c "wslpath -u '$BashTestsPath'"
+	}
+
+	#set the environment variables.
+	$env:ShellPath = $ShellPath
+	$env:SSH_TEST_ENVIRONMENT = 1
+	$env:TEST_SSH_TRACE = "yes"
+	$env:TEST_SHELL = "/bin/sh"
+	$env:TEST_SSH_PORT = 22
+	$env:TEST_SSH_SSH = $OpenSSHBinPath_shell_fmt+"/ssh.exe"
+	$env:TEST_SSH_SSHD = $OpenSSHBinPath_shell_fmt+"/sshd.exe"
+	$env:TEST_SSH_SSHAGENT = $OpenSSHBinPath_shell_fmt+"/ssh-agent.exe"
+	$env:TEST_SSH_SSHADD = $OpenSSHBinPath_shell_fmt+"/ssh-add.exe"
+	$env:TEST_SSH_SSHKEYGEN = $OpenSSHBinPath_shell_fmt+"/ssh-keygen.exe"
+	$env:TEST_SSH_SSHKEYSCAN = $OpenSSHBinPath_shell_fmt+"/ssh-keyscan.exe"
+	$env:TEST_SSH_SFTP = $OpenSSHBinPath_shell_fmt+"/sftp.exe"
+	$env:TEST_SSH_SFTPSERVER = $OpenSSHBinPath_shell_fmt+"/sftp-server.exe"
+	$env:TEST_SSH_SCP = $OpenSSHBinPath_shell_fmt+"/scp.exe"
+	$env:BUILDDIR = $BUILDDIR
+	$env:TEST_WINDOWS_SSH = 1
+	$env:TEST_SSH_ASKPASS = $TEST_SSH_ASKPASS
+
+	$user = &"$env:windir\system32\whoami.exe"
+	if($user.Contains($env:COMPUTERNAME.ToLower())) {
+		# for local accounts, skip COMPUTERNAME
+		$user = Split-Path $user -leaf
+		$env:TEST_SSH_USER = $user
+	} else {
+		# for domain user convert "domain\user" to "domain/user".
+		$user = $user -replace "\\","/"
+		$env:TEST_SSH_USER = $user
+		$env:TEST_SSH_USER_DOMAIN = Split-Path $user
+	}
+
+	Write-Output "USER: $env:TEST_SSH_USER"
+	Write-Output "DOMAIN: $env:TEST_SSH_USER_DOMAIN"
+	Write-Output "OpenSSHBinPath: $OpenSSHBinPath_shell_fmt"
+	Write-Output "BUILDDIR: $BUILDDIR"
+	Write-Output "BashTestsPath: $BashTestsPath"
+
+	# remove, create the temp test directory
+	$temp_test_path = "temp_test"
+	$null = Remove-Item -Recurse -Force $temp_test_path -ErrorAction SilentlyContinue
+	$null = New-Item -ItemType directory -Path $temp_test_path -Force -ErrorAction Stop
+
+	# remove the summary, output files.
+	$bash_test_summary = "$ArtifactsDirectoryPath\bash_tests_summary.txt"
+	$bash_test_log_file = "$ArtifactsDirectoryPath\bash_tests_output.log"
+	$null = Remove-Item -Force $bash_test_summary -ErrorAction SilentlyContinue
+	$null = Remove-Item -Force $bash_test_log_file -ErrorAction SilentlyContinue
+	[int]$total_tests = 0
+	[int]$total_tests_passed = 0
+	[int]$total_tests_failed = 0
+	[string]$failed_testcases = [string]::Empty
+	
+	# These are the known failed testcases.
+	# transfer.sh, rekey.sh tests fail on CygWin v3.4.0, but succeeds with v3.3.6
+	$known_failed_testcases = @("agent.sh", "key-options.sh", "forward-control.sh", "integrity.sh", "krl.sh", "cert-hostkey.sh", "cert-userkey.sh", "percent.sh", "transfer.sh", "rekey.sh")
+	$known_failed_testcases_skipped = @()
+
+	$start_time = (Get-Date)
+
+	if($TestFilePath) {
+		# User can specify individual test file path.
+		$all_tests = $TestFilePath
+	} else {
+		# picking the gawk.exe from bash folder.
+		# TODO - check if gawk.exe is present in WSL.
+		$all_tests = gawk.exe 'sub(/.*LTESTS=/,""""){f=1} f{print $1; if (!/\\\\/) exit}' Makefile
+	}
+
+	Write-Output ""
+
+	foreach ($test_file in $all_tests) {
+		if ($TestFilePath) {
+			$TEST = $test_file
+		} else {
+			if (!$test_file.Contains(".sh")) {
+				$TEST = $BashTestsPath + "/" + $test_file + ".sh"
+			} else {
+				$TEST = $BashTestsPath + "/" + $test_file
+			}
+		}
+
+		$test_file_name = [System.IO.Path]::GetFileName($TEST)
+		if ($known_failed_testcases.Contains($test_file_name))
+		{
+			Write-Output "Skip the known failed test:$test_file_name [$($all_tests.IndexOf($test_file) + 1) of $($all_tests.count)]"
+			$known_failed_testcases_skipped +=  "$test_file_name"
+		}
+		else
+		{
+			$msg = "Run $test_file_name [$($all_tests.IndexOf($test_file) + 1) of $($all_tests.count)] " + [System.DateTime]::Now
+			Write-Output $msg | Tee-Object -FilePath $bash_test_log_file -Append -ErrorAction Stop
+
+			&$env:ShellPath -c "/usr/bin/sh $BashTestsPath/test-exec.sh $BashTestsPath/$temp_test_path $TEST 2>&1" | Out-File -FilePath $bash_test_log_file -Append -ErrorAction Stop
+			if ($?)
+			{
+				$msg = "$test_file_name PASSED " + [System.DateTime]::Now
+				Write-Output $msg | Tee-Object -FilePath $bash_test_log_file -Append -ErrorAction Stop
+				$total_tests_passed++
+			}
+			else
+			{
+				$msg = "$test_file_name FAILED " + [System.DateTime]::Now
+				Write-Output $msg | Tee-Object -FilePath $bash_test_log_file -Append -ErrorAction Stop
+				$total_tests_failed++
+				$failed_testcases = $failed_testcases + "$test_file_name "
+			}
+		}
+
+		$total_tests++
+	}
+
+	$end_time = (Get-Date)
+
+	# Create artifacts
+	$Global:bash_tests_summary = [ordered]@{
+		"StartTime" = $start_time.ToString();
+		"EndTime" = $end_time.ToString();
+		"TotalExecutionTime" = (NEW-TIMESPAN -Start $start_time -End $end_time).ToString("hh\:mm\:ss");
+		"TotalBashTests" = $total_tests;
+		"TotalBashTestsPassed" = $total_tests_passed;
+		"TotalBashTestsFailed" = $total_tests_failed;
+		"TotalBashTestsSkipped" = $known_failed_testcases_skipped.Count;
+		"FailedBashTests" = $failed_testcases;
+		"SkippedBashTests" = $known_failed_testcases_skipped -join ', ';
+		"BashTestSummaryFile" = $bash_test_summary
+		"BashTestLogFile"  = $bash_test_log_file
+	}
+
+	$Global:bash_tests_summary | ConvertTo-Json | Out-File -FilePath $bash_test_summary
+
+	#output the summary
+	Write-Output "`n============================================"
+	Get-Content -Raw $bash_test_summary
+	Write-Output "============================================`n"
+}
+finally
+{
+	# Restore User Path variable in the registry once the tests finish running.
+	[System.Environment]::SetEnvironmentVariable('Path', $OriginalSystemPath, [System.EnvironmentVariableTarget]::Machine)
+	# remove temp test directory
+	if (!$SkipCleanup)
+	{
+		# remove temp test folder
+		&$ShellPath -c "rm -rf $BashTestsPath/temp_test"
+
+		if(!$SkipInstallSSHD) {
+			# Uninstall the sshd, ssh-agent service
+			& "$PSScriptRoot\uninstall-sshd.ps1"
+		}
+
+		# Remove the test environment variable
+		Remove-Item ENV:\SSH_TEST_ENVIRONMENT
+
+		# Revert to user configured default shell.
+		if($user_default_shell) {
+			Set-ItemProperty -Path $registryPath -Name $dfltShell -Value $user_default_shell -Force
+			$out=(Get-ItemProperty -Path $registryPath -Name $dfltShell -ErrorAction SilentlyContinue)
+			if($out.$dfltShell -eq $user_default_shell) {
+				Write-Output "Reverted user configured default shell to $user_default_shell"
+			} else {
+				Write-Output "Failed to set HKLM:\Software\OpenSSH\DefaultShell to $user_default_shell"
+			}
+		} else {
+			Remove-ItemProperty -Path $registryPath -Name $dfltShell -ErrorAction SilentlyContinue
+		}
+	}
+
+	Push-location $user_pwd
+}
diff --git a/contrib/win32/openssh/build.json b/contrib/win32/openssh/build.json
new file mode 100644
index 000000000..2b494c2d8
--- /dev/null
+++ b/contrib/win32/openssh/build.json
@@ -0,0 +1,246 @@
+{
+  "Windows": [
+    {
+      "Name": "Onecore-X64",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X64 -Configuration Release -OneCore",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X64"
+    },
+    {
+      "Name": "Onecore-X86",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X86 -Configuration Release -OneCore",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x86",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X86"
+    },
+    {
+      "Name": "Onecore-ARM",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM -Configuration Release -OneCore",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM"
+    },
+    {
+      "Name": "Onecore-ARM64",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM64 -Configuration Release -OneCore",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM64"
+    },
+    {
+      "Name": "Onecore-X64-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X64 -Configuration Release -OneCore -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X64"
+    },
+    {
+      "Name": "Onecore-X86-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X86 -Configuration Release -OneCore -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x86",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X86"
+    },
+    {
+      "Name": "Onecore-ARM-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM -Configuration Release -OneCore -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM"
+    },
+    {
+      "Name": "Onecore-ARM64-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM64 -Configuration Release -OneCore -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM64"
+    },
+    {
+      "Name": "X64",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X64 -Configuration Release",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X64"
+    },
+    {
+      "Name": "X86",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X86 -Configuration Release",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x86",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X86"
+    },
+    {
+      "Name": "ARM",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM -Configuration Release",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM"
+    },
+    {
+      "Name": "ARM64",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM64 -Configuration Release",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM64"
+    },
+    {
+      "Name": "X64-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X64 -Configuration Release -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X64"
+    },
+    {
+      "Name": "X86-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch X86 -Configuration Release -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-x86",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-X86"
+    },
+    {
+      "Name": "ARM-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM -Configuration Release -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM"
+    },
+    {
+      "Name": "ARM64-NoOpenSSL",
+      "RepoDestinationPath": "C:\\OpenSSH",
+      "BuildCommand": "C:\\OpenSSH-build.ps1 -repolocation _RepoDestinationPath_ -destination _DockerVolume_ -NativeHostArch ARM64 -Configuration Release -NoOpenSSL",
+      "BuildDockerOptions": [
+        "-m",
+        "3968m"
+      ],
+      "DockerFile": ".\\contrib\\win32\\openssh\\DockerFile",
+      "AdditionalContextFiles": [ ".\\contrib\\win32\\openssh\\OpenSSH-build.ps1" ],
+      "DockerImageName": "di-openssh-arm64",
+      "BinaryBucket": "OpenSSH-Original",
+      "ArtifactsExpected": 1,
+      "VariableForExtractedBinariesPath": "OpenSSH-ARM64"
+    }
+  ],
+  "Linux": [
+  ]
+}
diff --git a/contrib/win32/openssh/config.h.vs b/contrib/win32/openssh/config.h.vs
new file mode 100644
index 000000000..d19b10758
--- /dev/null
+++ b/contrib/win32/openssh/config.h.vs
@@ -0,0 +1,1770 @@
+#pragma once
+
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define if you have a getaddrinfo that fails
+ for the all-zeros IPv6 address
+   */
+/* #undef AIX_GETNAMEINFO_HACK */
+
+/* Define if your AIX loginfailed() function
+ takes 4 arguments (AIX >= 5.2)
+   */
+/* #undef AIX_LOGINFAILED_4ARG */
+
+/* System only supports IPv4 audit records */
+/* #undef AU_IPv4 */
+
+/* Define if your resolver libs need this for getrrsetbyname */
+/* #undef BIND_8_COMPAT */
+
+/* Define if cmsg_type is not passed correctly */
+/* #undef BROKEN_CMSG_TYPE */
+
+/* getaddrinfo is broken (if present) */
+/* #undef BROKEN_GETADDRINFO */
+
+/* getgroups(0,NULL) will return -1 */
+/* #undef BROKEN_GETGROUPS */
+
+/* FreeBSD glob does not do what we need */
+/* #undef BROKEN_GLOB */
+
+/* Define if you system's inet_ntoa is busted
+ (e.g. Irix gcc issue) */
+/* #undef BROKEN_INET_NTOA */
+
+/* ia_uinfo routines not supported by OS yet */
+/* #undef BROKEN_LIBIAF */
+
+/* Ultrix mmap can't map files */
+/* #undef BROKEN_MMAP */
+
+/* Define if your struct dirent expects you to
+ allocate extra space for
+   d_name */
+/* #undef BROKEN_ONE_BYTE_DIRENT_D_NAME */
+
+/* Can't do comparisons on readv */
+/* #undef BROKEN_READV_COMPARISON */
+
+/* Define if you have a broken realpath. */
+/* #undef BROKEN_REALPATH */
+
+/* Needed for NeXT */
+/* #undef BROKEN_SAVED_UIDS */
+
+/* Define if your setregid() is broken */
+/* #undef BROKEN_SETREGID */
+
+/* Define if your setresgid() is broken */
+/* #undef BROKEN_SETRESGID */
+
+/* Define if your setresuid() is broken */
+/* #undef BROKEN_SETRESUID */
+
+/* Define if your setreuid() is broken */
+/* #undef BROKEN_SETREUID */
+
+/* LynxOS has broken setvbuf() implementation */
+/* #undef BROKEN_SETVBUF */
+
+/* QNX shadow support is broken */
+/* #undef BROKEN_SHADOW_EXPIRE */
+
+/* Define if your snprintf is busted */
+/* #undef BROKEN_SNPRINTF */
+
+/* tcgetattr with ICANON may hang */
+#define BROKEN_TCGETATTR_ICANON 1
+
+/* updwtmpx is broken (if present) */
+/* #undef BROKEN_UPDWTMPX */
+
+/* Define if you have BSD auth support */
+/* #undef BSD_AUTH */
+
+/* Define if you want to specify the path to your lastlog file */
+#define CONF_LASTLOG_FILE "/var/log/lastlog"
+
+/* Define if you want to specify the path to your utmp file */
+#define CONF_UTMP_FILE "/var/run/utmp"
+
+/* Define if you want to specify the path to your wtmpx file */
+/* #undef CONF_WTMPX_FILE */
+
+/* Define if you want to specify the path to your wtmp file */
+/* #undef CONF_WTMP_FILE */
+
+/* Define if your platform needs to skip post auth
+ file descriptor passing */
+/* #undef DISABLE_FD_PASSING */
+
+/* Define if you don't want to use lastlog */
+/* #undef DISABLE_LASTLOG */
+
+/* Define if you don't want to use your
+ system's login() call */
+/* #undef DISABLE_LOGIN */
+
+/* Define if you don't want to use pututline()
+ etc. to write [uw]tmp */
+/* #undef DISABLE_PUTUTLINE */
+
+/* Define if you don't want to use pututxline()
+ etc. to write [uw]tmpx */
+/* #undef DISABLE_PUTUTXLINE */
+
+/* Define if you want to disable shadow passwords */
+#define DISABLE_SHADOW 1
+
+/* Define if you don't want to use utmp */
+#define DISABLE_UTMP 1
+
+/* Define if you don't want to use utmpx */
+#define DISABLE_UTMPX 1
+
+/* Define if you don't want to use wtmp */
+#define DISABLE_WTMP 1
+
+/* Define if you don't want to use wtmpx */
+#define DISABLE_WTMPX 1
+
+/* Enable for PKCS#11 support */
+#define ENABLE_PKCS11 1
+
+/* Enable for U2F/FIDO support */
+#define ENABLE_SK
+
+/* Enable for built-in U2F/FIDO support */
+#define ENABLE_SK_INTERNAL
+
+/* Define for discoverable credential support */
+#define HAVE_FIDO_CRED_PROT
+#define HAVE_FIDO_CRED_SET_PROT
+#define HAVE_FIDO_DEV_SUPPORTS_CRED_PROT
+#define HAVE_FIDO_DEV_GET_TOUCH_BEGIN
+#define HAVE_FIDO_DEV_GET_TOUCH_STATUS
+#define HAVE_FIDO_CRED_SET_CLIENTDATA
+#define HAVE_FIDO_ASSERT_SET_CLIENTDATA
+#define HAVE_FIDO_DEV_IS_WINHELLO
+
+/* File names may not contain backslash characters */
+/* #undef FILESYSTEM_NO_BACKSLASH */
+
+/* fsid_t has member val */
+/* #undef FSID_HAS_VAL */
+
+/* fsid_t has member __val */
+/* #undef FSID_HAS___VAL */
+
+/* Define to 1 if the `getpgrp' function requires zero arguments. */
+/* #undef GETPGRP_VOID */
+
+/* Conflicting defs for getspnam */
+/* #undef GETSPNAM_CONFLICTING_DEFS */
+
+/* Define if your system glob() function has
+ the GLOB_ALTDIRFUNC extension */
+/* #undef GLOB_HAS_ALTDIRFUNC */
+
+/* Define if your system glob() function has
+ gl_matchc options in glob_t */
+#define GLOB_HAS_GL_MATCHC 1
+
+/* Define if your system glob() function has
+ gl_statv options in glob_t */
+#define GLOB_HAS_GL_STATV 1
+
+/* Define this if you want GSSAPI
+ support in the version 2 protocol */
+#define GSSAPI 1
+
+/* Define when enabling GSSAPI SSPI support on Windows */
+#define GSSAPI_SSPI 1
+
+/* Define if you want to use shadow password expire field */
+/* #undef HAS_SHADOW_EXPIRE */
+
+/* Define if your system uses access rights style
+ file descriptor passing */
+/* #undef HAVE_ACCRIGHTS_IN_MSGHDR */
+
+/* Define if you have ut_addr in utmp.h */
+/* #undef HAVE_ADDR_IN_UTMP */
+
+/* Define if you have ut_addr in utmpx.h */
+/* #undef HAVE_ADDR_IN_UTMPX */
+
+/* Define if you have ut_addr_v6 in utmp.h */
+/* #undef HAVE_ADDR_V6_IN_UTMP */
+
+/* Define if you have ut_addr_v6 in utmpx.h */
+/* #undef HAVE_ADDR_V6_IN_UTMPX */
+
+/* Define to 1 if you have the `arc4random' function. */
+#define HAVE_ARC4RANDOM 1
+
+/* Define to 1 if you have the `arc4random_buf' function. */
+#define HAVE_ARC4RANDOM_BUF 1
+
+/* Define to 1 if you have the `arc4random_uniform' function. */
+#define HAVE_ARC4RANDOM_UNIFORM 1
+
+/* Define to 1 if you have the `asprintf' function. */
+/* #undef HAVE_ASPRINTF */
+
+/* OpenBSD's gcc has bounded */
+/* #undef HAVE_ATTRIBUTE__BOUNDED__ */
+
+/* Have attribute nonnull */
+#define HAVE_ATTRIBUTE__NONNULL__ 1
+
+/* OpenBSD's gcc has sentinel */
+/* #undef HAVE_ATTRIBUTE__SENTINEL__ */
+
+/* Define to 1 if you have the `aug_get_machine' function. */
+/* #undef HAVE_AUG_GET_MACHINE */
+
+/* Define to 1 if you have the `b64_ntop' function. */
+/* #undef HAVE_B64_NTOP */
+
+/* Define to 1 if you have the `b64_pton' function. */
+/* #undef HAVE_B64_PTON */
+
+/* Define if you have the basename function. */
+#define HAVE_BASENAME 1
+
+/* Define to 1 if you have the `bcopy' function. */
+/* #undef HAVE_BCOPY */
+
+/* Define to 1 if you have the `bindresvport_sa' function. */
+/* #undef HAVE_BINDRESVPORT_SA */
+
+/* Define to 1 if you have the `BN_is_prime_ex' function. */
+#define HAVE_BN_IS_PRIME_EX 1
+
+/* Define to 1 if you have the <bsm/audit.h> header file. */
+/* #undef HAVE_BSM_AUDIT_H */
+
+/* Define to 1 if you have the <bstring.h> header file. */
+/* #undef HAVE_BSTRING_H */
+
+/* Define to 1 if you have the `clock' function. */
+#define HAVE_CLOCK 1
+
+/* define if you have clock_t data type */
+#define HAVE_CLOCK_T 1
+
+/* Define to 1 if you have the `closefrom' function. */
+/* #undef HAVE_CLOSEFROM */
+
+/* Define if gai_strerror() returns const char * */
+/* #undef HAVE_CONST_GAI_STRERROR_PROTO */
+
+/* Define if your system uses ancillary data style
+ file descriptor passing */
+/* #undef HAVE_CONTROL_IN_MSGHDR */
+
+/* Define to 1 if you have the <crypto/sha2.h> header file. */
+/* #undef HAVE_CRYPTO_SHA2_H */
+
+/* Define to 1 if you have the <crypt.h> header file. */
+/* #undef HAVE_CRYPT_H */
+
+/* Define if you are on Cygwin */
+/* #undef HAVE_CYGWIN */
+
+/* Define if your libraries define daemon() */
+/* #undef HAVE_DAEMON */
+
+/* Define to 1 if you have the declaration of `authenticate', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_AUTHENTICATE */
+
+/* Define to 1 if you have the declaration of `GLOB_NOMATCH', and to 0 if you
+   don't. */
+#define HAVE_DECL_GLOB_NOMATCH 1
+
+/* Define to 1 if you have the declaration of `h_errno', and to 0 if you
+   don't. */
+#define HAVE_DECL_H_ERRNO 0
+
+/* Define to 1 if you have the declaration of `loginfailed', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_LOGINFAILED */
+
+/* Define to 1 if you have the declaration of `loginrestrictions', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_LOGINRESTRICTIONS */
+
+/* Define to 1 if you have the declaration of `loginsuccess', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_LOGINSUCCESS */
+
+/* Define to 1 if you have the declaration of `MAXSYMLINKS', and to 0 if you
+   don't. */
+#define HAVE_DECL_MAXSYMLINKS 0
+
+/* Define to 1 if you have the declaration of `offsetof', and to 0 if you
+   don't. */
+#define HAVE_DECL_OFFSETOF 1
+
+/* Define to 1 if you have the declaration of `O_NONBLOCK', and to 0 if you
+   don't. */
+#define HAVE_DECL_O_NONBLOCK 1
+
+/* Define to 1 if you have the declaration of `passwdexpired', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_PASSWDEXPIRED */
+
+/* Define to 1 if you have the declaration of `setauthdb', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_SETAUTHDB */
+
+/* Define to 1 if you have the declaration of `SHUT_RD', and to 0 if you
+   don't. */
+#define HAVE_DECL_SHUT_RD 1
+
+/* Define to 1 if you have the declaration of `writev', and to 0 if you don't.
+   */
+#define HAVE_DECL_WRITEV 0
+
+/* Define to 1 if you have the declaration of `_getlong', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL__GETLONG */
+
+/* Define to 1 if you have the declaration of `_getshort', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL__GETSHORT */
+
+/* Define if you have /dev/ptmx */
+#define HAVE_DEV_PTMX 1
+
+/* Define if you have /dev/ptc */
+/* #undef HAVE_DEV_PTS_AND_PTC */
+
+/* Define to 1 if you have the <dirent.h> header file. */
+/* #undef HAVE_DIRENT_H
+
+/* Define to 1 if you have the `dirfd' function. */
+/* #undef HAVE_DIRFD */
+
+/* Define to 1 if you have the `dirname' function. */
+/* #define HAVE_DIRNAME 1 */
+
+/* Define to 1 if you have the `DSA_generate_parameters_ex' function. */
+#define HAVE_DSA_GENERATE_PARAMETERS_EX 1
+
+/* Define to 1 if you have the <endian.h> header file. */
+/* #undef HAVE_ENDIAN_H */
+
+/* Define to 1 if you have the `endutent' function. */
+/* #undef HAVE_ENDUTENT */
+
+/* Define to 1 if you have the `endutxent' function. */
+/* #undef HAVE_ENDUTXENT */
+
+/* Define if your system has /etc/default/login */
+/* #undef HAVE_ETC_DEFAULT_LOGIN */
+
+/* Define to 1 if you have the `EVP_sha256' function. */
+#define HAVE_EVP_SHA256 1
+
+/* Define to 1 if you have the `EVP_sha384' function. */
+#define HAVE_EVP_SHA384 1
+
+/* Define to 1 if you have the `EVP_sha512' function. */
+#define HAVE_EVP_SHA512 1
+
+/* Define if you have ut_exit in utmp.h */
+/* #undef HAVE_EXIT_IN_UTMP */
+
+/* Define to 1 if you have the `fchmod' function. */
+#define HAVE_FCHMOD  1
+
+/* Define to 1 if you have the `fchown' function. */
+#define HAVE_FCHOWN  1
+
+/* Use F_CLOSEM fcntl for closefrom */
+/* #undef HAVE_FCNTL_CLOSEM */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the <features.h> header file. */
+/* #undef HAVE_FEATURES_H */
+
+/* Define to 1 if you have the <floatingpoint.h> header file. */
+/* #undef HAVE_FLOATINGPOINT_H */
+
+/* Define to 1 if you have the `fmt_scaled' function. */
+/* #undef HAVE_FMT_SCALED */
+
+/* Define to 1 if you have the `freeaddrinfo' function. */
+/* #undef HAVE_FREEADDRINFO */
+
+/* Define to 1 if the system has the type `fsblkcnt_t'. */
+/* #undef HAVE_FSBLKCNT_T */
+
+/* Define to 1 if the system has the type `fsfilcnt_t'. */
+/* #undef HAVE_FSFILCNT_T */
+
+/* Define to 1 if you have the `fstatvfs' function. */
+#define HAVE_FSTATVFS 1
+
+/* Define to 1 if you have the `futimes' function. */
+/* #undef HAVE_FUTIMES */
+
+/* Define to 1 if you have the `gai_strerror' function. */
+/* #undef HAVE_GAI_STRERROR */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+/* #undef HAVE_GETADDRINFO */
+
+/* Define to 1 if you have the `getaudit' function. */
+/* #undef HAVE_GETAUDIT */
+
+/* Define to 1 if you have the `getaudit_addr' function. */
+/* #undef HAVE_GETAUDIT_ADDR */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getgrouplist' function. */
+/* #undef HAVE_GETGROUPLIST */
+
+/* Define to 1 if you have the `getgrset' function. */
+/* #undef HAVE_GETGRSET */
+
+/* Define to 1 if you have the `getlastlogxbyname' function. */
+/* #undef HAVE_GETLASTLOGXBYNAME */
+
+/* Define to 1 if you have the `getluid' function. */
+/* #undef HAVE_GETLUID */
+
+/* Define to 1 if you have the `getnameinfo' function. */
+/* #undef HAVE_GETNAMEINFO */
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define if your getopt(3) defines and uses optreset */
+/* #undef HAVE_GETOPT_OPTRESET */
+
+/* Define if your libraries define getpagesize() */
+/* #undef HAVE_GETPAGESIZE */
+
+/* Define to 1 if you have the `getpeereid' function. */
+/* #undef HAVE_GETPEEREID */
+
+/* Define to 1 if you have the `getpeerucred' function. */
+/* #undef HAVE_GETPEERUCRED */
+
+/* Define to 1 if you have the `getpwanam' function. */
+/* #undef HAVE_GETPWANAM */
+
+/* Define to 1 if you have the `getrlimit' function. */
+/* #undef HAVE_GETRLIMIT */
+
+/* Define if getrrsetbyname() exists */
+/* #undef HAVE_GETRRSETBYNAME */
+
+/* Define to 1 if you have the `getrusage' function. */
+/* #undef HAVE_GETRUSAGE */
+
+/* Define to 1 if you have the `getseuserbyname' function. */
+/* #undef HAVE_GETSEUSERBYNAME */
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `getttyent' function. */
+/* #undef HAVE_GETTTYENT */
+
+/* Define to 1 if you have the `getutent' function. */
+/* #undef HAVE_GETUTENT */
+
+/* Define to 1 if you have the `getutid' function. */
+/* #undef HAVE_GETUTID */
+
+/* Define to 1 if you have the `getutline' function. */
+/* #undef HAVE_GETUTLINE */
+
+/* Define to 1 if you have the `getutxent' function. */
+/* #undef HAVE_GETUTXENT */
+
+/* Define to 1 if you have the `getutxid' function. */
+/* #undef HAVE_GETUTXID */
+
+/* Define to 1 if you have the `getutxline' function. */
+/* #undef HAVE_GETUTXLINE */
+
+/* Define to 1 if you have the `getutxuser' function. */
+/* #undef HAVE_GETUTXUSER */
+
+/* Define to 1 if you have the `get_default_context_with_level' function. */
+/* #undef HAVE_GET_DEFAULT_CONTEXT_WITH_LEVEL */
+
+/* Define to 1 if you have the `glob' function. */
+/* #undef HAVE_GLOB */
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H 1
+
+/* Define to 1 if you have the `group_from_gid' function. */
+/* #undef HAVE_GROUP_FROM_GID */
+
+/* Define to 1 if you have the <gssapi_generic.h> header file. */
+/* #undef HAVE_GSSAPI_GENERIC_H */
+
+/* Define to 1 if you have the <gssapi/gssapi_generic.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_GENERIC_H */
+
+/* Define to 1 if you have the <gssapi/gssapi.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_H */
+
+/* Define to 1 if you have the <gssapi/gssapi_krb5.h> header file. */
+/* #undef HAVE_GSSAPI_GSSAPI_KRB5_H */
+
+/* Define to 1 if you have the <gssapi.h> header file. */
+#define HAVE_GSSAPI_H 1
+
+/* Define to 1 if you have the <gssapi_krb5.h> header file. */
+/* #undef HAVE_GSSAPI_KRB5_H */
+
+/* Define if HEADER.ad exists in arpa/nameser.h */
+/* #undef HAVE_HEADER_AD */
+
+/* Define if you have ut_host in utmp.h */
+/* #undef HAVE_HOST_IN_UTMP */
+
+/* Define if you have ut_host in utmpx.h */
+/* #undef HAVE_HOST_IN_UTMPX */
+
+/* Define to 1 if you have the <iaf.h> header file. */
+/* #undef HAVE_IAF_H */
+
+/* Define to 1 if you have the <ia.h> header file. */
+/* #undef HAVE_IA_H */
+
+/* Define if you have ut_id in utmp.h */
+/* #undef HAVE_ID_IN_UTMP */
+
+/* Define if you have ut_id in utmpx.h */
+/* #undef HAVE_ID_IN_UTMPX */
+
+/* Define to 1 if you have the `inet_aton' function. */
+/* #undef HAVE_INET_ATON */
+
+/* Define to 1 if you have the `inet_ntoa' function. */
+/* #undef HAVE_INET_NTOA */
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#define HAVE_INET_NTOP 1
+
+/* Define to 1 if you have the `innetgr' function. */
+/* #undef HAVE_INNETGR */
+
+/* define if you have int64_t data type */
+#define HAVE_INT64_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* define if you have intxx_t data type */
+#define HAVE_INTXX_T 1
+
+/* Define to 1 if the system has the type `in_addr_t'. */
+/* #undef HAVE_IN_ADDR_T */
+
+/* Define to 1 if the system has the type `in_port_t'. */
+/* #undef HAVE_IN_PORT_T */
+
+/* Define if you have isblank(3C). */
+#define HAVE_ISBLANK 1
+
+/* Define to 1 if you have the <lastlog.h> header file. */
+/* #undef HAVE_LASTLOG_H */
+
+/* Define to 1 if you have the <libaudit.h> header file. */
+/* #undef HAVE_LIBAUDIT_H */
+
+/* Define to 1 if you have the `bsm' library (-lbsm). */
+/* #undef HAVE_LIBBSM */
+
+/* Define to 1 if you have the `crypt' library (-lcrypt). */
+/* #undef HAVE_LIBCRYPT */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+/* #undef HAVE_LIBDL */
+
+/* Define to 1 if you have the <libgen.h> header file. */
+#define HAVE_LIBGEN_H 1
+
+/* Define if system has libiaf that supports set_id */
+/* #undef HAVE_LIBIAF */
+
+/* Define to 1 if you have the `network' library (-lnetwork). */
+/* #undef HAVE_LIBNETWORK */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `pam' library (-lpam). */
+/* #undef HAVE_LIBPAM */
+
+/* Define to 1 if you have the `socket' library (-lsocket). */
+/* #undef HAVE_LIBSOCKET */
+
+/* Define to 1 if you have the <libutil.h> header file. */
+/* #undef HAVE_LIBUTIL_H */
+
+/* Define to 1 if you have the `xnet' library (-lxnet). */
+/* #undef HAVE_LIBXNET */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define HAVE_LIBZ 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the <linux/if_tun.h> header file. */
+/* #undef HAVE_LINUX_IF_TUN_H */
+
+/* Define if your libraries define login() */
+/* #undef HAVE_LOGIN */
+
+/* Define to 1 if you have the <login_cap.h> header file. */
+/* #undef HAVE_LOGIN_CAP_H */
+
+/* Define to 1 if you have the `login_getcapbool' function. */
+/* #undef HAVE_LOGIN_GETCAPBOOL */
+
+/* Define to 1 if you have the <login.h> header file. */
+/* #undef HAVE_LOGIN_H */
+
+/* Define to 1 if you have the `logout' function. */
+/* #undef HAVE_LOGOUT */
+
+/* Define to 1 if you have the `logwtmp' function. */
+/* #undef HAVE_LOGWTMP */
+
+/* Define to 1 if the system has the type `long double'. */
+#define HAVE_LONG_DOUBLE 1
+
+/* Define to 1 if the system has the type `long long'. */
+#define HAVE_LONG_LONG 1
+
+/* Define to 1 if you have the <maillock.h> header file. */
+/* #undef HAVE_MAILLOCK_H */
+
+/* Define to 1 if you have the `md5_crypt' function. */
+/* #undef HAVE_MD5_CRYPT */
+
+/* Define if you want to allow MD5 passwords */
+/* #undef HAVE_MD5_PASSWORDS */
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkdtemp' function. */
+/* #undef HAVE_MKDTEMP */
+
+/* Define to 1 if you have the `mmap' function. */
+/* #undef HAVE_MMAP */
+
+/* define if you have mode_t data type */
+#define HAVE_MODE_T 1
+
+/* Some systems put nanosleep outside of libc */
+/* #undef HAVE_NANOSLEEP */
+
+/* Define to 1 if you have the <ndir.h> header file. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+/* #undef HAVE_NETDB_H */
+
+/* Define to 1 if you have the <netgroup.h> header file. */
+/* #undef HAVE_NETGROUP_H */
+
+/* Define to 1 if you have the <net/if_tun.h> header file. */
+/* #undef HAVE_NET_IF_TUN_H */
+
+/* Define if you are on NeXT */
+/* #undef HAVE_NEXT */
+
+/* Define to 1 if you have the `ngetaddrinfo' function. */
+/* #undef HAVE_NGETADDRINFO */
+
+/* Define to 1 if you have the `nsleep' function. */
+/* #undef HAVE_NSLEEP */
+
+/* Define to 1 if you have the `ogetaddrinfo' function. */
+/* #undef HAVE_OGETADDRINFO */
+
+/* Define if you have an old version of PAM
+ which takes only one argument to
+   pam_strerror */
+/* #undef HAVE_OLD_PAM */
+
+/* Define to 1 if you have the `openlog_r' function. */
+/* #undef HAVE_OPENLOG_R */
+
+/* Define to 1 if you have the `openpty' function. */
+/* #undef HAVE_OPENPTY */
+
+/* Define if your ssl headers are included
+ with #include <openssl/header.h>
+   */
+#define HAVE_OPENSSL 1
+
+/* Define if you have Digital Unix Security
+ Integration Architecture */
+/* #undef HAVE_OSF_SIA */
+
+/* Define to 1 if you have the `pam_getenvlist' function. */
+/* #undef HAVE_PAM_GETENVLIST */
+
+/* Define to 1 if you have the <pam/pam_appl.h> header file. */
+/* #undef HAVE_PAM_PAM_APPL_H */
+
+/* Define to 1 if you have the `pam_putenv' function. */
+/* #undef HAVE_PAM_PUTENV */
+
+/* Define to 1 if you have the <paths.h> header file. */
+/* #undef HAVE_PATHS_H */
+
+/* Define if you have ut_pid in utmp.h */
+/* #undef HAVE_PID_IN_UTMP */
+
+/* define if you have pid_t data type */
+#define HAVE_PID_T 1
+
+/* Define to 1 if you have the `poll' function. */
+/* #undef HAVE_POLL */
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `prctl' function. */
+/* #undef HAVE_PRCTL */
+
+/* Define to 1 if you have priveleged-port concept */
+/* #undef HAVE_PRIV_CONCEPT */
+
+/* Define if you have /proc/$pid/fd */
+#define HAVE_PROC_PID 1
+
+/* Define to 1 if you have the `pstat' function. */
+/* #undef HAVE_PSTAT */
+
+/* Define to 1 if you have the <pty.h> header file. */
+/* #undef HAVE_PTY_H */
+
+/* Define to 1 if you have the `pututline' function. */
+/* #undef HAVE_PUTUTLINE */
+
+/* Define to 1 if you have the `pututxline' function. */
+/* #undef HAVE_PUTUTXLINE */
+
+/* Define if your password has a pw_change field */
+/* #undef HAVE_PW_CHANGE_IN_PASSWD */
+
+/* Define if your password has a pw_class field */
+/* #undef HAVE_PW_CLASS_IN_PASSWD */
+
+/* Define if your password has a pw_expire field */
+/* #undef HAVE_PW_EXPIRE_IN_PASSWD */
+
+/* Define to 1 if you have the `readpassphrase' function. */
+/* #undef HAVE_READPASSPHRASE */
+
+/* Define to 1 if you have the <readpassphrase.h> header file. */
+/* #undef HAVE_READPASSPHRASE_H */
+
+/* Define to 1 if you have the `realpath' function. */
+#define HAVE_REALPATH 1
+
+/* Define to 1 if you have the `recvmsg' function. */
+/* #undef HAVE_RECVMSG */
+
+/* sys/resource.h has RLIMIT_NPROC */
+/* #undef HAVE_RLIMIT_NPROC */
+
+/* Define to 1 if you have the <rpc/types.h> header file. */
+/* #undef HAVE_RPC_TYPES_H */
+
+/* Define to 1 if you have the `rresvport_af' function. */
+/* #undef HAVE_RRESVPORT_AF */
+
+/* Define to 1 if you have the `RSA_generate_key_ex' function. */
+#define HAVE_RSA_GENERATE_KEY_EX 1
+
+/* Define to 1 if you have the `RSA_get_default_method' function. */
+#define HAVE_RSA_GET_DEFAULT_METHOD 1
+
+/* Define to 1 if you have the <sandbox.h> header file. */
+/* #undef HAVE_SANDBOX_H */
+
+/* Define to 1 if you have the `sandbox_init' function. */
+/* #undef HAVE_SANDBOX_INIT */
+
+/* define if you have sa_family_t data type */
+/* #undef HAVE_SA_FAMILY_T */
+
+/* Define if you have SecureWare-based
+ protected password database */
+/* #undef HAVE_SECUREWARE */
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define to 1 if you have the `sendmsg' function. */
+/* #undef HAVE_SENDMSG */
+
+/* Define to 1 if you have the `setauthdb' function. */
+/* #undef HAVE_SETAUTHDB */
+
+/* Define to 1 if you have the `setdtablesize' function. */
+/* #undef HAVE_SETDTABLESIZE */
+
+/* Define to 1 if you have the `setegid' function. */
+/* #undef HAVE_SETEGID */
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `seteuid' function. */
+/* #undef HAVE_SETEUID */
+
+/* Define to 1 if you have the `setgroupent' function. */
+/* #undef HAVE_SETGROUPENT */
+
+/* Define to 1 if you have the `setgroups' function. */
+/* #undef HAVE_SETGROUPS */
+
+/* Define to 1 if you have the `setlogin' function. */
+/* #undef HAVE_SETLOGIN */
+
+/* Define to 1 if you have the `setluid' function. */
+/* #undef HAVE_SETLUID */
+
+/* Define to 1 if you have the `setpcred' function. */
+/* #undef HAVE_SETPCRED */
+
+/* Define to 1 if you have the `setproctitle' function. */
+/* #undef HAVE_SETPROCTITLE */
+
+/* Define to 1 if you have the `setregid' function. */
+/* #undef HAVE_SETREGID */
+
+/* Define to 1 if you have the `setresgid' function. */
+/* #undef HAVE_SETRESGID */
+
+/* Define to 1 if you have the `setresuid' function. */
+/* #undef HAVE_SETRESUID */
+
+/* Define to 1 if you have the `setreuid' function. */
+/* #undef HAVE_SETREUID */
+
+/* Define to 1 if you have the `setrlimit' function. */
+/* #undef HAVE_SETRLIMIT */
+
+/* Define to 1 if you have the `setsid' function. */
+#define HAVE_SETSID 1
+
+/* Define to 1 if you have the `setutent' function. */
+/* #undef HAVE_SETUTENT */
+
+/* Define to 1 if you have the `setutxdb' function. */
+/* #undef HAVE_SETUTXDB */
+
+/* Define to 1 if you have the `setutxent' function. */
+/* #undef HAVE_SETUTXENT */
+
+/* Define to 1 if you have the `setvbuf' function. */
+#define HAVE_SETVBUF 1
+
+/* Define to 1 if you have the `set_id' function. */
+/* #undef HAVE_SET_ID */
+
+/* Define to 1 if you have the `SHA256_Update' function. */
+/* #undef HAVE_SHA256_UPDATE */
+
+/* Define to 1 if you have the <sha2.h> header file. */
+/* #undef HAVE_SHA2_H */
+
+/* Define to 1 if you have the <shadow.h> header file. */
+/* #undef HAVE_SHADOW_H */
+
+/* Define to 1 if you have the `sigaction' function. */
+/* #undef HAVE_SIGACTION */
+
+/* Define to 1 if you have the `sigvec' function. */
+/* #undef HAVE_SIGVEC */
+
+/* Define to 1 if the system has the type `sig_atomic_t'. */
+#define HAVE_SIG_ATOMIC_T 1
+
+/* define if you have size_t data type */
+#define HAVE_SIZE_T 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define to 1 if you have the `socketpair' function. */
+/* #undef HAVE_SOCKETPAIR */
+
+/* Have PEERCRED socket option */
+/* #undef HAVE_SO_PEERCRED */
+
+/* define if you have ssize_t data type */
+/* #define HAVE_SSIZE_T 1 */
+
+/* Fields in struct sockaddr_storage */
+#define HAVE_SS_FAMILY_IN_SS 1
+
+/* Define to 1 if you have the `statfs' function. */
+/* #undef HAVE_STATFS */
+
+/* Define to 1 if you have the `statvfs' function. */
+#define HAVE_STATVFS 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Silly mkstemp() */
+/* #undef HAVE_STRICT_MKSTEMP */
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the `strmode' function. */
+/* #undef HAVE_STRMODE */
+
+/* Define to 1 if you have the `strnvis' function. */
+/* #undef HAVE_STRNVIS */
+
+/* Define to 1 if you have the `strptime' function. */
+/* #undef HAVE_STRPTIME */
+
+/* Define to 1 if you have the `strsep' function. */
+/* #undef HAVE_STRSEP */
+
+/* Define to 1 if you have the `strtoll' function. */
+#define HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `strtonum' function. */
+/* #undef HAVE_STRTONUM */
+
+/* Define to 1 if you have the `strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* define if you have struct addrinfo data type */
+#define HAVE_STRUCT_ADDRINFO 1
+
+/* define if you have struct in6_addr data type */
+/* #undef HAVE_STRUCT_IN6_ADDR */
+
+/* define if you have struct sockaddr_in6 data type */
+/* #undef HAVE_STRUCT_SOCKADDR_IN6 */
+
+/* Define to 1 if `sin6_scope_id' is a member of `struct sockaddr_in6'. */
+/* #undef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID */
+
+/* define if you have struct sockaddr_storage data type */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if `st_blksize' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BLKSIZE */
+
+/* Define to 1 if the system has the type `struct timespec'. */
+/* #undef HAVE_STRUCT_TIMESPEC */
+#define HAVE_STRUCT_TIMESPEC 1
+
+/* define if you have struct timeval */
+#define HAVE_STRUCT_TIMEVAL 1
+
+/* Define to 1 if you have the `swap32' function. */
+/* #undef HAVE_SWAP32 */
+
+/* Define to 1 if you have the `sysconf' function. */
+/* #undef HAVE_SYSCONF */
+
+/* Define if you have syslen in utmpx.h */
+/* #undef HAVE_SYSLEN_IN_UTMPX */
+
+/* Define to 1 if you have the <sys/audit.h> header file. */
+/* #undef HAVE_SYS_AUDIT_H */
+
+/* Define to 1 if you have the <sys/bitypes.h> header file. */
+/* #undef HAVE_SYS_BITYPES_H */
+
+/* Define to 1 if you have the <sys/bsdtty.h> header file. */
+/* #undef HAVE_SYS_BSDTTY_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+/* #undef HAVE_SYS_CDEFS_H */
+
+/* Define to 1 if you have the <sys/dir.h> header file. */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define if your system defines sys_errlist[] */
+/* #undef HAVE_SYS_ERRLIST */
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+/* #undef HAVE_SYS_MMAN_H */
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+/* #undef HAVE_SYS_MOUNT_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file. */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define if your system defines sys_nerr */
+/* #undef HAVE_SYS_NERR */
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+/* #undef HAVE_SYS_POLL_H */
+
+/* Define to 1 if you have the <sys/prctl.h> header file. */
+/* #undef HAVE_SYS_PRCTL_H */
+
+/* Define to 1 if you have the <sys/pstat.h> header file. */
+/* #undef HAVE_SYS_PSTAT_H */
+
+/* Define to 1 if you have the <sys/ptms.h> header file. */
+/* #undef HAVE_SYS_PTMS_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#define HAVE_SYS_STATVFS_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/stream.h> header file. */
+/* #undef HAVE_SYS_STREAM_H */
+
+/* Define to 1 if you have the <sys/stropts.h> header file. */
+/* #undef HAVE_SYS_STROPTS_H */
+
+/* Define to 1 if you have the <sys/strtio.h> header file. */
+/* #undef HAVE_SYS_STRTIO_H */
+
+/* Force use of sys/syslog.h on Ultrix */
+/* #undef HAVE_SYS_SYSLOG_H */
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+/* #undef HAVE_SYS_SYSMACROS_H */
+
+/* Define to 1 if you have the <sys/timers.h> header file. */
+/* #undef HAVE_SYS_TIMERS_H */
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H  1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the `tcgetpgrp' function. */
+/* #undef HAVE_TCGETPGRP */
+
+/* Define to 1 if you have the `tcsendbreak' function. */
+/* #undef HAVE_TCSENDBREAK */
+
+/* Define to 1 if you have the `time' function. */
+#define HAVE_TIME 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define if you have ut_time in utmp.h */
+/* #undef HAVE_TIME_IN_UTMP */
+
+/* Define if you have ut_time in utmpx.h */
+/* #undef HAVE_TIME_IN_UTMPX */
+
+/* Define to 1 if you have the `timingsafe_bcmp' function. */
+/* #undef HAVE_TIMINGSAFE_BCMP */
+
+/* Define to 1 if you have the <tmpdir.h> header file. */
+/* #undef HAVE_TMPDIR_H */
+
+/* Define to 1 if you have the `truncate' function. */
+/* #undef HAVE_TRUNCATE */
+
+/* Define to 1 if you have tty support */
+/* #undef HAVE_TTY */
+
+/* Define to 1 if you have the <ttyent.h> header file. */
+/* #undef HAVE_TTYENT_H */
+
+/* Define if you have ut_tv in utmp.h */
+/* #undef HAVE_TV_IN_UTMP */
+
+/* Define if you have ut_tv in utmpx.h */
+/* #undef HAVE_TV_IN_UTMPX */
+
+/* Define if you have ut_type in utmp.h */
+/* #undef HAVE_TYPE_IN_UTMP */
+
+/* Define if you have ut_type in utmpx.h */
+/* #undef HAVE_TYPE_IN_UTMPX */
+
+/* Define to 1 if you have the <ucred.h> header file. */
+/* #undef HAVE_UCRED_H */
+
+/* define if you have uintxx_t data type */
+#define HAVE_UINTXX_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+/* #undef HAVE_UNSETENV */
+
+/* Define to 1 if the system has the type `unsigned long long'. */
+#define HAVE_UNSIGNED_LONG_LONG 1
+
+/* Define to 1 if you have the `updwtmp' function. */
+/* #undef HAVE_UPDWTMP */
+
+/* Define to 1 if you have the `updwtmpx' function. */
+/* #undef HAVE_UPDWTMPX */
+
+/* Define to 1 if you have the <usersec.h> header file. */
+/* #undef HAVE_USERSEC_H */
+
+/* Define to 1 if you have the `user_from_uid' function. */
+#define HAVE_USER_FROM_UID 1
+
+/* Define to 1 if you have the <util.h> header file. */
+/* #undef HAVE_UTIL_H */
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+/* #undef HAVE_UTIME_H */
+
+/* Define to 1 if you have the `utmpname' function. */
+/* #undef HAVE_UTMPNAME */
+
+/* Define to 1 if you have the `utmpxname' function. */
+/* #undef HAVE_UTMPXNAME */
+
+/* Define to 1 if you have the <utmpx.h> header file. */
+/* #undef HAVE_UTMPX_H */
+
+/* Define to 1 if you have the <utmp.h> header file. */
+/* #undef HAVE_UTMP_H */
+
+/* define if you have u_char data type */
+/* #undef HAVE_U_CHAR */
+
+/* define if you have u_int data type */
+/* #undef HAVE_U_INT */
+
+/* define if you have u_int64_t data type */
+/* #undef HAVE_U_INT64_T */
+
+/* define if you have u_intxx_t data type */
+/* #undef HAVE_U_INTXX_T */
+
+/* Define to 1 if you have the `vasprintf' function. */
+/* #undef HAVE_VASPRINTF */
+
+/* Define if va_copy exists */
+#define HAVE_VA_COPY 1
+
+/* Define to 1 if you have the `vhangup' function. */
+/* #undef HAVE_VHANGUP */
+
+/* Define to 1 if you have the <vis.h> header file. */
+/* #undef HAVE_VIS_H */
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#define HAVE_VSNPRINTF 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define HAVE_WAITPID 1
+
+/* Define to 1 if you have the `_getlong' function. */
+/* #undef HAVE__GETLONG */
+
+/* Define to 1 if you have the `_getpty' function. */
+/* #undef HAVE__GETPTY */
+
+/* Define to 1 if you have the `_getshort' function. */
+/* #undef HAVE__GETSHORT */
+
+/* Define if you have struct __res_state _res as an extern */
+#define HAVE__RES_EXTERN 1
+
+/* Define to 1 if you have the `__b64_ntop' function. */
+/* #undef HAVE___B64_NTOP */
+
+/* Define to 1 if you have the `__b64_pton' function. */
+/* #undef HAVE___B64_PTON */
+
+/* Define if compiler implements __FUNCTION__ */
+#define HAVE___FUNCTION__ 1
+
+/* Define if libc defines __progname */
+#define HAVE___PROGNAME  1
+
+/* Fields in struct sockaddr_storage */
+/* #undef HAVE___SS_FAMILY_IN_SS */
+
+/* Define if __va_copy exists */
+#define HAVE___VA_COPY 1
+
+/* Define if compiler implements __func__ */
+#define HAVE___func__ 1
+
+/* Define this if you are using the Heimdal
+ version of Kerberos V5 */
+/* #undef HEIMDAL */
+
+/* Define if you need to use IP address
+ instead of hostname in $DISPLAY */
+/* #undef IPADDR_IN_DISPLAY */
+
+/* Detect IPv4 in IPv6 mapped addresses
+ and treat as IPv4 */
+/* #undef IPV4_IN_IPV6 */
+
+/* Define if your system choked on IP TOS setting */
+#define IP_TOS_IS_BROKEN 1
+
+/* Define if you want Kerberos 5 support */
+/* #undef KRB5 */
+
+/* Define if pututxline updates lastlog too */
+/* #undef LASTLOG_WRITE_PUTUTXLINE */
+
+/* Define if you want
+ TCP Wrappers support */
+/* #undef LIBWRAP */
+
+/* Define to whatever link() returns for "not supported"
+ if it doesn't return
+   EOPNOTSUPP. */
+/* #undef LINK_OPNOTSUPP_ERRNO */
+
+/* Adjust Linux out-of-memory killer */
+/* #undef LINUX_OOM_ADJUST */
+
+/* max value of long long calculated by configure */
+/* #undef LLONG_MAX */
+
+/* min value of long long calculated by configure */
+/* #undef LLONG_MIN */
+
+/* Account locked with pw(1) */
+/* #undef LOCKED_PASSWD_PREFIX */
+
+/* String used in /etc/passwd to denote locked account */
+/* #undef LOCKED_PASSWD_STRING */
+
+/* String used in /etc/passwd to denote locked account */
+/* #undef LOCKED_PASSWD_SUBSTR */
+
+/* Some versions of /bin/login need the TERM supplied
+ on the commandline */
+/* #undef LOGIN_NEEDS_TERM */
+
+/* Some systems need a utmpx entry for /bin/login to work */
+/* #undef LOGIN_NEEDS_UTMPX */
+
+/* Define if your login program cannot handle end of options ("--") */
+/* #undef LOGIN_NO_ENDOPT */
+
+/* If your header files don't define LOGIN_PROGRAM,
+ then use this (detected)
+   from environment and PATH */
+#define LOGIN_PROGRAM_FALLBACK "/usr/bin/login"
+
+/* Set this to your mail directory if you do not have _PATH_MAILDIR */
+#define MAIL_DIRECTORY "/var/spool/mail"
+
+/* Define on *nto-qnx systems */
+/* #undef MISSING_FD_MASK */
+
+/* Define on *nto-qnx systems */
+/* #undef MISSING_HOWMANY */
+
+/* Define on *nto-qnx systems */
+/* #undef MISSING_NFDBITS */
+
+/* Need setpgrp to acquire controlling tty */
+/* #undef NEED_SETPGRP */
+
+/* Define if the concept of ports only accessible to
+ superusers isn't known
+   */
+#define NO_IPPORT_RESERVED_CONCEPT 1
+
+/* Define if you don't want to use lastlog in session.c */
+/* #undef NO_SSH_LASTLOG */
+
+/* Define if X11 doesn't support AF_UNIX sockets on that system */
+#define NO_X11_UNIX_SOCKETS 1
+
+/* Define if EVP_DigestUpdate returns void */
+/* #undef OPENSSL_EVP_DIGESTUPDATE_VOID */
+
+/* libcrypto includes complete ECC support */
+#define OPENSSL_HAS_ECC 1
+#define OPENSSL_HAS_NISTP521 1
+#define HAVE_EC_KEY_METHOD_NEW 1
+
+/* libcrypto is missing AES 192 and 256 bit functions */
+/* #undef OPENSSL_LOBOTOMISED_AES */
+
+/* Define if you want OpenSSL's internally seeded PRNG only */
+#define OPENSSL_PRNG_ONLY 1
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "openssh-unix-dev@mindrot.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "OpenSSH"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "OpenSSH Portable"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "openssh"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "Portable"
+
+/* Define if you are using Solaris-derived PAM which
+ passes pam_messages to
+   the conversation function
+ with an extra level of indirection */
+/* #undef PAM_SUN_CODEBASE */
+
+/* Work around problematic Linux PAM modules handling of PAM_TTY */
+/* #undef PAM_TTY_KLUDGE */
+
+/* must supply username to passwd */
+/* #undef PASSWD_NEEDS_USERNAME */
+
+/* Port number of PRNGD/EGD random number socket */
+/* #undef PRNGD_PORT */
+
+/* Location of PRNGD/EGD random number socket */
+/* #undef PRNGD_SOCKET */
+
+/* read(1) can return 0 for a non-closed fd */
+/* #undef PTY_ZEROREAD */
+
+/* Sandbox using Darwin sandbox_init(3) */
+/* #undef SANDBOX_DARWIN */
+
+/* no privsep sandboxing */
+#define SANDBOX_NULL 1
+
+/* Sandbox using setrlimit(2) */
+/* #undef SANDBOX_RLIMIT */
+
+/* Sandbox using systrace(4) */
+/* #undef SANDBOX_SYSTRACE */
+
+/* Define if your platform breaks doing a seteuid before a setuid */
+/* #undef SETEUID_BREAKS_SETUID */
+
+/* The size of `char', as computed by sizeof. */
+#define SIZEOF_CHAR 1
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long int', as computed by sizeof. */
+#define SIZEOF_LONG_INT 4
+
+/* The size of `long long int', as computed by sizeof. */
+#define SIZEOF_LONG_LONG_INT 8
+
+/* The size of `short int', as computed by sizeof. */
+#define SIZEOF_SHORT_INT 2
+
+/* Define if you want S/Key support */
+/* #undef SKEY */
+
+/* Define if your skeychallenge()
+ function takes 4 arguments (NetBSD) */
+/* #undef SKEYCHALLENGE_4ARG */
+
+/* Define as const if snprintf() can declare const char *fmt */
+#define SNPRINTF_CONST const
+
+/* Define to a Set Process Title type if your system is
+ supported by
+   bsd-setproctitle.c */
+/* #undef SPT_TYPE */
+
+/* Define if sshd somehow reacquires a controlling TTY
+ after setsid() */
+/* #undef SSHD_ACQUIRES_CTTY */
+
+/* Define if pam_chauthtok wants real uid set
+ to the unpriv'ed user */
+/* #undef SSHPAM_CHAUTHTOK_NEEDS_RUID */
+
+/* Use audit debugging module */
+/* #undef SSH_AUDIT_EVENTS */
+
+/* Windows is sensitive to read buffer size */
+/* #undef SSH_IOBUFSZ */
+
+/* non-privileged user for privilege separation */
+#define SSH_PRIVSEP_USER "sshd"
+
+/* Use tunnel device compatibility to OpenBSD */
+/* #undef SSH_TUN_COMPAT_AF */
+
+/* Open tunnel devices the FreeBSD way */
+/* #undef SSH_TUN_FREEBSD */
+
+/* Open tunnel devices the Linux tun/tap way */
+/* #undef SSH_TUN_LINUX */
+
+/* No layer 2 tunnel support */
+/* #undef SSH_TUN_NO_L2 */
+
+/* Open tunnel devices the OpenBSD way */
+/* #undef SSH_TUN_OPENBSD */
+
+/* Prepend the address family to IP tunnel traffic */
+/* #undef SSH_TUN_PREPEND_AF */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define if you want a different $PATH
+ for the superuser */
+/* #undef SUPERUSER_PATH */
+
+/* syslog_r function is safe to use in in a signal handler */
+/* #undef SYSLOG_R_SAFE_IN_SIGHAND */
+
+/* Support passwords > 8 chars */
+/* #undef UNIXWARE_LONG_PASSWORDS */
+
+/* Specify default $PATH */
+#define USER_PATH "/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin"
+
+/* Define this if you want to use libkafs' AFS support */
+/* #undef USE_AFS */
+
+/* Use BSM audit module */
+/* #undef USE_BSM_AUDIT */
+
+/* Use btmp to log bad logins */
+/* #undef USE_BTMP */
+
+/* Use libedit for sftp */
+/* #undef USE_LIBEDIT */
+
+/* Use Linux audit module */
+/* #undef USE_LINUX_AUDIT */
+
+/* Enable OpenSSL engine support */
+/* #undef USE_OPENSSL_ENGINE */
+
+/* Define if you want to enable PAM support */
+/* #undef USE_PAM */
+
+/* Use PIPES instead of a socketpair() */
+#define USE_PIPES 1
+
+/* Define if you want to sanitize fds */
+/* #undef USE_SANITISE_STDFD */
+
+/* Define if you have Solaris process contracts */
+/* #undef USE_SOLARIS_PROCESS_CONTRACTS */
+
+/* Define if you have Solaris projects */
+/* #undef USE_SOLARIS_PROJECTS */
+
+/* Define if you shouldn't strip 'tty' from your
+ ttyname in [uw]tmp */
+/* #undef WITH_ABBREV_NO_TTY */
+
+/* Define if you want to enable AIX4's authenticate function */
+/* #undef WITH_AIXAUTHENTICATE */
+
+/* Define if you have/want arrays
+ (cluster-wide session managment, not C
+   arrays) */
+/* #undef WITH_IRIX_ARRAY */
+
+/* Define if you want IRIX audit trails */
+/* #undef WITH_IRIX_AUDIT */
+
+/* Define if you want IRIX kernel jobs */
+/* #undef WITH_IRIX_JOBS */
+
+/* Define if you want IRIX project management */
+/* #undef WITH_IRIX_PROJECT */
+
+/* Define if you want SELinux support. */
+/* #undef WITH_SELINUX */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define if xauth is found in your path */
+/* #undef XAUTH_PATH */
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* log for bad login attempts */
+/* #undef _PATH_BTMP */
+
+/* Full path of your "passwd" program */
+#define _PATH_PASSWD_PROG "/usr/bin/passwd"
+
+/* Specify location of ssh.pid */
+/* #undef _PATH_SSH_PIDDIR */
+
+/* Define if we don't have struct __res_state in resolv.h */
+#define __res_state state
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* type to use in place of socklen_t if not defined */
+/* #undef socklen_t */
+#define WIN32_LEAN_AND_MEAN 1
+#define WINDOWS 1
+#define SUPPORT_CRLF 1
+
+#define BROKEN_READV_COMPARISON
+
+/* Override detection of some headers and functions on MinGW */
+#undef BROKEN_SNPRINTF
+#define GETPGRP_VOID 1
+#undef HAVE_CRYPT_H
+#define HAVE_DAEMON 1
+#undef HAVE_ENDIAN_H
+#undef HAVE_FCNTL_H
+#define HAVE_FREEADDRINFO 1
+#define HAVE_GAI_STRERROR 1
+#define HAVE_GETADDRINFO 1
+#define HAVE_GETGROUPLIST 1
+#define HAVE_GETNAMEINFO 1
+#undef HAVE_ID_IN_UTMPX
+#define HAVE_INET_ATON 1
+#define HAVE_INET_NTOA 1
+#define HAVE_INNETGR 1
+#undef HAVE_LIBCRYPT
+#define HAVE_NANOSLEEP 1
+#undef HAVE_PATHS_H
+#undef HAVE_PROC_PID
+#undef HAVE_PTY_H
+#define HAVE_NANOSLEEP 1
+#define HAVE_READPASSPHRASE 1
+#undef HAVE_SIG_ATOMIC_T
+#define HAVE_SIZE_T 1
+#undef HAVE_STRERROR
+#define HAVE_STRMODE 1
+#undef __USE_W32_SOCKETS
+
+#ifdef __MINGW32__ /* FIXME: Use autoconf to set this correctly */
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#define HAVE_STRNCASECMP 1
+#endif
+
+/* Define to 1 if you have the locale.h header. */
+#define HAVE_LOCALE_H 1
+
+#define HAVE_STRUCT_IN6_ADDR 1
+#define HAVE_STRUCT_SOCKADDR_IN6 1
+#define HAVE_STRUCT_TIMEVAL 1
+#undef HAVE_SYS_CDEFS_H
+#undef HAVE_SYS_SYSMACROS_H
+#undef HAVE_SYS_MMAN_H
+#define _STRUCT_WINSIZE 1
+
+#define HAVE_TCGETPGRP 1
+
+#undef HAVE_TIME
+
+#define HAVE_VIS_H 1
+
+#define MISSING_FD_MASK 1
+#define MISSING_HOWMANY 1
+#define MISSING_NFDBITS 1
+
+#undef SSH_PRIVSEP_USER
+
+#define HAVE_OPENPTY 1
+
+/* Fixes for loginrec.c */
+#undef CONF_UTMP_FILE
+#undef CONF_WTMPX_FILE
+#undef CONF_WTMP_FILE
+#undef CONF_UTMPX_FILE
+#undef CONF_LASTLOG_FILE
+
+#define BROKEN_SYS_TERMIO_H
+
+
+#define WITH_OPENSSL 1
+#define OPENSSL_HAVE_EVPGCM 1
+#define HAVE_EVP_CIPHER_CTX_CTRL 1
+#define HAVE_DECL_NFDBITS 0
+#define HAVE_DECL_HOWMANY 0
+#define HAVE_STRTOULL 1
+#define HAVE_USLEEP 1
+#define HAVE_EVP_RIPEMD160 1
+
+#if defined ( WIN32 )
+#define __func__ __FUNCTION__
+#endif
+
+#define HAVE_BZERO 1
+#define PATH_MAX 32768
+#define S_IFIFO        0x1000  
+#define HAVE_EXPLICIT_BZERO
+#define HAVE_MBTOWC 1
+#define HAVE_LLABS 1
+#define HAVE_RAISE 1
+
+#include <signal.h>
+#include <io.h>
+
+#define __attribute__(A)
+
+/* disable inclusion of compatability definitions in CRT headers */
+#define __STDC__ 1
+
+#define umac128_new umac_new
+#define umac128_update umac_update 
+#define umac_final umac128_final
+#define umac_delete umac128_delete
+
+#define HAVE_MBLEN 1
+
+#define _PATH_PRIVSEP_CHROOT_DIR "."
+#define SSHDIR "__PROGRAMDATA__\\ssh"
+#define _PATH_SSH_PIDDIR SSHDIR
+#define _PATH_SFTP_SERVER "sftp-server.exe"
+#define _PATH_SSH_PROGRAM "ssh.exe"
+#define _PATH_LS			"dir"
+#define _PATH_DEVNULL "NUL"
+#define FORK_NOT_SUPPORTED
+#define HAVE_FREEZERO
+#define FILESYSTEM_NO_BACKSLASH
+#define HAVE_LOCALTIME_R
+#define HAVE_DECL_MEMMEM 0
+#define WITH_ZLIB
+#define _PATH_TTY "conin$"
+#define HAVE_STRUCT_POLLFD_FD 1
+#define HAVE_KILLPG 1
+
+/* Definitions needed to prevent re-definition of OpenSSL functions and structs */
+#define HAVE_DSA_GET0_PQG 1
+#define HAVE_DSA_SET0_PQG 1
+#define HAVE_DSA_GET0_KEY 1
+#define HAVE_DSA_SET0_KEY 1
+#define HAVE_RSA_GET0_KEY 1
+#define HAVE_RSA_SET0_KEY 1
+#define HAVE_RSA_GET0_CRT_PARAMS 1
+#define HAVE_RSA_SET0_CRT_PARAMS 1
+#define HAVE_RSA_GET0_FACTORS 1
+#define HAVE_RSA_SET0_FACTORS 1
+#define HAVE_EVP_CIPHER_CTX_GET_IV 1
+#define HAVE_EVP_CIPHER_CTX_SET_IV 1
+#define HAVE_DSA_SIG_GET0 1
+#define HAVE_DSA_SIG_SET0 1
+#define HAVE_ECDSA_SIG_GET0 1
+#define HAVE_ECDSA_SIG_SET0 1
+#define HAVE_DH_GET0_PQG 1
+#define HAVE_DH_SET0_PQG 1
+#define HAVE_DH_GET0_KEY 1
+#define HAVE_DH_SET0_KEY 1
+#define HAVE_DH_SET_LENGTH 1
+#define HAVE_RSA_METH_FREE 1
+#define HAVE_RSA_METH_DUP 1
+#define HAVE_RSA_METH_SET1_NAME 1
+#define HAVE_RSA_METH_GET_FINISH 1
+#define HAVE_RSA_METH_SET_PRIV_ENC 1
+#define HAVE_RSA_METH_SET_PRIV_DEC 1
+#define HAVE_RSA_METH_SET_FINISH 1
+#define HAVE_EVP_PKEY_GET0_RSA 1
+#define HAVE_EVP_MD_CTX_NEW 1
+#define HAVE_EVP_MD_CTX_FREE 1
diff --git a/contrib/win32/openssh/config.ps1 b/contrib/win32/openssh/config.ps1
new file mode 100644
index 000000000..1befe6828
--- /dev/null
+++ b/contrib/win32/openssh/config.ps1
@@ -0,0 +1,19 @@
+Param($Config_h_vs, $Config_h, $VCIncludePath, $OutCRTHeader)
+
+Copy-Item $Config_h_vs $Config_h -Force
+if (Test-Path $OutCRTHeader) {exit}
+$headers = ("stdio.h", "string.h", "sys\types.h", "ctype.h", "stdlib.h", "sys\stat.h", "fcntl.h", "time.h")
+$paths = $VCIncludePath.Split(";")
+Set-Content -Path $OutCRTHeader -Value "/*`r`n * DO NOT EDIT - AutoGenerated by config.ps1`r`n */`r`n" -Force
+foreach ($header in $headers) {
+    foreach ($path in $paths)
+    {
+        if ($path -and (Test-Path (Join-Path $path $header)))
+        {
+            $entry = "#define  " + $header.ToUpper().Replace(".","_").Replace("\","_") + "  `"" + (Join-Path $path $header) + "`""
+            Add-Content -Path $OutCRTHeader -Value $entry
+            break
+        }
+
+    }
+}
\ No newline at end of file
diff --git a/contrib/win32/openssh/config.vcxproj b/contrib/win32/openssh/config.vcxproj
new file mode 100644
index 000000000..a55e29b51
--- /dev/null
+++ b/contrib/win32/openssh/config.vcxproj
@@ -0,0 +1,505 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <PropertyGroup>
+    <DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
+  </PropertyGroup>
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8F9D3B74-8D33-448E-9762-26E8DCC6B2F4}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>config</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>config</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>No</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>No</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>No</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat\includes;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>No</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;libssh.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+    <PreBuildEvent>
+      <Command>powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)config.ps1" -Config_h_vs "$(SolutionDir)config.h.vs" -Config_h "$(OpenSSH-Src-Path)config.h" -VCIncludePath "$(VC_IncludePath)" -OutCRTHeader "$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h"
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetFIDO2.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetLibreSSL.ps1
+powershell.exe -Executionpolicy Bypass -File "$(SolutionDir)GetZlib.ps1"</Command>
+    </PreBuildEvent>
+    <PreBuildEvent>
+      <Message>Generate crtheaders.h and config.h; fetch libressl sdk</Message>
+    </PreBuildEvent>
+    <PostBuildEvent>
+      <Command>copy /Y "$(SolutionDir)install-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)uninstall-ssh*ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)OpenSSHUtils.ps*1" "$(OutDir)"
+copy /Y "$(SolutionDir)Fix*FilePermissions.ps1" "$(OutDir)"
+copy /Y "$(SolutionDir)sshd_config" "$(OutDir)sshd_config_default"
+copy /Y "$(OpenSSH-Src-Path)moduli" "$(OutDir)moduli"
+copy /Y "$(OpenSSH-Src-Path)LICENCE" "$(OutDir)LICENSE.txt"
+copy /Y "$(OpenSSH-Src-Path)contrib\win32\openssh\NOTICE_for_release.txt" "$(OutDir)NOTICE.txt"
+copy /Y "$(SolutionDir)openssh-events.man" "$(OutDir)"</Command>
+      <Message>Copy install-sshd.ps1, uninstall-sshd.ps1, OpenSSHUtils.psm1, OpenSSHUtils.psd1, FixHostFilePermissions.ps1, FixUserFilePermissions.ps1,  ssh-add-hostkey.ps1, sshd_config (as sshd_config_default), openssh-events.man, moduli to build directory</Message>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+  <Target Name="BeforeClean">
+    <Delete Files="$(OpenSSH-Src-Path)contrib\win32\win32compat\inc\crtheaders.h" />
+  </Target>
+</Project>
diff --git a/contrib/win32/openssh/config.vcxproj.filters b/contrib/win32/openssh/config.vcxproj.filters
new file mode 100644
index 000000000..34783958e
--- /dev/null
+++ b/contrib/win32/openssh/config.vcxproj.filters
@@ -0,0 +1,17 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{C40EA84D-1664-404D-95C2-79A9E794A94D}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{E2570738-658F-4541-9487-90ECF5F26A93}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{464A0812-84B6-4B3D-B5FD-B3E7F0E0C10E}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/etwgen.cmd b/contrib/win32/openssh/etwgen.cmd
new file mode 100644
index 000000000..de16f056c
--- /dev/null
+++ b/contrib/win32/openssh/etwgen.cmd
@@ -0,0 +1,3 @@
+mc -um -h ..\win32compat -r . openssh-events.man
+
+wevtutil im openssh-events.man
\ No newline at end of file
diff --git a/contrib/win32/openssh/install-sshd.ps1 b/contrib/win32/openssh/install-sshd.ps1
new file mode 100644
index 000000000..080bb659a
--- /dev/null
+++ b/contrib/win32/openssh/install-sshd.ps1
@@ -0,0 +1,143 @@
+﻿# @manojampalam - authored initial script
+# @friism - Fixed issue with invalid SDDL on Set-Acl
+# @manojampalam - removed ntrights.exe dependency
+# @bingbing8 - removed secedit.exe dependency
+# @tessgauthier - added permissions check for %programData%/ssh
+# @tessgauthier - added update to system path for scp/sftp discoverability
+
+[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
+param ()
+Set-StrictMode -Version 2.0
+
+$ErrorActionPreference = 'Stop'
+
+if (!([bool]([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")))
+{
+    throw "You must be running as an administrator, please restart as administrator"
+}
+
+$scriptpath = $MyInvocation.MyCommand.Path
+$scriptdir = Split-Path $scriptpath
+
+$sshdpath = Join-Path $scriptdir "sshd.exe"
+$sshagentpath = Join-Path $scriptdir "ssh-agent.exe"
+$etwman = Join-Path $scriptdir "openssh-events.man"
+
+if (-not (Test-Path $sshdpath)) {
+    throw "sshd.exe is not present in script path"
+}
+
+if (Get-Service sshd -ErrorAction SilentlyContinue) 
+{
+   Stop-Service sshd
+   sc.exe delete sshd 1>$null
+}
+
+if (Get-Service ssh-agent -ErrorAction SilentlyContinue) 
+{
+   Stop-Service ssh-agent
+   sc.exe delete ssh-agent 1>$null
+}
+
+# Unregister etw provider
+# PowerShell 7.3+ has new/different native command argument parsing
+if ($PSVersiontable.PSVersion -le '7.2.9') {
+    wevtutil um `"$etwman`"
+}
+else {
+    wevtutil um "$etwman"
+}
+
+# adjust provider resource path in instrumentation manifest
+[XML]$xml = Get-Content $etwman
+$xml.instrumentationManifest.instrumentation.events.provider.resourceFileName = "$sshagentpath"
+$xml.instrumentationManifest.instrumentation.events.provider.messageFileName = "$sshagentpath"
+
+$streamWriter = $null
+$xmlWriter = $null
+try {
+    $streamWriter = new-object System.IO.StreamWriter($etwman)
+    $xmlWriter = [System.Xml.XmlWriter]::Create($streamWriter)    
+    $xml.Save($xmlWriter)
+}
+finally {
+    if($streamWriter) {
+        $streamWriter.Close()
+    }
+}
+
+# Fix the registry permissions
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\OpenSSHUtils -Force
+Enable-Privilege SeRestorePrivilege | out-null
+
+$sshRootRegPath="HKLM:SOFTWARE/Openssh"
+if (Test-Path $sshRootRegPath)
+{
+    $sshRootAcl=Get-Acl $sshRootRegPath
+    # SDDL - FullAcess to System and Builtin/Admins and read only access to Authenticated users
+    $sshRootAcl.SetSecurityDescriptorSddlForm("O:BAG:SYD:P(A;OICI;KR;;;AU)(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)")
+    Set-Acl $sshRootRegPath $sshRootAcl
+}
+
+$sshAgentRegPath="HKLM:SOFTWARE/Openssh/agent"
+if (Test-Path $sshAgentRegPath)
+{
+    $sshAgentAcl=Get-Acl $sshAgentRegPath
+    # SDDL - FullAcess to System and Builtin/Admins.
+    $sshAgentAcl.SetSecurityDescriptorSddlForm("O:BAG:SYD:P(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)")
+    Set-Acl $sshAgentRegPath  $sshAgentAcl
+}
+
+#Fix permissions for moduli file
+$moduliPath = Join-Path $PSScriptRoot "moduli"
+if (Test-Path $moduliPath -PathType Leaf)
+{
+    # if user calls .\install-sshd.ps1 with -confirm, use that
+    # otherwise, need to preserve legacy behavior
+    if (-not $PSBoundParameters.ContainsKey('confirm'))
+    {
+        $PSBoundParameters.add('confirm', $false)
+    }
+    Repair-ModuliFilePermission -FilePath $moduliPath @psBoundParameters
+}
+
+# If %programData%/ssh folder already exists, verify and, if necessary and approved by user, fix permissions 
+$sshProgDataPath = Join-Path $env:ProgramData "ssh"
+if (Test-Path $sshProgDataPath)
+{
+    # SSH Folder - owner: System or Admins; full access: System, Admins; read or readandexecute/synchronize permissible: Authenticated Users
+    Repair-SSHFolderPermission -FilePath $sshProgDataPath @psBoundParameters
+    # Files in SSH Folder (excluding private key files) 
+    # owner: System or Admins; full access: System, Admins; read/readandexecute/synchronize permissable: Authenticated Users
+    $privateKeyFiles = @("ssh_host_dsa_key", "ssh_host_ecdsa_key", "ssh_host_ed25519_key", "ssh_host_rsa_key")
+    Get-ChildItem -Path (Join-Path $sshProgDataPath '*') -Recurse -Exclude ($privateKeyFiles) -Force | ForEach-Object {
+        Repair-SSHFolderFilePermission -FilePath $_.FullName @psBoundParameters
+    }
+    # Private key files - owner: System or Admins; full access: System, Admins
+    Get-ChildItem -Path (Join-Path $sshProgDataPath '*') -Recurse -Include $privateKeyFiles -Force | ForEach-Object {
+        Repair-SSHFolderPrivateKeyPermission -FilePath $_.FullName @psBoundParameters
+    }
+}
+
+# Register etw provider
+# PowerShell 7.3+ has new/different native command argument parsing
+if ($PSVersiontable.PSVersion -le '7.2.9') {
+    wevtutil im `"$etwman`"
+} else {
+    wevtutil im "$etwman"
+}
+
+$agentDesc = "Agent to hold private keys used for public key authentication."
+New-Service -Name ssh-agent -DisplayName "OpenSSH Authentication Agent" -BinaryPathName "`"$sshagentpath`"" -Description $agentDesc -StartupType Manual | Out-Null
+sc.exe sdset ssh-agent "D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)(A;;RP;;;AU)"
+sc.exe privs ssh-agent SeAssignPrimaryTokenPrivilege/SeTcbPrivilege/SeBackupPrivilege/SeRestorePrivilege/SeImpersonatePrivilege
+
+$sshdDesc = "SSH protocol based service to provide secure encrypted communications between two untrusted hosts over an insecure network."
+New-Service -Name sshd -DisplayName "OpenSSH SSH Server" -BinaryPathName "`"$sshdpath`"" -Description $sshdDesc -StartupType Manual | Out-Null
+sc.exe privs sshd SeAssignPrimaryTokenPrivilege/SeTcbPrivilege/SeBackupPrivilege/SeRestorePrivilege/SeImpersonatePrivilege
+
+Write-Host -ForegroundColor Green "sshd and ssh-agent services successfully installed"
+
+# add folder to system PATH
+Add-MachinePath -FilePath $scriptdir @psBoundParameters
diff --git a/contrib/win32/openssh/keygen.vcxproj b/contrib/win32/openssh/keygen.vcxproj
new file mode 100644
index 000000000..a026218a3
--- /dev/null
+++ b/contrib/win32/openssh/keygen.vcxproj
@@ -0,0 +1,421 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{47496135-131B-41D6-BF2B-EE7144873DD0}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-keygen</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;libcrypto.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-keygen.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshsig.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/keygen.vcxproj.filters b/contrib/win32/openssh/keygen.vcxproj.filters
new file mode 100644
index 000000000..df8d63ecf
--- /dev/null
+++ b/contrib/win32/openssh/keygen.vcxproj.filters
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-keygen.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshsig.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/libssh.vcxproj b/contrib/win32/openssh/libssh.vcxproj
new file mode 100644
index 000000000..68bd69e72
--- /dev/null
+++ b/contrib/win32/openssh/libssh.vcxproj
@@ -0,0 +1,461 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{05E1115F-8529-46D0-AAAF-52A404CE79A7}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>libssh</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <ExceptionHandling>false</ExceptionHandling>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <CompileAs>CompileAsC</CompileAs>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <ExceptionHandling>false</ExceptionHandling>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <CompileAs>CompileAsC</CompileAs>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <ExceptionHandling>false</ExceptionHandling>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <CompileAs>CompileAsC</CompileAs>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <ExceptionHandling>false</ExceptionHandling>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <CompileAs>CompileAsC</CompileAs>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)addr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)addrmatch.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)atomicio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)authfd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)authfile.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)bitmap.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)canohost.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)chacha.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)channels.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aes.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aesctr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-chachapoly.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cleanup.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)compat.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)dh.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-libc.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==true">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)dispatch.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)dns.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ed25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)entropy.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)fatal.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-genr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hash.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hmac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hostfile.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kex.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexc25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexdh.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexecdh.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgex.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgexc.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgen.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexsntrup761x25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)krl.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)log.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)mac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)match.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)moduli.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor_fdpass.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)msg.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)nchan.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)packet.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)poly1305.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)progressmeter.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)readpass.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)rijndael.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)smult_curve25519_ref.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sntrup761.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-dss.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ecdsa.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ed25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-rsa.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-basic.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-crypto.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssherr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshkey.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh_api.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)umac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)xmalloc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-pledge.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-tracing.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-pledge.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\ttymodes_windows.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\w32-sshfileperm.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-openssl.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgexs.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ecdsa-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ed25519-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-io.c" />
+    <ClCompile Include="..\..\..\cipher-chachapoly-libcrypto.c" />
+    <ClCompile Include="..\win32compat\spawn-ext.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshfileperm.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/libssh.vcxproj.filters b/contrib/win32/openssh/libssh.vcxproj.filters
new file mode 100644
index 000000000..c118bf32f
--- /dev/null
+++ b/contrib/win32/openssh/libssh.vcxproj.filters
@@ -0,0 +1,285 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)addrmatch.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)atomicio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)authfd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)authfile.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)bitmap.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)canohost.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)chacha.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)channels.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aes.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aesctr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-chachapoly.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)cleanup.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)compat.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)dh.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-libc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)dispatch.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)dns.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ed25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)entropy.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)fatal.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)fe25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ge25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-genr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hash.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hmac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)hostfile.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kex.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexc25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexdh.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexecdh.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgex.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgexc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)krl.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)log.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)mac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor_fdpass.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)msg.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)nchan.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)packet.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)poly1305.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sc25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)smult_curve25519_ref.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-dss.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ecdsa.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ed25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-rsa.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-basic.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-crypto.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssherr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshkey.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh_api.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)umac.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-pledge.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-tracing.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-pledge.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\ttymodes_windows.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\w32-sshfileperm.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-openssl.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)match.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)moduli.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)progressmeter.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)readpass.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)rijndael.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)verify.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)xmalloc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgexs.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)addr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgen.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)kexsntrup761x25519.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sntrup761.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ecdsa-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ed25519-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-io.c" />
+    <ClCompile Include="..\win32compat\spawn-ext.c" />
+    <ClCompile Include="..\..\..\cipher-chachapoly-libcrypto.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)addrmatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)atomicio.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)authfd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)authfile.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)bitmap.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)canohost.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)chacha.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)channels.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aes.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-aesctr.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-chachapoly.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher-ctr.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cipher.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)cleanup.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)compat.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)dh.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-libc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)dispatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)dns.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ed25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)entropy.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)fatal.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)fe25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ge25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-genr.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)hash.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)hmac.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)hostfile.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kex.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexc25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexdh.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexecdh.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgex.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)kexgexc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)krl.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)log.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)mac.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor_fdpass.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)msg.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)nchan.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)packet.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)poly1305.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sc25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)smult_curve25519_ref.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-dss.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ecdsa.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-ed25519.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-rsa.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-basic.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-getput-crypto.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf-misc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshbuf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssherr.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshkey.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh_api.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)umac.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-pledge.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)platform-tracing.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)platform.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-pledge.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\ttymodes_windows.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)digest-openssl.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\w32-sshfileperm.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshfileperm.h" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/openbsd_compat.vcxproj b/contrib/win32/openssh/openbsd_compat.vcxproj
new file mode 100644
index 000000000..a31663dc1
--- /dev/null
+++ b/contrib/win32/openssh/openbsd_compat.vcxproj
@@ -0,0 +1,451 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\arc4random.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\base64.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\basename.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bcrypt_pbkdf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bindresvport.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\blowfish.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-asprintf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-closefrom.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cygwin_util.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getline.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getpagesize.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getpeereid.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-nextstep.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-openpty.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-poll.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-setres_id.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-snprintf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-statvfs.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-waitpid.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\daemon.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\dirname.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\explicit_bzero.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\fake-rfc2553.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\fmt_scaled.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getcwd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getgrouplist.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getopt_long.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getrrsetbyname-ldns.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_aton.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_ntoa.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_ntop.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\kludge-fd_set.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\libressl-api-compat.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\md5.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\memmem.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\mktemp.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\openssl-compat.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-irix.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-linux.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-solaris.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-net.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-uw.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\readpassphrase.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\reallocarray.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\recallocarray.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\rresvport.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\setenv.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\setproctitle.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\sha1.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\sha2.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strlcat.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strlcpy.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strmode.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strptime.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strsep.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoll.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtonum.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoul.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoull.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\timingsafe_bcmp.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\vis.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\xcrypt.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\glob.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strcasestr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strndup.c" />
+    <ClCompile Include="..\..\..\openbsd-compat\bsd-pselect.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\base64.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\blf.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cray.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cygwin_util.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-misc.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-nextstep.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-poll.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-setres_id.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-statvfs.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-waitpid.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\chacha_private.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\charclass.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\fake-rfc2553.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\getopt.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\getrrsetbyname.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\glob.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\md5.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\openbsd-compat.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\openssl-compat.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-aix.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-irix.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-linux.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-solaris.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-net.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-uw.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\readpassphrase.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sha1.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sha2.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sys-queue.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sys-tree.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\vis.h" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{DD483F7D-C553-4740-BC1A-903805AD0174}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>openbsd_compat</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)openbsd-compat;$(OpenSSH-Src-Path)libkrb;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+    <Lib>
+      <AdditionalOptions>/ignore:4221</AdditionalOptions>
+    </Lib>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/openbsd_compat.vcxproj.filters b/contrib/win32/openssh/openbsd_compat.vcxproj.filters
new file mode 100644
index 000000000..3235e55d3
--- /dev/null
+++ b/contrib/win32/openssh/openbsd_compat.vcxproj.filters
@@ -0,0 +1,315 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\arc4random.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\base64.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\basename.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bcrypt_pbkdf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bindresvport.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\blowfish.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-asprintf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-closefrom.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cygwin_util.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getpeereid.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-misc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-nextstep.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-openpty.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-poll.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-setres_id.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-snprintf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-statvfs.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-waitpid.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\daemon.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\dirname.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\explicit_bzero.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\fake-rfc2553.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\fmt_scaled.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getcwd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getgrouplist.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getopt_long.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\getrrsetbyname-ldns.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_aton.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_ntoa.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\inet_ntop.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\kludge-fd_set.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\md5.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\mktemp.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\openssl-compat.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-irix.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-linux.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-solaris.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-net.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\port-uw.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\readpassphrase.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\reallocarray.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\rresvport.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\setenv.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\setproctitle.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\sha1.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\sha2.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strlcat.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strlcpy.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strmode.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strptime.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strsep.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoll.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtonum.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoul.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strtoull.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\timingsafe_bcmp.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\vis.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\xcrypt.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getpagesize.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\recallocarray.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\glob.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strcasestr.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\strndup.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-getline.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\libressl-api-compat.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)openbsd-compat\memmem.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\openbsd-compat\bsd-pselect.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\base64.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\blf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cray.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-cygwin_util.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-nextstep.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-poll.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-setres_id.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-statvfs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\bsd-waitpid.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\chacha_private.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\charclass.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\fake-rfc2553.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\getopt.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\getrrsetbyname.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\glob.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\md5.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\openbsd-compat.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\openssl-compat.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-aix.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-irix.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-linux.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-solaris.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-net.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\port-uw.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\readpassphrase.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sha1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sha2.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sys-queue.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\sys-tree.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)openbsd-compat\vis.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/openssh-events.rc b/contrib/win32/openssh/openssh-events.rc
new file mode 100644
index 000000000..b43340c62
--- /dev/null
+++ b/contrib/win32/openssh/openssh-events.rc
@@ -0,0 +1,3 @@
+LANGUAGE 0x9,0x1
+1 11 "MSG00001.bin"
+1 WEVT_TEMPLATE "openssh-eventsTEMP.BIN"
diff --git a/contrib/win32/openssh/openssh-eventsTEMP.BIN b/contrib/win32/openssh/openssh-eventsTEMP.BIN
new file mode 100644
index 0000000000000000000000000000000000000000..30011f8e5e5a7f56e4675c71cee152b5ad4b2cc6
GIT binary patch
literal 1114
zcmb7@ze^lZ5Xa}v^)yBBE?A_nSiwLFAr|Im<>hWcz4csk%bj*PH4(w{!fE_b2qLM1
zg$RO#K)}i_DG~^_NfAhEiu?sy_&=<lS$E~F9E8j=@6G$Z@64Nd^S1C}Y+~9H>5vqk
z$iuB~KObd&l#XT}_Y8bGOb>w7oT@(zCqTMbccQzf+QT@dnP2LFEHP`Gkq(V1;xgbW
z)4KSF6h`yqV>mJO7j_oabJg`6%^B-n4!RSqZRSaNBd=sxDtx2zK=Lv#4Os*c8EmtE
z#cxSnR$(>a)ny5u-G*Bv@~pg-1@?UZxjV?&TBq+!cs7QXubPeOUs*oepSt(C^5^%F
zzi~4Dw<pE@2Ehj?#hqK?$Xb}{suaWH>*}5lf~U;yo0ft0gJenvmXskjaN_<`T~yj4
z<2lwVeCgX{WBs3hT{fw<Nz{4#$<ER~sgUZmJkg>M6LZ0O!IC+|m>HLzc!kL@0E6pP
z-BV_LKY9e}eI=G2fqJJ5+I!Tyz}9?FuNy$$0qPB5+t}-2U!O^VdsqznHy3qJ<gT&r
zu&+1O0_!vI8tfJw*Vmyvy>IM|fxQlW8nBXYL-R<yg?yz16iUgNsl~QaE&E!a)~bS;
zMPu2<{xT8)8+rkT9AX3MQ;H?Qe`jncLHS%u4vj@aU&r6O!PkF`d(FlDW|`oBY{Sp+
Rt7+|#*k=6W8~pDf=@MR#jO_pb

literal 0
HcmV?d00001

diff --git a/contrib/win32/openssh/openssh_build.cmd b/contrib/win32/openssh/openssh_build.cmd
new file mode 100644
index 000000000..3ddb6a63e
--- /dev/null
+++ b/contrib/win32/openssh/openssh_build.cmd
@@ -0,0 +1,4 @@
+msbuild /property:Configuration=Release /property:Platform=x64 Win32-OpenSSH.sln
+msbuild /property:Configuration=Release /property:Platform=x86 Win32-OpenSSH.sln
+msbuild /property:Configuration=Debug /property:Platform=x64 Win32-OpenSSH.sln
+msbuild /property:Configuration=Debug /property:Platform=x86 Win32-OpenSSH.sln
diff --git a/contrib/win32/openssh/paths.targets b/contrib/win32/openssh/paths.targets
new file mode 100644
index 000000000..b8fe7e4b8
--- /dev/null
+++ b/contrib/win32/openssh/paths.targets
@@ -0,0 +1,33 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <OpenSSH-Src-Path>$(SolutionDir)..\..\..\</OpenSSH-Src-Path>
+    <OpenSSH-Bin-Path>$(SolutionDir)..\..\..\bin\</OpenSSH-Bin-Path>
+    <OpenSSH-Lib-Path>$(SolutionDir)lib\</OpenSSH-Lib-Path>
+    <LibreSSLVersion>3.8.2.0</LibreSSLVersion>
+    <ZLibVersion>1.3</ZLibVersion>
+    <fido2Version>1.14.0</fido2Version>
+    <!--libcbor version is not used in the build; it is needed for pipeline compliance tasks-->  
+    <libcborVersion>0.10.1</libcborVersion> 
+    <LibreSSL-Path>$(SolutionDir)\LibreSSL\sdk\</LibreSSL-Path>
+    <LibreSSL-x86-Path>$(SolutionDir)\LibreSSL\bin\desktop\x86\</LibreSSL-x86-Path>
+    <LibreSSL-x64-Path>$(SolutionDir)\LibreSSL\bin\desktop\x64\</LibreSSL-x64-Path>
+    <LibreSSL-arm64-Path>$(SolutionDir)\LibreSSL\bin\desktop\arm64\</LibreSSL-arm64-Path>
+    <LibreSSL-arm-Path>$(SolutionDir)\LibreSSL\bin\desktop\arm\</LibreSSL-arm-Path>
+    <fido2-Path>$(SolutionDir)\libfido2\</fido2-Path>
+    <fido2-x86-Path>$(SolutionDir)\libfido2\Win32\Release\static\</fido2-x86-Path>
+    <fido2-x64-Path>$(SolutionDir)\libfido2\Win64\Release\static\</fido2-x64-Path>
+    <fido2-arm64-Path>$(SolutionDir)\libfido2\ARM64\Release\static\</fido2-arm64-Path>
+    <fido2-arm-Path>$(SolutionDir)\libfido2\ARM\Release\static\</fido2-arm-Path>
+    <ZLib-Path>$(SolutionDir)\ZLib\sdk\</ZLib-Path>
+    <ZLib-x86-Path>$(SolutionDir)\ZLib\bin\x86\</ZLib-x86-Path>
+    <ZLib-x64-Path>$(SolutionDir)\ZLib\bin\x64\</ZLib-x64-Path>
+    <ZLib-arm64-Path>$(SolutionDir)\ZLib\bin\arm64\</ZLib-arm64-Path>
+    <ZLib-arm-Path>$(SolutionDir)\ZLib\bin\arm\</ZLib-arm-Path>
+    <UseOpenSSL>true</UseOpenSSL>
+    <SSLLib>libcrypto.lib;</SSLLib>
+    <WindowsSDKVersion>10.0.22621.0</WindowsSDKVersion>
+    <AdditionalDependentLibs>bcrypt.lib;Userenv.lib;Crypt32.lib;Ws2_32.lib;Secur32.lib;Shlwapi.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;Netapi32.lib;Rpcrt4.lib;ntdll.lib</AdditionalDependentLibs>
+    <MinimalCoreWin>false</MinimalCoreWin>
+  </PropertyGroup>
+</Project>
diff --git a/contrib/win32/openssh/resource.h b/contrib/win32/openssh/resource.h
new file mode 100644
index 000000000..7097a903f
--- /dev/null
+++ b/contrib/win32/openssh/resource.h
@@ -0,0 +1,15 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by version.rc
+//
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1000
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff --git a/contrib/win32/openssh/scp.vcxproj b/contrib/win32/openssh/scp.vcxproj
new file mode 100644
index 000000000..dc1376ee9
--- /dev/null
+++ b/contrib/win32/openssh/scp.vcxproj
@@ -0,0 +1,423 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)scp.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c" />
+    <ClCompile Include="..\..\..\sftp-client.c" />
+    <ClCompile Include="..\..\..\sftp-common.c" />
+    <ClCompile Include="..\..\..\sftp-glob.c" />
+    <ClCompile Include="..\..\..\sftp-usergroup.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{29B98ADF-1285-49CE-BF6C-AA92C5D2FB24}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>scp</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/scp.vcxproj.filters b/contrib/win32/openssh/scp.vcxproj.filters
new file mode 100644
index 000000000..8cfa02f26
--- /dev/null
+++ b/contrib/win32/openssh/scp.vcxproj.filters
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{C40EA84D-1664-404D-95C2-79A9E794A94D}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{E2570738-658F-4541-9487-90ECF5F26A93}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{464A0812-84B6-4B3D-B5FD-B3E7F0E0C10E}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)scp.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sftp-common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sftp-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sftp-glob.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sftp-usergroup.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sftp-server.vcxproj b/contrib/win32/openssh/sftp-server.vcxproj
new file mode 100644
index 000000000..4ae8ccbdd
--- /dev/null
+++ b/contrib/win32/openssh/sftp-server.vcxproj
@@ -0,0 +1,420 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-server-main.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-server.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6657614F-7821-4D55-96EF-7C3C4B551880}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>sftp-server</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sftp-server.vcxproj.filters b/contrib/win32/openssh/sftp-server.vcxproj.filters
new file mode 100644
index 000000000..7688428cd
--- /dev/null
+++ b/contrib/win32/openssh/sftp-server.vcxproj.filters
@@ -0,0 +1,36 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-server-main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-server.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sftp.vcxproj b/contrib/win32/openssh/sftp.vcxproj
new file mode 100644
index 000000000..688081f2e
--- /dev/null
+++ b/contrib/win32/openssh/sftp.vcxproj
@@ -0,0 +1,424 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)progressmeter.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-client.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-glob.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c" />
+    <ClCompile Include="..\..\..\sftp-usergroup.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{BBEFF9D7-0BC3-41D1-908B-8052158B5052}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>sftp</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sftp.vcxproj.filters b/contrib/win32/openssh/sftp.vcxproj.filters
new file mode 100644
index 000000000..ec3e9cd0d
--- /dev/null
+++ b/contrib/win32/openssh/sftp.vcxproj.filters
@@ -0,0 +1,48 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)progressmeter.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-glob.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sftp-usergroup.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-add.vcxproj b/contrib/win32/openssh/ssh-add.vcxproj
new file mode 100644
index 000000000..ddb37bd51
--- /dev/null
+++ b/contrib/win32/openssh/ssh-add.vcxproj
@@ -0,0 +1,423 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-add.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="..\win32compat\win32-utf8.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="resource.h" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{029797FF-C986-43DE-95CD-2E771E86AEBC}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-add</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-add.vcxproj.filters b/contrib/win32/openssh/ssh-add.vcxproj.filters
new file mode 100644
index 000000000..f4c969964
--- /dev/null
+++ b/contrib/win32/openssh/ssh-add.vcxproj.filters
@@ -0,0 +1,41 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-add.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-agent.vcxproj b/contrib/win32/openssh/ssh-agent.vcxproj
new file mode 100644
index 000000000..e7fde1d3c
--- /dev/null
+++ b/contrib/win32/openssh/ssh-agent.vcxproj
@@ -0,0 +1,427 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F6644EC5-D6B6-42A1-828C-75E2977470E0}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-agent</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh-agent</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories);$(OpenSSH-Src-Path)contrib\win32\ssh-pubkey</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\agent-request.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\agent.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\agent-main.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\agent.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\connection.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ssh-agent\keyagent-request.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11-client.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="openssh-events.rc" />
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-keyscan.vcxproj b/contrib/win32/openssh/ssh-keyscan.vcxproj
new file mode 100644
index 000000000..dc0bdac36
--- /dev/null
+++ b/contrib/win32/openssh/ssh-keyscan.vcxproj
@@ -0,0 +1,414 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{7D0A75FC-F366-4B60-B72F-B37C3EA07CCA}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>sshkeyscan</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-keyscan</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-keyscan.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-keyscan.vcxproj.filters b/contrib/win32/openssh/ssh-keyscan.vcxproj.filters
new file mode 100644
index 000000000..1f1364b37
--- /dev/null
+++ b/contrib/win32/openssh/ssh-keyscan.vcxproj.filters
@@ -0,0 +1,33 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-keyscan.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-pkcs11-helper.vcxproj b/contrib/win32/openssh/ssh-pkcs11-helper.vcxproj
new file mode 100644
index 000000000..29928b680
--- /dev/null
+++ b/contrib/win32/openssh/ssh-pkcs11-helper.vcxproj
@@ -0,0 +1,415 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{21D772C3-0EB0-47B7-A93C-FF624675A58D}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>sshpkcs11helper</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-pkcs11-helper</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11-helper.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-pkcs11.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-shellhost.vcxproj b/contrib/win32/openssh/ssh-shellhost.vcxproj
new file mode 100644
index 000000000..29302ab63
--- /dev/null
+++ b/contrib/win32/openssh/ssh-shellhost.vcxproj
@@ -0,0 +1,410 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\shell-host.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\utf.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{C0AE8A30-E4FA-49CE-A2B5-0C072C77EC64}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>shellhost</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-shellhost</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>openbsd_compat.lib;$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh-sk-helper.vcxproj b/contrib/win32/openssh/ssh-sk-helper.vcxproj
new file mode 100644
index 000000000..97cc75080
--- /dev/null
+++ b/contrib/win32/openssh/ssh-sk-helper.vcxproj
@@ -0,0 +1,417 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{7D0A75FC-F366-4B60-B72F-B37C3EA07CCB}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>sshskhelper</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh-sk-helper</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(fido2-Path)include;$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);$(fido2-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);$(fido2-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);$(fido2-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);$(fido2-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);$(fido2-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);$(fido2-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);$(fido2-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;fido2.lib;cbor.lib;setupapi.lib;hid.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);$(fido2-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-helper.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sk-usbhid.c">
+      <AdditionalIncludeDirectories Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(OpenSSH-Src-Path)contrib\libfido2\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh.vcxproj b/contrib/win32/openssh/ssh.vcxproj
new file mode 100644
index 000000000..79ba0fb8a
--- /dev/null
+++ b/contrib/win32/openssh/ssh.vcxproj
@@ -0,0 +1,527 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{74E69D5E-A1EF-46EA-9173-19A412774104}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>ssh</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>ssh</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)acss.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)atomicio.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)audit.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-options.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-pam.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-sia.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)auth.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)authfd.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)authfile.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)bitmap.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)buffer.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)canohost.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)chacha.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)channels.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher-aesctr.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher-chachapoly.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)clientloop.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)compat.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)compress.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)crc32.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)crypto_api.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)deattack.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)defines.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)dh.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)digest.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)dispatch.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)dns.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)entropy.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)fe25519.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ge25519.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)groupaccess.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)hmac.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)hostfile.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)jpake.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)kerberos-sspi.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)kex.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)key.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)krl.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)log.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)loginrec.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)mac.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)match.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)md5crypt.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)misc.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_fdpass.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_mm.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_wrap.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)msg.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)myproposal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)opacket.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)packet.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)pam.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)pathnames.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)pkcs11.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)platform.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)poly1305.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)progressmeter.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)readconf.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)rijndael.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)roaming.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)rsa.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sc25519.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)schnorr.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)servconf.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)serverloop.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)session.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp-client.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp-common.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-gss.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-pkcs11.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-sandbox.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh1.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh2.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sshbuf.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sshconnect.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssherr.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sshkey.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sshlogin.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)sshpty.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh_api.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)ttymodes.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)uidswap.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)umac.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)uuencode.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)version.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)xmalloc.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)clientloop.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)readconf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshconnect.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshconnect2.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_sshtty.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="..\..\..\misc.c" />
+    <ClCompile Include="..\..\..\sshkey.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/ssh.vcxproj.filters b/contrib/win32/openssh/ssh.vcxproj.filters
new file mode 100644
index 000000000..7720669d4
--- /dev/null
+++ b/contrib/win32/openssh/ssh.vcxproj.filters
@@ -0,0 +1,329 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)acss.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)atomicio.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)audit.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-options.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-pam.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)auth-sia.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)auth.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)authfd.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)authfile.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)bitmap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)buffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)canohost.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)chacha.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)channels.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher-aesctr.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher-chachapoly.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)cipher.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)clientloop.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)compat.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)compress.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)crc32.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)crypto_api.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)deattack.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)defines.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)dh.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)digest.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)dispatch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)dns.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)entropy.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)fe25519.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ge25519.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)groupaccess.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)hmac.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)hostfile.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)jpake.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)kerberos-sspi.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)kex.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)key.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)krl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)log.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)loginrec.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)mac.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)match.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)md5crypt.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)misc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_fdpass.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_mm.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)monitor_wrap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)msg.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)myproposal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)opacket.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)packet.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)pam.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)pathnames.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)pkcs11.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)platform.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)poly1305.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)progressmeter.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)readconf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)rijndael.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)roaming.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)rsa.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sc25519.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)schnorr.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)servconf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)serverloop.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)session.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp-client.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp-common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sftp.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-gss.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-pkcs11.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh-sandbox.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh2.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshbuf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshconnect.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssherr.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshkey.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshlogin.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)sshpty.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ssh_api.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)ttymodes.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)uidswap.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)umac.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)uuencode.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)version.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)xmalloc.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)clientloop.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)readconf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshconnect.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshconnect2.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_sshtty.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\misc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sshkey.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sshTelemetry.c b/contrib/win32/openssh/sshTelemetry.c
new file mode 100644
index 000000000..7dfbf4acf
--- /dev/null
+++ b/contrib/win32/openssh/sshTelemetry.c
@@ -0,0 +1,220 @@
+/*
+* Author: Tess Gauthier <tessgauthier@microsoft.com>
+*
+* Copyright(c) 2021 Microsoft Corp.
+* All rights reserved
+*
+* Misc Unix POSIX routine implementations for Windows
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/ 
+
+/*
+this file defines functions to collect Microsoft Telemetry,
+which will only be sent for Windows In-Box releases. 
+GitHub releases will not send any Telemetry. 
+*/
+
+#include <string.h>
+#include <stdio.h>
+#include <Objbase.h>
+
+#include "sshTelemetry.h"
+#include "sshTelemetryInternal.h"
+
+// {0d986661-0dd7-561a-b15b-fcc1cd46d2bb}
+TRACELOGGING_DEFINE_PROVIDER(
+    g_hProvider1,
+    "Microsoft.Windows.Win32OpenSSH",
+    (0x0d986661, 0x0dd7, 0x561a, 0xb1, 0x5b, 0xfc, 0xc1, 0xcd, 0x46, 0xd2, 0xbb),
+    TraceLoggingOptionMicrosoftTelemetry());
+
+void send_auth_telemetry(const int status, const char* auth_type)
+{
+    /* 
+    registering only needs to be done once per process but
+    since these functions are used by multiple processes
+    and we need to unregister so the ETW process knows
+    not to do any callbacks, registering and unregistering 
+    is done after each tracelogging call for safety 
+    */
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "Auth",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingInt16(status, "success"),
+        TraceLoggingString(auth_type, "authType")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_auth_method_telemetry(const char* auth_methods)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "AuthMethods",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(auth_methods, "authMethodsConfigured")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_encryption_telemetry(const char* direction, 
+    const char* cipher, const char* kex, const char* mac, 
+    const char* comp, const char* host_key, 
+    const char** cproposal, const char** sproposal)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "Encryption",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(direction, "direction"),
+        TraceLoggingString(cipher, "cipher"),
+        TraceLoggingString(kex, "kex"),
+        TraceLoggingString(mac, "mac"),
+        TraceLoggingString(comp, "compression"),
+        TraceLoggingString(host_key, "hostKey"),
+        TraceLoggingString(cproposal[0], "clientProposedKex"),
+        TraceLoggingString(cproposal[1], "clientProposedHostKeys"),
+        TraceLoggingString(cproposal[2], "clientProposedCiphersCtos"),
+        TraceLoggingString(cproposal[3], "clientProposedCiphersStoc"),
+        TraceLoggingString(cproposal[4], "clientProposedMACsCtos"),
+        TraceLoggingString(cproposal[5], "clientProposedMACsStoc"),
+        TraceLoggingString(cproposal[6], "clientProposedCompressionCtos"),
+        TraceLoggingString(cproposal[7], "clientProposedCompressionStoc"),
+        TraceLoggingString(sproposal[0], "serverProposedKex"),
+        TraceLoggingString(sproposal[1], "serverProposedHostKeys"),
+        TraceLoggingString(sproposal[2], "serverProposedCiphersCtos"),
+        TraceLoggingString(sproposal[3], "serverProposedCiphersStoc"),
+        TraceLoggingString(sproposal[4], "serverProposedMACsCtos"),
+        TraceLoggingString(sproposal[5], "serverProposedMACsStoc"),
+        TraceLoggingString(sproposal[6], "serverProposedCompressionCtos"),
+        TraceLoggingString(sproposal[7], "serverProposedCompressionStoc")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_kex_exch_exit_code_telemetry(const int exit_code)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "KexExchExitCodeSSHD",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingInt16(exit_code, "KexExchExitCodeSSHD")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_pubkey_telemetry(const char* pubKeyStatus)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "PublicKey",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(pubKeyStatus, "status")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_shell_telemetry(const int pty, const int shell_type)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "Shell",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingInt16(pty, "PTY"),
+        TraceLoggingInt16(shell_type, "type")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_pubkey_sign_telemetry(const char* pubKeySignStatus)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "PubkeySigning",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(pubKeySignStatus, "status")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_ssh_connection_telemetry(const char* conn, const char* port)
+{
+    int isCustomPort = 0;
+    if (strcmp(port, "22") != 0) {
+        isCustomPort = 1;
+    }
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "Connection",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(conn, "status"),
+        TraceLoggingBool(isCustomPort, "isCustomSSHServerPort")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_sshd_connection_telemetry(const char* conn)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "SSHD",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(conn, "connStatus")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
+
+void send_ssh_version_telemetry(const char* ssh_version, 
+    const char* peer_version, const char* remote_protocol_error)
+{
+    TraceLoggingRegister(g_hProvider1);
+    TraceLoggingWrite(
+        g_hProvider1,
+        "Startup",
+        TelemetryPrivacyDataTag(PDT_ProductAndServiceUsage),
+        TraceLoggingKeyword(MICROSOFT_KEYWORD_MEASURES),
+        TraceLoggingString(ssh_version, "ourVersion"),
+        TraceLoggingString(remote_protocol_error, "remoteProtocolError"),
+        TraceLoggingString(peer_version, "peerVersion")
+    );
+    TraceLoggingUnregister(g_hProvider1);
+}
diff --git a/contrib/win32/openssh/sshTelemetry.h b/contrib/win32/openssh/sshTelemetry.h
new file mode 100644
index 000000000..69a905054
--- /dev/null
+++ b/contrib/win32/openssh/sshTelemetry.h
@@ -0,0 +1,35 @@
+#pragma once
+
+// sends authentication type and status
+void send_auth_telemetry(const int status, const char* auth_type);
+
+// sends authentication methods configured by SSHD
+void send_auth_method_telemetry(const char* auth_methods);
+
+// sends crypto information like cipher, kex, and mac
+void send_encryption_telemetry(const char* direction, 
+	const char* cipher, const char* kex, const char* mac, 
+	const char* comp, const char* host_key, 
+	const char** cproposal, const char** sproposal);
+
+// sends exit code of kex_exchange_identification(), utilized only in sshd
+void send_kex_exch_exit_code_telemetry(const int exit_code);
+
+// sends status if using key-based auth
+void send_pubkey_telemetry(const char* pubKeyStatus);
+
+// sends shell configuration and if pty session is used
+void send_shell_telemetry(const int pty, const int shell_type);
+
+// sends signing status if using key-based auth
+void send_pubkey_sign_telemetry(const char* pubKeySignStatus);
+
+// sends connection status from ssh client
+void send_ssh_connection_telemetry(const char* conn, const char* port);
+
+// sends connection status from ssh server
+void send_sshd_connection_telemetry(const char* conn);
+
+// sends version and peer version from ssh & sshd
+void send_ssh_version_telemetry(const char* ssh_version,
+	const char* peer_version, const char* remote_protocol_error);
diff --git a/contrib/win32/openssh/sshTelemetryInternal.h b/contrib/win32/openssh/sshTelemetryInternal.h
new file mode 100644
index 000000000..0d04e13aa
--- /dev/null
+++ b/contrib/win32/openssh/sshTelemetryInternal.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include <windows.h> // Defines macros used by TraceLoggingProvider.h
+#include "TraceLoggingProvider.h"  // The native TraceLogging API
+#include "MicrosoftTelemetry.h"
+
+// Forward-declare the g_hProvider1 variable that you will use for tracing
+TRACELOGGING_DECLARE_PROVIDER(g_hProvider1);
\ No newline at end of file
diff --git a/contrib/win32/openssh/sshd.vcxproj b/contrib/win32/openssh/sshd.vcxproj
new file mode 100644
index 000000000..be70e41fd
--- /dev/null
+++ b/contrib/win32/openssh/sshd.vcxproj
@@ -0,0 +1,483 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F58FF6BA-098B-4DB9-9609-A030DFB4D03F}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>keygen</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>sshd</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 /CETCOMPAT %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <ForceFileOutput>MultiplyDefinedSymbolOnly</ForceFileOutput>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <FullProgramDatabaseFile>true</FullProgramDatabaseFile>
+      <ShowProgress>NotSet</ShowProgress>
+      <AdditionalOptions>/debug /debugtype:cv,fixup /opt:ref /opt:icf /incremental:no /ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)audit-bsm.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)audit-linux.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)audit.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-bsdauth.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-krb5.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-options.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-pam.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-passwd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-rhosts.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-shadow.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-sia.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-chall.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-gss.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-hostbased.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-kbdint.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-none.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-passwd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-pubkey.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-serv-krb5.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-serv.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)loginrec.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor_wrap.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)platform.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-capsicum.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-darwin.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-null.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-rlimit.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-seccomp-filter.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-systrace.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)servconf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)serverloop.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)session.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)sshlogin.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_groupaccess.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_sshpty.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_sshd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\w32-doexec.c" />
+    <ClCompile Include="..\..\..\auth2-pubkeyfile.c" />
+    <ClCompile Include="..\..\..\misc.c" />
+    <ClCompile Include="..\..\..\srclimit.c" />
+    <ClCompile Include="..\..\..\ssh-sk-client.c" />
+    <ClCompile Include="..\..\..\sshkey.c" />
+    <ClCompile Include="..\win32compat\win32-utf8.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sshd.vcxproj.filters b/contrib/win32/openssh/sshd.vcxproj.filters
new file mode 100644
index 000000000..9791d1d85
--- /dev/null
+++ b/contrib/win32/openssh/sshd.vcxproj.filters
@@ -0,0 +1,168 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)audit-bsm.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)audit-linux.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)audit.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-bsdauth.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-krb5.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-options.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-pam.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-passwd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-rhosts.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-shadow.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth-sia.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-chall.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-gss.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-hostbased.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-kbdint.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-none.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-passwd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2-pubkey.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)auth2.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-serv-krb5.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)gss-serv.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)loginrec.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)monitor_wrap.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)platform.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-capsicum.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-darwin.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-null.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-rlimit.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-seccomp-filter.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sandbox-systrace.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)servconf.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)serverloop.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)session.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sftp-common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)sshlogin.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_sshd.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_sshpty.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\win32_groupaccess.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\w32-doexec.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\win32compat\win32-utf8.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\srclimit.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\ssh-sk-client.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\auth2-pubkeyfile.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\misc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\..\sshkey.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="version.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/sshd_config b/contrib/win32/openssh/sshd_config
new file mode 100644
index 000000000..cbe8d88be
--- /dev/null
+++ b/contrib/win32/openssh/sshd_config
@@ -0,0 +1,88 @@
+# This is the sshd server system-wide configuration file.  See
+# sshd_config(5) for more information.
+
+# The strategy used for options in the default sshd_config shipped with
+# OpenSSH is to specify options with their default value where
+# possible, but leave them commented.  Uncommented options override the
+# default value.
+
+#Port 22
+#AddressFamily any
+#ListenAddress 0.0.0.0
+#ListenAddress ::
+
+#HostKey __PROGRAMDATA__/ssh/ssh_host_rsa_key
+#HostKey __PROGRAMDATA__/ssh/ssh_host_dsa_key
+#HostKey __PROGRAMDATA__/ssh/ssh_host_ecdsa_key
+#HostKey __PROGRAMDATA__/ssh/ssh_host_ed25519_key
+
+# Ciphers and keying
+#RekeyLimit default none
+
+# Logging
+#SyslogFacility AUTH
+#LogLevel INFO
+
+# Authentication:
+
+#LoginGraceTime 2m
+#PermitRootLogin prohibit-password
+#StrictModes yes
+#MaxAuthTries 6
+#MaxSessions 10
+
+#PubkeyAuthentication yes
+
+# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
+# but this is overridden so installations will only check .ssh/authorized_keys
+AuthorizedKeysFile	.ssh/authorized_keys
+
+#AuthorizedPrincipalsFile none
+
+# For this to work you will also need host keys in %programData%/ssh/ssh_known_hosts
+#HostbasedAuthentication no
+# Change to yes if you don't trust ~/.ssh/known_hosts for
+# HostbasedAuthentication
+#IgnoreUserKnownHosts no
+# Don't read the user's ~/.rhosts and ~/.shosts files
+#IgnoreRhosts yes
+
+# To disable tunneled clear text passwords, change to no here!
+#PasswordAuthentication yes
+#PermitEmptyPasswords no
+
+# GSSAPI options
+#GSSAPIAuthentication no
+
+#AllowAgentForwarding yes
+#AllowTcpForwarding yes
+#GatewayPorts no
+#PermitTTY yes
+#PrintMotd yes
+#PrintLastLog yes
+#TCPKeepAlive yes
+#UseLogin no
+#PermitUserEnvironment no
+#ClientAliveInterval 0
+#ClientAliveCountMax 3
+#UseDNS no
+#PidFile /var/run/sshd.pid
+#MaxStartups 10:30:100
+#PermitTunnel no
+#ChrootDirectory none
+#VersionAddendum none
+
+# no default banner path
+#Banner none
+
+# override default of no subsystems
+Subsystem	sftp	sftp-server.exe
+
+# Example of overriding settings on a per-user basis
+#Match User anoncvs
+#	AllowTcpForwarding no
+#	PermitTTY no
+#	ForceCommand cvs server
+
+Match Group administrators
+       AuthorizedKeysFile __PROGRAMDATA__/ssh/administrators_authorized_keys
diff --git a/contrib/win32/openssh/targetos.manifest b/contrib/win32/openssh/targetos.manifest
new file mode 100644
index 000000000..87ac04756
--- /dev/null
+++ b/contrib/win32/openssh/targetos.manifest
@@ -0,0 +1,22 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
+        <application xmlns="urn:schemas-microsoft-com:asm.v3"> 
+            <!-- Windows 10 --> 
+            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
+            <!-- Windows 8.1 -->
+            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
+            <!-- Windows Vista -->
+            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
+            <!-- Windows 7 -->
+            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
+            <!-- Windows 8 -->
+            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
+        </application> 
+    </compatibility>
+    <application xmlns="urn:schemas-microsoft-com:asm.v3">
+        <windowsSettings>
+            <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
+        </windowsSettings>
+    </application> 
+</assembly>
\ No newline at end of file
diff --git a/contrib/win32/openssh/uninstall-sshd.ps1 b/contrib/win32/openssh/uninstall-sshd.ps1
new file mode 100644
index 000000000..b9a28f7e6
--- /dev/null
+++ b/contrib/win32/openssh/uninstall-sshd.ps1
@@ -0,0 +1,37 @@
+﻿if (!([bool]([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")))
+{
+    throw "You must be running as an administrator, please restart as administrator"
+}
+
+$scriptpath = $MyInvocation.MyCommand.Path
+$scriptdir = Split-Path $scriptpath
+$etwman = Join-Path $scriptdir "openssh-events.man"
+
+if (Get-Service sshd -ErrorAction SilentlyContinue) 
+{
+   Stop-Service sshd
+   sc.exe delete sshd 1>$null
+   Write-Host -ForegroundColor Green "sshd successfully uninstalled"
+}
+else {
+    Write-Host -ForegroundColor Yellow "sshd service is not installed"
+}
+
+# Unregister etw provider
+# PowerShell 7.3+ has new/different native command argument parsing
+if ($PSVersiontable.PSVersion -le '7.2.9') {
+    wevtutil um `"$etwman`"
+}
+else {
+    wevtutil um "$etwman"
+}
+
+if (Get-Service ssh-agent -ErrorAction SilentlyContinue) 
+{
+   Stop-Service ssh-agent
+   sc.exe delete ssh-agent 1>$null
+   Write-Host -ForegroundColor Green "ssh-agent successfully uninstalled"
+}
+else {
+    Write-Host -ForegroundColor Yellow "ssh-agent service is not installed"
+}
diff --git a/contrib/win32/openssh/unittest-bitmap.vcxproj b/contrib/win32/openssh/unittest-bitmap.vcxproj
new file mode 100644
index 000000000..ad184cf6e
--- /dev/null
+++ b/contrib/win32/openssh/unittest-bitmap.vcxproj
@@ -0,0 +1,418 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D901596E-76C7-4608-9CFA-2B42A9FD7250}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-bitmap</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-bitmap</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\bitmap\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-hostkeys.vcxproj b/contrib/win32/openssh/unittest-hostkeys.vcxproj
new file mode 100644
index 000000000..bc0abdc82
--- /dev/null
+++ b/contrib/win32/openssh/unittest-hostkeys.vcxproj
@@ -0,0 +1,431 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{890C6129-286F-4CD8-8252-FB8D3B4E6E1B}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-hostkeys</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-hostkeys</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\hostkeys\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\hostkeys\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\hostkeys\test_iterate.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="..\win32compat\win32-utf8.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-kex.vcxproj b/contrib/win32/openssh/unittest-kex.vcxproj
new file mode 100644
index 000000000..aaa760d8b
--- /dev/null
+++ b/contrib/win32/openssh/unittest-kex.vcxproj
@@ -0,0 +1,431 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8EC56B06-5A9A-4D6D-804D-037FE26FD43E}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-kex</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-kex</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);$(ZLib-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);$(ZLib-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);$(ZLib-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(ZLib-Path);$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);$(ZLib-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;zlib.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+      <AdditionalOptions>/ignore:4099 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\kex\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\kex\test_kex.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="..\..\..\regress\unittests\kex\test_proposal.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-match.vcxproj b/contrib/win32/openssh/unittest-match.vcxproj
new file mode 100644
index 000000000..fb4c618bf
--- /dev/null
+++ b/contrib/win32/openssh/unittest-match.vcxproj
@@ -0,0 +1,418 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{484A8CDE-B949-4BDA-B447-74685C8E032F}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-match</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-match</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\match\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-misc.vcxproj b/contrib/win32/openssh/unittest-misc.vcxproj
new file mode 100644
index 000000000..c5ee19a9b
--- /dev/null
+++ b/contrib/win32/openssh/unittest-misc.vcxproj
@@ -0,0 +1,437 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0B527504-2AF5-4E6E-A84F-10BADFAEDA88}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-misc</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-misc</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_parse.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_expand.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_convtime.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_argv.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_strdelim.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\misc\test_hpdelim.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="..\..\..\regress\unittests\misc\test_ptimeout.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-sshbuf.vcxproj b/contrib/win32/openssh/unittest-sshbuf.vcxproj
new file mode 100644
index 000000000..04051d540
--- /dev/null
+++ b/contrib/win32/openssh/unittest-sshbuf.vcxproj
@@ -0,0 +1,442 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{CD9740CE-C96E-49B3-823F-012E09D17806}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-sshbuf</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshbuf</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_fixed.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_fuzz.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_getput_basic.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_getput_crypto.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_getput_fuzz.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)==false">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshbuf\test_sshbuf_misc.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\fuzz.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-sshkey.vcxproj b/contrib/win32/openssh/unittest-sshkey.vcxproj
new file mode 100644
index 000000000..71508de9e
--- /dev/null
+++ b/contrib/win32/openssh/unittest-sshkey.vcxproj
@@ -0,0 +1,443 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{FC568FF0-60F2-4B2E-AF62-FD392EDBA1B9}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-sshkey</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-sshkey</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+    <PostBuildEvent>
+      <Command>xcopy /Y "$(ProjectDir)..\..\..\regress\unittests\sshkey\testdata\*" "$(OutDir)"
+copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshkey\common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshkey\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshkey\test_file.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshkey\test_fuzz.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\sshkey\test_sshkey.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\fuzz.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)ssh-sk-client.c" />
+    <ClCompile Include="..\win32compat\win32-utf8.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-utf8.vcxproj b/contrib/win32/openssh/unittest-utf8.vcxproj
new file mode 100644
index 000000000..ce18c5e7c
--- /dev/null
+++ b/contrib/win32/openssh/unittest-utf8.vcxproj
@@ -0,0 +1,208 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{114CAA59-46C0-4B87-BA86-C1946A68101D}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-utf8</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-utf8</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-utf8</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-utf8</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-utf8</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>Netapi32.lib;posix_compat.lib;bcrypt.lib;Userenv.lib;Ws2_32.lib;Secur32.lib;Shlwapi.lib;openbsd_compat.lib;libssh.lib;libcrypto.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>Netapi32.lib;posix_compat.lib;bcrypt.lib;Userenv.lib;Ws2_32.lib;Secur32.lib;Shlwapi.lib;openbsd_compat.lib;libssh.lib;libcrypto.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>Netapi32.lib;posix_compat.lib;bcrypt.lib;Userenv.lib;Ws2_32.lib;Secur32.lib;Shlwapi.lib;openbsd_compat.lib;libssh.lib;libcrypto.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>Netapi32.lib;posix_compat.lib;bcrypt.lib;Userenv.lib;Ws2_32.lib;Secur32.lib;Shlwapi.lib;openbsd_compat.lib;libssh.lib;libcrypto.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\utf8\tests.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/unittest-win32compat.vcxproj b/contrib/win32/openssh/unittest-win32compat.vcxproj
new file mode 100644
index 000000000..34974bcc6
--- /dev/null
+++ b/contrib/win32/openssh/unittest-win32compat.vcxproj
@@ -0,0 +1,439 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\file_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\socket_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\test_helper\test_helper.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)contrib\win32\win32compat\wmain_common.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\dir_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\miscellaneous_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\string_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+    <ClCompile Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\signal_tests.c">
+      <ExcludedFromBuild Condition="$(UseOpenSSL)=='false'">true</ExcludedFromBuild>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)regress\unittests\win32compat\tests.h" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{BF295BA9-4BF8-43F8-8CBF-FAE84815466C}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>Win32OpenSSH</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>unittest-win32compat</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v143</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(OpenSSH-Bin-Path)$(Platform)\$(Configuration)\$(TargetName)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+    <TargetName>unittest-win32compat</TargetName>
+    <IncludePath>$(OpenSSH-Src-Path)contrib\win32\win32compat\inc;$(VC_IncludePath);$(WindowsSDK_IncludePath);</IncludePath>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level1</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;_UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <CompileAs>CompileAsC</CompileAs>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x86-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x86-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-x64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-x64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm64-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm64-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <WarningLevel>Level1</WarningLevel>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_WIN32_WINNT=0x601;_LIB;_CRT_SECURE_NO_WARNINGS;_CRT_NONSTDC_NO_WARNINGS;_WINSOCK_DEPRECATED_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>false</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir);$(LibreSSL-Path)include;$(OpenSSH-Src-Path)includes;$(OpenSSH-Src-Path);$(OpenSSH-Src-Path)contrib\win32\win32compat;$(OpenSSH-Src-Path)libkrb;$(OpenSSH-Src-Path)libkrb\libKrb5;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalLibraryDirectories>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration);$(LibreSSL-arm-Path);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>posix_compat.lib;libssh.lib;openbsd_compat.lib;$(SSLLib)$(AdditionalDependentLibs);%(AdditionalDependencies)</AdditionalDependencies>
+      <EntryPointSymbol>wmainCRTStartup</EntryPointSymbol>
+    </Link>
+    <PostBuildEvent>
+      <command>copy /Y "$(LibreSSL-arm-Path)\libcrypto.dll" "$(OutDir)"</command>
+    </PostBuildEvent>
+    <Manifest>
+      <AdditionalManifestFiles>targetos.manifest</AdditionalManifestFiles>
+    </Manifest>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/updateSigning.ps1 b/contrib/win32/openssh/updateSigning.ps1
new file mode 100644
index 000000000..19f8c3506
--- /dev/null
+++ b/contrib/win32/openssh/updateSigning.ps1
@@ -0,0 +1,37 @@
+# Copyright (c) Microsoft Corporation. All rights reserved.
+# Licensed under the MIT License.
+# Script for use to update SignConfig.xml
+param(
+    [string] $SigningXmlPath = (Join-Path -Path $PSScriptRoot  -ChildPath 'SignConfig.xml')
+)
+
+# Parse the signing xml
+$signingXml = [xml](Get-Content $signingXmlPath)
+
+# Get any variables to updating 'signType' in the XML
+# Define a variable named `<signTypeInXml>SignType' in xml to updating that signing type
+# Example:  $env:AuthenticodeSignType='newvalue'  
+# will cause all files with the 'Authenticode' signtype to be updated with the 'newvalue' signtype
+$signTypes = @{}
+Get-ChildItem -Path env:/*SignType | ForEach-Object -Process {
+    $signType = $_.Name.ToUpperInvariant().Replace('SIGNTYPE','')
+    Write-Host "Found SigningType $signType with value $($_.value)"
+    $signTypes[$signType] = $_.Value
+}
+
+# examine each job in the xml
+$signingXml.SignConfigXML.job | ForEach-Object -Process { 
+    # examine each file in the job
+    $_.file | ForEach-Object -Process {
+        # if the sign type is one of the variables we found, update it to the new value
+        $signType = $_.SignType.ToUpperInvariant()
+        if($signTypes.ContainsKey($signType))
+        {
+            $newSignType = $signTypes[$signType]
+            Write-Host "Updating $($_.src) to $newSignType"
+            $_.signType = $newSignType
+        }
+    }
+}
+
+$signingXml.Save($signingXmlPath)
diff --git a/contrib/win32/openssh/version.rc b/contrib/win32/openssh/version.rc
new file mode 100644
index 000000000..6bef21401
--- /dev/null
+++ b/contrib/win32/openssh/version.rc
@@ -0,0 +1,95 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "winres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (United States) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""winres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 9,5,0,0
+ PRODUCTVERSION 9,5,0,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x0L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "FileVersion", "9.5.0.0"
+            VALUE "ProductName", "OpenSSH for Windows"
+            VALUE "ProductVersion", "OpenSSH_9.5p1 for Windows"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (United States) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff --git a/contrib/win32/openssh/vstsbuild.ps1 b/contrib/win32/openssh/vstsbuild.ps1
new file mode 100644
index 000000000..5e1762e44
--- /dev/null
+++ b/contrib/win32/openssh/vstsbuild.ps1
@@ -0,0 +1,139 @@
+[cmdletbinding(DefaultParameterSetName='Build')]
+param(
+    [Parameter(Mandatory,ParameterSetName='Build')]
+    [String]$Name="X64",
+    # full paths to files to add to container to run the build
+    [Parameter(Mandatory,ParameterSetName='packageSigned')]
+    [string]$BuildPath,
+    [Parameter(ParameterSetName='packageSigned')]
+    [string]$SignedFilesPath
+)
+
+$gitBinFullPath = (Get-Command -Name git).Source
+if (-not $gitBinFullPath)
+{
+    throw "Git is required to proceed. Install from 'https://git-scm.com/download/win'"
+}
+
+function Get-RepoFork
+{
+    [CmdletBinding()]    
+    param([string]$AccountURL="https://github.com/powershell", [string]$RepoFork, [string]$repoLocalPath, [string]$BranchName)
+    if (Test-Path -Path $repoLocalPath -PathType Container)
+    {
+        Remove-Item -Path $repoLocalPath -Recurse -Force
+    }    
+
+    Write-Verbose "cloning -b $BranchName --quiet --recursive $AccountURL/$RepoFork $repoLocalPath" -Verbose
+    git clone -b $BranchName --quiet --recursive $AccountURL/$RepoFork $repoLocalPath    
+    
+    Write-Verbose "pull latest from repo $RepoFork"
+    Push-Location $repoLocalPath
+    git submodule update --init --recursive --quiet
+    Pop-Location
+}
+
+function Get-RepositoryRoot
+{    
+    $start = $currentDir = (Get-Item -Path $PSScriptRoot)
+    while ($null -ne $currentDir.Parent)
+    {
+        $path = Join-Path -Path $currentDir.FullName -ChildPath '.git'
+        if (Test-Path -Path $path)
+        {
+            return $currentDir
+        }
+        $currentDir = $currentDir.Parent
+    }
+    return $start
+}
+
+[System.IO.DirectoryInfo] $repositoryRoot = Get-RepositoryRoot
+
+# Get repo root    
+$OSS_OpenSSHRoot = Get-Item -Path $repositoryRoot.FullName
+$gitRoot = split-path $OSS_OpenSSHRoot
+$script:publishedFiles = @()
+# clone psrelease.
+$PSReleaseLocalPath = Join-Path -Path $gitRoot -ChildPath 'PSRelease'
+Get-RepoFork -AccountURL 'https://github.com/powershell' -RepoFork 'PSRelease' -repoLocalPath $PSReleaseLocalPath -BranchName 'master'
+Import-Module "$PSReleaseLocalPath\vstsBuild" -Force
+Import-Module "$PSReleaseLocalPath\dockerBasedBuild" -Force
+try 
+{
+    Clear-VstsTaskState
+    switch($PSCmdlet.ParameterSetName)
+    {
+        'Build' {            
+            Invoke-Build -RepoPath '.\' -BuildJsonPath '.\contrib\win32\openssh\build.json' -Name $Name
+        }
+        'packageSigned' {            
+            #Publish artifacts appropriately
+            if($SignedFilesPath)
+            {
+                Write-Verbose "SignedFilesPath: $SignedFilesPath" -Verbose
+                $files = Get-ChildItem -Path $SignedFilesPath\* -File | Select-Object -ExpandProperty FullName
+                #Count the remaining file not signed files.
+                Get-ChildItem -Path $BuildPath\* -Recurse -File | % {
+                    $src = $_.FullName                    
+                    $dest = "$SignedFilesPath\$($_.Name)"
+                    Write-Verbose "src: $src" -Verbose
+                    Write-Verbose "dest: $dest" -Verbose
+                    if (-not (Test-Path $dest))
+                    {
+                        $files += $_.FullName
+                    }
+                }
+            }
+            else
+            {
+                #did not run codesign, so publish the plain binaries
+                $files = Get-ChildItem -Path $BuildPath\* -File | Select-Object -ExpandProperty FullName
+            }
+            $Bucket = (Split-Path $BuildPath -Leaf).Replace("_symbols", "")
+
+            foreach($fileName in $files)
+            {        
+                # Only publish files once
+                if($script:publishedFiles -inotcontains $fileName)
+                {
+                    $leafFileName = $(Split-path -Path $fileName -Leaf)                    
+                    $extension = [System.IO.Path]::GetExtension($leafFileName)
+                    if($extension -ieq '.pdb')
+                    {
+                        $folderName = "$($Bucket)_Symbols"
+                        $artifactname = "$folderName-$leafFileName"
+                        Write-Host "##vso[artifact.upload containerfolder=$folderName;artifactname=$artifactname]$fileName"
+                    }
+                    elseif($extension -ieq '.log')
+                    {
+                        $folderName = "$($Bucket)_Logs"
+                        $artifactname = "$folderName-$leafFileName"
+                        Write-Host "##vso[artifact.upload containerfolder=$folderName;artifactname=$artifactname]$fileName"
+                    }
+                    elseif($extension -ieq '.zip')
+                    {                        
+                        Write-Host "##vso[artifact.upload artifactname=$leafFileName]$fileName"
+                    }
+                    else
+                    {
+                        $artifactname = "$Bucket-$leafFileName"
+                        Write-Host "##vso[artifact.upload containerfolder=$Bucket;artifactname=$artifactname]$fileName"
+                    }            
+                    $script:publishedFiles += $fileName
+                }
+            }            
+        }
+        default {
+            throw 'Unknow parameterset passed to vstsbuild.ps1'
+        }
+    }
+}
+catch
+{
+    Write-VstsError -Error $_
+}
+finally{
+    Write-VstsTaskState
+    exit 0
+}
\ No newline at end of file
diff --git a/contrib/win32/openssh/win32iocompat.vcxproj b/contrib/win32/openssh/win32iocompat.vcxproj
new file mode 100644
index 000000000..e39609989
--- /dev/null
+++ b/contrib/win32/openssh/win32iocompat.vcxproj
@@ -0,0 +1,380 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="paths.targets" />
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|ARM">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM">
+      <Configuration>Release</Configuration>
+      <Platform>ARM</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0D02F0F0-013B-4EE3-906D-86517F3822C0}</ProjectGuid>
+    <RootNamespace>win32iocompat</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>
+    <ProjectName>posix_compat</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PlatformToolset>v143</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+    <SpectreMitigation>Spectre</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.23107.0</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <OutDir>$(OpenSSH-Lib-Path)$(Platform)\$(Configuration)\</OutDir>
+    <IntDir>$(Platform)\$(Configuration)\$(TargetName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <ExceptionHandling>false</ExceptionHandling>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <Optimization>MaxSpeed</Optimization>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <Optimization>MaxSpeed</Optimization>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <Optimization>MaxSpeed</Optimization>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
+    <ClCompile>
+      <AdditionalIncludeDirectories>
+      </AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>_CRT_DECLARE_NONSTDC_NAMES=0;_LIB;USE_MSCNG;_WIN32_WINNT=0x601;WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <SDLCheck>false</SDLCheck>
+      <Optimization>MaxSpeed</Optimization>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <ControlFlowGuard>Guard</ControlFlowGuard>
+      <AdditionalOptions>/Gy /ZH:SHA_256 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32fd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\socketio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\fileio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\termio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_sigalrm.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_sigchld.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32api_proxies.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_usertoken_utils.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32log.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\pwd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_dirent.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\no-ops.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ansiprsr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\console.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tncon.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tnnet.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\utf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\spawn.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_wait.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_pty.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\gss-sspi.c" />
+    <ClCompile Include="sshTelemetry.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32fd.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\fcntl.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\signal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\select.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\socket.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\stat.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\time.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\wait.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\unistd.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\poll.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\statvfs.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\dlfcn.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\syslog.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_internal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\utf.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\arpa\inet.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\arpa\nameser.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\grp.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\libgen.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netdb.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\in.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\in_systm.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\ip.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\tcp.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\process.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\resolv.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\ioctl.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\resource.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\uio.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\un.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\termios.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\dirent.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\pwd.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\misc_internal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\stdio.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\string.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\strings.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\types.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\ctype.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\stdlib.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\debug.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\console.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tnnet.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\spawn.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\net\if.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\time.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\gssapi.h" />
+    <ClInclude Include="MicrosoftTelemetry.h" />
+    <ClInclude Include="sshTelemetry.h" />
+    <ClInclude Include="sshTelemetryInternal.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/openssh/win32iocompat.vcxproj.filters b/contrib/win32/openssh/win32iocompat.vcxproj.filters
new file mode 100644
index 000000000..d37496fab
--- /dev/null
+++ b/contrib/win32/openssh/win32iocompat.vcxproj.filters
@@ -0,0 +1,180 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32fd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\socketio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\fileio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\termio.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\misc.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_sigalrm.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_sigchld.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_wait.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32log.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\pwd.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_dirent.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\no-ops.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\ansiprsr.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\console.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tncon.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tnnet.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\utf.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\spawn.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32api_proxies.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_usertoken_utils.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\gss-sspi.c" />
+    <ClCompile Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\win32_pty.c" />
+    <ClCompile Include="sshTelemetry.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\w32fd.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\select.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\socket.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\stat.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\time.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\fcntl.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\signal.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\unistd.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\poll.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\wait.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\statvfs.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\signal_internal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\utf.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\ioctl.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\resource.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\uio.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\un.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\arpa\inet.h">
+      <Filter>inc\arpa</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\arpa\nameser.h">
+      <Filter>inc\arpa</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\in.h">
+      <Filter>inc\netinet</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\in_systm.h">
+      <Filter>inc\netinet</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\ip.h">
+      <Filter>inc\netinet</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netinet\tcp.h">
+      <Filter>inc\netinet</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\grp.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\netdb.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\process.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\resolv.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\termios.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\libgen.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\misc_internal.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\stdio.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\string.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\pwd.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\dirent.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\dlfcn.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\sys\types.h">
+      <Filter>inc\sys</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\strings.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\syslog.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\stdlib.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\ctype.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\debug.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\console.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\tnnet.h" />
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\spawn.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\time.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\net\if.h">
+      <Filter>inc\net</Filter>
+    </ClInclude>
+    <ClInclude Include="$(OpenSSH-Src-Path)\contrib\win32\win32compat\inc\gssapi.h">
+      <Filter>inc</Filter>
+    </ClInclude>
+    <ClInclude Include="MicrosoftTelemetry.h" />
+    <ClInclude Include="sshTelemetry.h" />
+    <ClInclude Include="sshTelemetryInternal.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <Filter Include="inc">
+      <UniqueIdentifier>{b70431df-c3b2-46ee-a825-aeb9df643f7f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="inc\sys">
+      <UniqueIdentifier>{9fd6aa70-2efb-4577-87eb-d285a9cbbaa0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="inc\arpa">
+      <UniqueIdentifier>{6e4a035d-0b38-4507-9eec-19097d4ac16f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="inc\netinet">
+      <UniqueIdentifier>{d943f1aa-2df9-4df3-b499-4403a899fe8d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="inc\net">
+      <UniqueIdentifier>{b16bbf61-e602-4b0f-832b-190085cbfd5c}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/contrib/win32/win32compat/Debug.h b/contrib/win32/win32compat/Debug.h
new file mode 100644
index 000000000..9b0baf52b
--- /dev/null
+++ b/contrib/win32/win32compat/Debug.h
@@ -0,0 +1,15 @@
+#pragma once
+#ifndef __attribute__
+#define __attribute__(A)
+#endif
+
+#include "..\..\..\log.h"
+#include "..\..\..\ssherr.h"
+/* Enable the following for verbose logging */
+#if (0)
+#define debug4 debug2
+#define debug5 debug3
+#else
+#define debug4(a,...)
+#define debug5(a,...)
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/ansiprsr.c b/contrib/win32/win32compat/ansiprsr.c
new file mode 100644
index 000000000..e96a1b64d
--- /dev/null
+++ b/contrib/win32/win32compat/ansiprsr.c
@@ -0,0 +1,772 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * ANSI Parser to run on Win32 based operating systems
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <windows.h>
+
+#include "ansiprsr.h"
+#include "tncon.h"
+#include "tnnet.h"
+
+#define TS_IS			  0
+#define TS_SEND			  1
+
+/* items used from other modules */
+TelParams Parameters;
+
+extern int ScreenX;
+extern int ScreenY;
+extern int ScrollTop;
+extern int ScrollBottom;
+
+bool gbVTAppMode = false;
+/* private message for port printing to */
+unsigned char VT_ST[] = { 0x1b, '/', '\0' };
+static int AutoWrap = 1;
+BOOL bAtEOLN = FALSE;
+
+/*
+ * ParseANSI globals - these need to be here, because sometimes blocks are sent
+ * in mid ANSI sequence
+*/
+int iParam[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+int iCurrentParam = 0;
+int bDelimiter = 0;
+int bMode = 0;
+int fcompletion = 1;
+int bExtMode = 0;
+int bCS0 = 0;
+int bCS1 = 0;
+int bBkMode = 0;
+int bCharMode = 0;
+int ReportedX = 0;
+int ReportedY = 0;
+int VTMode = 0;
+
+BOOL fShiftOut = FALSE;
+BOOL InPrintMode = FALSE;
+BOOL fPcMode = FALSE;
+char printErr[] = "Unable to Print: Printer not assigned.  Press any key to continue...";
+char cursor_report[255];
+
+#define MODE_CURSORAPP		0x0001
+#define MODE_ANSIVT52		0x0002
+#define MODE_COL132		0x0004
+#define MODE_SMOOTHSCROLL	0x0008
+#define MODE_REVERSESCREEN	0x0010
+#define MODE_ORIGINREL		0x0020
+#define MODE_WRAPAROUND		0x0040
+#define MODE_AUTOREPEAT		0x0080
+#define MODE_APPMODE		0x0100
+#define MODE_LNM		0x0200
+#define MODE_IRM_INSERT		0x0400
+
+#define MODE_CURSORAPP		0x0001
+#define MODE_ANSIVT52		0x0002
+#define MODE_COL132		0x0004
+#define MODE_SMOOTHSCROLL	0x0008
+#define MODE_REVERSESCREEN	0x0010
+#define MODE_ORIGINREL		0x0020
+#define MODE_WRAPAROUND		0x0040
+#define MODE_AUTOREPEAT		0x0080
+#define MODE_APPMODE		0x0100
+#define MODE_LNM		0x0200
+
+char *
+GetTerminalId()
+{
+	return TERMINAL_ID;
+}
+
+char *
+GetStatusReport()
+{
+	return STATUS_REPORT;
+}
+
+char *
+GetCursorPositionReport()
+{
+	DWORD wr = 0;
+	DWORD out = 0;
+
+	out = _snprintf_s(cursor_report, sizeof(cursor_report), _TRUNCATE,
+		CURSOR_REPORT_FORMAT_STRING, ConGetCursorY() + 1, ConGetCursorX() + 1);
+	if (out > 0)
+		return cursor_report;
+
+	return NULL;
+}
+
+void
+BufConvertToG2(char * pszBuffer, int length)
+{
+	int i;
+	for (i = 0; i < length; i++)
+		pszBuffer[i] = '|';
+}
+
+
+void
+GoToNextLine()
+{
+	int currentX = 0;
+	int currentY = 0;
+	
+	ConGetCursorPosition(&currentX, &currentY);
+
+	/* If the cursor is the last line of the visible window */
+	if (is_cursor_at_lastline_of_visible_window()) {		
+		if (currentY >= ConGetBufferHeight()) {
+			/* handle the max window buffer size */
+			ConScrollDown(0, currentY);
+			ConMoveCursorPosition(-currentX, 0);		
+		} else {
+			/* max window buffer is not breached */
+			ConMoveVisibleWindow(1);
+			ConMoveCursorPosition(-currentX, 1);
+		}
+	} else /* If the cursor is NOT the last line of the visible window */
+		ConMoveCursorPosition(-currentX, 1);
+	
+	bAtEOLN = FALSE;
+}
+
+unsigned char* 
+ParseBuffer(unsigned char* pszBuffer, unsigned char* pszBufferEnd, unsigned char **respbuf, size_t *resplen)
+{
+	int currentX;
+
+	if (!fcompletion) {
+		if (pszBuffer < pszBufferEnd - 1) {
+			unsigned char * pszCurrent = pszBuffer + 1;
+			unsigned char * pszNewCurrent = pszCurrent;
+
+			pszNewCurrent = ParseANSI(pszCurrent, pszBufferEnd, respbuf, resplen);
+
+			/* Pointer didn't move inside Parse function */
+			if (pszCurrent == pszNewCurrent) {
+				pszNewCurrent += ConWriteString((char *)pszCurrent, 1);
+				return pszNewCurrent;
+			}
+
+			if (pszNewCurrent > pszCurrent)
+				pszBuffer = pszNewCurrent;
+		}
+	}
+
+	/* Handle special characters including locating the ESC which starts a terminal control seq */
+	switch ((unsigned char)(*pszBuffer))
+	{
+	case 0:  /* FALLTHROUGH */
+	case 1:  /* FALLTHROUGH */
+	case 2:  /* FALLTHROUGH */
+	case 3:  /* FALLTHROUGH */
+	case 4:  /* FALLTHROUGH */
+	case 5:  /* FALLTHROUGH */
+	case 6:  /* FALLTHROUGH */
+	case 11: /* FALLTHROUGH */
+		pszBuffer++;
+		break;
+
+	case 7:
+		Beep(1000, 400);
+		pszBuffer++;
+		break;
+
+	case 8:
+		pszBuffer++;
+		if (!bAtEOLN) {
+			currentX = ConGetCursorX();
+			if (currentX == 0) {
+				ConMoveCursorPosition(ScreenX - 1, -1);
+				ConWriteString(" ", 1);
+			} else {
+				ConClearNFromCursorLeft(1);
+				ConMoveCursorPosition(-1, 0);
+			}
+		}
+		bAtEOLN = FALSE;
+		break;
+
+	case 9:
+	{
+		if (bAtEOLN) GoToNextLine();
+		int i, MoveRight = 8 - (ConGetCursorX() % 8);
+
+		for (i = 0; i < MoveRight; i++)
+			ConWriteString(" ", 1);
+		pszBuffer++;
+		AutoWrap = 1;
+		bAtEOLN = FALSE;
+	}
+	break;
+
+	case 10:
+		pszBuffer++;
+		AutoWrap = 1;
+		bAtEOLN = FALSE;
+		break;
+
+	case 12:
+		pszBuffer++;
+		ConSetCursorPosition(0, 0);
+		ConClearScreen();
+		AutoWrap = 1;
+		bAtEOLN = FALSE;
+		break;
+
+	case 13:
+		pszBuffer++;
+		AutoWrap = 1;
+		GoToNextLine();
+		break;
+
+	case 14:
+		pszBuffer++;
+		fShiftOut = TRUE;
+		break;
+
+	case 15:
+		fShiftOut = FALSE;
+		pszBuffer++;
+		break;
+
+	case 27:
+		if (pszBuffer < pszBufferEnd - 1) {
+			unsigned char * pszCurrent = pszBuffer + 1;
+			unsigned char * pszNewCurrent = pszCurrent;
+
+			if (*pszCurrent == 27) {
+				pszNewCurrent += ConWriteString((char *)pszCurrent, 1);
+				return pszBuffer + 1;
+			} else				
+				pszNewCurrent = ParseANSI(pszCurrent, pszBufferEnd, respbuf, resplen);
+
+			if (pszNewCurrent > pszCurrent)
+				pszBuffer = pszNewCurrent;
+		}
+		break;
+
+	default:
+	{
+		if (bAtEOLN) GoToNextLine();
+
+		unsigned char* pszCurrent = pszBuffer;
+		currentX = ConGetCursorX();
+		int nCharCount = 0;
+
+		while ((pszCurrent < pszBufferEnd) && (*pszCurrent != (unsigned char)27)
+			&& (*pszCurrent > (unsigned char)15) && (*pszCurrent != (unsigned char)255)
+			&& (currentX++ < ScreenX)) {
+			if (*pszCurrent > 127) {
+				unsigned char nLead = *pszCurrent;
+				nCharCount++;
+				if ((nLead & 128) == 128)
+					pszCurrent++;
+				if ((nLead & 192) == 192)
+					pszCurrent++;
+				if ((nLead & 224) == 224)
+					pszCurrent++;
+				if ((nLead & 240) == 240)
+					pszCurrent++;
+			}
+			else
+				pszCurrent++;
+		}
+
+		if (fShiftOut)
+			memset(pszBuffer, '|', pszCurrent - pszBuffer);
+
+		pszBuffer += ConWriteString((char *)pszBuffer, (int)(pszCurrent - pszBuffer));
+
+		if ((currentX >= ScreenX) && AutoWrap && !(VTMode & MODE_CURSORAPP))
+			bAtEOLN = TRUE;
+	}
+	break;
+	}
+
+	return pszBuffer;
+}
+
+
+unsigned char *
+GetNextChar(unsigned char *pszBuffer, unsigned char *pszBufferEnd)
+{
+	if (++pszBuffer > pszBufferEnd)
+		return NULL;
+	else
+		return pszBuffer;
+}
+
+void 
+ConSetExtendedMode(int iFunction, BOOL bEnable)
+{
+	switch (iFunction) {
+	case 1:
+		if (bEnable) {
+			VTMode |= MODE_CURSORAPP;
+			gbVTAppMode = true;
+		} else {
+			VTMode &= ~MODE_CURSORAPP;
+			gbVTAppMode = false;
+		}
+		break;
+	case 2:
+		if (!bEnable)
+			VTMode |= MODE_ANSIVT52;
+		break;
+	case 3:
+		if (bEnable)
+			VTMode |= MODE_COL132;
+		else
+			VTMode &= ~MODE_COL132;
+		break;
+	case 4:
+		if (bEnable)
+			VTMode |= MODE_SMOOTHSCROLL;
+		else
+			VTMode &= ~MODE_SMOOTHSCROLL;
+		break;
+	case 5:
+		if (bEnable)
+			VTMode |= MODE_REVERSESCREEN;
+		else
+			VTMode &= ~MODE_REVERSESCREEN;
+		break;
+	case 6:
+		if (bEnable)
+			VTMode |= MODE_ORIGINREL;
+		else
+			VTMode &= ~MODE_ORIGINREL;
+		break;
+	case 7:
+		if (bEnable)
+			VTMode |= MODE_WRAPAROUND;
+		else
+			VTMode &= ~MODE_WRAPAROUND;
+		break;
+	case 8:
+		if (bEnable)
+			VTMode |= MODE_AUTOREPEAT;
+		else
+			VTMode &= ~MODE_AUTOREPEAT;
+		break;
+	case 20:   /* LNM Mode CSI 20h */
+		if (bEnable) {
+			VTMode |= MODE_LNM;
+			Parameters.nReceiveCRLF = ENUM_CRLF;
+		} else {
+			VTMode &= ~MODE_LNM;
+			Parameters.nReceiveCRLF = ENUM_LF;
+		}
+		break;
+	case 25:
+		ConDisplayCursor(bEnable);
+		break;
+
+	}
+}
+
+#define MODE_EXT	0x00000001
+#define MODE_CS0	0x00000002
+#define MODE_CS1	0x00000004
+#define MODE_CS2	0x00000008
+#define MODE_CS3	0x00000010
+#define MODE_BRK	0x00000020
+#define MODE_CHAR	0x00000040
+#define MODE_K		0x00000080
+
+#define DIGI_MASK   (MODE_CS0 | MODE_CS1 | MODE_CS2 | MODE_CS3 | MODE_CHAR)
+
+unsigned char *
+ParseANSI(unsigned char * pszBuffer, unsigned char * pszBufferEnd, unsigned char **respbuf, size_t *resplen)
+{
+	const int nParam = 10;	/* Maximum number of parameters */
+	static int SavedX = 0;
+	static int SavedY = 0;
+	unsigned char *	pszCurrent = pszBuffer;
+
+	if (pszCurrent == NULL || pszBufferEnd == NULL)
+		return NULL;
+
+	fcompletion = 0;
+	do {
+		switch ((unsigned char)*pszCurrent) {
+		case ';': /* Delimiter */
+			bDelimiter = TRUE;
+			break;
+		/* Modifiers */
+		case '?': /* Extended Mode */
+			bMode |= MODE_EXT;
+			break;
+		case '(':
+			bMode |= MODE_CS0;
+			break;
+		case ')':
+			bMode |= MODE_CS1;
+			break;
+		case '*':
+			bMode |= MODE_CS2;
+			break;
+		case '+':
+			bMode |= MODE_CS3;
+			break;
+		case '[':
+			bMode |= MODE_BRK;
+			break;
+		case '#':
+			bMode |= MODE_CHAR;
+			break;
+
+		/* Termination Options */
+		case 0:
+			fcompletion = 1;
+			break;
+
+		case '}':
+			fcompletion = 1;
+			break;
+
+		case '<': /* Character set */
+			fcompletion = 1;
+			break;
+
+		case '\\':
+			fcompletion = 1;
+			break;
+
+		case '~':
+			fcompletion = 1;
+			break;
+
+		case '^': /* Private message */
+			/* while not stop */
+			while (pszCurrent && pszCurrent < pszBufferEnd &&
+				_strnicmp((const char *)pszCurrent, (const char *)VT_ST, strnlen((const char *)VT_ST, sizeof(VT_ST)))) {
+				if (pszCurrent && pszCurrent < pszBufferEnd &&
+				    _strnicmp((const char *)pszCurrent, (const char *)VT_ST, strnlen((const char *)VT_ST, sizeof(VT_ST))))
+					pszCurrent++;
+			}
+			pszCurrent += strnlen((const char *)VT_ST, sizeof(VT_ST)) - 1;
+			fcompletion = 1;
+			break;
+
+		case 'A': /* Character Set change or Cursor Up */
+			if (bMode & MODE_BRK) { /* Cursor UP */
+				if (iParam[0] == 0)
+					iParam[0] = 1;
+				ConMoveCursorPosition(0, -iParam[0]);
+			}
+			fcompletion = 1;
+			break;
+
+		case 'B': /* Character set change or Cursor down */
+			if (bMode & MODE_BRK) { /* Cursor DOWN */
+				if (iParam[0] == 0)
+					iParam[0] = 1;
+				ConMoveCursorPosition(0, iParam[0]);
+			}
+			fcompletion = 1;
+			break;
+
+		case 'C': /* Character Set change or Cursor right */
+			if (bMode & MODE_BRK) {  /* Cursor right */
+				if (iParam[0] == 0)
+					iParam[0] = 1;
+				ConMoveCursorPosition(iParam[0], 0);
+			}
+			fcompletion = 1;
+			break;
+
+		case 'D':
+			if (bMode & MODE_BRK) { /* Cursor left */
+				if (iParam[0] == 0)
+					iParam[0] = 1;
+				ConMoveCursorPosition(-iParam[0], 0);
+			} else if (bMode == 0) { /* Index */
+				ConScrollDown(ScrollTop, ScrollBottom);
+			}
+			fcompletion = 1;
+			bAtEOLN = FALSE;
+			break;
+
+		case '=': /* Application mode */
+			VTMode |= MODE_APPMODE;
+			fcompletion = 1;
+			break;
+
+		case '>': /* Numeric mode */
+			VTMode &= ~MODE_APPMODE;
+			fcompletion = 1;
+			break;
+
+		case '%': /* Character set definitions */
+			fcompletion = 1;
+			break;
+
+		case 'h':
+			if (bMode & MODE_EXT) {
+				if (iParam[0] == 4 && iParam[1] == 7) {
+					ConSaveScreen();
+				}
+			}
+		case 'l': /* ^[?25h */
+			if (bMode & MODE_EXT) {
+				if (iParam[0] == 4 && iParam[1] == 7)
+					ConRestoreScreen();
+				else {
+					if (iParam[0] == 4)
+						VTMode |= MODE_IRM_INSERT;
+					int i;
+					for (i = 0; i < iCurrentParam; i++)
+						ConSetExtendedMode(iParam[i], *pszCurrent == 'h' ? 1 : 0);
+				}
+			} else if (bMode & MODE_BRK) {
+				/* Possible set Line feed (option 20) */
+				if (iParam[0] == 20)
+					ConSetExtendedMode(iParam[0], *pszCurrent == 'h' ? 1 : 0);
+				if (iParam[0] == 4)
+					VTMode &= ~MODE_IRM_INSERT;
+			}
+			fcompletion = 1;
+			break;
+
+		case 'L':
+			if (iParam[0]) {
+				int i;
+				for (i = 0; i < iParam[0]; i++)
+					ConScrollUp(ConGetCursorY() - 1, ScrollTop + ConVisibleWindowHeight() - 2);
+			} else {
+				if (ConGetCursorY() <= ScrollTop + ConVisibleWindowHeight() - 2)
+					ConScrollUp(ConGetCursorY() - 1, ScrollTop + ConVisibleWindowHeight() - 2);
+			}
+			fcompletion = 1;
+			bAtEOLN = FALSE;
+			break;
+
+		case 'N': /* FALLTHROUGH */
+		case 'O':
+			fcompletion = 1;
+			break;
+		case 'm':
+			ConSetAttribute(iParam, iCurrentParam);
+			fcompletion = 1;
+			break;
+		case 'r':
+			fcompletion = 1;
+			break;
+		case 'R':
+			ReportedX = iParam[1];
+			ReportedY = iParam[0];
+			break;
+		case 'H':
+		case 'f':
+			if (bMode & MODE_BRK)
+				ConSetCursorPosition((iParam[1] > 0) ? iParam[1] - 1 : 0, (iParam[0] > 0) ? iParam[0] - 1 : 0);
+			
+			fcompletion = 1;
+			bAtEOLN = FALSE;
+			break;
+
+		case 'M':
+			if (iParam[0]) {
+				int i;
+				for (i = 0; i < iParam[0]; i++)
+					ConScrollUp(ConGetCursorY(), ScrollTop - ConGetCursorY());
+			} else {
+				if (ConGetCursorY() <= ScrollTop + ConVisibleWindowHeight() - 2)
+					ConScrollUp(ConGetCursorY(), ScrollTop - ConGetCursorY());
+			}
+			fcompletion = 1;
+			bAtEOLN = FALSE;
+			break;
+
+		case 'E':
+		case 'G':
+		case 'g':
+			fcompletion = 1;
+			break;
+
+		case 'i': /* ANSI or VTXXX Print */
+			if (iParam[0] == 4)
+				InPrintMode = FALSE;
+			fcompletion = 1;
+			break;
+
+		case 'K':
+			if (bMode & MODE_BRK) {
+				switch (iParam[0])
+				{
+				case 0:
+					ConClearEOLine();
+					break;
+				case 1:
+					ConClearBOLine();
+					break;
+				case 2:
+					ConClearLine();
+					break;
+				}
+			} else if (bMode == 0)
+				bMode |= MODE_K;
+
+			fcompletion = 1;
+			break;
+
+		case 'J':
+			switch (iParam[0]) {
+			case 0:
+				ConClearEOScreen();
+				break;
+			case 1:
+				ConClearBOScreen();
+				break;
+			case 2:
+				ConClearScreen();
+				break;
+			}
+			fcompletion = 1;
+			break;
+
+		case 'n':
+			if (iCurrentParam == 1) {
+				if (iParam[0] == 5) {
+					char * szStatus = GetStatusReport();
+					if (respbuf != NULL) {
+						*respbuf = szStatus;
+						if (resplen != NULL)
+							*resplen = strlen(szStatus);
+					}
+				} else if (iParam[0] == 6) {
+					char * szStatus = GetCursorPositionReport();
+					if (szStatus != NULL && respbuf != NULL) {
+						*respbuf = szStatus;
+						if (resplen != NULL)
+							*resplen = strlen(szStatus);
+					}
+				}
+			}
+			fcompletion = 1;
+			break;
+
+		case 'c':
+			if (bMode == MODE_BRK) {
+				char* szTerminalId = GetTerminalId();
+				if (szTerminalId) {
+					if (respbuf != NULL) {
+						*respbuf = szTerminalId;
+						if (resplen != NULL)
+							*resplen = strlen(szTerminalId);
+					}
+				}
+			}
+			fcompletion = 1;
+			break;
+
+		case 'y':
+		case 'q':
+			fcompletion = 1;
+			break;
+
+		case 'Z': /* Identify - This is really a VT52 command */
+		{
+			char* szTerminalId = GetTerminalId();
+			if (szTerminalId) {
+				*respbuf = szTerminalId;
+				if (resplen != NULL)
+					*resplen = strlen(szTerminalId);
+			}
+		}
+		fcompletion = 1;
+		break;
+
+		case 'P':
+			ConDeleteChars(iParam[0]);
+			fcompletion = 1;
+			break;
+
+		default:
+			/* pszHead should point to digit now. Otherwise we got a bad escape
+		 	 * sequence, so we just get out of here!
+			 */
+			if (*pszCurrent) {
+				if (!isdigit(*pszCurrent)) {
+					pszCurrent = pszBuffer;
+					return pszCurrent;
+				}
+
+				iParam[iCurrentParam] = strtoul((const char *)pszCurrent, (char **)&pszCurrent, 10);
+				pszCurrent--;
+				if (iCurrentParam < nParam)
+					iCurrentParam++;
+
+				/* Check for digit completion */
+				if (bMode & DIGI_MASK)
+					fcompletion = 1;
+
+				if (bMode == 0) {
+					switch (iParam[0]) {
+					case 7:
+						SavedX = ConGetCursorX();
+						SavedY = ConGetCursorY();
+						break;
+					case 8:
+						ConSetCursorPosition(SavedX, SavedY);
+						break;
+					}
+					fcompletion = 1;
+				}
+			} else {
+				pszCurrent = pszBuffer;
+				return pszCurrent;
+			}
+			break;
+		}
+
+	} while ((++pszCurrent < pszBufferEnd) && !fcompletion);
+
+	if (fcompletion) {
+		memset(iParam, '\0', sizeof(iParam));
+		iCurrentParam = 0;
+		bDelimiter = 0;
+		bMode = 0;
+		bExtMode = 0;
+		bCS0 = 0;
+		bCS1 = 0;
+		bBkMode = 0;
+		bCharMode = 0;
+		return pszCurrent;
+	} else
+		return pszBuffer;
+}
diff --git a/contrib/win32/win32compat/ansiprsr.h b/contrib/win32/win32compat/ansiprsr.h
new file mode 100644
index 000000000..a35a107bd
--- /dev/null
+++ b/contrib/win32/win32compat/ansiprsr.h
@@ -0,0 +1,80 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* ansiprsr.h
+ * 
+ * ANSI Parser header file to run on Win32 based operating systems.
+ *
+ */
+
+#ifndef __ANSIPRSR_H
+#define __ANSIPRSR_H
+
+#define TERM_ANSI 0
+
+unsigned char * ParseBuffer(unsigned char* pszBuffer, unsigned char* pszBufferEnd, unsigned char **respbuf, size_t *resplen);
+unsigned char * GetNextChar(unsigned char * pszBuffer, unsigned char *pszBufferEnd);
+unsigned char * ParseANSI(unsigned char * pszBuffer, unsigned char * pszBufferEnd, unsigned char **respbuf, size_t *resplen);
+void GoToNextLine();
+
+#define true TRUE
+#define false FALSE
+#define bool BOOL
+
+#define ENUM_CRLF 0
+#define ENUM_LF 1
+#define ENUM_CR 2
+
+typedef struct _TelParams 
+{
+	int fLogging;
+	FILE *fplogfile;
+
+	char *pInputFile;
+
+	char *szDebugInputFile;
+    BOOL fDebugWait;
+
+	int timeOut;
+	int fLocalEcho;
+	int fTreatLFasCRLF;
+	int	fSendCROnly;
+	int nReceiveCRLF;
+
+    char sleepChar;
+	char menuChar;
+
+	SOCKET Socket;
+	BOOL bVT100Mode;
+
+	char *pAltKey;
+
+} TelParams;
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/console.c b/contrib/win32/win32compat/console.c
new file mode 100644
index 000000000..f34a8d19d
--- /dev/null
+++ b/contrib/win32/win32compat/console.c
@@ -0,0 +1,1695 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Common library for Windows Console Screen IO.
+ * Contains Windows console related definition so that emulation code can draw
+ * on Windows console screen surface.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <windows.h>
+#include <conio.h>
+#include <io.h>
+
+#include "debug.h"
+#include "console.h"
+#include "ansiprsr.h"
+#include "misc_internal.h"
+
+DWORD	stdin_dwSavedAttributes = 0;
+DWORD	stdout_dwSavedAttributes = 0;
+WORD	wStartingAttributes = 0;
+unsigned int console_out_cp_saved = 0;
+unsigned int console_in_cp_saved = 0;
+
+int ScreenX;
+int ScreenY;
+int ScrollTop;
+int ScrollBottom;
+int LastCursorX;
+int LastCursorY;
+BOOL isAnsiParsingRequired = FALSE;
+BOOL isConsoleVTSeqAvailable = FALSE;
+/* 1 - We track the viewport (visible window) and restore it back because
+ * console renders badly when user scroll up/down. Only used if ConPTY not
+ * available. */
+int track_view_port_no_pty_hack= 0; 
+char *pSavedScreen = NULL;
+static COORD ZeroCoord = { 0,0 };
+COORD SavedScreenSize = { 0,0 };
+COORD SavedScreenCursor = { 0, 0 };
+SMALL_RECT SavedViewRect = { 0,0,0,0 };
+CONSOLE_SCREEN_BUFFER_INFOEX SavedWindowState;
+BOOL isConHostParserEnabled = TRUE;
+
+typedef struct _SCREEN_RECORD {
+	PCHAR_INFO pScreenBuf;
+	COORD ScreenSize;
+	COORD ScreenCursor;
+	SMALL_RECT  srWindowRect;
+}SCREEN_RECORD, *PSCREEN_RECORD;
+
+PSCREEN_RECORD pSavedScreenRec = NULL;
+int in_raw_mode = 0;
+
+HANDLE
+GetConsoleOutputHandle()
+{
+	SECURITY_ATTRIBUTES sa;
+	static HANDLE	s_hOutputConsole = INVALID_HANDLE_VALUE;
+
+	if (s_hOutputConsole != INVALID_HANDLE_VALUE)
+		return s_hOutputConsole;
+
+	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+	sa.lpSecurityDescriptor = NULL;
+	sa.bInheritHandle = TRUE;
+
+	s_hOutputConsole = CreateFile(TEXT("CONOUT$"), GENERIC_READ | GENERIC_WRITE,
+			FILE_SHARE_WRITE | FILE_SHARE_READ,
+			&sa, OPEN_EXISTING, 0, NULL);
+
+	if (s_hOutputConsole == INVALID_HANDLE_VALUE)
+		debug("Unable to open console output handle, I am probably not attached to a console");
+
+	return s_hOutputConsole;
+}
+
+HANDLE
+GetConsoleInputHandle()
+{
+	SECURITY_ATTRIBUTES sa;
+	static HANDLE	s_hInputConsole = INVALID_HANDLE_VALUE;
+
+	if (s_hInputConsole != INVALID_HANDLE_VALUE)
+		return s_hInputConsole;
+
+	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+	sa.lpSecurityDescriptor = NULL;
+	sa.bInheritHandle = TRUE;
+
+	s_hInputConsole = CreateFile(TEXT("CONIN$"), GENERIC_READ | GENERIC_WRITE,
+			FILE_SHARE_WRITE | FILE_SHARE_READ,
+			&sa, OPEN_EXISTING, 0, NULL);
+
+	if (s_hInputConsole == INVALID_HANDLE_VALUE)
+		debug("Unable to open console input handle, I am probably not attached to a console");
+
+	return s_hInputConsole;
+}
+
+/* Used to enter the raw mode */
+void 
+ConEnterRawMode()
+{
+	DWORD dwAttributes = 0;
+	DWORD dwRet = 0;
+	BOOL bRet = FALSE;
+	CONSOLE_SCREEN_BUFFER_INFO csbi;
+	static bool bFirstConInit = true;
+
+	if (!GetConsoleMode(GetConsoleInputHandle(), &stdin_dwSavedAttributes)) {
+		dwRet = GetLastError();
+		error("GetConsoleMode on console input handle failed with %d", dwRet);
+		return;
+	}
+
+	dwAttributes = stdin_dwSavedAttributes;
+	dwAttributes &= ~(ENABLE_LINE_INPUT |
+		ENABLE_ECHO_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_MOUSE_INPUT);
+	dwAttributes |= ENABLE_WINDOW_INPUT;
+
+	if (!SetConsoleMode(GetConsoleInputHandle(), dwAttributes)) { /* Windows NT */
+		dwRet = GetLastError();
+		error("SetConsoleMode on STD_INPUT_HANDLE failed with %d", dwRet);
+		return;
+	}
+
+	dwAttributes |= ENABLE_VIRTUAL_TERMINAL_INPUT;
+	if (SetConsoleMode(GetConsoleInputHandle(), dwAttributes)) {
+		debug("ENABLE_VIRTUAL_TERMINAL_INPUT is supported. Reading the VTSequence from console");
+		isConsoleVTSeqAvailable = TRUE;
+	}
+
+	if (!GetConsoleMode(GetConsoleOutputHandle(), &stdout_dwSavedAttributes)) {
+		dwRet = GetLastError();
+		error("GetConsoleMode on GetConsoleOutputHandle() failed with %d", dwRet);
+		return;
+	}
+
+	dwAttributes = stdout_dwSavedAttributes;
+	dwAttributes |= (DWORD)ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;
+
+	char *envValue = NULL;
+	size_t len = 0;	
+	_dupenv_s(&envValue, &len, "SSH_TERM_CONHOST_PARSER");
+	
+	if (NULL != envValue) {
+		isConHostParserEnabled = atoi(envValue);
+		free(envValue);
+	}		
+
+	/* We use our custom ANSI parser when
+	 * a) User sets the environment variable "SSH_TERM_CONHOST_PARSER" to 0
+	 * b) or when the console doesn't have the inbuilt capability to parse the ANSI/Xterm raw buffer.
+	 */	 
+	if (FALSE == isConHostParserEnabled || !SetConsoleMode(GetConsoleOutputHandle(), dwAttributes)) /* Windows NT */
+		isAnsiParsingRequired = TRUE;
+			
+	BOOL gcsbRet = GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &csbi);
+	
+	/* We track the view port, if conpty is not supported */
+	if (!is_conpty_supported())
+		track_view_port_no_pty_hack= 1;
+
+	/* if we are passing rawbuffer to console then we need to move the cursor to top 
+	 *  so that the clearscreen will not erase any lines.
+	 */
+	if (TRUE == isAnsiParsingRequired) {
+		if (gcsbRet == 0)
+		{
+			dwRet = GetLastError();
+			error("GetConsoleScreenBufferInfo on GetConsoleOutputHandle() failed with %d", dwRet);
+			return;
+		}
+		SavedViewRect = csbi.srWindow;
+		debug("console doesn't support the ansi parsing");
+	} else {
+		debug("ENABLE_VIRTUAL_TERMINAL_PROCESSING is supported. Console supports the ansi parsing");
+		console_out_cp_saved = GetConsoleOutputCP();
+		console_in_cp_saved = GetConsoleCP();
+		if (SetConsoleOutputCP(CP_UTF8))
+			debug3("Successfully set console output code page from:%d to %d", console_out_cp_saved, CP_UTF8);
+		else
+			error("Failed to set console output code page from:%d to %d error:%d", console_out_cp_saved, CP_UTF8, GetLastError());
+
+		if (SetConsoleCP(CP_UTF8))
+			debug3("Successfully set console input code page from:%d to %d", console_in_cp_saved, CP_UTF8);
+		else
+			error("Failed to set console input code page from:%d to %d error:%d", console_in_cp_saved, CP_UTF8, GetLastError());
+
+		if (track_view_port_no_pty_hack) {
+			ConSaveViewRect_NoPtyHack();
+		}
+	}
+
+	ConSetScreenX();
+	ConSetScreenY();
+	ScrollTop = 0;
+	ScrollBottom = ConVisibleWindowHeight();
+	
+	in_raw_mode = 1;
+
+	/*
+	Consume and ignore the first WINDOW_BUFFER_SIZE_EVENT, as we've triggered it ourselves by updating the console settings above.
+	Not consuming this event can cause a race condition: the event can cause a write to the console to be printed twice as the
+	SIGWINCH interrupt makes the write operation think its failed, and causes it to try again.
+	*/
+	INPUT_RECORD peek_input;
+	int out_count = 0;
+	if (PeekConsoleInputW(GetConsoleInputHandle(), &peek_input, 1, &out_count) && peek_input.EventType == WINDOW_BUFFER_SIZE_EVENT) {
+		ReadConsoleInputW(GetConsoleInputHandle(), &peek_input, 1, &out_count);
+	}
+}
+
+/* Used to Uninitialize the Console */
+void 
+ConExitRawMode()
+{
+	if (0 == in_raw_mode) {
+		return;
+	}
+
+	SetConsoleMode(GetConsoleInputHandle(), stdin_dwSavedAttributes);
+	SetConsoleMode(GetConsoleOutputHandle(), stdout_dwSavedAttributes);
+
+	if (FALSE == isAnsiParsingRequired) {
+		if (console_out_cp_saved) {
+			if(SetConsoleOutputCP(console_out_cp_saved))
+				debug3("Successfully set console output code page from %d to %d", CP_UTF8, console_out_cp_saved);
+			else
+				error("Failed to set console output code page from %d to %d error:%d", CP_UTF8, console_out_cp_saved, GetLastError());
+		}
+
+		if (console_in_cp_saved) {
+			if (SetConsoleCP(console_in_cp_saved))
+				debug3("Successfully set console input code page from %d to %d", CP_UTF8, console_in_cp_saved);
+			else
+				error("Failed to set console input code page from %d to %d error:%d", CP_UTF8, console_in_cp_saved, GetLastError());
+		}
+	}
+	
+	in_raw_mode = 0;
+}
+
+/* Used to exit the raw mode */
+void 
+ConUnInitWithRestore()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (GetConsoleOutputHandle() == NULL)
+		return;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), stdin_dwSavedAttributes);
+	SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE), stdout_dwSavedAttributes);
+	Coord = consoleInfo.dwCursorPosition;
+	Coord.X = 0;
+	DWORD dwNumChar = (consoleInfo.dwSize.Y - consoleInfo.dwCursorPosition.Y) * consoleInfo.dwSize.X;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', dwNumChar, Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), wStartingAttributes, dwNumChar, Coord, &dwWritten);
+	SetConsoleTextAttribute(GetConsoleOutputHandle(), wStartingAttributes);
+}
+
+BOOL 
+ConSetScreenRect(int xSize, int ySize)
+{
+	BOOL bSuccess = TRUE;
+	CONSOLE_SCREEN_BUFFER_INFO csbi; /* hold current console buffer info */
+	SMALL_RECT srWindowRect; /* hold the new console size */
+	COORD coordScreen;
+
+	bSuccess = GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &csbi);
+	if (!bSuccess)
+		return bSuccess;
+
+	/* get the largest size we can size the console window to */
+	coordScreen = GetLargestConsoleWindowSize(GetConsoleOutputHandle());
+
+	/* define the new console window size and scroll position */
+	srWindowRect.Top = csbi.srWindow.Top;
+	srWindowRect.Left = csbi.srWindow.Left;
+	srWindowRect.Right = xSize - 1 + srWindowRect.Left;
+	srWindowRect.Bottom = ySize - 1 + srWindowRect.Top;
+
+	/* define the new console buffer size */
+	coordScreen.X = max(csbi.dwSize.X, xSize);
+	coordScreen.Y = max(csbi.dwSize.Y, ySize);
+
+	/* if the current buffer is larger than what we want, resize the */
+	/* console window first, then the buffer */
+	if (csbi.dwSize.X < coordScreen.X || csbi.dwSize.Y < coordScreen.Y) {
+		bSuccess = SetConsoleScreenBufferSize(GetConsoleOutputHandle(), coordScreen);
+		if (bSuccess)
+			bSuccess = SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &srWindowRect);
+	} else {
+		bSuccess = SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &srWindowRect);
+		if (bSuccess)
+			bSuccess = SetConsoleScreenBufferSize(GetConsoleOutputHandle(), coordScreen);
+	}
+
+	if (bSuccess && track_view_port_no_pty_hack)
+		ConSaveViewRect_NoPtyHack();
+
+	/* if the current buffer *is* the size we want, don't do anything! */
+	return bSuccess;
+}
+
+BOOL 
+ConSetScreenSize(int xSize, int ySize)
+{
+	BOOL bSuccess = TRUE;
+	CONSOLE_SCREEN_BUFFER_INFO csbi; /* hold current console buffer info */
+	SMALL_RECT srWindowRect; /* hold the new console size */
+	COORD coordScreen;
+
+	bSuccess = GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &csbi);
+	if (!bSuccess)
+		return bSuccess;
+
+	/* get the largest size we can size the console window to */
+	coordScreen = GetLargestConsoleWindowSize(GetConsoleOutputHandle());
+
+	/* define the new console window size and scroll position */
+	srWindowRect.Right = (SHORT)(min(xSize, coordScreen.X) - 1);
+	srWindowRect.Bottom = (SHORT)(min(ySize, coordScreen.Y) - 1);
+	srWindowRect.Left = srWindowRect.Top = (SHORT)0;
+
+	/* define the new console buffer size */
+	coordScreen.X = xSize;
+	coordScreen.Y = ySize;
+
+	/* if the current buffer is larger than what we want, resize the */
+	/* console window first, then the buffer */
+	if ((DWORD)csbi.dwSize.X * csbi.dwSize.Y > (DWORD)xSize * ySize) {
+		bSuccess = SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &srWindowRect);
+		if (bSuccess)
+			bSuccess = SetConsoleScreenBufferSize(GetConsoleOutputHandle(), coordScreen);
+	}
+
+	/* if the current buffer is smaller than what we want, resize the */
+	/* buffer first, then the console window */
+	if ((DWORD)csbi.dwSize.X * csbi.dwSize.Y < (DWORD)xSize * ySize) {
+		bSuccess = SetConsoleScreenBufferSize(GetConsoleOutputHandle(), coordScreen);
+		if (bSuccess)
+			bSuccess = SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &srWindowRect);
+	}
+
+	if (bSuccess && track_view_port_no_pty_hack)
+		ConSaveViewRect_NoPtyHack();
+
+	/* if the current buffer *is* the size we want, don't do anything! */
+	return bSuccess;
+}
+
+/* Used to set the Color of the console and other attributes */
+void 
+ConSetAttribute(int *iParam, int iParamCount)
+{
+	static int iAttr = 0;
+	int i = 0;
+	BOOL bRet = TRUE;
+
+	if (iParamCount < 1) {
+		iAttr |= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+		iAttr = iAttr & ~BACKGROUND_INTENSITY;
+		iAttr = iAttr & ~FOREGROUND_INTENSITY;
+		iAttr = iAttr & ~COMMON_LVB_UNDERSCORE;
+		iAttr = iAttr & ~COMMON_LVB_REVERSE_VIDEO;
+
+		SetConsoleTextAttribute(GetConsoleOutputHandle(), (WORD)iAttr);
+	} else {
+		for (i = 0; i < iParamCount; i++) {
+			switch (iParam[i]) {
+			case ANSI_ATTR_RESET:
+				iAttr |= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr = iAttr & ~BACKGROUND_INTENSITY;
+				iAttr = iAttr & ~FOREGROUND_INTENSITY;
+				iAttr = iAttr & ~COMMON_LVB_UNDERSCORE;
+				iAttr = iAttr & ~COMMON_LVB_REVERSE_VIDEO;
+				break;
+			case ANSI_BRIGHT:
+				iAttr |= FOREGROUND_INTENSITY;
+				break;
+			case ANSI_DIM:
+				break;
+			case ANSI_NOUNDERSCORE:
+				iAttr = iAttr & ~COMMON_LVB_UNDERSCORE;
+				break;
+			case ANSI_UNDERSCORE:
+				iAttr |= COMMON_LVB_UNDERSCORE;
+				break;
+			case ANSI_BLINK:
+				break;
+			case ANSI_REVERSE:
+				iAttr |= COMMON_LVB_REVERSE_VIDEO;
+				break;
+			case ANSI_HIDDEN:
+				break;
+			case ANSI_NOREVERSE:
+				iAttr = iAttr & ~COMMON_LVB_REVERSE_VIDEO;
+				break;
+			case ANSI_DEFAULT_FOREGROUND:
+				/* White */
+				iAttr |= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+				break;
+			case ANSI_FOREGROUND_BLACK:
+				iAttr = iAttr & ~FOREGROUND_RED;
+				iAttr = iAttr & ~FOREGROUND_BLUE;
+				iAttr = iAttr & ~FOREGROUND_GREEN;
+				iAttr |= 0;
+				break;
+			case ANSI_FOREGROUND_RED:
+				iAttr = iAttr & ~FOREGROUND_GREEN;
+				iAttr = iAttr & ~FOREGROUND_BLUE;
+				iAttr |= FOREGROUND_RED;
+				break;
+			case ANSI_FOREGROUND_GREEN:
+				iAttr = iAttr & ~FOREGROUND_BLUE;
+				iAttr = iAttr & ~FOREGROUND_RED;
+				iAttr |= FOREGROUND_GREEN;
+				break;
+			case ANSI_FOREGROUND_YELLOW:
+				iAttr = iAttr & ~FOREGROUND_BLUE;
+				iAttr |= FOREGROUND_RED | FOREGROUND_GREEN;
+				break;
+			case ANSI_FOREGROUND_BLUE:
+				iAttr = iAttr & ~FOREGROUND_GREEN;
+				iAttr = iAttr & ~FOREGROUND_RED;
+				iAttr |= FOREGROUND_BLUE;
+				break;
+			case ANSI_FOREGROUND_MAGENTA:
+				iAttr = iAttr & ~FOREGROUND_GREEN;
+				iAttr |= FOREGROUND_BLUE | FOREGROUND_RED;
+				break;
+			case ANSI_FOREGROUND_CYAN:
+				iAttr = iAttr & ~FOREGROUND_RED;
+				iAttr |= FOREGROUND_BLUE | FOREGROUND_GREEN;
+				break;
+			case ANSI_FOREGROUND_WHITE:
+				iAttr |= FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN;
+				break;
+			case ANSI_DEFAULT_BACKGROUND:
+				/* Black */
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr |= 0;
+				break;
+			case ANSI_BACKGROUND_BLACK:
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr |= 0;
+				break;
+			case ANSI_BACKGROUND_RED:
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr |= BACKGROUND_RED;
+				break;
+			case ANSI_BACKGROUND_GREEN:
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr |= BACKGROUND_GREEN;
+				break;
+			case ANSI_BACKGROUND_YELLOW:
+				iAttr = iAttr & ~BACKGROUND_BLUE;
+				iAttr |= BACKGROUND_RED | BACKGROUND_GREEN;
+				break;
+			case ANSI_BACKGROUND_BLUE:
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr |= BACKGROUND_BLUE;
+				break;
+			case ANSI_BACKGROUND_MAGENTA:
+				iAttr = iAttr & ~BACKGROUND_GREEN;
+				iAttr |= BACKGROUND_BLUE | BACKGROUND_RED;
+				break;
+			case ANSI_BACKGROUND_CYAN:
+				iAttr = iAttr & ~BACKGROUND_RED;
+				iAttr |= BACKGROUND_BLUE | BACKGROUND_GREEN;
+				break;
+			case ANSI_BACKGROUND_WHITE:
+				iAttr |= BACKGROUND_BLUE | BACKGROUND_RED | BACKGROUND_GREEN;
+				break;
+			case ANSI_BACKGROUND_BRIGHT:
+				iAttr |= BACKGROUND_INTENSITY;
+				break;
+			default:
+				continue;
+			}
+		}
+
+		if (iAttr)
+			bRet = SetConsoleTextAttribute(GetConsoleOutputHandle(), (WORD)iAttr);
+	}
+}
+
+/* Returns the width of current screen */
+int
+ConScreenSizeX()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	return (consoleInfo.dwSize.X);
+}
+
+/* Sets the width of the screen */
+int
+ConSetScreenX()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	ScreenX = (consoleInfo.dwSize.X);
+	return 0;
+}
+
+/* returns actual size of screen buffer */
+int
+ConScreenSizeY()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	return (consoleInfo.srWindow.Bottom - consoleInfo.srWindow.Top + 1);
+}
+
+/* returns width of visible window */
+int
+ConVisibleWindowWidth()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	return (consoleInfo.srWindow.Right - consoleInfo.srWindow.Left + 1);
+}
+
+/* returns height of visible window */
+int
+ConVisibleWindowHeight()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	return (consoleInfo.srWindow.Bottom - consoleInfo.srWindow.Top + 1);
+}
+
+int
+ConSetScreenY()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (-1);
+
+	ScreenY = consoleInfo.dwSize.Y - 1;
+
+	return 0;
+}
+
+void 
+ConFillToEndOfLine()
+{
+	DWORD rc = 0;
+
+	int size = ConScreenSizeX();
+	for (int i = ConGetCursorX(); i < size; i++)
+		WriteConsole(GetConsoleOutputHandle(), (char *)" ", 1, &rc, 0);
+}
+
+int 
+ConWriteString(char* pszString, int cbString)
+{
+	DWORD Result = 0;
+	int needed = 0;
+	int cnt = 0;
+	wchar_t* utf16 = NULL;
+
+	if (pszString == NULL)
+		return 0;
+
+	if ((needed = MultiByteToWideChar(CP_UTF8, 0, pszString, cbString, NULL, 0)) == 0 ||
+	    (utf16 = malloc(needed * sizeof(wchar_t))) == NULL ||
+	    (cnt = MultiByteToWideChar(CP_UTF8, 0, pszString, cbString, utf16, needed)) == 0) {
+		Result = (DWORD)printf_s(pszString);	// CodeQL [SM01734] false positive: call is not format string with arguments.
+	}
+	else {
+		if (GetConsoleOutputHandle())
+			WriteConsoleW(GetConsoleOutputHandle(), utf16, cnt, &Result, 0);
+		else
+		{
+			Result = (DWORD)wprintf_s(utf16);	// CodeQL [SM01734] false positive: call is not format string with arguments.
+		}
+	}
+
+	if (utf16)
+		free(utf16);
+
+	return cbString;
+}
+
+int 
+ConTranslateAndWriteString(char* pszString, int cbString)
+{
+	DWORD Result = 0;
+
+	if (pszString == NULL)
+		return 0;
+
+	if (GetConsoleOutputHandle())
+		WriteConsole(GetConsoleOutputHandle(), pszString, cbString, &Result, 0);
+	else
+		Result = (DWORD)printf_s(pszString);
+
+	return Result;
+}
+
+BOOL 
+ConWriteChar(CHAR ch)
+{
+	int X, Y, Result;
+	BOOL fOkay = TRUE;
+
+	Y = ConGetCursorY();
+	X = ConGetCursorX();
+
+	switch (ch) {
+	case 0x8: /* BackSpace */
+		if (X == 0) {
+			ConSetCursorPosition(ScreenX - 1, --Y);
+			WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+			ConSetCursorPosition(ScreenX - 1, Y);
+		} else {
+			ConSetCursorPosition(X - 1, Y);
+			WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+			ConSetCursorPosition(X - 1, Y);
+		}
+
+		break;
+	case '\r':
+		ConSetCursorPosition(0, Y);
+
+		break;
+	case '\n':
+		Y++;
+		if (Y > ScrollBottom - 1) {
+			ConScrollDown(ScrollTop, ScrollBottom);
+			ConSetCursorPosition(0, ScrollBottom);
+		} else
+			ConSetCursorPosition(0, Y);
+		break;
+	default:
+		fOkay = (BOOL)WriteConsole(GetConsoleOutputHandle(), &ch, 1, (LPDWORD)&Result, 0);
+
+		/* last coord */
+		if (X >= ScreenX - 1) {
+			if (Y >= ScrollBottom - 1) { /* last coord */
+				ConScrollDown(ScrollTop, ScrollBottom);
+				ConMoveCursorPosition(-ConGetCursorX(), 0);
+			} else
+				ConMoveCursorPosition(-ConGetCursorX(), 1);
+		}
+		break;
+	}
+
+	return fOkay;
+}
+
+BOOL 
+ConWriteCharW(WCHAR ch)
+{
+	int X, Y, Result;
+	BOOL fOkay = TRUE;
+
+	Y = ConGetCursorY();
+	X = ConGetCursorX();
+
+	switch (ch) {
+	case 0x8: /* BackSpace */
+		if (X == 0) {
+			ConSetCursorPosition(ScreenX - 1, --Y);
+			WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+			ConSetCursorPosition(ScreenX - 1, Y);
+		} else {
+			ConSetCursorPosition(X - 1, Y);
+			WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+			ConSetCursorPosition(X - 1, Y);
+		}
+		break;
+	case L'\r':
+		ConSetCursorPosition(0, Y);
+		break;
+
+	case L'\n':
+		Y++;
+		if (Y > ScrollBottom - 1) {
+			ConScrollDown(ScrollTop, ScrollBottom);
+			ConSetCursorPosition(0, ScrollBottom);
+		}
+		else
+			ConSetCursorPosition(0, Y);
+		break;
+
+	default:
+		fOkay = (BOOL)WriteConsoleW(GetConsoleOutputHandle(), &ch, 1, (LPDWORD)&Result, 0);
+
+		if (X >= ScreenX - 1) { /* last coord */
+			if (Y >= ScrollBottom - 1) { /* last coord */
+				ConScrollDown(ScrollTop, ScrollBottom);
+				ConMoveCursorPosition(-ConGetCursorX(), 0);
+			} else
+				ConMoveCursorPosition(-ConGetCursorX(), 1);
+		}
+		break;
+	}
+	return fOkay;
+}
+
+
+/* Special Function for handling TABS and other bad control chars */
+int 
+ConWriteConsole(char *pData, int NumChars)
+{
+	int X, CurrentY, CurrentX, Result;
+
+	for (X = 0; (X < NumChars) && (pData[X] != '\0'); X++) {
+		switch (pData[X]) {
+		case 0: /* FALLTHROUGH */
+		case 1: /* FALLTHROUGH */
+		case 2: /* FALLTHROUGH */
+		case 3: /* FALLTHROUGH */
+		case 4: /* FALLTHROUGH */
+		case 5: /* FALLTHROUGH */
+		case 6: /* FALLTHROUGH */
+		case 11: /* FALLTHROUGH */
+			break;
+
+		case 7:
+			Beep(1000, 400);
+			break;
+
+		case 8:
+			ConMoveCursorPosition(-1, 0);
+			WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+			ConMoveCursorPosition(-1, 0);
+			break;
+
+		case 9:
+		{
+			int i, MoveRight = TAB_LENGTH - (ConGetCursorX() % TAB_LENGTH);
+
+			for (i = 0; i < MoveRight; i++)
+				WriteConsole(GetConsoleOutputHandle(), " ", 1, (LPDWORD)&Result, 0);
+		}
+		break;
+
+		case 10:
+			CurrentY = ConGetCursorY() + 1;
+			if (CurrentY >= ScrollBottom) {
+				ConScrollDown(ScrollTop, ScrollBottom);
+				ConMoveCursorPosition(-ConGetCursorX(), 0);
+			} else
+				ConMoveCursorPosition(0, 1);
+			break;
+
+		case 12:
+			ConClearScreen();
+			ConSetCursorPosition(0, 0);
+			break;
+
+		case 13:
+			ConMoveCursorPosition(-ConGetCursorX(), 0);
+			break;
+
+		case 14: /* FALLTHROUGH */
+		case 15:
+			break;
+
+		default:
+		{
+			CurrentY = ConGetCursorY();
+			CurrentX = ConGetCursorX();
+
+			WriteConsole(GetConsoleOutputHandle(), &pData[X], 1, (LPDWORD)&Result, 0);
+
+			if (CurrentX >= ScreenX - 1) { /* last coord */
+				if (CurrentY >= ScrollBottom - 1) { /* last coord */
+					ConScrollDown(ScrollTop, ScrollBottom);
+					ConMoveCursorPosition(-ConGetCursorX(), 0);
+				} else
+					ConMoveCursorPosition(-ConGetCursorX(), 1);
+			}
+		}
+		}
+	}
+
+	return X;
+}
+
+PCHAR 
+ConWriteLine(char* pData)
+{
+	PCHAR pCurrent, pNext, pTab;
+	DWORD Result;
+	size_t distance, tabCount, pos;
+	size_t tabLength, charCount;
+
+	pCurrent = pData;
+	pNext = strchr(pCurrent, '\r');
+	if (pNext != NULL) {
+		distance = pNext - pCurrent;
+
+		if (distance > (size_t)ScreenX)
+			distance = (size_t)ScreenX;
+
+		pos = 0;
+		tabCount = 0;
+		pTab = strchr(pCurrent, TAB_CHAR);
+		if ((pTab != NULL) && (pTab < pNext)) {
+			/* Tab exists in string So we use our WriteString */
+			while ((pTab != NULL) && (pTab < pNext) && (pos < (size_t)ScreenX)) {
+				tabCount++;
+				charCount = (pTab - pCurrent) - 1;	/* Ignore actual TAB since we add 8 for it */
+				pos = charCount + (tabCount * TAB_LENGTH);
+				pTab++;	/* increment past last tab */
+				pTab = strchr(pTab, TAB_CHAR);
+			}
+
+			tabLength = (tabCount * TAB_LENGTH);
+
+			distance = ConWriteConsole(pCurrent, (int)distance); /* Special routine for handling TABS */
+
+		} else
+			WriteConsole(GetConsoleOutputHandle(), pCurrent, (DWORD)distance, &Result, 0);
+
+		ConSetCursorPosition(0, ConGetCursorY() + 1);
+
+		pCurrent += (distance + 2);  /* Add one to always skip last char printed */
+	} else {
+		distance = strlen(pCurrent);
+		if (distance > (size_t)ScreenX)
+			distance = (size_t)ScreenX;
+		WriteConsole(GetConsoleOutputHandle(), pCurrent, (DWORD)distance, &Result, 0);
+		pCurrent += distance;
+	}
+
+	return pCurrent;
+}
+
+PCHAR
+ConDisplayData(char* pData, int NumLines)
+{
+	PCHAR pCurrent, pNext, pTab;
+	DWORD Result;
+	size_t Y, distance, pos, add;
+	int linecnt = 0;
+
+	pCurrent = pData;
+	for (; (pCurrent) && ((Y = (size_t)ConGetCursorY()) <= (size_t)ScrollBottom) && (*pCurrent != '\0'); ) {
+		pNext = strchr(pCurrent, '\n');
+		if (pNext != NULL) {
+			--pNext;
+			if (*pNext != '\r') {
+				pNext++;
+				add = 1;
+			}
+			else
+				add = 2;
+			distance = pNext - pCurrent;
+
+			if (distance > 0 && linecnt < NumLines) {
+				pos = 0;
+				pTab = strchr(pCurrent, TAB_CHAR);
+				if ((distance > (size_t)ScreenX) || ((pTab != NULL) && (pTab < pNext)))
+					ConWriteConsole(pCurrent, (int)distance); /* Special routine for handling TABS */
+				else
+					WriteConsole(GetConsoleOutputHandle(), pCurrent, (DWORD)distance, &Result, 0);
+			}
+			ConMoveCursorPosition(-ConGetCursorX(), 1);
+			pCurrent += (distance + add);  /* Add one to always skip last char printed */
+			linecnt++;
+		} else {
+			distance = strlen(pCurrent);
+			if (distance > (size_t)ScreenX)
+				distance = ScreenX;
+			if (linecnt < NumLines)
+				WriteConsole(GetConsoleOutputHandle(), pCurrent, (DWORD)distance, &Result, 0);
+			return pCurrent + distance;
+		}
+	}
+	return pCurrent;
+}
+
+int 
+Con_printf(const char *Format, ...)
+{
+	va_list va_data;
+	int len;
+	char temp[4096];
+
+	memset(temp, '\0', sizeof(temp));
+	va_start(va_data, Format);
+	len = vsnprintf_s(temp, sizeof(temp), _TRUNCATE, Format, va_data);
+	if (len == -1) {
+		error("Error from vsnprintf_s!");
+		return -1;
+	}
+	ConWriteConsole(temp, len);
+	va_end(va_data);
+
+	return len;
+}
+
+BOOL 
+ConDisplayCursor(BOOL bVisible)
+{
+	CONSOLE_CURSOR_INFO ConsoleCursorInfo;
+
+	if (GetConsoleCursorInfo(GetConsoleOutputHandle(), &ConsoleCursorInfo)) {
+		ConsoleCursorInfo.bVisible = bVisible;
+		return SetConsoleCursorInfo(GetConsoleOutputHandle(), &ConsoleCursorInfo);
+	}
+
+	return FALSE;
+}
+
+void 
+ConClearScreen()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	SMALL_RECT srcWindow;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = 0;
+
+	DWORD dwNumChar = (consoleInfo.dwSize.Y) * (consoleInfo.dwSize.X);
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', dwNumChar, Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes, dwNumChar, Coord, &dwWritten);
+	srcWindow = consoleInfo.srWindow;
+	ConSetCursorPosition(0, 0);
+}
+
+void
+ConClearScrollRegion()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = ScrollTop + consoleInfo.srWindow.Top;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', (DWORD)consoleInfo.dwSize.X * (DWORD)ScrollBottom,
+		Coord, &dwWritten);
+
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes,
+		(DWORD)consoleInfo.dwSize.X * (DWORD)ScrollBottom, Coord, &dwWritten);
+
+	ConSetCursorPosition(0, ScrollTop);
+}
+
+void
+ConClearEOScreen()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = (short)(ConGetCursorY() + 1) + consoleInfo.srWindow.Top;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ',
+		(DWORD)(consoleInfo.dwSize.X)*
+		(DWORD)(consoleInfo.srWindow.Bottom - Coord.Y + 1),
+		Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes,
+		(DWORD)(consoleInfo.dwSize.X)*
+		(DWORD)(consoleInfo.srWindow.Bottom - Coord.Y + 1),
+		Coord, &dwWritten);
+
+	ConClearEOLine();
+}
+
+void 
+ConClearBOScreen()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = 0;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ',
+		(DWORD)(consoleInfo.dwSize.X)*
+		(DWORD)(consoleInfo.dwSize.Y - ConGetCursorY() - 1),
+		Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes,
+		(DWORD)(consoleInfo.dwSize.X)*
+		(DWORD)(consoleInfo.dwSize.Y - ConGetCursorY() - 1),
+		Coord, &dwWritten);
+
+	ConClearBOLine();
+}
+
+void 
+ConClearLine()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = ConGetCursorY();
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes, ScreenX, Coord, &dwWritten);
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', ScreenX, Coord, &dwWritten);
+}
+
+void 
+ConClearEOLine()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;;
+
+	Coord.X = ConGetCursorX() + consoleInfo.srWindow.Left;
+	Coord.Y = ConGetCursorY() + consoleInfo.srWindow.Top;
+
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ',
+		(DWORD)(ScreenX - ConGetCursorX()),
+		Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes,
+		(DWORD)(ScreenX - ConGetCursorX()),
+		Coord, &dwWritten);
+}
+
+void
+ConClearNFromCursorRight(int n)
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = ConGetCursorX() + consoleInfo.srWindow.Left;
+	Coord.Y = ConGetCursorY() + consoleInfo.srWindow.Top;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', (DWORD)n, Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes, (DWORD)n, Coord, &dwWritten);
+}
+
+void 
+ConClearNFromCursorLeft(int n)
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = ConGetCursorX() + consoleInfo.srWindow.Left - n;
+	Coord.Y = ConGetCursorY() + consoleInfo.srWindow.Top;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', (DWORD)n, Coord, &dwWritten);
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes, (DWORD)n, Coord, &dwWritten);
+}
+
+void 
+ConScrollDownEntireBuffer()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+	ConScrollDown(0, consoleInfo.dwSize.Y - 1);
+	return;
+}
+
+void 
+ConScrollUpEntireBuffer()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+	ConScrollUp(0, consoleInfo.dwSize.Y - 1);
+	return;
+}
+
+void 
+ConScrollUp(int topline, int botline)
+{
+	SMALL_RECT ScrollRect;
+	SMALL_RECT ClipRect;
+	COORD destination;
+	CHAR_INFO Fill;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	if ((botline - topline) == consoleInfo.dwSize.Y - 1) { /* scrolling whole buffer */
+		ScrollRect.Top = topline;
+		ScrollRect.Bottom = botline;
+	} else {
+		ScrollRect.Top = topline + consoleInfo.srWindow.Top;
+		ScrollRect.Bottom = botline + consoleInfo.srWindow.Top;
+	}
+
+	ScrollRect.Left = 0;
+	ScrollRect.Right = ConScreenSizeX() - 1;
+
+	ClipRect.Top = ScrollRect.Top;
+	ClipRect.Bottom = ScrollRect.Bottom;
+	ClipRect.Left = ScrollRect.Left;
+	ClipRect.Right = ScrollRect.Right;
+
+	destination.X = 0;
+	destination.Y = ScrollRect.Top + 1;
+
+	Fill.Attributes = consoleInfo.wAttributes;
+	Fill.Char.AsciiChar = ' ';
+
+	BOOL bRet = ScrollConsoleScreenBuffer(GetConsoleOutputHandle(),
+		&ScrollRect,
+		&ClipRect,
+		destination,
+		&Fill
+	);
+}
+
+void
+ConMoveVisibleWindow(int offset)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	SMALL_RECT visibleWindowRect;
+	errno_t r = 0;
+
+	memset(&visibleWindowRect, 0, sizeof(SMALL_RECT));
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo)) {
+		/* Check if applying the offset results in console buffer overflow.
+		* if yes, then scrolldown the console buffer.
+		*/
+		if ((consoleInfo.srWindow.Bottom + offset) >= (consoleInfo.dwSize.Y - 1)) {
+			for (int i = 0; i < offset; i++)
+				ConScrollDown(0, consoleInfo.dwSize.Y - 1);
+
+			if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo) == FALSE) {
+				error("GetConsoleScreenBufferInfo failed with %d", GetLastError());
+				return;
+			}
+			if ((r = memcpy_s(&visibleWindowRect, sizeof(visibleWindowRect), &consoleInfo.srWindow, sizeof(visibleWindowRect))) != 0) {
+				error("memcpy_s failed with error: %d.", r);
+				return;
+			}
+		} else {
+			if ((r = memcpy_s(&visibleWindowRect, sizeof(visibleWindowRect), &consoleInfo.srWindow, sizeof(visibleWindowRect))) != 0) {
+				error("memcpy_s failed with error: %d.", r);
+				return;
+			}
+			visibleWindowRect.Top += offset;
+			visibleWindowRect.Bottom += offset;
+		}
+
+		SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &visibleWindowRect);
+	}
+}
+
+void 
+ConScrollDown(int topline, int botline)
+{
+	SMALL_RECT ScrollRect;	
+	COORD destination;
+	CHAR_INFO Fill;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	if ((botline - topline) == consoleInfo.dwSize.Y - 1) { /* scrolling whole buffer */
+		ScrollRect.Top = topline;
+		ScrollRect.Bottom = botline;
+	} else {
+		ScrollRect.Top = topline + consoleInfo.srWindow.Top + 1;
+		ScrollRect.Bottom = botline + consoleInfo.srWindow.Top;
+	}
+
+	ScrollRect.Left = 0;
+	ScrollRect.Right = ConScreenSizeX() - 1;
+
+	destination.X = 0;
+	destination.Y = ScrollRect.Top - 1;
+
+	Fill.Attributes = consoleInfo.wAttributes;
+	Fill.Char.AsciiChar = ' ';
+
+	BOOL bRet = ScrollConsoleScreenBuffer(GetConsoleOutputHandle(),
+		&ScrollRect,
+		NULL,
+		destination,
+		&Fill
+	);
+}
+
+void
+ConClearBOLine()
+{
+	DWORD dwWritten;
+	COORD Coord;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = 0;
+	Coord.Y = (short)(ConGetCursorY());
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), consoleInfo.wAttributes,
+		(DWORD)(ConGetCursorX()),
+		Coord, &dwWritten);
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ',
+		(DWORD)(ConGetCursorX()),
+		Coord, &dwWritten);
+}
+
+void
+ConSetCursorPosition(int x, int y)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	COORD Coord;
+	int rc;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = (short)(x);
+	Coord.Y = (short)(y);
+
+	if ((y > consoleInfo.dwSize.Y - 1) && y > LastCursorY) {
+		for (int n = LastCursorY; n < y; n++)
+			GoToNextLine();
+	}
+
+	if (y >= consoleInfo.dwSize.Y) {
+		Coord.Y = consoleInfo.dwSize.Y - 1;
+	}
+
+	if (!SetConsoleCursorPosition(GetConsoleOutputHandle(), Coord))
+		rc = GetLastError();
+
+	LastCursorX = x;
+	LastCursorY = y;
+}
+
+BOOL 
+ConChangeCursor(CONSOLE_CURSOR_INFO *pCursorInfo)
+{
+	return SetConsoleCursorInfo(GetConsoleOutputHandle(), pCursorInfo);
+}
+
+void
+ConGetCursorPosition(int *x, int *y)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo)) {
+		*x = consoleInfo.dwCursorPosition.X;
+		*y = consoleInfo.dwCursorPosition.Y;
+	}
+}
+
+int 
+ConGetCursorX()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return 0;
+
+	return consoleInfo.dwCursorPosition.X;
+}
+
+int
+is_cursor_at_lastline_of_visible_window()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	int return_val = 0;
+
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo)) {
+		int cursor_linenum_in_visible_window = consoleInfo.dwCursorPosition.Y - consoleInfo.srWindow.Top;
+		if (cursor_linenum_in_visible_window >= ConVisibleWindowHeight() - 1)
+			return_val = 1;
+	}
+
+	return return_val;
+}
+
+int 
+ConGetCursorY()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return 0;
+
+	return (consoleInfo.dwCursorPosition.Y - consoleInfo.srWindow.Top);
+}
+
+int 
+ConGetBufferHeight()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return 0;
+
+	return (consoleInfo.dwSize.Y - 1);
+}
+
+void 
+ConMoveCursorPosition(int x, int y)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	COORD Coord;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	Coord.X = (short)(consoleInfo.dwCursorPosition.X + x);
+	Coord.Y = (short)(consoleInfo.dwCursorPosition.Y + y);
+
+	SetConsoleCursorPosition(GetConsoleOutputHandle(), Coord);
+}
+
+void 
+ConGetRelativeCursorPosition(int *x, int *y)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	*x -= consoleInfo.srWindow.Left;
+	*y -= consoleInfo.srWindow.Top;
+}
+
+void 
+ConDeleteChars(int n)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	COORD coord;
+	CHAR_INFO chiBuffer[256];   // 1 row, 256 characters
+	SMALL_RECT sr;
+	COORD temp;
+	int result;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return;
+
+	coord.X = (short)(consoleInfo.dwCursorPosition.X);
+	coord.Y = (short)(consoleInfo.dwCursorPosition.Y);
+
+	sr.Left = coord.X + n;
+	sr.Top = coord.Y;
+	sr.Bottom = coord.Y;
+	sr.Right = consoleInfo.srWindow.Right;
+
+	temp.X = 256;
+	temp.Y = 1;
+	result = ReadConsoleOutput(GetConsoleOutputHandle(),		/* console screen buffer handle */
+				   (PCHAR_INFO)chiBuffer,	/* address of buffer that receives data */
+				   temp,			/* column-row size of destination buffer */
+				   ZeroCoord,			/* upper-left cell to write to */
+				   &sr				/* address of rectangle to read from */
+	);
+	ConClearEOLine();
+
+	sr.Left = coord.X;
+	temp.X = 256;
+	temp.Y = 1;
+
+	sr.Right -= n;
+	result = WriteConsoleOutput(GetConsoleOutputHandle(), (PCHAR_INFO)chiBuffer, temp, ZeroCoord, &sr);
+}
+
+
+SCREEN_HANDLE 
+ConSaveScreenHandle(SCREEN_HANDLE hScreen)
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	PSCREEN_RECORD pScreenRec = (PSCREEN_RECORD)hScreen;
+	int result, width, height;
+
+	if (GetConsoleOutputHandle() == NULL)
+		return NULL;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (NULL);
+
+	if (pScreenRec == NULL) {
+		pScreenRec = (PSCREEN_RECORD)malloc(sizeof(SCREEN_RECORD));
+		if (pScreenRec == NULL)
+			fatal("out of memory");
+		
+		pScreenRec->pScreenBuf = NULL;
+	}
+
+	pScreenRec->srWindowRect = consoleInfo.srWindow;
+	width = consoleInfo.srWindow.Right - consoleInfo.srWindow.Left + 1;
+	height = consoleInfo.srWindow.Bottom - consoleInfo.srWindow.Top + 1;
+	pScreenRec->ScreenSize.X = width;
+	pScreenRec->ScreenSize.Y = height;
+	pScreenRec->ScreenCursor.X = consoleInfo.dwCursorPosition.X - consoleInfo.srWindow.Left;
+	pScreenRec->ScreenCursor.Y = consoleInfo.dwCursorPosition.Y - consoleInfo.srWindow.Top;
+
+	if (pScreenRec->pScreenBuf == NULL)
+		pScreenRec->pScreenBuf = (PCHAR_INFO)malloc(sizeof(CHAR_INFO) * width * height);
+
+	if (!pScreenRec->pScreenBuf) {
+		if (pScreenRec != (PSCREEN_RECORD)hScreen)
+			free(pScreenRec);
+		
+		return NULL;
+	}
+
+	result = ReadConsoleOutput(GetConsoleOutputHandle(),			/* console screen buffer handle */
+				   (PCHAR_INFO)(pScreenRec->pScreenBuf),/* address of buffer that receives data */ 
+				   pScreenRec->ScreenSize,		/* column-row size of destination buffer */
+				   ZeroCoord,				/* upper-left cell to write to */
+				   &consoleInfo.srWindow		/* address of rectangle to read from */
+	);
+
+	return((SCREEN_HANDLE)pScreenRec);
+}
+
+BOOL 
+ConRestoreScreenHandle(SCREEN_HANDLE hScreen)
+{
+	BOOL fOkay = FALSE;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	COORD beginOfScreen = { 0, 0 };
+	PCHAR_INFO pSavedCharInfo;
+	DWORD dwWritten;
+	PSCREEN_RECORD pScreenRec = (PSCREEN_RECORD)hScreen;
+	int  width, height;
+
+	if (GetConsoleOutputHandle() == NULL)
+		return FALSE;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (FALSE);
+
+	width = consoleInfo.srWindow.Right - consoleInfo.srWindow.Left + 1;
+	height = consoleInfo.srWindow.Bottom - consoleInfo.srWindow.Top + 1;
+
+	beginOfScreen.X = consoleInfo.srWindow.Left;
+	beginOfScreen.Y = consoleInfo.srWindow.Top;
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ', (DWORD)width*height, beginOfScreen, &dwWritten);
+
+	pSavedCharInfo = (PCHAR_INFO)(pScreenRec->pScreenBuf);
+	SetConsoleTextAttribute(GetConsoleOutputHandle(), pSavedCharInfo->Attributes);
+
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), pSavedCharInfo->Attributes,
+		(DWORD)width*height,
+		beginOfScreen, &dwWritten);
+
+	fOkay = WriteConsoleOutput(GetConsoleOutputHandle(),			/* handle to a console screen buffer */
+				  (PCHAR_INFO)(pScreenRec->pScreenBuf),	/* pointer to buffer with data to write  */
+				  pScreenRec->ScreenSize,		/* column-row size of source buffer */
+				  ZeroCoord,				/* upper-left cell to write from */
+				  &consoleInfo.srWindow			/* pointer to rectangle to write to */
+	);
+	
+	SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &pScreenRec->srWindowRect);
+	ConSetCursorPosition(pScreenRec->ScreenCursor.X, pScreenRec->ScreenCursor.Y);
+	
+	return fOkay;
+}
+
+BOOL 
+ConRestoreScreenColors()
+{
+	SCREEN_HANDLE hScreen = pSavedScreenRec;
+	BOOL fOkay = FALSE;
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	COORD beginOfScreen = { 0, 0 };
+	PCHAR_INFO pSavedCharInfo;
+	DWORD dwWritten;
+	PSCREEN_RECORD pScreenRec = (PSCREEN_RECORD)hScreen;
+
+	if (GetConsoleOutputHandle() == NULL)
+		return FALSE;
+
+	if (pSavedScreen == NULL)
+		return FALSE;
+
+	if (!GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo))
+		return (FALSE);
+
+	beginOfScreen.X = consoleInfo.srWindow.Left;
+	beginOfScreen.Y = consoleInfo.srWindow.Top;
+
+	FillConsoleOutputCharacter(GetConsoleOutputHandle(), ' ',
+		(DWORD)pScreenRec->ScreenSize.X*pScreenRec->ScreenSize.Y,
+		beginOfScreen, &dwWritten);
+
+	pSavedCharInfo = (PCHAR_INFO)(pScreenRec->pScreenBuf);
+	SetConsoleTextAttribute(GetConsoleOutputHandle(), pSavedCharInfo->Attributes);
+
+	FillConsoleOutputAttribute(GetConsoleOutputHandle(), pSavedCharInfo->Attributes,
+		(DWORD)pScreenRec->ScreenSize.X*pScreenRec->ScreenSize.Y,
+		beginOfScreen, &dwWritten);
+
+	return fOkay;
+}
+
+void 
+ConDeleteScreenHandle(SCREEN_HANDLE hScreen)
+{
+	PSCREEN_RECORD pScreenRec = (PSCREEN_RECORD)hScreen;
+
+	free(pScreenRec->pScreenBuf);
+	free(pScreenRec);
+}
+
+/* Restores Previous Saved screen info and buffer */
+BOOL
+ConRestoreScreen()
+{
+	return ConRestoreScreenHandle(pSavedScreenRec);
+}
+
+/* Saves current screen info and buffer */
+void
+ConSaveScreen()
+{
+	pSavedScreenRec = (PSCREEN_RECORD)ConSaveScreenHandle(pSavedScreenRec);	
+}
+
+void
+ConSaveViewRect_NoPtyHack()
+{
+	CONSOLE_SCREEN_BUFFER_INFO csbi;
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &csbi))
+		SavedViewRect = csbi.srWindow;
+}
+
+void
+ConRestoreViewRect_NoPtyHack()
+{
+	CONSOLE_SCREEN_BUFFER_INFO consoleInfo;
+	HWND hwnd = GetConsoleWindow();
+
+	WINDOWPLACEMENT wp;
+	wp.length = sizeof(WINDOWPLACEMENT);
+	GetWindowPlacement(hwnd, &wp);
+
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &consoleInfo) &&
+	    ((consoleInfo.srWindow.Top != SavedViewRect.Top ||
+	      consoleInfo.srWindow.Bottom != SavedViewRect.Bottom))) {
+		if ((SavedViewRect.Right - SavedViewRect.Left > consoleInfo.dwSize.X) ||
+		    (wp.showCmd == SW_SHOWMAXIMIZED)) {
+			COORD coordScreen;
+			coordScreen.X = SavedViewRect.Right - SavedViewRect.Left;
+			coordScreen.Y = consoleInfo.dwSize.Y;
+			SetConsoleScreenBufferSize(GetConsoleOutputHandle(), coordScreen);
+			
+			ShowWindow(hwnd, SW_SHOWMAXIMIZED);
+		} else
+			ShowWindow(hwnd, SW_RESTORE);
+
+		SetConsoleWindowInfo(GetConsoleOutputHandle(), TRUE, &SavedViewRect);
+	}
+}
+
+void
+ConSaveWindowsState()
+{
+	CONSOLE_SCREEN_BUFFER_INFOEX csbiex;
+	csbiex.cbSize = sizeof(CONSOLE_SCREEN_BUFFER_INFOEX);
+
+	if (!GetConsoleScreenBufferInfoEx(GetConsoleOutputHandle(), &csbiex))
+		return;
+
+	SavedWindowState = csbiex;
+}
+
+void
+ConMoveCursorTopOfVisibleWindow()
+{
+	CONSOLE_SCREEN_BUFFER_INFO csbi;
+	int offset;
+
+	if (GetConsoleScreenBufferInfo(GetConsoleOutputHandle(), &csbi)) {
+		offset = csbi.dwCursorPosition.Y - csbi.srWindow.Top;
+		ConMoveVisibleWindow(offset);
+
+		if(track_view_port_no_pty_hack)
+			ConSaveViewRect_NoPtyHack();
+	}
+}
+
+HANDLE
+get_console_handle(FILE *stream, DWORD * mode)
+{
+	int file_num = 0, ret = 0;
+	intptr_t lHandle = 0;
+	HANDLE hFile = NULL;
+	DWORD type = 0;
+
+	file_num = (_fileno)(stream);
+	if (file_num == -1) {
+		return INVALID_HANDLE_VALUE;
+	}
+
+	lHandle = _get_osfhandle(file_num);
+	if (lHandle == -1 && errno == EBADF) {
+		return INVALID_HANDLE_VALUE;
+	}
+
+	type = GetFileType((HANDLE)lHandle);
+	if (type == FILE_TYPE_CHAR && file_num >= 0 && file_num <= 2) {
+		if (file_num == 0)
+			hFile = GetStdHandle(STD_INPUT_HANDLE);
+		else if (file_num == 1)
+			hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+		else if (file_num == 2)
+			hFile = GetStdHandle(STD_ERROR_HANDLE);
+
+		if ((hFile != NULL) &&
+			(hFile != INVALID_HANDLE_VALUE) &&
+			(GetFileType(hFile) == FILE_TYPE_CHAR) &&
+			GetConsoleMode(hFile, mode))
+			return hFile;
+	}
+	return INVALID_HANDLE_VALUE;
+}
diff --git a/contrib/win32/win32compat/console.h b/contrib/win32/win32compat/console.h
new file mode 100644
index 000000000..6f7c0f2d8
--- /dev/null
+++ b/contrib/win32/win32compat/console.h
@@ -0,0 +1,152 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* console.h
+ * 
+ * Common library for Windows Console Screen IO.
+ * Contains Windows console related definition so that emulation code can draw
+ * on Windows console screen surface.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ */
+ 
+#ifndef __PRAGMA_CONSOLE_h
+#define __PRAGMA_CONSOLE_h
+
+#define ANSI_ATTR_RESET			0
+#define ANSI_BRIGHT			1
+#define ANSI_DIM			2
+#define ANSI_UNDERSCORE			4
+#define ANSI_BLINK			5
+#define ANSI_REVERSE			7
+#define ANSI_HIDDEN			8
+#define ANSI_NOUNDERSCORE		24
+#define ANSI_NOREVERSE			27
+
+#define ANSI_FOREGROUND_BLACK		30
+#define ANSI_FOREGROUND_RED		31
+#define ANSI_FOREGROUND_GREEN		32
+#define ANSI_FOREGROUND_YELLOW		33
+#define ANSI_FOREGROUND_BLUE		34
+#define ANSI_FOREGROUND_MAGENTA		35
+#define ANSI_FOREGROUND_CYAN		36
+#define ANSI_FOREGROUND_WHITE		37
+#define ANSI_DEFAULT_FOREGROUND		39
+#define ANSI_BACKGROUND_BLACK		40
+#define ANSI_BACKGROUND_RED		41
+#define ANSI_BACKGROUND_GREEN		42
+#define ANSI_BACKGROUND_YELLOW		43
+#define ANSI_BACKGROUND_BLUE		44
+#define ANSI_BACKGROUND_MAGENTA		45
+#define ANSI_BACKGROUND_CYAN		46
+#define ANSI_BACKGROUND_WHITE		47
+#define ANSI_DEFAULT_BACKGROUND		49
+#define ANSI_BACKGROUND_BRIGHT		128
+
+#define TAB_LENGTH			4
+#define TAB_CHAR			'\t'
+#define TAB_SPACE			"    "
+
+#define true TRUE
+#define false FALSE
+#define bool BOOL
+
+#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
+#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x4
+#endif
+
+#ifndef ENABLE_VIRTUAL_TERMINAL_INPUT
+#define ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
+#endif
+
+#ifndef DISABLE_NEWLINE_AUTO_RETURN
+#define DISABLE_NEWLINE_AUTO_RETURN 0x8
+#endif
+
+typedef void *  SCREEN_HANDLE;
+
+void ConEnterRawMode();
+void ConUnInitWithRestore();
+void ConExitRawMode();
+
+BOOL ConSetScreenRect(int xSize, int ySize);
+BOOL ConSetScreenSize(int X, int Y);
+BOOL ConRestoreScreen();
+void ConSaveScreen();
+void ConSetAttribute(int *iParam, int iParamCount);
+int ConScreenSizeX();
+int ConSetScreenX();
+int ConScreenSizeY();
+int ConVisibleWindowWidth();
+int ConVisibleWindowHeight();
+int ConSetScreenY();
+void ConFillToEndOfLine();
+int ConWriteString(char* pszString, int cbString);
+BOOL ConWriteChar(CHAR ch);
+int ConWriteConsole(char *pData, int NumChars);
+PCHAR ConDisplayData(char* pData, int NumLines);
+PCHAR ConWriteLine(char* pData);
+int Con_printf(const char *Format, ...);
+void ConClearScrollRegion();
+void ConClearScreen();
+void ConClearEOScreen();
+void ConClearBOScreen();
+void ConClearLine();
+void ConClearEOLine();
+void ConClearNFromCursorRight(int n);
+void ConClearNFromCursorLeft(int n);
+void ConScrollUpEntireBuffer();
+void ConScrollDownEntireBuffer();
+void ConScrollUp(int topline,int botline);
+void ConScrollDown(int topline,int botline);
+void ConClearBOLine();
+BOOL ConChangeCursor(CONSOLE_CURSOR_INFO *pCursorInfo);
+void ConSetCursorPosition(int x, int y);
+int ConGetCursorX();
+int ConGetCursorY();
+int ConGetBufferHeight();
+BOOL ConDisplayCursor(BOOL bVisible);
+void ConMoveCursorPosition(int x, int y);
+void ConGetRelativeCursorPosition(int *x, int *y);
+BOOL ConRestoreScreenHandle(SCREEN_HANDLE hScreen);
+BOOL ConRestoreScreenColors();
+SCREEN_HANDLE ConSaveScreenHandle(SCREEN_HANDLE);
+void ConDeleteScreenHandle(SCREEN_HANDLE hScreen);
+void ConSaveViewRect_NoPtyHack();
+void ConRestoreViewRect_NoPtyHack();
+void ConDeleteChars(int n);
+void ConSaveWindowsState();
+void ConMoveVisibleWindow(int offset);
+int is_cursor_at_lastline_of_visible_window();
+void ConGetCursorPosition(int *x, int *y);
+void ConMoveCursorTopOfVisibleWindow();
+HANDLE get_console_handle(FILE *, DWORD *);
+#endif
diff --git a/contrib/win32/win32compat/fileio.c b/contrib/win32/win32compat/fileio.c
new file mode 100644
index 000000000..e0d9f58a4
--- /dev/null
+++ b/contrib/win32/win32compat/fileio.c
@@ -0,0 +1,1386 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Author: Bryan Berns <berns@uwalumni.com>
+*  Added symlink support
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <fcntl.h>
+#include "inc/sys/stat.h"
+#include "inc/sys/types.h"
+#include <io.h>
+#include <errno.h>
+#include <stddef.h>
+#include <direct.h>
+
+#include "w32fd.h"
+#include "inc\utf.h"
+#include "inc\fcntl.h"
+#include "inc\pwd.h"
+#include "misc_internal.h"
+#include "debug.h"
+#include <Sddl.h>
+
+/* internal read buffer size */
+#define READ_BUFFER_SIZE 100*1024
+/* internal write buffer size */
+#define WRITE_BUFFER_SIZE 100*1024
+
+/*
+* A ACE is a binary data structure of changeable length
+* https://msdn.microsoft.com/en-us/library/windows/desktop/aa374928(v=vs.85).aspx
+* The value is calculated based on current need: max sid string (184) plus the enough spaces for other fields in ACEs
+*/
+#define MAX_ACE_LENGTH 225
+/* 
+* A security descriptor is a binary data structure of changeable length
+* https://msdn.microsoft.com/en-us/library/windows/desktop/aa379570(v=vs.85).aspx
+* The value is calculated based on current need: 4 ACEs plus the enough spaces for owner sid and dcal flag
+*/
+#define SDDL_LENGTH 5* MAX_ACE_LENGTH
+
+/*MAX length attribute string looks like 0xffffffff*/
+#define MAX_ATTRIBUTE_LENGTH 10
+
+#define errno_from_Win32LastError() errno_from_Win32Error(GetLastError())
+
+struct createFile_flags {
+	DWORD dwDesiredAccess;
+	DWORD dwShareMode;
+	SECURITY_ATTRIBUTES securityAttributes;
+	DWORD dwCreationDisposition;
+	DWORD dwFlagsAndAttributes;
+};
+
+int syncio_initiate_read(struct w32_io* pio);
+int syncio_initiate_write(struct w32_io* pio, DWORD num_bytes);
+int syncio_close(struct w32_io* pio);
+
+/* maps Win32 error to errno */
+int
+errno_from_Win32Error(int win32_error)
+{
+	switch (win32_error) {
+	case ERROR_PRIVILEGE_NOT_HELD:
+	case ERROR_ACCESS_DENIED:
+		return EACCES;
+	case ERROR_OUTOFMEMORY:
+		return ENOMEM;
+	case ERROR_FILE_EXISTS:
+		return EEXIST;
+	case ERROR_FILE_NOT_FOUND:
+	case ERROR_PATH_NOT_FOUND:
+	case ERROR_INVALID_NAME:
+		return ENOENT;
+	case ERROR_INVALID_FUNCTION:
+	case ERROR_NOT_SUPPORTED:
+		return EOPNOTSUPP;
+	default:
+		return win32_error;
+	}
+}
+
+struct w32_io*
+fileio_afunix_socket() 
+{
+	struct w32_io* ret = (struct w32_io*)malloc(sizeof(struct w32_io));
+	if (ret == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	memset(ret, 0, sizeof(struct w32_io));
+	return ret;
+}
+
+int
+fileio_connect(struct w32_io* pio, char* name) 
+{
+	wchar_t* name_w = NULL;
+	HANDLE h = INVALID_HANDLE_VALUE;
+	int ret = 0;
+
+	if (pio->handle != 0 && pio->handle != INVALID_HANDLE_VALUE) {
+		debug3("fileio_connect called in unexpected state, pio = %p", pio);
+		errno = EOTHER;
+		ret = -1;
+		goto cleanup;
+	}
+
+	if ((name_w = utf8_to_utf16(name)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+	
+	do {
+		h = CreateFileW(name_w, GENERIC_READ | GENERIC_WRITE, 0,
+			NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED | SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION, NULL);
+	
+		if (h != INVALID_HANDLE_VALUE)
+			break;
+		if (GetLastError() != ERROR_PIPE_BUSY)
+			break;
+	
+		debug4("waiting for agent connection, retrying after 1 sec");
+		if ((ret = wait_for_any_event(NULL, 0, 1000) != 0) != 0)
+			goto cleanup;
+	} while(1);
+
+	if (h == INVALID_HANDLE_VALUE) {
+		debug3("unable to connect to pipe %ls, error: %d", name_w, GetLastError());
+		errno = errno_from_Win32LastError();
+		ret = -1;
+		goto cleanup;
+	}
+
+	if (SetHandleInformation(h, HANDLE_FLAG_INHERIT,
+	    pio->fd_flags & FD_CLOEXEC ? 0 : HANDLE_FLAG_INHERIT) == FALSE) {
+		errno = errno_from_Win32LastError();
+		debug3("SetHandleInformation failed, error = %d, pio = %p", GetLastError(), pio);
+		ret = -1;
+		goto cleanup;
+	}
+	
+	pio->handle = h;
+	h = INVALID_HANDLE_VALUE;
+
+cleanup:
+	if (name_w)
+		free(name_w);
+	if (h != INVALID_HANDLE_VALUE)
+		CloseHandle(h);
+	return ret;
+}
+
+/* used to name named pipes used to implement pipe() */
+static int pipe_counter = 0;
+
+/*
+ * pipe() (unidirectional) and socketpair() (duplex)
+ * implementation. Creates an inbound named pipe, uses CreateFile to connect
+ * to it. These handles are associated with read end and write end of the pipe
+ */
+int
+fileio_pipe(struct w32_io* pio[2], int duplex)
+{
+	HANDLE read_handle = INVALID_HANDLE_VALUE, write_handle = INVALID_HANDLE_VALUE;
+	struct w32_io *pio_read = NULL, *pio_write = NULL;
+	char pipe_name[PATH_MAX];
+	SECURITY_ATTRIBUTES sec_attributes;
+
+	if (pio == NULL) {
+		errno = EINVAL;
+		debug3("pipe - ERROR invalid parameter");
+		return -1;
+	}
+
+	/* create name for named pipe */
+	if (-1 == sprintf_s(pipe_name, PATH_MAX, "\\\\.\\Pipe\\W32PosixPipe.%08x.%08x",
+		GetCurrentProcessId(), pipe_counter++)) {
+		errno = EOTHER;
+		debug3("pipe - ERROR sprintf_s %d", errno);
+		goto error;
+	}
+
+	sec_attributes.bInheritHandle = TRUE;
+	sec_attributes.lpSecurityDescriptor = NULL;
+	sec_attributes.nLength = sizeof(sec_attributes);
+
+	/* create named pipe */
+	write_handle = CreateNamedPipeA(pipe_name,
+		(duplex ? PIPE_ACCESS_DUPLEX : PIPE_ACCESS_OUTBOUND ) | FILE_FLAG_OVERLAPPED,
+		PIPE_TYPE_BYTE | PIPE_WAIT,
+		1,
+		4096,
+		4096,
+		0,
+		&sec_attributes);
+	if (write_handle == INVALID_HANDLE_VALUE) {
+		errno = errno_from_Win32LastError();
+		debug3("pipe - CreateNamedPipe() ERROR:%d", errno);
+		goto error;
+	}
+
+	/* connect to named pipe */
+	read_handle = CreateFileA(pipe_name,
+		duplex ? GENERIC_READ | GENERIC_WRITE :  GENERIC_READ,
+		0,
+		&sec_attributes,
+		OPEN_EXISTING,
+		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
+		NULL);
+	if (read_handle == INVALID_HANDLE_VALUE) {
+		errno = errno_from_Win32LastError();
+		debug3("pipe - ERROR CreateFile() :%d", errno);
+		goto error;
+	}
+
+	/* create w32_io objects encapsulating above handles */
+	pio_read = (struct w32_io*)malloc(sizeof(struct w32_io));
+	pio_write = (struct w32_io*)malloc(sizeof(struct w32_io));
+
+	if (!pio_read || !pio_write) {
+		errno = ENOMEM;
+		debug3("pip - ERROR:%d", errno);
+		goto error;
+	}
+
+	memset(pio_read, 0, sizeof(struct w32_io));
+	memset(pio_write, 0, sizeof(struct w32_io));
+
+	pio_read->handle = read_handle;
+	pio_write->handle = write_handle;
+
+	pio[0] = pio_read;
+	pio[1] = pio_write;
+	return 0;
+
+error:
+	if (read_handle)
+		CloseHandle(read_handle);
+	if (write_handle)
+		CloseHandle(write_handle);
+	if (pio_read)
+		free(pio_read);
+	if (pio_write)
+		free(pio_write);
+	return -1;
+}
+
+static int
+st_mode_to_file_att(int mode, wchar_t * attributes)
+{
+	DWORD att = 0;
+	switch (mode) {
+	case S_IRWXO:
+		swprintf_s(attributes, MAX_ATTRIBUTE_LENGTH, L"FA");
+		break;
+	default:
+		if((mode & S_IROTH) != 0)
+			att |= (FILE_GENERIC_READ | FILE_EXECUTE);
+		if ((mode & S_IWOTH) != 0)
+			att |= (FILE_GENERIC_WRITE | DELETE);
+		if ((mode & S_IXOTH) != 0)
+			att |= FILE_GENERIC_EXECUTE;
+		swprintf_s(attributes, MAX_ATTRIBUTE_LENGTH, L"%#lx", att);
+		break;		
+	}
+	return 0;
+}
+
+/* maps open() file modes and flags to ones needed by CreateFile */
+static int
+createFile_flags_setup(int flags, mode_t mode, struct createFile_flags* cf_flags)
+{
+	/* check flags */
+	int rwflags = flags & 0x3, c_s_flags = flags & 0xfffffffc, ret = -1;
+	PSECURITY_DESCRIPTOR pSD = NULL;
+	wchar_t sddl[SDDL_LENGTH + 1] = { 0 }, owner_ace[MAX_ACE_LENGTH + 1] = {0}, everyone_ace[MAX_ACE_LENGTH + 1] = {0};
+	wchar_t owner_access[MAX_ATTRIBUTE_LENGTH + 1] = {0}, everyone_access[MAX_ATTRIBUTE_LENGTH + 1] = {0}, *sid_utf16 = NULL;
+	PACL dacl = NULL;
+	PSID owner_sid = NULL;
+
+	/*
+	* should be one of one of the following access modes:
+	* O_RDONLY, O_WRONLY, or O_RDWR
+	*/
+	if ((rwflags != O_RDONLY) && (rwflags != O_WRONLY) && (rwflags != O_RDWR)) {
+		debug3("open - flags ERROR: wrong rw flags: %d", flags);
+		errno = EINVAL;
+		return -1;
+	}
+
+	/*only following create and status flags currently supported*/
+	if (c_s_flags & ~(O_NONBLOCK | O_APPEND | O_CREAT | O_TRUNC | O_EXCL | O_BINARY)) {
+		debug3("open - ERROR: Unsupported flags: %d", flags);
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	cf_flags->dwShareMode = 0;
+
+	switch (rwflags) {
+	case O_RDONLY:
+		cf_flags->dwDesiredAccess = GENERIC_READ;
+		/* refer to https://msdn.microsoft.com/en-us/library/windows/desktop/aa363874(v=vs.85).aspx */
+		cf_flags->dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+		break;
+	case O_WRONLY:
+		cf_flags->dwDesiredAccess = GENERIC_WRITE;
+		cf_flags->dwShareMode = FILE_SHARE_WRITE;
+		break;
+	case O_RDWR:
+		cf_flags->dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;
+		break;
+	}	
+	cf_flags->dwCreationDisposition = OPEN_EXISTING;
+	if (c_s_flags & O_TRUNC)
+		cf_flags->dwCreationDisposition = TRUNCATE_EXISTING;
+	if (c_s_flags & O_CREAT) {
+		if (c_s_flags & O_EXCL)
+			cf_flags->dwCreationDisposition = CREATE_NEW;
+		else if (c_s_flags & O_TRUNC)
+			cf_flags->dwCreationDisposition = CREATE_ALWAYS;
+		else
+			cf_flags->dwCreationDisposition = OPEN_ALWAYS;
+	}
+
+	if (c_s_flags & O_APPEND)
+		cf_flags->dwDesiredAccess = FILE_APPEND_DATA;
+
+	cf_flags->dwFlagsAndAttributes = FILE_FLAG_OVERLAPPED | FILE_FLAG_BACKUP_SEMANTICS;
+
+	// If the mode is USHRT_MAX then we will inherit the permissions from the parent folder.
+	if (mode != USHRT_MAX) {
+		/*validate mode*/
+		/*
+		 * __S_IFDIR  __S_IFREG are added for compat
+		 * TODO- open(__S_IFDIR) on a file and vice versa should fail
+		*/
+		if (mode & ~(S_IRWXU | S_IRWXG | S_IRWXO | __S_IFDIR | __S_IFREG)) {
+			debug3("open - ERROR: unsupported mode: %d", mode);
+			errno = ENOTSUP;
+			return -1;
+		}
+
+		if ((owner_sid = get_sid(NULL)) == NULL || (!ConvertSidToStringSidW(owner_sid, &sid_utf16))) {
+			debug3("cannot retrieve current user's SID");
+			goto cleanup;
+		}
+
+		if (!IsWellKnownSid(owner_sid, WinLocalSystemSid) && ((mode & S_IRWXU) != 0)) {
+			if (st_mode_to_file_att((mode & S_IRWXU) >> 6, owner_access) != 0) {
+				debug3("st_mode_to_file_att()");
+				goto cleanup;
+			}
+			swprintf_s(owner_ace, MAX_ACE_LENGTH, L"(A;;%s;;;%s)", owner_access, sid_utf16);
+		}
+
+		if (mode & S_IRWXO) {
+			if (st_mode_to_file_att(mode & S_IRWXO, everyone_access) != 0) {
+				debug3("st_mode_to_file_att()");
+				goto cleanup;
+			}
+			swprintf_s(everyone_ace, MAX_ACE_LENGTH, L"(A;;%s;;;WD)", everyone_access);
+		}
+
+		swprintf_s(sddl, SDDL_LENGTH, L"O:%sD:PAI(A;;FA;;;BA)(A;;FA;;;SY)%s%s", sid_utf16, owner_ace, everyone_ace);
+		if (ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl, SDDL_REVISION, &pSD, NULL) == FALSE) {
+			debug3("ConvertStringSecurityDescriptorToSecurityDescriptorW failed with error code %d", GetLastError());
+			goto cleanup;
+		}
+
+		if (IsValidSecurityDescriptor(pSD) == FALSE) {
+			debug3("IsValidSecurityDescriptor return FALSE");
+			goto cleanup;
+		}
+	}
+
+	cf_flags->securityAttributes.lpSecurityDescriptor = pSD;
+	cf_flags->securityAttributes.bInheritHandle = TRUE;
+	cf_flags->securityAttributes.nLength = sizeof(cf_flags->securityAttributes);
+
+	ret = 0;
+cleanup:
+	if (owner_sid)
+		free(owner_sid);
+
+	if (sid_utf16)
+		LocalFree(sid_utf16);
+		
+	return ret;
+}
+
+/* returns 1 if true, 0 otherwise */
+int
+file_in_chroot_jail(HANDLE handle) {
+	/* ensure final path is within chroot */
+	wchar_t *final_path;
+	
+	final_path = get_final_path_by_handle(handle);
+	if (!final_path)
+		return 0;
+
+	const wchar_t* uncPrefix = L"UNC\\";
+	int isUNCPath = memcmp(final_path, uncPrefix, 2 * wcslen(uncPrefix));
+
+	if (0 == isUNCPath) {
+		debug3("symlink points to UNCPath");
+		return 1;
+	}
+
+	to_wlower_case(final_path);
+	if ((wcslen(final_path) < wcslen(chroot_pathw)) ||
+	    memcmp(final_path, chroot_pathw, 2 * wcslen(chroot_pathw)) != 0 ||
+	    final_path[wcslen(chroot_pathw)] != '\\') {
+		debug3("access denied due to attempt to escape chroot jail");
+		return 0;
+	}
+
+	return 1;
+}
+
+/* open() implementation. Uses CreateFile to open file, console, device, etc */
+struct w32_io*
+fileio_open(const char *path_utf8, int flags, mode_t mode)
+{
+	struct w32_io* pio = NULL;
+	struct createFile_flags cf_flags;
+	HANDLE handle = INVALID_HANDLE_VALUE;
+	wchar_t *path_utf16 = NULL;
+	int nonfs_dev = 0; /* opening a non file system device */
+
+	debug4("open - pathname:%s, flags:%d, mode:%d", path_utf8, flags, mode);
+	/* check input params*/
+	if (path_utf8 == NULL) {
+		errno = EINVAL;
+		debug3("open - ERROR:%d", errno);
+		return NULL;
+	}
+
+	/* if opening null device, point to Windows equivalent */
+	if (strncmp(path_utf8, NULL_DEVICE, sizeof(NULL_DEVICE)) == 0
+		|| strncmp(path_utf8, NULL_DEVICE_WIN, sizeof(NULL_DEVICE_WIN)) == 0) {
+		nonfs_dev = 1;
+		path_utf16 = utf8_to_utf16(NULL_DEVICE_WIN);
+	}
+	else
+		path_utf16 = resolved_path_utf16(path_utf8);
+
+	if (path_utf16 == NULL) 
+		return NULL;
+
+	if (createFile_flags_setup(flags, mode, &cf_flags) == -1) {
+		debug3("createFile_flags_setup() failed.");
+		goto cleanup;
+	}	
+
+	handle = CreateFileW(path_utf16, cf_flags.dwDesiredAccess, cf_flags.dwShareMode,
+		&cf_flags.securityAttributes, cf_flags.dwCreationDisposition,
+		cf_flags.dwFlagsAndAttributes, NULL);	
+
+	if (handle == INVALID_HANDLE_VALUE) {
+		errno = errno_from_Win32LastError();
+		debug3("failed to open file:%S error:%d", path_utf16, GetLastError());
+		goto cleanup;
+	}
+
+	if (chroot_pathw && !nonfs_dev && !file_in_chroot_jail(handle)) {	
+		debug3("%s is not in chroot jail", path_utf8);
+		errno = EACCES;
+		goto cleanup;
+	}
+	
+	pio = (struct w32_io*)malloc(sizeof(struct w32_io));
+	if (pio == NULL) {
+		CloseHandle(handle);
+		errno = ENOMEM;
+		debug3("fileio_open(), failed to allocate memory error:%d", errno);
+		goto cleanup;
+	}
+
+	memset(pio, 0, sizeof(struct w32_io));
+
+	if (flags & O_NONBLOCK)
+		pio->fd_status_flags = O_NONBLOCK;
+
+	pio->handle = handle;
+	handle = INVALID_HANDLE_VALUE;
+
+cleanup:
+	if ((&cf_flags.securityAttributes != NULL) && (&cf_flags.securityAttributes.lpSecurityDescriptor != NULL))
+		LocalFree(cf_flags.securityAttributes.lpSecurityDescriptor);
+	if(path_utf16)
+		free(path_utf16);
+	if (handle != INVALID_HANDLE_VALUE)
+		CloseHandle(handle);
+
+	return pio;
+}
+
+VOID CALLBACK 
+ReadCompletionRoutine(_In_ DWORD dwErrorCode, _In_ DWORD dwNumberOfBytesTransfered, _Inout_ LPOVERLAPPED lpOverlapped)
+{
+	struct w32_io* pio = (struct w32_io*)((char*)lpOverlapped - offsetof(struct w32_io, read_overlapped));
+	debug4("ReadCB pio:%p, pending_state:%d, error:%d, received:%d",
+		pio, pio->read_details.pending, dwErrorCode, dwNumberOfBytesTransfered);
+	pio->read_details.error = dwErrorCode;
+	pio->read_details.remaining = dwNumberOfBytesTransfered;
+	pio->read_details.completed = 0;
+	pio->read_details.pending = FALSE;
+	*((__int64*)&lpOverlapped->Offset) += dwNumberOfBytesTransfered;
+}
+
+/* initiate an async read */
+/* TODO:  make this a void func, store error in context */
+int
+fileio_ReadFileEx(struct w32_io* pio, unsigned int bytes_requested)
+{
+	debug4("ReadFileEx io:%p", pio);
+
+	if (pio->read_details.buf == NULL) {
+		pio->read_details.buf = malloc(READ_BUFFER_SIZE);
+		if (!pio->read_details.buf) {
+			errno = ENOMEM;
+			debug4("ReadFileEx - ERROR: %d, io:%p", errno, pio);
+			return -1;
+		}
+	}
+
+	if (FILETYPE(pio) == FILE_TYPE_DISK)
+		pio->read_details.buf_size = min(bytes_requested, READ_BUFFER_SIZE);
+	else
+		pio->read_details.buf_size = READ_BUFFER_SIZE;
+
+	if (ReadFileEx(WINHANDLE(pio), pio->read_details.buf, pio->read_details.buf_size,
+		&pio->read_overlapped, &ReadCompletionRoutine))
+		pio->read_details.pending = TRUE;
+	else {
+		errno = errno_from_Win32LastError();
+		debug3("ReadFileEx() ERROR:%d, io:%p", GetLastError(), pio);
+		return -1;
+	}
+
+	return 0;
+}
+
+/* read() implementation */
+int
+fileio_read(struct w32_io* pio, void *dst, size_t max_bytes)
+{
+	int bytes_copied;
+	errno_t r = 0;
+
+	debug5("read - io:%p remaining:%d", pio, pio->read_details.remaining);
+
+	/* if read is pending */
+	if (pio->read_details.pending) {
+		if (w32_io_is_blocking(pio)) {
+			debug4("read - io is pending, blocking call made, io:%p", pio);
+			while (fileio_is_io_available(pio, TRUE) == FALSE) {
+				if (-1 == wait_for_any_event(NULL, 0, INFINITE))
+					return -1;
+			}
+		}
+		errno = EAGAIN;
+		debug4("read - io is already pending, io:%p", pio);
+		return -1;
+	}
+
+	if (fileio_is_io_available(pio, TRUE) == FALSE) {
+		if (pio->type == NONSOCK_SYNC_FD || FILETYPE(pio) == FILE_TYPE_CHAR) {
+			if (-1 == syncio_initiate_read(pio))
+				return -1;
+		} else {
+			if (-1 == fileio_ReadFileEx(pio, (int)max_bytes)) {
+				if ((FILETYPE(pio) == FILE_TYPE_PIPE)
+					&& (errno == ERROR_BROKEN_PIPE)) {
+					/* write end of the pipe closed */
+					debug3("read - no more data, io:%p", pio);
+					errno = 0;
+					return 0;
+				}
+				/* on W2012, ReadFileEx on file throws a synchronous EOF error*/
+				else if ((FILETYPE(pio) == FILE_TYPE_DISK)
+					&& (errno == ERROR_HANDLE_EOF)) {
+					debug3("read - no more data, io:%p", pio);
+					errno = 0;
+					return 0;
+				}
+				return -1;
+			}
+		}
+
+		/* pick up APC if IO has completed */
+		SleepEx(0, TRUE);
+
+		if (w32_io_is_blocking(pio)) {
+			while (fileio_is_io_available(pio, TRUE) == FALSE) {
+				if (-1 == wait_for_any_event(NULL, 0, INFINITE))
+					return -1;
+			}
+		}
+		else if (pio->read_details.pending) {
+			errno = EAGAIN;
+			debug4("read - IO is pending, io:%p", pio);
+			return -1;
+		}
+	}
+
+	if (pio->read_details.error) {
+		errno = errno_from_Win32Error(pio->read_details.error);
+		/*write end of the pipe is closed or pipe broken or eof reached*/
+		if ((pio->read_details.error == ERROR_BROKEN_PIPE) ||
+			(pio->read_details.error == ERROR_HANDLE_EOF)) {
+			debug4("read - (2) no more data, io:%p", pio);
+			errno = 0;
+			pio->read_details.error = 0;
+			return 0;
+		}
+		debug3("read - ERROR from cb :%d, io:%p", errno, pio);
+		pio->read_details.error = 0;
+		return -1;
+	}
+
+	bytes_copied = min((DWORD)max_bytes, pio->read_details.remaining);
+	if ((r = memcpy_s(dst, max_bytes, pio->read_details.buf + pio->read_details.completed, bytes_copied)) != 0) {
+		debug3("memcpy_s failed with error: %d.", r);
+		return -1;
+	}
+	pio->read_details.remaining -= bytes_copied;
+	pio->read_details.completed += bytes_copied;
+	debug4("read - io:%p read: %d remaining: %d", pio, bytes_copied,
+		pio->read_details.remaining);
+	return bytes_copied;
+}
+
+VOID CALLBACK 
+WriteCompletionRoutine(_In_ DWORD dwErrorCode,
+			_In_ DWORD dwNumberOfBytesTransfered,
+			_Inout_ LPOVERLAPPED lpOverlapped)
+{
+	struct w32_io* pio =
+		(struct w32_io*)((char*)lpOverlapped - offsetof(struct w32_io, write_overlapped));
+	debug4("WriteCB - pio:%p, pending_state:%d, error:%d, transferred:%d of remaining: %d",
+		pio, pio->write_details.pending, dwErrorCode, dwNumberOfBytesTransfered,
+		pio->write_details.remaining);
+	pio->write_details.error = dwErrorCode;
+	/* TODO - assert that remaining == dwNumberOfBytesTransfered */
+	if ((dwErrorCode == 0) && (pio->write_details.remaining != dwNumberOfBytesTransfered)) {
+		error("WriteCB - ERROR: broken assumption, io:%p, wrote:%d, remaining:%d", pio,
+			dwNumberOfBytesTransfered, pio->write_details.remaining);
+		debug_assert_internal();
+	}
+	pio->write_details.remaining -= dwNumberOfBytesTransfered;
+	pio->write_details.pending = FALSE;
+	*((__int64*)&lpOverlapped->Offset) += dwNumberOfBytesTransfered;
+}
+
+int
+fileio_write_wrapper(struct w32_io* pio, const void* buf, size_t bytes_to_copy)
+{
+	int bytes_written = 0;
+	if (bytes_to_copy <= WRITE_BUFFER_SIZE) {
+		bytes_written = fileio_write(pio, buf, bytes_to_copy);
+		return bytes_written;
+	}
+
+	void* chunk_buf = NULL;
+	int chunk_count = 0;
+	int bytes_copied = -1;
+	size_t chunk_size = 0;
+
+	for (int i = 0; i < bytes_to_copy; i += WRITE_BUFFER_SIZE, chunk_count++) {
+		chunk_buf = (BYTE*)buf + chunk_count * WRITE_BUFFER_SIZE;
+		chunk_size = ((bytes_to_copy - i) >= WRITE_BUFFER_SIZE) ? WRITE_BUFFER_SIZE : (bytes_to_copy - i);
+		bytes_written = fileio_write(pio, chunk_buf, chunk_size);
+
+		if (bytes_written == -1)
+			return bytes_copied;
+
+		if (bytes_copied == -1)
+			bytes_copied = 0;
+
+		bytes_copied += bytes_written;
+	}
+	return bytes_copied;
+
+}
+
+/* write() implementation */
+int
+fileio_write(struct w32_io* pio, const void *buf, size_t max_bytes)
+{
+	int bytes_copied;
+	DWORD pipe_flags = 0, pipe_instances = 0;
+	errno_t r = 0;
+
+	debug4("write - io:%p", pio);
+	if (pio->write_details.pending) {
+		if (w32_io_is_blocking(pio)) {
+			debug4("write - io pending, blocking call made, io:%p", pio);
+			while (pio->write_details.pending)
+				if (wait_for_any_event(NULL, 0, INFINITE) == -1)
+					return -1;
+		} else {
+			errno = EAGAIN;
+			debug4("write - IO is already pending, io:%p", pio);
+			return -1;
+		}
+	}
+
+	if (pio->write_details.error) {
+		errno = errno_from_Win32Error(pio->write_details.error);
+		debug3("write - ERROR:%d on prior unblocking write, io:%p", errno, pio);
+		pio->write_details.error = 0;
+		if ((FILETYPE(pio) == FILE_TYPE_PIPE) && (errno == ERROR_BROKEN_PIPE)) {
+			debug4("write - ERROR:read end of the pipe closed, io:%p", pio);
+			errno = EPIPE;
+		}
+		return -1;
+	}
+
+	if (pio->write_details.buf == NULL) {
+		pio->write_details.buf = malloc(WRITE_BUFFER_SIZE);
+		if (pio->write_details.buf == NULL) {
+			errno = ENOMEM;
+			debug3("write - ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+		pio->write_details.buf_size = WRITE_BUFFER_SIZE;
+	}
+
+	bytes_copied = min((int)max_bytes, pio->write_details.buf_size);
+	if((r = memcpy_s(pio->write_details.buf, max_bytes, buf, bytes_copied)) != 0) {
+		debug3("memcpy_s failed with error: %d.", r);
+		return -1;
+	}
+
+	if (pio->type == NONSOCK_SYNC_FD || FILETYPE(pio) == FILE_TYPE_CHAR) {
+		if (syncio_initiate_write(pio, bytes_copied) == 0) {
+			pio->write_details.pending = TRUE;
+			pio->write_details.remaining = bytes_copied;
+		} else
+			return -1;
+	} else {
+		if (WriteFileEx(WINHANDLE(pio), pio->write_details.buf, bytes_copied,
+			&pio->write_overlapped, &WriteCompletionRoutine)) {
+			pio->write_details.pending = TRUE;
+			pio->write_details.remaining = bytes_copied;
+		} else {
+			errno = errno_from_Win32LastError();
+			/* read end of the pipe closed ?   */
+			if ((FILETYPE(pio) == FILE_TYPE_PIPE) && (errno == ERROR_BROKEN_PIPE)) {
+				debug3("write - ERROR:read end of the pipe closed, io:%p", pio);
+				errno = EPIPE;
+			}
+			debug3("write ERROR from cb(2):%d, io:%p", errno, pio);
+			return -1;
+		}
+	}
+
+	if (w32_io_is_blocking(pio)) {
+		while (pio->write_details.pending) {
+			if (wait_for_any_event(NULL, 0, INFINITE) == -1) {
+				/* if interrupted but write has completed, we are good*/
+				if ((errno != EINTR) || (pio->write_details.pending))
+					return -1;
+				errno = 0;
+			}
+		}
+	}
+
+	/* execute APC to give a chance for write to complete */
+	SleepEx(0, TRUE);
+
+	/* if write has completed, pick up any error reported*/
+	if (!pio->write_details.pending && pio->write_details.error) {
+		errno = errno_from_Win32Error(pio->write_details.error);
+		debug3("write - ERROR from cb:%d, io:%p", pio->write_details.error, pio);
+		pio->write_details.error = 0;
+		return -1;
+	}
+	debug4("write - reporting %d bytes written, io:%p", bytes_copied, pio);
+	return bytes_copied;
+}
+
+/* fstat() implemetation */
+int
+fileio_fstat(struct w32_io* pio, struct _stat64 *buf)
+{
+	HANDLE dup_handle = 0;
+	if (!DuplicateHandle(GetCurrentProcess(), pio->handle, GetCurrentProcess(), &dup_handle, 0,
+		TRUE, DUPLICATE_SAME_ACCESS)) {
+		errno = EOTHER;
+		return -1;
+	}
+
+	int fd = _open_osfhandle((intptr_t)dup_handle, 0);
+	debug4("fstat - pio:%p", pio);
+	if (fd == -1) {
+		CloseHandle(dup_handle);
+		errno = EOTHER;
+		return -1;
+	}
+
+	int res = _fstat64(fd, buf);
+	_close(fd);
+	return res;
+}
+
+int
+fileio_stat_or_lstat_internal(const char *path, struct _stat64 *buf, int do_lstat)
+{
+	wchar_t *wpath = NULL;
+	char link_test = L'\0';
+	HANDLE link_handle = INVALID_HANDLE_VALUE;
+	WIN32_FILE_ATTRIBUTE_DATA attributes = { 0 };
+	int ret = -1;
+	int is_link = 0;
+
+	memset(buf, 0, sizeof(struct _stat64));
+
+	/* Detect root dir */
+	if (path && strcmp(path, "/") == 0) {
+		buf->st_mode = _S_IFDIR | _S_IREAD | 0xFF;
+		buf->st_dev = USHRT_MAX;   // rootdir flag
+		return 0;
+	}
+
+	if ((wpath = resolved_path_utf16(path)) == NULL)
+		return -1;
+
+	/* get the file attributes (or symlink attributes if symlink) */
+	if (GetFileAttributesExW(wpath, GetFileExInfoStandard, &attributes) == FALSE) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	/* try to see if it is a symlink */
+	is_link = (attributes.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT &&
+		fileio_readlink(path, &link_test, 1) == 1);
+
+	/* if doing a stat() on a link, then lookup attributes on the target of the link */
+	if (!do_lstat && is_link) {
+
+		/* obtain a file handle to the destination file (not the source link) */
+		BY_HANDLE_FILE_INFORMATION link_attributes;
+		if ((link_handle = CreateFileW(wpath, 0, 0, NULL, OPEN_EXISTING, 
+			FILE_FLAG_BACKUP_SEMANTICS, NULL)) == INVALID_HANDLE_VALUE 
+			|| GetFileInformationByHandle(link_handle, &link_attributes) == 0)
+		{
+			errno = errno_from_Win32LastError();
+			goto cleanup;
+		}
+
+		/* copy attributes from handle structure to normal structure */
+		attributes.ftCreationTime = link_attributes.ftCreationTime;
+		attributes.ftLastAccessTime = link_attributes.ftLastAccessTime;
+		attributes.ftLastWriteTime = link_attributes.ftLastWriteTime;
+		attributes.nFileSizeHigh = link_attributes.nFileSizeHigh;
+		attributes.nFileSizeLow = link_attributes.nFileSizeLow;
+		attributes.dwFileAttributes = link_attributes.dwFileAttributes;
+		is_link = 0;
+	}
+
+	buf->st_ino = 0; /* Has no meaning in the FAT, HPFS, or NTFS file systems*/
+	buf->st_gid = 0; /* UNIX - specific; has no meaning on windows */
+	buf->st_uid = 0; /* UNIX - specific; has no meaning on windows */
+	buf->st_nlink = 1; /* number of hard links. Always 1 on non - NTFS file systems.*/
+	buf->st_mode |= file_attr_to_st_mode(wpath, attributes.dwFileAttributes);
+	buf->st_size = attributes.nFileSizeLow | (((off_t)attributes.nFileSizeHigh) << 32);
+	if (wcslen(wpath) > 1 && __ascii_iswalpha(*wpath) && (*(wpath + 1) == ':'))
+		buf->st_dev = buf->st_rdev = towupper(*wpath) - L'A'; /* drive num */
+	else
+		buf->st_dev = buf->st_rdev = _getdrive() - 1;
+	file_time_to_unix_time(&(attributes.ftLastAccessTime), &(buf->st_atime));
+	file_time_to_unix_time(&(attributes.ftLastWriteTime), &(buf->st_mtime));
+	file_time_to_unix_time(&(attributes.ftCreationTime), &(buf->st_ctime));
+
+	/* link type supercedes other file type bits */
+	if (is_link) {
+		buf->st_mode &= ~S_IFMT;
+		buf->st_mode |= S_IFLNK;
+	}
+
+	ret = 0;
+
+cleanup:
+	if (link_handle != INVALID_HANDLE_VALUE)
+		CloseHandle(link_handle);
+	if (wpath)
+		free(wpath);
+	return ret;
+}
+
+int
+fileio_stat(const char *path, struct _stat64 *buf)
+{
+	return fileio_stat_or_lstat_internal(path, buf, 0);
+}
+
+int
+fileio_lstat(const char *path, struct _stat64 *buf)
+{
+	return fileio_stat_or_lstat_internal(path, buf, 1);
+}
+
+long
+fileio_lseek(struct w32_io* pio, unsigned __int64 offset, int origin)
+{
+	debug4("lseek - pio:%p", pio);
+	if (origin != SEEK_SET) {
+		debug3("lseek - ERROR, origin is not supported %d", origin);
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	pio->write_overlapped.Offset = pio->read_overlapped.Offset = offset & 0xffffffff;
+	pio->write_overlapped.OffsetHigh = pio->read_overlapped.OffsetHigh = (offset & 0xffffffff00000000) >> 32;
+	 
+	return 0;
+}
+
+/* fdopen() to be used  on pipe handles */
+static FILE*
+fileio_fdopen_pipe(struct w32_io* pio, const char *mode)
+{
+	int fd_flags = 0;
+	FILE* ret;
+	debug4("fdopen - io:%p", pio);
+
+	if (mode[1] == '\0') {
+		switch (*mode) {
+		case 'r':
+			fd_flags = _O_RDONLY;
+			break;
+		case 'w':
+			break;
+		case 'a':
+			fd_flags = _O_APPEND;
+			break;
+		default:
+			errno = ENOTSUP;
+			debug3("fdopen - ERROR unsupported mode %s", mode);
+			return NULL;
+		}
+	}
+	else {
+		errno = ENOTSUP;
+		debug3("fdopen - ERROR unsupported mode %s", mode);
+		return NULL;
+	}
+
+	int fd = _open_osfhandle((intptr_t)pio->handle, fd_flags);
+
+	if (fd == -1 || (ret = _fdopen(fd, mode)) == NULL) {
+		errno = EOTHER;
+		debug3("fdopen - ERROR:%d _open_osfhandle()", errno);
+		return NULL;
+	}
+
+	// overwrite underlying win32 handle - its expected to be closed via fclose
+	// and close pio
+	pio->handle = NULL;
+	int w32_close(int);
+	w32_close(pio->table_index);
+	return ret;
+}
+
+/* fdopen() to be used  on file handles */
+static FILE*
+fileio_fdopen_disk(struct w32_io* pio, const char *mode)
+{
+	wchar_t *file_path, *wmode = NULL;
+	FILE* ret = NULL;
+	
+	debug4("fdopen - io:%p", pio);
+
+	if ((wmode = utf8_to_utf16(mode)) == NULL)
+		goto cleanup;
+
+	file_path = get_final_path_by_handle(pio->handle);
+	if (!file_path) 
+		goto cleanup;
+	
+	/* 
+	 * close the win32 handle right away and remove entry from table
+	 * otherwise, wfopen will get an access denied due to sharing violation
+	 */
+	int w32_close(int);
+	w32_close(pio->table_index);
+	errno = _wfopen_s(&ret, file_path, wmode);
+
+cleanup:
+	if (wmode)
+		free(wmode);
+
+	return ret;
+}
+
+/*
+ * fdopen implementation - use with caution
+ * this implementation deviates from POSIX spec the following way
+ * - the underlying file descriptor is closed automatically
+ * hence no further POSIX io operations (read, write, close, etc) on the
+ * underlying file descriptor are supported
+ */
+FILE*
+fileio_fdopen(struct w32_io* pio, const char *mode)
+{
+	DWORD type = 0;
+
+	debug4("fdopen - io:%p", pio);
+
+	type = GetFileType(pio->handle);
+	if (type == FILE_TYPE_DISK) {
+		return fileio_fdopen_disk(pio, mode);
+	} else if (type == FILE_TYPE_PIPE) {
+		return fileio_fdopen_pipe(pio, mode);
+	} else {
+		errno = ENOTSUP;
+		return NULL;
+	}
+}
+
+void
+fileio_on_select(struct w32_io* pio, BOOL rd)
+{
+	if (!rd)
+		return;
+
+	if (!pio->read_details.pending && !fileio_is_io_available(pio, rd))
+		/* initiate read, record any error so read() will pick up */
+		if (pio->type == NONSOCK_SYNC_FD || FILETYPE(pio) == FILE_TYPE_CHAR) {
+			if (syncio_initiate_read(pio) != 0) {
+				pio->read_details.error = errno;
+				errno = 0;
+				return;
+			}
+		} else {
+			if (fileio_ReadFileEx(pio, INT_MAX) != 0) {
+				pio->read_details.error = errno;
+				errno = 0;
+				return;
+			}
+		}
+}
+
+int
+fileio_close(struct w32_io* pio)
+{
+	debug4("fileclose - pio:%p", pio);
+
+	if (pio->type == NONSOCK_SYNC_FD || FILETYPE(pio) == FILE_TYPE_CHAR)
+		return syncio_close(pio);
+
+	/* handle can be null on AF_UNIX sockets that are not yet connected */
+	if (WINHANDLE(pio) == 0 || WINHANDLE(pio) == INVALID_HANDLE_VALUE) {
+		free(pio);
+		return 0;
+	}
+
+	/*
+	* we report to POSIX app that an async write has completed as soon its
+	* copied to internal buffer. The app may subsequently try to close the
+	* fd thinking everything is written. IF the Windows handle is closed
+	* now, the pipe/file io write operation may terminate prematurely.
+	* To compensate for the discrepency
+	* wait here until async write has completed.
+	* If you see any process waiting here indefinitely - its because no one
+	* is draining from other end of the pipe/file. This is an unfortunate
+	* consequence that should otherwise have very little impact on practical
+	* scenarios.
+	*/
+	while (pio->write_details.pending)
+		if (0 != wait_for_any_event(NULL, 0, INFINITE))
+			return -1;
+
+	CancelIo(WINHANDLE(pio));
+	/* let queued APCs (if any) drain */
+	SleepEx(0, TRUE);
+	CloseHandle(WINHANDLE(pio));
+	if (pio->read_details.buf)
+		free(pio->read_details.buf);
+	if (pio->write_details.buf)
+		free(pio->write_details.buf);
+	free(pio);
+
+	return 0;
+}
+
+BOOL
+fileio_is_io_available(struct w32_io* pio, BOOL rd)
+{
+	if (rd) {
+		if (pio->read_details.remaining || pio->read_details.error)
+			return TRUE;
+		else
+			return FALSE;
+	} else { /* write */
+		return (pio->write_details.pending == FALSE) ? TRUE : FALSE;
+	}
+}
+
+ssize_t
+fileio_readlink(const char *path, char *buf, size_t bufsiz)
+{
+	/* note: there are two approaches for resolving a symlink in Windows:
+	 *
+	 * 1) Use CreateFile() to obtain a file handle to the reparse point and
+	 *    send using the DeviceIoControl() call to retrieve the link data from the
+	 *    reparse point.
+	 * 2) Use CreateFile() to obtain a file handle to the target file followed
+	 *    by a call to GetFinalPathNameByHandle() to get the real path on the
+	 *    file system.
+	 *
+	 * This approach uses the first method because the second method does not
+	 * work on broken link since the target file cannot be opened.  It also
+	 * requires additional I/O to read both the symlink and its target.
+	 */
+
+	/* abbreviated REPARSE_DATA_BUFFER data structure for decoding symlinks;
+	 * the full definition can be found in ntifs.h within the Windows DDK.
+	 * we include it here so the DDK does not become prereq to the build.
+	 * for more info: https://msdn.microsoft.com/en-us/library/cc232006.aspx
+	 */
+
+	typedef struct _REPARSE_DATA_BUFFER_SYMLINK {
+		ULONG ReparseTag;
+		USHORT ReparseDataLength;
+		USHORT Reserved;
+		USHORT SubstituteNameOffset;
+		USHORT SubstituteNameLength;
+		USHORT PrintNameOffset;
+		USHORT PrintNameLength;
+		ULONG Flags;
+		WCHAR PathBuffer[1];
+	} REPARSE_DATA_BUFFER_SYMLINK, *PREPARSE_DATA_BUFFER_SYMLINK;
+
+	/* early declarations for cleanup */
+	ssize_t ret = -1;
+	wchar_t *wpath = NULL;
+	wchar_t *linkpath = NULL;
+	char *output = NULL;
+	HANDLE handle = INVALID_HANDLE_VALUE;
+	PREPARSE_DATA_BUFFER_SYMLINK reparse_buffer = NULL;
+
+	/* sanity check */
+	if (path == NULL || buf == NULL || bufsiz == 0) {
+		errno = EINVAL;
+		goto cleanup;
+	}
+
+	if ((wpath = resolved_path_utf16(path)) == NULL)
+		goto cleanup;
+
+	/* obtain a handle to send to deviceioctl */
+	handle = CreateFileW(wpath, 0, 0, NULL, OPEN_EXISTING, 
+		FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+	if (handle == INVALID_HANDLE_VALUE) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	/* allocate the maximum possible size the reparse buffer size could be */
+	reparse_buffer = (PREPARSE_DATA_BUFFER_SYMLINK)malloc(MAXIMUM_REPARSE_DATA_BUFFER_SIZE); // CodeQL [SM02320]: DeviceIoControl will set reparse_buffer
+	if (reparse_buffer == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	/* send a request to the file system to get the real path */
+	DWORD dwBytesReturned = 0;
+	if (DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0,
+		(LPVOID) reparse_buffer, MAXIMUM_REPARSE_DATA_BUFFER_SIZE, &dwBytesReturned, 0) == 0) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	/* ensure file is actually symlink */
+	if (reparse_buffer->ReparseTag != IO_REPARSE_TAG_SYMLINK) {
+		errno = EINVAL;
+		goto cleanup;
+	}
+
+	/* the symlink structure has a 'Print Name' value that is displayed to the
+	 * user which is different from the actual value it uses for redirection
+	 * called the 'Substitute Name'; since the Substitute Name has an odd format
+	 * that begins with \??\ and it appears that CreateSymbolicLink() always
+	 * formats the PrintName value consistently we will just use that
+	 */
+	int symlink_nonnull_size = reparse_buffer->PrintNameLength;
+	wchar_t * symlink_nonnull = &reparse_buffer->PathBuffer[reparse_buffer->PrintNameOffset / sizeof(WCHAR)];
+
+	/* allocate area to hold a null terminated version of the string */
+	if ((linkpath = malloc(symlink_nonnull_size + sizeof(wchar_t))) == NULL) {
+		goto cleanup;
+	}
+
+	/* copy the data out of the reparse buffer and add null terminator */
+	memcpy_s(linkpath, symlink_nonnull_size + sizeof(wchar_t), symlink_nonnull, symlink_nonnull_size);
+	linkpath[symlink_nonnull_size / sizeof(wchar_t)] = L'\0';
+
+	/* convert link path to utf8 */
+	if ((output = utf16_to_utf8(linkpath)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	/* determine if we need to prepend a forward slash to make this look like
+	 * an absolute path C:\Path\Target --> /C:/Path/Target
+	 */
+	int abs_chars = is_absolute_path(output) ? 1 : 0;
+	if (abs_chars)
+		buf[0] = '/';
+
+	/* copy link data to output buffer; per specification, truncation is okay */
+	convertToForwardslash(output);
+	size_t out_size = strlen(output);
+	memcpy(buf + abs_chars, output, min(out_size, bufsiz - abs_chars));
+	ret = (ssize_t) min(out_size + abs_chars, bufsiz);
+
+cleanup:
+
+	if (linkpath)
+		free(linkpath);
+	if (reparse_buffer)
+		free(reparse_buffer);
+	if (handle != INVALID_HANDLE_VALUE)
+		CloseHandle(handle);
+	if (wpath)
+		free(wpath);
+	if (output)
+		free(output);
+
+	return (ssize_t)ret;
+}
+
+int
+fileio_symlink(const char *target, const char *linkpath)
+{
+	DWORD ret = -1;
+	char target_modified[PATH_MAX] = { 0 };
+	char *linkpath_resolved = NULL, *target_resolved = NULL;
+
+	if (target == NULL || linkpath == NULL) {
+		errno = EFAULT;
+		return -1;
+	}
+
+	/* First resolve linkpath */
+	if (NULL == (linkpath_resolved = resolved_path_utf8(linkpath)))	
+		goto cleanup;
+
+	/* Relative targets are relative to the link and not our current directory
+	 * so attempt to calculate a resolvable path by removing the link file name
+	 * leaving only the parent path and then append the relative link:
+	 * C:\Path\Link with Link->SubDir\Target to C:\Path\SubDir\Target
+	 */
+	if (!is_absolute_path(target)) {
+		strcpy_s(target_modified, _countof(target_modified), linkpath_resolved);
+		convertToBackslash(target_modified);
+		char *tmp = NULL;
+
+		/* copy the relative target to the end of the link's parent */
+		if (tmp = strrchr(target_modified, '\\'))			
+			strcpy_s(tmp + 1, _countof(target_modified) - (tmp + 1 - target_modified), target);
+		else
+			strcpy_s(target_modified, _countof(target_modified), target);
+	} else {
+		/* resolve target */
+		if (NULL == (target_resolved = resolved_path_utf8(target)))
+			goto cleanup;
+
+		strcpy_s(target_modified, _countof(target_modified), target_resolved);
+	}
+
+	wchar_t *linkpath_utf16 = resolved_path_utf16(linkpath);
+	wchar_t *resolved_target_utf16 = utf8_to_utf16(target_modified);
+	if (resolved_target_utf16 == NULL || linkpath_utf16 == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	/* unlike other platforms, we need to know whether the symbolic link target is
+	 * a file or a directory.  the only way we can confidently do this is to
+	 * get the attributes of the target.  therefore, our symlink() has the
+	 * limitation of only creating symlink with valid targets
+	 */
+	WIN32_FILE_ATTRIBUTE_DATA attributes = { 0 };
+	if (GetFileAttributesExW(resolved_target_utf16, GetFileExInfoStandard, &attributes) == FALSE) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	/* use the attribute of the file to determine the proper flag to send */
+	DWORD create_flags = (attributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ?
+		SYMBOLIC_LINK_FLAG_DIRECTORY : 0;
+
+	/* symlink creation on earlier versions of windows were a privileged op
+ 	 * and then an option was added to create symlink using from an unprivileged
+ 	 * context so we try both operations, attempting privileged version first.
+	 * note: 0x2 = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE
+	 */
+	if (CreateSymbolicLinkW(linkpath_utf16, resolved_target_utf16, create_flags) == 0) {
+		if (CreateSymbolicLinkW(linkpath_utf16, resolved_target_utf16, create_flags | 0x2) == 0) {
+			errno = errno_from_Win32LastError();
+			goto cleanup;
+		}
+	}
+	
+	ret = 0;
+cleanup:
+
+	if (linkpath_utf16)
+		free(linkpath_utf16);
+
+	if (resolved_target_utf16)
+		free(resolved_target_utf16);
+
+	if (linkpath_resolved)
+		free(linkpath_resolved);
+
+	if (target_resolved)
+		free(target_resolved);
+
+	return ret;
+}
+
+int 
+fileio_link(const char *oldpath, const char *newpath)
+{
+	DWORD ret = -1;
+
+	if (oldpath == NULL || newpath == NULL) {
+		errno = EFAULT;
+		return -1;
+	}
+
+	wchar_t *oldpath_utf16 = resolved_path_utf16(oldpath);
+	wchar_t *newpath_utf16 = resolved_path_utf16(newpath);
+
+	if (oldpath_utf16 == NULL || newpath_utf16 == NULL)
+		goto cleanup;
+
+	if (CreateHardLinkW(newpath_utf16, oldpath_utf16, NULL) == 0) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	ret = 0;
+cleanup:
+
+	if (oldpath_utf16)
+		free(oldpath_utf16);
+	if (newpath_utf16)
+		free(newpath_utf16);
+
+	return ret;
+}
diff --git a/contrib/win32/win32compat/gss-sspi.c b/contrib/win32/win32compat/gss-sspi.c
new file mode 100644
index 000000000..547759567
--- /dev/null
+++ b/contrib/win32/win32compat/gss-sspi.c
@@ -0,0 +1,1104 @@
+/*
+ * Author: Bryan Berns <berns@uwalumni.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <windows.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+
+#include "inc\utf.h"
+#include "inc\pwd.h"
+#include "debug.h"
+#include "inc\gssapi.h"
+
+ /*
+  * This file provides the GSSAPI interface to support Kerberos SSPI within
+  * OpenSSH.  This is only a partial definition of the full GSSAPI specification
+  * since OpenSSH only requires a subset of the overall functionality.
+  *
+  * The function definitions as well as the accompanying comments are derived
+  * from information provided in RFC2744.  In addition, RFC2743 provides
+  * additional information on the GSSAPI specification and intended operation.
+  */
+
+/* 
+ * Include the definitions necessary to implement some of the interface
+ * structure that are required for gss-serv.c to perform Kerberos operations.
+ */
+#include "..\..\..\config.h"
+#undef HAVE_GSSAPI_H
+#include "..\..\..\ssh-gss.h"
+
+/*
+ * This will be initialized to a function table that contains pointers to 
+ * all standard security functions.  The reason for using this instead of
+ * relying on the standard imports is because the OneCore libraries do
+ * not expose all the functions we need.
+ */
+PSecurityFunctionTableW SecFunctions = NULL;
+
+/*
+ * GSS_C_NT_HOSTBASED_SERVICE is a oid value that is used to negotiate a 
+ * a Kerberos transaction using an SPN in the format host@user@realm format. 
+ */
+#define GSS_C_NT_HOSTBASED_SERVICE_STR "\x2A\x86\x48\x86\xF7\x12\x01\x02\x02"
+gss_OID GSS_C_NT_HOSTBASED_SERVICE = &(gss_OID_desc)
+{ 
+	sizeof(GSS_C_NT_HOSTBASED_SERVICE_STR) - 1,
+	(void *) GSS_C_NT_HOSTBASED_SERVICE_STR 
+};
+
+/* 
+ * This handle is used to relay the handle for the user to functions that 
+ * ultimately call CreateProcessAsUser to spawn the user shell.
+ */
+HANDLE sspi_auth_user = 0;
+
+struct cred_st {
+	int isToken;
+	union { 
+		HANDLE token;
+		CredHandle credHandle;
+	};
+};
+
+/*
+ * This is called before each gssapi implementation function to ensure the
+ * environment is initialized properly.  Any additional implementation setup
+ * should be added to this function.
+ */
+static int 
+ssh_gss_sspi_init(_Out_ OM_uint32 * minor_status)
+{	
+	/* minor status never used - reset to zero*/
+	*minor_status = 0;
+
+	/* already initialized; return */
+	if (SecFunctions != NULL) 
+		return 1;
+
+	/* get a pointer to a function table containing all the function pointers */
+	if ((SecFunctions = InitSecurityInterfaceW()) == NULL) {
+		/* failure */
+		debug("failed to acquire function table for sspi support.");
+		return 0;
+	}
+
+	/* success */
+	return 1;
+}
+
+/*
+ * Allows an application to determine which underlying security mechanisms are
+ * available.
+ */
+OM_uint32 
+gss_indicate_mechs(_Out_ OM_uint32 * minor_status, _Outptr_ gss_OID_set *mech_set)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* create an list that contains the one oid that we support */
+	if (gss_create_empty_oid_set(minor_status, mech_set) != GSS_S_COMPLETE)
+		return GSS_S_FAILURE;
+	
+	if (gss_add_oid_set_member(minor_status, GSS_C_NT_HOSTBASED_SERVICE, mech_set) != GSS_S_COMPLETE) {
+		gss_release_oid_set(minor_status, mech_set);
+		return GSS_S_FAILURE;
+	}
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Create an object-identifier set containing no object identifiers, to which
+ * members may be subsequently added using the gss_add_oid_set_member() routine.
+ * These routines are intended to be used to construct sets of mechanism object
+ * identifiers, for input to gss_acquire_cred.
+ */
+OM_uint32 
+gss_create_empty_oid_set(_Out_ OM_uint32 * minor_status, _Outptr_ gss_OID_set * oid_set)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* allocate / initialize space for this new oid set */
+	if (((*oid_set) = calloc(1, sizeof(gss_OID_set_desc))) == NULL)
+		return GSS_S_FAILURE;
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Free storage associated with a GSSAPI-generated gss_OID_set object. The set
+ * parameter must refer to an OID-set that was returned from a GSS-API routine.
+ * gss_release_oid_set() will free the storage associated with each individual
+ * member OID, the OID set's elements array, and the gss_OID_set_desc.
+ */
+OM_uint32 
+gss_release_oid_set(_Out_ OM_uint32 * minor_status, _In_ gss_OID_set * set)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* free all individual oid strings */
+	for (size_t oid_num = 0; oid_num < (*set)->count; oid_num++)
+		free((*set)->elements[oid_num].elements);
+
+	/* free overall oid set */
+	free((*set)->elements);
+	free(*set);
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Add an Object Identifier to an Object Identifier set.  This routine is
+ * intended for use in conjunction with gss_create_empty_oid_set when
+ * constructing a set of mechanism OIDs for input to gss_acquire_cred. The
+ * oid_set parameter must refer to an OID-set that was created by GSS-API (e.g.
+ * a set returned by gss_create_empty_oid_set()). GSS-API creates a copy of the
+ * member_oid and inserts this copy into the set, expanding the storage
+ * allocated to the OID-set's elements array if necessary.  The routine may add
+ * the new member OID anywhere within the elements array, and implementations
+ * should verify that the new member_oid is not already contained within the
+ * elements array; if the member_oid is already present, the oid_set should
+ * remain unchanged.
+ */
+OM_uint32 
+gss_add_oid_set_member(_Out_ OM_uint32 * minor_status, _In_ gss_OID member_oid, _In_ gss_OID_set * oid_set)
+{
+	OM_uint32 ret = GSS_S_FAILURE;
+	void * member_oid_elements = NULL;
+
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* create our own copy of the oid entry itself to add to the set */
+	if ((member_oid_elements = malloc(member_oid->length)) == NULL)
+		goto cleanup;
+	memcpy(member_oid_elements, member_oid->elements, member_oid->length);
+
+	/* reallocate the new elements structure based on the increased size */
+	const size_t current_count = (*oid_set)->count;
+	(*oid_set)->elements = realloc((*oid_set)->elements, (current_count + 1) * sizeof(gss_OID_desc));
+	if ((*oid_set)->elements == NULL)
+		goto cleanup;
+	
+	/* append the new oid to the end of the recently increased list */
+	(*oid_set)->elements[current_count].elements = member_oid_elements;
+	(*oid_set)->elements[current_count].length = member_oid->length;
+	(*oid_set)->count++;
+
+	member_oid_elements = NULL;
+	ret = GSS_S_COMPLETE;
+cleanup:
+	if (member_oid_elements)
+		free(member_oid_elements);
+
+	return ret;
+}
+
+/*
+ * Interrogate an Object Identifier set to determine whether a specified Object
+ * Identifier is a member.  This routine is intended to be used with OID sets
+ * returned by gss_indicate_mechs(), gss_acquire_cred(), and gss_inquire_cred(),
+ * but will also work with user-generated sets.
+ */
+OM_uint32 
+gss_test_oid_set_member(_Out_ OM_uint32 * minor_status, _In_ gss_OID member,
+	_In_ gss_OID_set set, _Out_ int * present)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* loop through each oid in the passed set */
+	for (size_t oid_num = 0; oid_num < set->count; oid_num++) {
+		/* do not bother doing memory comparison if sizes do not match */
+		if (set->elements[oid_num].length != member->length) 
+			continue;
+
+		/* compare the binary storage of the test oid to the one in our list */
+		if (memcmp(set->elements[oid_num].elements, member->elements, member->length) == 0) {
+			/* match found */
+			*present = TRUE;
+			return GSS_S_COMPLETE;
+		}
+	}
+
+	/* no match found in the list */
+	*present = FALSE;
+	return GSS_S_COMPLETE;
+}
+
+/* 
+ * Convert a contiguous string name to internal form.  In general, the internal
+ * name returned (via the <output_name> parameter) will not be an MN; the
+ * exception to this is if the <input_name_type> indicates that the contiguous
+ * string provided via the <input_name_buffer> parameter is of type
+ * GSS_C_NT_EXPORT_NAME, in which case the returned internal name will be an MN
+ * for the mechanism that exported the name.
+ */
+OM_uint32 
+gss_import_name(_Out_ OM_uint32 * minor_status, _In_ gss_buffer_t input_name_buffer,
+	_In_ gss_OID input_name_type, _Outptr_ gss_name_t * output_name)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* make sure we support the passed type */
+	if (input_name_type->length != GSS_C_NT_HOSTBASED_SERVICE->length ||
+	    memcmp(input_name_type->elements, GSS_C_NT_HOSTBASED_SERVICE->elements, input_name_type->length) != 0)
+		return GSS_S_BAD_NAMETYPE;
+	
+	/* there is nothing special we have to do for this type so just duplicate
+	the  */
+	(*output_name) = _strdup(input_name_buffer->value);
+
+	if (output_name == NULL)
+		return GSS_S_FAILURE;
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Free GSSAPI-allocated storage associated with an internal-form name.
+ * Implementations are encouraged to set the name to GSS_C_NO_NAME on successful
+ * completion of this call.
+ */
+OM_uint32 
+gss_release_name(_Out_ OM_uint32 * minor_status, _Inout_ gss_name_t * input_name)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* validate input */
+	if (input_name == NULL || *input_name == NULL)
+		return GSS_S_BAD_NAME;
+	
+	/* deallocate memory associated with the name */
+	free(*input_name);
+	*input_name = GSS_C_NO_NAME;
+	
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * To produce a canonical contiguous string representation of a mechanism name
+ * (MN), suitable for direct comparison (e.g. with memcmp) for use in
+ * authorization functions (e.g. matching entries in an access-control list).
+ * The <input_name> parameter must specify a or by gss_canonicalize_name).
+ */
+OM_uint32 
+gss_export_name(_Out_ OM_uint32 * minor_status, _In_ const gss_name_t input_name,
+	_Inout_ gss_buffer_t exported_name)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* convenience pointer to shorten the void */
+	const gss_OID_desc* const ntoid = GSS_C_NT_HOSTBASED_SERVICE;
+
+	/* make sure we support the passed type */
+	if (strstr(input_name, "host@") == input_name)
+		return GSS_S_BAD_NAMETYPE;
+
+	/* get the lengths of all the parts of the string */
+	/* note: assumes short format for encoding oid length (i.e. less than 128)
+	*/
+	const uint16_t token_id = 0x0401;
+	const uint8_t oid_tag = 0x06;
+	const uint8_t oid_len = (uint8_t) ntoid->length;
+	const uint16_t oid_outer_len = sizeof(oid_tag) + sizeof(oid_len) + oid_len;
+	const uint32_t name_len = (uint16_t) strlen(input_name);
+
+	/* allocate space for the exported name */
+	exported_name->length = sizeof(token_id) + sizeof(oid_outer_len) + oid_outer_len + sizeof(name_len) + name_len;
+	exported_name->value = malloc(exported_name->length);
+	if (exported_name->value == NULL)
+		return GSS_S_FAILURE;
+
+	/* get big-endian values so we can just do a direct memcpy from the values
+	*/
+	const uint16_t token_id_be = htons(token_id);
+	const uint16_t oid_outer_len_be = htons(oid_outer_len);
+	const uint32_t name_len_be = htonl(name_len);
+
+	/* construct the encoded value */
+	uint8_t * output = exported_name->value;
+	memcpy(output, &token_id_be, sizeof(token_id_be)); output += sizeof(token_id_be);
+	memcpy(output, &oid_outer_len_be, sizeof(oid_outer_len_be)); output += sizeof(oid_outer_len_be);
+	memcpy(output, &oid_tag, sizeof(oid_tag)); output += sizeof(oid_tag);
+	memcpy(output, &oid_len, sizeof(oid_len)); output += sizeof(oid_len);
+	memcpy(output, ntoid->elements, ntoid->length); output += ntoid->length;
+	memcpy(output, &name_len_be, sizeof(name_len_be)); output += sizeof(name_len_be);
+	memcpy(output, input_name, name_len);
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Free storage associated with a buffer.  The storage must have been allocated
+ * by a GSS-API routine.  In addition to freeing the associated storage, the
+ * routine will zero the length field in the descriptor to which the buffer
+ * parameter refers, and implementations are encouraged to additionally set the
+ * pointer field in the descriptor to NULL.  Any buffer object returned by a
+ * GSS-API routine may be passed to gss_release_buffer (even if there is no
+ * storage associated with the buffer).
+ */
+OM_uint32 
+gss_release_buffer(_Out_ OM_uint32 * minor_status, _Inout_ gss_buffer_t buffer)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* deallocate the buffer associated with the buffer */
+	free(buffer->value);	
+	buffer->length = 0;
+	buffer->value = NULL;
+
+	return GSS_S_COMPLETE;
+}
+
+/* 
+ * Allows an application to acquire a handle for a pre-existing credential by
+ * name.  GSS-API implementations must impose a local access-control policy on
+ * callers of this routine to prevent unauthorized callers from acquiring
+ * credentials to which they are not entitled.  This routine is not intended to
+ * provide a "login to the network" function, as such a function would involve
+ * the creation of new credentials rather than merely acquiring a handle to
+ * existing credentials.  Such functions, if required, should be defined in
+ * implementation-specific extensions to the API.
+ */
+OM_uint32 
+gss_acquire_cred(_Out_ OM_uint32 *minor_status, _In_opt_ gss_name_t desired_name,
+	_In_opt_ OM_uint32 time_req, _In_opt_ gss_OID_set desired_mechs, _In_ gss_cred_usage_t cred_usage,
+	_Outptr_opt_ gss_cred_id_t * output_cred_handle, _Outptr_opt_ gss_OID_set *actual_mechs, _Out_opt_ OM_uint32 *time_rec)
+{
+	OM_uint32 ret = GSS_S_FAILURE;
+	SYSTEMTIME current_time_system;
+	wchar_t * desired_name_utf16 = NULL;
+	CredHandle cred_handle, *p_cred_handle = NULL;
+	
+
+	if (output_cred_handle != NULL)
+		*output_cred_handle = NULL;
+
+	if (ssh_gss_sspi_init(minor_status) == 0)
+		goto done;
+
+	/* get the current time so we can determine expiration if requested */
+	GetSystemTime(&current_time_system);
+
+	/* translate credential usage parameters */
+	ULONG cred_usage_local = 0;
+	if (cred_usage == GSS_C_ACCEPT) cred_usage_local = SECPKG_CRED_INBOUND;
+	else if (cred_usage == GSS_C_INITIATE) cred_usage_local = SECPKG_CRED_OUTBOUND;
+	else if (cred_usage == GSS_C_BOTH) cred_usage_local = SECPKG_CRED_BOTH;
+
+	/* convert input name to unicode so we can process usernames with special characters */
+	if ((desired_name_utf16 = utf8_to_utf16(desired_name)) == NULL)
+		goto done;
+
+	/* acquire a handle to existing credentials -- in many cases the name will
+	 * be null in which case the credentials of the current user are used */
+	TimeStamp expiry;
+	SECURITY_STATUS status = SecFunctions->AcquireCredentialsHandleW(desired_name_utf16, MICROSOFT_KERBEROS_NAME_W, cred_usage_local,
+		NULL, NULL, NULL, NULL, &cred_handle, &expiry);
+
+	/* fail immediately if errors occurred */
+	if (status != SEC_E_OK)
+		goto done;
+	
+	p_cred_handle = &cred_handle;
+	/* copy credential data out of local buffer */
+	if (output_cred_handle != NULL) {
+		if ((*output_cred_handle = malloc(sizeof(struct cred_st))) == NULL)
+			goto done;
+		(*output_cred_handle)->isToken = 0;
+		(*output_cred_handle)->credHandle = cred_handle;
+	}
+	
+	/* determine expiration if requested */
+	if (time_rec != NULL) {
+		FILETIME current_time;
+		if (SystemTimeToFileTime(&current_time_system, &current_time) != 0)
+			*time_rec = (OM_uint32)(expiry.QuadPart - ((PLARGE_INTEGER)&current_time)->QuadPart) / 10000;
+		else
+			error("SystemTimeToFileTime failed with %d", GetLastError());
+	}
+
+	/* set actual supported mechs if requested */
+	if (actual_mechs != NULL && gss_indicate_mechs(minor_status, actual_mechs) != GSS_S_COMPLETE)
+		goto done;
+
+	ret = GSS_S_COMPLETE;
+done:
+	if (desired_name_utf16)
+		free(desired_name_utf16);
+	if (ret != GSS_S_COMPLETE) {
+		if (p_cred_handle)
+			SecFunctions->FreeCredentialsHandle(p_cred_handle);
+		if (output_cred_handle && *output_cred_handle) {
+			free(*output_cred_handle);
+			*output_cred_handle = NULL;
+		}
+	}
+
+	return ret;
+}
+
+/*
+ * Initiates the establishment of a security context between the application and
+ * a remote peer.  Initially, the input_token parameter should be specified
+ * either as GSS_C_NO_BUFFER, or as a pointer to a gss_buffer_desc object whose
+ * length field contains the value zero. The routine may return a output_token
+ * which should be transferred to the peer application, where the peer
+ * application will present it to gss_accept_sec_context.
+ */
+OM_uint32 
+gss_init_sec_context(
+	_Out_ OM_uint32 * minor_status, _In_ gss_cred_id_t claimant_cred_handle, _In_ gss_ctx_id_t * context_handle,
+	_In_ gss_name_t target_name, _In_ gss_OID mech_type, _In_ OM_uint32 req_flags, _In_ OM_uint32 time_req, _In_ gss_channel_bindings_t input_chan_bindings,
+	_In_ gss_buffer_t input_token, _Inout_ gss_OID * actual_mech_type, _Inout_ gss_buffer_t output_token, _Out_ OM_uint32 * ret_flags,
+	_Out_ OM_uint32 * time_rec)
+{
+	OM_uint32 ret = GSS_S_FAILURE;
+	wchar_t * target_name_utf16 = NULL;
+	gss_ctx_id_t p_ctx_h = NULL;
+
+	output_token->value = NULL;
+
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		goto done;
+
+	/* make sure we support the passed type */
+	if (mech_type->length != GSS_C_NT_HOSTBASED_SERVICE->length ||
+	    memcmp(mech_type->elements, GSS_C_NT_HOSTBASED_SERVICE->elements, mech_type->length) != 0) {
+		ret = GSS_S_BAD_NAMETYPE;
+		goto done;
+	}
+	
+	unsigned long sspi_req_flags = ISC_REQ_ALLOCATE_MEMORY;
+	if (req_flags & GSS_C_MUTUAL_FLAG) 
+		sspi_req_flags |= ISC_REQ_MUTUAL_AUTH;
+	if (req_flags & GSS_C_CONF_FLAG) 
+		sspi_req_flags |= ISC_REQ_CONFIDENTIALITY;
+	if (req_flags & GSS_C_REPLAY_FLAG) 
+		sspi_req_flags |= ISC_REQ_REPLAY_DETECT;
+	if (req_flags & GSS_C_DELEG_FLAG) 
+		sspi_req_flags |= ISC_REQ_DELEGATE;
+	if (req_flags & GSS_C_INTEG_FLAG) 
+		sspi_req_flags |= ISC_REQ_INTEGRITY;
+	if (req_flags & GSS_C_SEQUENCE_FLAG) 
+		sspi_req_flags |= ISC_REQ_SEQUENCE_DETECT;
+
+	/* determine if this is the first call (no input buffer available) */
+	gss_buffer_desc empty_buffer = GSS_C_EMPTY_BUFFER;
+	const int no_input_buffer = (input_token == GSS_C_NO_BUFFER) || memcmp(input_token, &empty_buffer, sizeof(gss_buffer_desc)) == 0;
+
+	/* setup input buffer */
+	SecBuffer input_buffer_token = { (no_input_buffer) ? 0 : (unsigned long) input_token->length, SECBUFFER_TOKEN, (no_input_buffer) ? NULL : input_token->value };
+	SecBufferDesc input_buffer = { SECBUFFER_VERSION, 1, &input_buffer_token };
+
+	/* setup output buffer - will be dynamically allocated by function */
+	SecBuffer output_buffer_token = { 0, SECBUFFER_TOKEN, NULL };
+	SecBufferDesc output_buffer = { SECBUFFER_VERSION, 1, &output_buffer_token };
+
+	/* get the current time so we can determine expiration if requested */
+	SYSTEMTIME current_time_system;
+	GetSystemTime(&current_time_system);
+
+	/* acquire default cred handler if none specified */
+	CredHandle *pCredHandle = NULL;
+	if (claimant_cred_handle != NULL)
+		pCredHandle = &(claimant_cred_handle->credHandle);
+	
+	if (pCredHandle == NULL) {
+		static CredHandle cred_handle = { 0, 0 };
+		pCredHandle = &cred_handle;
+		if (cred_handle.dwLower == 0 && cred_handle.dwUpper == 0) {
+			TimeStamp expiry_cred;
+			if (SecFunctions->AcquireCredentialsHandleW(NULL, MICROSOFT_KERBEROS_NAME_W, SECPKG_CRED_OUTBOUND,
+			    NULL, NULL, NULL, NULL, &cred_handle, &expiry_cred) != SEC_E_OK)
+				goto done;
+		}
+	}
+
+	/* condition the string for windows */
+	if ((target_name_utf16 = utf8_to_utf16(target_name)) == NULL)
+		goto done;
+
+	if (wcsncmp(target_name_utf16, L"host@", wcslen(L"host@")) == 0) 
+		*wcschr(target_name_utf16, L'@') = L'/';
+
+	TimeStamp expiry;
+	LONG sspi_ret_flags = 0;
+	CtxtHandle out_context;
+
+	const SECURITY_STATUS status = SecFunctions->InitializeSecurityContextW(pCredHandle,
+		(*context_handle == GSS_C_NO_CONTEXT) ? NULL : *context_handle,
+		target_name_utf16, sspi_req_flags, 0, SECURITY_NATIVE_DREP, (no_input_buffer) ? NULL : &input_buffer,
+		0, (*context_handle != NULL) ? NULL : &out_context, &output_buffer, &sspi_ret_flags, (time_rec == NULL) ? NULL : &expiry);
+
+	/* check if error occurred */
+	if (status != SEC_E_OK && status != SEC_I_CONTINUE_NEEDED)
+		goto done;
+	
+	/* copy output token to output buffer */
+	output_token->length = output_buffer_token.cbBuffer;
+	if ((output_token->value = malloc(output_token->length)) == NULL)
+		goto done;
+
+	memcpy(output_token->value, output_buffer_token.pvBuffer, output_token->length);
+	SecFunctions->FreeContextBuffer(output_buffer_token.pvBuffer);
+
+	/* if requested, translate returned flags that are actually available */
+	if (ret_flags != NULL) {
+		*ret_flags = 0;
+		if (sspi_ret_flags & ISC_RET_MUTUAL_AUTH) 
+			*ret_flags |= GSS_C_MUTUAL_FLAG;
+		if (sspi_ret_flags & ISC_RET_CONFIDENTIALITY) 
+			*ret_flags |= GSS_C_CONF_FLAG;
+		if (sspi_ret_flags & ISC_RET_REPLAY_DETECT) 
+			*ret_flags |= GSS_C_REPLAY_FLAG;
+		if (sspi_ret_flags & ISC_RET_DELEGATE) 
+			*ret_flags |= GSS_C_DELEG_FLAG;
+		if (sspi_ret_flags & ISC_RET_INTEGRITY) 
+			*ret_flags |= GSS_C_INTEG_FLAG;
+		if (sspi_ret_flags & ISC_RET_SEQUENCE_DETECT) 
+			*ret_flags |= GSS_C_SEQUENCE_FLAG;
+	}
+
+	/* report if delegation was requested by not fulfilled */
+	if ((sspi_req_flags & ISC_REQ_DELEGATE) != 0 && (sspi_ret_flags & ISC_RET_DELEGATE) == 0)
+		debug("sspi delegation was requested but not fulfilled");
+
+	/* if requested, translate the expiration time to number of second */
+	if (time_rec != NULL) {
+		FILETIME current_time;
+		if (SystemTimeToFileTime(&current_time_system, &current_time) != 0)
+			*time_rec = (OM_uint32)(expiry.QuadPart - ((PLARGE_INTEGER)&current_time)->QuadPart) / 10000;
+		else
+			error("SystemTimeToFileTime failed with %d", GetLastError());
+	}
+
+	/* if requested, return the supported mechanism oid */
+	if (actual_mech_type != NULL)
+		*actual_mech_type = GSS_C_NT_HOSTBASED_SERVICE;
+	
+	/* copy the credential context structure to the caller */
+	if (*context_handle == GSS_C_NO_CONTEXT) {
+		if ((p_ctx_h = malloc(sizeof(out_context))) == NULL)
+			goto done;
+		*context_handle = p_ctx_h;
+		memcpy(*context_handle, &out_context, sizeof(out_context));
+	}
+
+	ret = (status == SEC_I_CONTINUE_NEEDED) ? GSS_S_CONTINUE_NEEDED : GSS_S_COMPLETE;
+done:
+	if (target_name_utf16)
+		free(target_name_utf16);
+
+	if (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {
+		if (output_token->value) {
+			free(output_token->value);
+			output_token->value = NULL;
+		}
+		if (p_ctx_h)
+			free(p_ctx_h);
+		
+	}
+
+	return ret;
+}
+
+/*
+ * Informs GSS-API that the specified credential handle is no longer required by
+ * the application, and frees associated resources. Implementations are
+ * encouraged to set the cred_handle to GSS_C_NO_CREDENTIAL on successful
+ * completion of this call.
+ */
+OM_uint32 
+gss_release_cred(_Out_ OM_uint32 * minor_status, _Inout_opt_ gss_cred_id_t * cred_handle)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	if (*cred_handle != GSS_C_NO_CREDENTIAL) {
+		if ((*cred_handle)->isToken) {
+			CloseHandle((*cred_handle)->token);
+			if ((*cred_handle)->token == sspi_auth_user)
+				sspi_auth_user = 0;
+		}
+		else
+			SecFunctions->FreeCredentialsHandle(&(*cred_handle)->credHandle);
+		free(*cred_handle);
+		*cred_handle = GSS_C_NO_CREDENTIAL;
+	}
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Delete a security context.  gss_delete_sec_context will delete the local data
+ * structures associated with the specified security context, and may generate
+ * an output_token, which when passed to the peer gss_process_context_token will
+ * instruct it to do likewise.  If no token is required by the mechanism, the
+ * GSS-API should set the length field of the output_token (if provided) to
+ * zero.  No further security services may be obtained using the context
+ * specified by context_handle.
+ */
+OM_uint32 
+gss_delete_sec_context(_Out_ OM_uint32 * minor_status, _Inout_ gss_ctx_id_t * context_handle, 
+	_Inout_opt_ gss_buffer_t output_token)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* input sanity checks */
+	if (context_handle == NULL)
+		return GSS_S_NO_CONTEXT;
+
+	if (output_token != GSS_C_NO_BUFFER) {
+		free(output_token->value);
+		output_token->value = NULL;
+		output_token->length = 0;
+	}
+
+	/* cleanup security context */
+	SecFunctions->DeleteSecurityContext(*context_handle);
+	free(*context_handle);
+	*context_handle = GSS_C_NO_CONTEXT;
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Verifies that a cryptographic MIC, contained in the token parameter, fits the
+ * supplied message.  The qop_state parameter allows a message recipient to
+ * determine the strength of protection that was applied to the message.
+ */
+OM_uint32 
+gss_verify_mic(_Out_ OM_uint32 * minor_status, _In_ gss_ctx_id_t context_handle,
+	_In_ gss_buffer_t message_buffer, _In_ gss_buffer_t message_token, _Out_opt_ gss_qop_t * qop_state)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* translate the message and token to a security buffer so we can verify it */
+	SecBuffer verify_buffer_set[] = { 
+		{ (unsigned long) message_buffer->length, SECBUFFER_DATA, message_buffer->value },
+		{ (unsigned long) message_token->length, SECBUFFER_TOKEN, message_token->value } };
+	SecBufferDesc verify_buffer = { SECBUFFER_VERSION, _countof(verify_buffer_set), verify_buffer_set };
+
+	/* verify message and signature */
+	ULONG qop;
+	const SECURITY_STATUS status = SecFunctions->VerifySignature(context_handle, &verify_buffer, 0, &qop);
+
+	/* translate error codes */
+	OM_uint32 return_code = GSS_S_COMPLETE;
+	if (status != SEC_E_OK) {
+		/* translate specific error */
+		if (status == SEC_E_MESSAGE_ALTERED) return_code = GSS_S_BAD_SIG;
+		else if (status == SEC_E_OUT_OF_SEQUENCE) return_code = GSS_S_UNSEQ_TOKEN;
+		else if (status == SEC_E_INVALID_TOKEN) return_code = GSS_S_DEFECTIVE_TOKEN;
+		else if (status == SEC_E_CONTEXT_EXPIRED) return_code = GSS_S_CONTEXT_EXPIRED;
+		else if (status == SEC_E_QOP_NOT_SUPPORTED) return_code = GSS_S_BAD_QOP;
+		else return_code = GSS_S_FAILURE;
+	}
+
+	if (qop_state != NULL)
+		*qop_state = (OM_uint32) GSS_C_QOP_DEFAULT;
+	
+	return return_code;
+}
+
+/* 
+ * Generates a cryptographic MIC for the supplied message, and places the MIC in
+ * a token for transfer to the peer application. The qop_req parameter allows a
+ * choice between several cryptographic algorithms, if supported by the chosen
+ * mechanism.
+ */
+OM_uint32 
+gss_get_mic(_Out_ OM_uint32 * minor_status, _In_ gss_ctx_id_t context_handle,
+	_In_opt_ gss_qop_t qop_req, _In_ gss_buffer_t message_buffer, _Out_ gss_buffer_t message_token)
+{
+	OM_uint32 ret = GSS_S_FAILURE;
+
+	message_token->value = NULL;	
+	if (ssh_gss_sspi_init(minor_status) == 0)
+		goto done;
+
+	/* determine the max possible signature and allocate memory to support it */
+	SecPkgContext_Sizes sizes;
+	if (SecFunctions->QueryContextAttributesW(context_handle, SECPKG_ATTR_SIZES, &sizes) != SEC_E_OK)
+		goto done;
+	if ((message_token->value = malloc(sizes.cbMaxSignature)) == NULL)
+		goto done;
+
+	message_token->length = sizes.cbMaxSignature;
+
+	/* translate the message and token to a security buffer so we can sign it */
+	SecBuffer sign_buffer_set[] = {
+		{ (unsigned long) message_buffer->length, SECBUFFER_DATA, message_buffer->value },
+		{ (unsigned long) message_token->length, SECBUFFER_TOKEN, message_token->value } };
+	SecBufferDesc sign_buffer = { SECBUFFER_VERSION, _countof(sign_buffer_set), sign_buffer_set };
+
+	/* attempt to sign the data */
+	ULONG qop = 0;
+	const SECURITY_STATUS status = SecFunctions->MakeSignature(context_handle, qop, &sign_buffer, 0);
+
+	/* translate error codes */
+	if (status != SEC_E_OK)  {
+		if (status == SEC_E_CONTEXT_EXPIRED) 
+			ret = GSS_S_CONTEXT_EXPIRED;
+		else if (status == SEC_E_QOP_NOT_SUPPORTED) 
+			ret = GSS_S_BAD_QOP;
+		goto done;
+	}
+
+	ret = GSS_S_COMPLETE;
+
+done:
+	if (ret != GSS_S_COMPLETE) {
+		if (message_token->value) {
+			free(message_token->value);
+			message_token->value = NULL;
+		}
+	}
+	return ret;
+}
+
+/*
+ * Allows a remotely initiated security context between the application and a
+ * remote peer to be established.  The routine may return a output_token which
+ * should be transferred to the peer application, where the peer application
+ * will present it to gss_init_sec_context. If no token need be sent,
+ * gss_accept_sec_context will indicate this by setting the length field of the
+ * output_token argument to zero.  To complete the context establishment, one or
+ * more reply tokens may be required from the peer application; if so,
+ * gss_accept_sec_context will return a status flag of GSS_S_CONTINUE_NEEDED, in
+ * which case it should be called again when the reply token is received from
+ * the peer application, passing the token to gss_accept_sec_context via the
+ * input_token parameters.
+ */
+OM_uint32 
+gss_accept_sec_context(_Out_ OM_uint32 * minor_status, _Inout_opt_ gss_ctx_id_t * context_handle,
+	_In_opt_ gss_cred_id_t acceptor_cred_handle, _In_ gss_buffer_t input_token_buffer, _In_opt_ gss_channel_bindings_t input_chan_bindings,
+	_Out_opt_ gss_name_t * src_name, _Out_opt_ gss_OID * mech_type, _Outptr_ gss_buffer_t output_token,
+	_Out_ OM_uint32 * ret_flags, _Out_opt_ OM_uint32 * time_rec, _Outptr_opt_ gss_cred_id_t * delegated_cred_handle)
+{
+	OM_uint32 ret = GSS_S_FAILURE;
+	gss_ctx_id_t p_ctx_h = NULL;
+
+	*src_name = NULL;
+
+	if (delegated_cred_handle != NULL)
+		*delegated_cred_handle = NULL;
+
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		goto done;
+
+	/* setup input buffer */
+	SecBuffer input_buffer_token = { (unsigned long) input_token_buffer->length, 
+		SECBUFFER_TOKEN | SECBUFFER_READONLY, input_token_buffer->value };
+	SecBufferDesc input_buffer = { SECBUFFER_VERSION, 1, &input_buffer_token };
+
+	/* setup output buffer - will be dynamically allocated by function */
+	SecBuffer output_buffer_token = { 0, SECBUFFER_TOKEN, NULL };
+	SecBufferDesc output_buffer = { SECBUFFER_VERSION, 1, &output_buffer_token };
+
+	/* get the current time so we can determine expiration if requested */
+	SYSTEMTIME current_time_system;
+	GetSystemTime(&current_time_system);
+
+	TimeStamp expiry;
+	CtxtHandle sspi_context_handle;
+	ULONG sspi_ret_flags = 0;
+	ULONG sspi_req_flags = ASC_REQ_CONFIDENTIALITY | ASC_REQ_MUTUAL_AUTH | ASC_REQ_INTEGRITY | 
+		ASC_REQ_DELEGATE | ASC_REQ_SEQUENCE_DETECT | ASC_REQ_ALLOCATE_MEMORY;
+
+	/* call sspi accept security context function */
+	const SECURITY_STATUS status = SecFunctions->AcceptSecurityContext(&acceptor_cred_handle->credHandle, 
+		(*context_handle == GSS_C_NO_CONTEXT) ? NULL : *context_handle, &input_buffer,
+		sspi_req_flags, SECURITY_NATIVE_DREP, 
+		(*context_handle == GSS_C_NO_CONTEXT) ? &sspi_context_handle : *context_handle, 
+		&output_buffer, &sspi_ret_flags, &expiry);
+
+	/* translate error codes */
+	if (status != SEC_E_OK && status != SEC_I_CONTINUE_NEEDED) {
+		if (status == SEC_E_INVALID_TOKEN) 
+			ret = GSS_S_DEFECTIVE_TOKEN;
+		else if (status == SEC_E_INVALID_HANDLE) 
+			ret = GSS_S_NO_CONTEXT;
+		goto done;
+	}
+
+	/* only do checks on the finalized context (no continue needed) */
+	if (status == SEC_E_OK) {
+		/* validate accepted context is actually a host service ticket */
+		SecPkgContext_NativeNamesW target;
+		if (SecFunctions->QueryContextAttributesW((*context_handle == GSS_C_NO_CONTEXT) ? &sspi_context_handle : *context_handle,
+		    SECPKG_ATTR_NATIVE_NAMES, &target) != SEC_E_OK)
+			goto done;
+		
+		const int valid_spn = _wcsnicmp(target.sServerName, L"host/", wcslen(L"host/")) == 0;
+		FreeContextBuffer(target.sServerName);
+		FreeContextBuffer(target.sClientName);
+		if (valid_spn == 0) {
+			debug("client passed an invalid principal name");
+			ret = GSS_S_FAILURE;
+			goto done;
+		}
+	}
+
+	/* copy the context handler to the caller */
+	if (*context_handle == GSS_C_NO_CONTEXT) {
+		if ((p_ctx_h = malloc(sizeof(CtxtHandle))) == NULL)
+			goto done;
+		*context_handle = p_ctx_h;
+		memcpy(*context_handle, &sspi_context_handle, sizeof(CtxtHandle));
+	}
+
+	/* if requested, translate returned flags that are actually available */
+	if (ret_flags != NULL) {
+		*ret_flags = 0;
+		if (sspi_ret_flags & ASC_RET_MUTUAL_AUTH) 
+			*ret_flags |= GSS_C_MUTUAL_FLAG;
+		if (sspi_ret_flags & ASC_RET_CONFIDENTIALITY) 
+			*ret_flags |= GSS_C_CONF_FLAG;
+		if (sspi_ret_flags & ASC_RET_REPLAY_DETECT) 
+			*ret_flags |= GSS_C_REPLAY_FLAG;
+		if (sspi_ret_flags & ASC_RET_DELEGATE) 
+			*ret_flags |= GSS_C_DELEG_FLAG;
+		if (sspi_ret_flags & ASC_RET_INTEGRITY) 
+			*ret_flags |= GSS_C_INTEG_FLAG;
+		if (sspi_ret_flags & ASC_RET_SEQUENCE_DETECT) 
+			*ret_flags |= GSS_C_SEQUENCE_FLAG;
+	}
+
+	/* report if delegation was requested by not fulfilled */
+	if ((sspi_req_flags & ASC_REQ_DELEGATE) != 0 && (sspi_ret_flags & ASC_RET_DELEGATE) == 0)
+		debug("%s: delegation was requested but not fulfilled", __FUNCTION__);
+	
+	/* if provided, specify the mechanism */
+	if (mech_type != NULL)
+		*mech_type = GSS_C_NT_HOSTBASED_SERVICE;
+	
+	/* if requested, translate the expiration time to number of second */
+	if (time_rec != NULL) {
+		FILETIME current_time;
+		if (SystemTimeToFileTime(&current_time_system, &current_time) != 0)
+			*time_rec = (OM_uint32)(expiry.QuadPart - ((PLARGE_INTEGER)&current_time)->QuadPart) / 10000;
+		else
+			error("SystemTimeToFileTime failed with %d", GetLastError());
+	}
+
+	/* only do checks on the finalized context (no continue needed) */
+	if (status == SEC_E_OK) {
+		/* extract the username from the context handle will be domain\samaccountname format */
+		SecPkgContext_NamesW NamesBuffer;
+		if (SecFunctions->QueryContextAttributesW(*context_handle, SECPKG_ATTR_NAMES, &NamesBuffer) != SEC_E_OK)
+			goto done;
+		
+		/* copy to internal utf8 string and free the sspi string */
+		if ((*src_name = utf16_to_utf8(NamesBuffer.sUserName)) == NULL)
+			goto done;
+
+		FreeContextBuffer(NamesBuffer.sUserName);
+	}
+
+	/* copy output token to output buffer */
+	output_token->length = output_buffer_token.cbBuffer;
+	output_token->value = malloc(output_token->length);
+	memcpy(output_token->value, output_buffer_token.pvBuffer, output_token->length);
+	SecFunctions->FreeContextBuffer(output_buffer_token.pvBuffer);
+
+	/* get the user token for impersonation */
+	if (delegated_cred_handle != NULL) {
+		if ((*delegated_cred_handle = malloc(sizeof(struct cred_st))) == NULL)
+			goto done;
+		if (SecFunctions->QuerySecurityContextToken(*context_handle, &sspi_auth_user) != SEC_E_OK)
+			goto done;
+		(*delegated_cred_handle)->isToken = 1;
+		(*delegated_cred_handle)->token = sspi_auth_user;
+	}
+
+	ret = (status == SEC_I_CONTINUE_NEEDED) ? GSS_S_CONTINUE_NEEDED : GSS_S_COMPLETE;
+
+done:
+	if (ret != GSS_S_COMPLETE && ret != GSS_S_CONTINUE_NEEDED) {
+		if (p_ctx_h)
+			free(p_ctx_h);
+		if (*src_name)
+			free(*src_name);
+		if (delegated_cred_handle && *delegated_cred_handle)
+			free(*delegated_cred_handle);
+	}
+	return ret;
+}
+
+/*
+ * Allows an application to obtain a textual representation of an opaque
+ * internal-form name for display purposes.  The syntax of a printable name is
+ * defined by the GSS-API implementation.
+ */
+OM_uint32 
+gss_display_name(_Out_ OM_uint32 * minor_status, _In_ gss_name_t input_name, 
+	_Out_ gss_buffer_t output_name_buffer, _Out_ gss_OID * output_name_type)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	output_name_buffer->length = strlen(input_name) + 1;
+	if ((output_name_buffer->value = _strdup(input_name)) == NULL)
+		return GSS_S_FAILURE;
+
+	/* set the output oid type if requested */
+	if (output_name_type != NULL)
+		*output_name_type = GSS_C_NT_HOSTBASED_SERVICE;
+	
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * Allows an application to obtain a textual representation of a GSS-API status
+ * code, for display to the user or for logging purposes.  Since some status
+ * values may indicate multiple conditions, applications may need to call
+ * gss_display_status multiple times, each call generating a single text string.
+ * The message_context parameter is used by gss_display_status to store state
+ * information about which error messages have already been extracted from a
+ * given status_value; message_context must be initialized to 0 by the
+ * application prior to the first call, and gss_display_status will return a
+ * non-zero value in this parameter if there are further messages to extract.
+ */
+OM_uint32 
+gss_display_status(_In_ OM_uint32 * minor_status, _In_ OM_uint32 status_value, _In_ int status_type,
+	_In_opt_ gss_OID mech_type, _Out_ OM_uint32 * message_context, _Inout_ gss_buffer_t status_string)
+{
+	if (ssh_gss_sspi_init(minor_status) == 0) 
+		return GSS_S_FAILURE;
+
+	/* lookup textual representation of the numeric status code */
+	char * message_string = NULL;
+	if (status_value == GSS_S_COMPLETE) 
+		message_string = "GSS_S_COMPLETE";
+	else if (status_value == GSS_S_BAD_BINDINGS) 
+		message_string = "GSS_S_BAD_BINDINGS";
+	else if (status_value == GSS_S_BAD_MECH) 
+		message_string = "GSS_S_BAD_MECH";
+	else if (status_value == GSS_S_BAD_NAME) 
+		message_string = "GSS_S_BAD_NAME";
+	else if (status_value == GSS_S_BAD_NAMETYPE) 
+		message_string = "GSS_S_BAD_NAMETYPE";
+	else if (status_value == GSS_S_BAD_QOP) 
+		message_string = "GSS_S_BAD_QOP";
+	else if (status_value == GSS_S_BAD_SIG) 
+		message_string = "GSS_S_BAD_SIG";
+	else if (status_value == GSS_S_BAD_STATUS) 
+		message_string = "GSS_S_BAD_STATUS";
+	else if (status_value == GSS_S_CONTEXT_EXPIRED) 
+		message_string = "GSS_S_CONTEXT_EXPIRED";
+	else if (status_value == GSS_S_CONTINUE_NEEDED) 
+		message_string = "GSS_S_CONTINUE_NEEDED";
+	else if (status_value == GSS_S_CREDENTIALS_EXPIRED) 
+		message_string = "GSS_S_CREDENTIALS_EXPIRED";
+	else if (status_value == GSS_S_DEFECTIVE_CREDENTIAL) 
+		message_string = "GSS_S_DEFECTIVE_CREDENTIAL";
+	else if (status_value == GSS_S_DEFECTIVE_TOKEN) 
+		message_string = "GSS_S_DEFECTIVE_TOKEN";
+	else if (status_value == GSS_S_DUPLICATE_ELEMENT) 
+		message_string = "GSS_S_DUPLICATE_ELEMENT";
+	else if (status_value == GSS_S_DUPLICATE_TOKEN) 
+		message_string = "GSS_S_DUPLICATE_TOKEN";
+	else if (status_value == GSS_S_FAILURE) 
+		message_string = "GSS_S_FAILURE";
+	else if (status_value == GSS_S_NAME_NOT_MN) 
+		message_string = "GSS_S_NAME_NOT_MN";
+	else if (status_value == GSS_S_NO_CONTEXT) 
+		message_string = "GSS_S_NO_CONTEXT";
+	else if (status_value == GSS_S_NO_CRED) 
+		message_string = "GSS_S_NO_CRED";
+	else if (status_value == GSS_S_OLD_TOKEN) 
+		message_string = "GSS_S_OLD_TOKEN";
+	else if (status_value == GSS_S_UNAUTHORIZED) 
+		message_string = "GSS_S_UNAUTHORIZED";
+	else if (status_value == GSS_S_UNAVAILABLE) 
+		message_string = "GSS_S_UNAVAILABLE";
+	else if (status_value == GSS_S_UNSEQ_TOKEN) 
+		message_string = "GSS_S_UNSEQ_TOKEN";
+
+	/* copy local status string to the output buffer */
+	status_string->length = strlen(message_string) + 1;
+	if ((status_string->value = _strdup(message_string)) == NULL)
+		return GSS_S_FAILURE;
+
+	/* no supplementary messages available */
+	*message_context = 0;
+
+	return GSS_S_COMPLETE;
+}
+
+/*
+ * The function ssh_gssapi_krb5_userok and gssapi_kerberos_mech structure
+ * are referenced in gss-serv.c and are required in order for the calling
+ * code to accept negotiate a kerberos token.
+ */
+
+static int 
+ssh_gssapi_krb5_userok(ssh_gssapi_client *client, char *name)
+{
+	/*
+	 * This check is important since it makes sure that the username string
+	 * that the user passed (e.g. user@host) matches the user authenticated
+	 * via SSPI.  If this check fails, the authentication process will move
+	 * onto the next available method.
+	 */
+	struct passwd * user = getpwnam(name);
+	if (user == NULL)
+	{
+		error("sspi getpwnam failed to get user from user-provided, resolved user '%s'", name);
+		return 0;
+	}
+	if (_stricmp(client->displayname.value, user->pw_name) != 0) {
+		/* check failed */
+		debug("sspi user '%s' did not match user-provided, resolved user '%s'", 
+			(char *) client->displayname.value, name);
+		return 0;
+	}
+
+	return 1;
+}
+
+ssh_gssapi_mech gssapi_kerberos_mech = {
+	"toWM5Slw5Ew8Mqkay+al2g==",
+	"Kerberos",
+	{sizeof(GSS_C_NT_HOSTBASED_SERVICE_STR) - 1, GSS_C_NT_HOSTBASED_SERVICE_STR},
+	NULL,
+	&ssh_gssapi_krb5_userok,
+	NULL,
+	NULL
+};
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/arpa/inet.h b/contrib/win32/win32compat/inc/arpa/inet.h
new file mode 100644
index 000000000..d522ea827
--- /dev/null
+++ b/contrib/win32/win32compat/inc/arpa/inet.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_INET_H
+#define COMPAT_INET_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/arpa/nameser.h b/contrib/win32/win32compat/inc/arpa/nameser.h
new file mode 100644
index 000000000..a9ecc0c34
--- /dev/null
+++ b/contrib/win32/win32compat/inc/arpa/nameser.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_NAMESER_H
+#define COMPAT_NAMESER_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/crypto-wrap.h b/contrib/win32/win32compat/inc/crypto-wrap.h
new file mode 100644
index 000000000..6ed12df54
--- /dev/null
+++ b/contrib/win32/win32compat/inc/crypto-wrap.h
@@ -0,0 +1,76 @@
+
+#ifndef _OPENSSL_WRAP_H
+#define _OPENSSL_WRAP_H
+
+struct sshdh;
+struct sshbn;
+struct sshbuf;
+struct ssh;
+struct sshedh;
+struct sshepoint;
+struct sshecurve;
+
+
+struct sshdh *sshdh_new(void);
+void sshdh_free(struct sshdh *dh);
+struct sshbn *sshdh_pubkey(struct sshdh *dh);
+struct sshbn *sshdh_p(struct sshdh *dh);
+struct sshbn *sshdh_g(struct sshdh *dh);
+void sshdh_dump(struct sshdh *dh);
+size_t sshdh_shared_key_size(struct sshdh *dh);
+int sshdh_compute_key(struct sshdh *dh, struct sshbn *pubkey,
+struct sshbn **shared_secretp);
+int sshdh_generate(struct sshdh *dh, size_t len);
+int sshdh_new_group_hex(const char *gen, const char *modulus,
+struct sshdh **dhp);
+struct sshdh *sshdh_new_group(struct sshbn *gen, struct sshbn *modulus);
+
+struct sshedh *sshedh_new(void);
+void sshedh_free(struct sshdh *dh);
+struct sshepoint *sshedh_pubkey(struct sshedh *dh);
+void sshedh_dump(struct sshedh *dh);
+size_t sshedh_shared_key_size(struct sshedh *dh);
+int sshedh_compute_key(struct sshedh *dh, struct sshepoint *pubkey,
+struct sshbn **shared_secretp);
+int sshedh_generate(struct sshedh *dh, size_t len);
+struct sshedh *sshedh_new_curve(int nid);
+
+struct sshepoint * sshepoint_new(void);
+int sshepoint_from(struct sshbn * x, struct sshbn * y, struct sshecurve * sshecurve, struct sshepoint **retp);
+int sshepoint_to(struct sshepoint * pt, struct sshbn  **retx, struct sshbn **rety, struct sshecurve ** retcurve);
+void sshepoint_free(struct sshepoint * pt);
+
+struct sshecurve * sshecurve_new(void);
+void sshecurve_free(struct sshecurve * curve);
+struct sshecurve * sshecurve_new_curve(int nid);
+
+
+
+struct sshbn *sshbn_new(void);
+void sshbn_free(struct sshbn *bn);
+int sshbn_from(const void *d, size_t l, struct sshbn **retp);
+int sshbn_from_hex(const char *hex, struct sshbn **retp);
+size_t sshbn_bits(const struct sshbn *bn);
+const struct sshbn *sshbn_value_0(void);
+const struct sshbn *sshbn_value_1(void);
+int sshbn_cmp(const struct sshbn *a, const struct sshbn *b);
+int sshbn_sub(struct sshbn *r, const struct sshbn *a, const struct sshbn *b);
+int sshbn_is_bit_set(const struct sshbn *bn, size_t i);
+int sshbn_to(const struct sshbn *a, unsigned char *to);
+size_t sshbn_bytes(const struct sshbn *bn);
+
+/* XXX move to sshbuf.h; rename s/_wrap$// */
+int sshbuf_get_bignum2_wrap(struct sshbuf *buf, struct sshbn *bn);
+int sshbuf_get_bignum1_wrap(struct sshbuf *buf, struct sshbn *bn);
+int sshbuf_put_bignum2_wrap(struct sshbuf *buf, const struct sshbn *bn);
+int sshbuf_put_bignum1_wrap(struct sshbuf *buf, const struct sshbn *bn);
+int sshpkt_get_bignum2_wrap(struct ssh *ssh, struct sshbn *bn);
+int sshpkt_put_bignum2_wrap(struct ssh *ssh, const struct sshbn *bn);
+
+/* bridge to unwrapped OpenSSL APIs; XXX remove later */
+struct sshbn *sshbn_from_bignum(BIGNUM *bn);
+BIGNUM *sshbn_bignum(struct sshbn *bn);
+DH *sshdh_dh(struct sshdh *dh);
+
+
+#endif /* _OPENSSL_WRAP_H */
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/ctype.h b/contrib/win32/win32compat/inc/ctype.h
new file mode 100644
index 000000000..61f451a81
--- /dev/null
+++ b/contrib/win32/win32compat/inc/ctype.h
@@ -0,0 +1,5 @@
+#include "crtheaders.h"
+#include CTYPE_H
+
+#define isascii __isascii
+
diff --git a/contrib/win32/win32compat/inc/dirent.h b/contrib/win32/win32compat/inc/dirent.h
new file mode 100644
index 000000000..d1441a6c9
--- /dev/null
+++ b/contrib/win32/win32compat/inc/dirent.h
@@ -0,0 +1,26 @@
+// direntry functions in Windows platform like Ubix/Linux
+// opendir(), readdir(), closedir().
+// 	NT_DIR * nt_opendir(char *name) ;
+// 	struct nt_dirent *nt_readdir(NT_DIR *dirp);
+// 	int nt_closedir(NT_DIR *dirp) ;
+
+#ifndef __DIRENT_H__
+#define __DIRENT_H__
+
+#include <direct.h>
+#include <io.h>
+#include <fcntl.h>
+#include "..\misc_internal.h"
+
+struct dirent {
+	int            d_ino;       /* Inode number */
+	char           d_name[PATH_MAX]; /* Null-terminated filename */
+};
+
+typedef struct DIR_ DIR;
+
+DIR * opendir(const char*);
+int closedir(DIR*);
+struct dirent *readdir(void*);
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/dlfcn.h b/contrib/win32/win32compat/inc/dlfcn.h
new file mode 100644
index 000000000..02be32978
--- /dev/null
+++ b/contrib/win32/win32compat/inc/dlfcn.h
@@ -0,0 +1,9 @@
+#pragma once
+#include <Windows.h>
+#define RTLD_NOW 0
+
+HMODULE dlopen(const char *filename, int flags);
+
+int dlclose(HMODULE handle);
+void * dlsym(HMODULE handle, const char *symbol);
+char * dlerror();
diff --git a/contrib/win32/win32compat/inc/fcntl.h b/contrib/win32/win32compat/inc/fcntl.h
new file mode 100644
index 000000000..c2e126c9b
--- /dev/null
+++ b/contrib/win32/win32compat/inc/fcntl.h
@@ -0,0 +1,68 @@
+#include "crtheaders.h"
+#include FCNTL_H
+
+/*fcntl commands*/
+#define F_GETFL 0x1
+#define F_SETFL 0x2
+#define F_GETFD 0x4
+#define F_SETFD 0x8
+#define F_DUPFD 0x10
+
+/*fd flags*/
+#define FD_CLOEXEC 0x1
+
+#define F_OK 0
+
+
+int w32_fcntl(int fd, int cmd, ... /* arg */);
+#define fcntl(a,b,...)		w32_fcntl((a), (b),  __VA_ARGS__)
+
+#define open(a,b,...) w32_open((a), (b),  __VA_ARGS__)
+int w32_open(const char *pathname, int flags, ... /* arg */);
+
+void* w32_fd_to_handle(int fd);
+
+#define O_RDONLY     _O_RDONLY
+#define O_WRONLY     _O_WRONLY
+#define O_RDWR       _O_RDWR
+#define O_APPEND     _O_APPEND
+#define O_CREAT      _O_CREAT
+#define O_TRUNC      _O_TRUNC
+#define O_EXCL       _O_EXCL
+#define O_TEXT       _O_TEXT
+#define O_BINARY     _O_BINARY
+#define O_RAW        _O_BINARY
+#define O_TEMPORARY  _O_TEMPORARY
+#define O_NOINHERIT  _O_NOINHERIT
+#define O_SEQUENTIAL _O_SEQUENTIAL
+#define O_RANDOM     _O_RANDOM
+#define O_U16TEXT     _O_U16TEXT
+
+/*
+* open() POSIX specific modes and flags.
+* Caution while making changes
+* - cross check conflict with common macros in Windows headers
+* - Ex. #define O_APPEND    0x8
+*/
+#define O_ACCMODE			0x0003
+#define O_NONBLOCK			0x0004  /*io operations wont block*/
+# define S_IXUSR			0000100	/* execute/search permission, */
+# define S_IXGRP			0000010	/* execute/search permission, */
+# define S_IXOTH			0000001	/* execute/search permission, */
+# define _S_IWUSR			0000200	/* write permission, */
+# define S_IWUSR			_S_IWUSR	/* write permission, owner */
+# define S_IWGRP			0000020	/* write permission, group */
+# define S_IWOTH			0000002	/* write permission, other */
+# define S_IRUSR			0000400	/* read permission, owner */
+# define S_IRGRP			0000040	/* read permission, group */
+# define S_IROTH			0000004	/* read permission, other */
+# define S_IRWXU			0000700	/* read, write, execute */
+# define S_IRWXG			0000070	/* read, write, execute */
+# define S_IRWXO			0000007	/* read, write, execute */
+
+/* 
+ * File types. Note that the values are different from similar variants 
+ * defined in stat.h. These are based on similar definition values on Linux
+ */
+#define __S_IFDIR       0040000 /* Directory.  */
+#define __S_IFREG       0100000 /* Regular file.  */
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/fnmatch.h b/contrib/win32/win32compat/inc/fnmatch.h
new file mode 100644
index 000000000..8a02e349b
--- /dev/null
+++ b/contrib/win32/win32compat/inc/fnmatch.h
@@ -0,0 +1,7 @@
+#ifndef FNMATCH_H
+#define FNMATCH_H 1
+
+int fnmatch(const char *pattern, const char *string, int flags);
+
+
+#endif
diff --git a/contrib/win32/win32compat/inc/grp.h b/contrib/win32/win32compat/inc/grp.h
new file mode 100644
index 000000000..222fc9c1a
--- /dev/null
+++ b/contrib/win32/win32compat/inc/grp.h
@@ -0,0 +1,4 @@
+#ifndef COMPAT_GRP_H
+#define COMPAT_GRP_H 1
+
+#endif
diff --git a/contrib/win32/win32compat/inc/gssapi.h b/contrib/win32/win32compat/inc/gssapi.h
new file mode 100644
index 000000000..f85e30448
--- /dev/null
+++ b/contrib/win32/win32compat/inc/gssapi.h
@@ -0,0 +1,246 @@
+/*
+ * Author: Bryan Berns <berns@uwalumni.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+ /*
+  * This file provides the GSSAPI interface to support Kerberos SSPI within
+  * OpenSSH.  This is only a partial definition of the full GSSAPI specification
+  * since OpenSSH only requires a subset of the overall functionality.
+  *
+  * The definitions are derived from information provided in RFC2744.  In
+  * addition, RFC2743 provides additional information on the GSSAPI
+  * specification and intended operation.
+  */
+
+#include <windows.h>
+#include <stdint.h>
+
+#define SECURITY_WIN32
+#include <security.h>
+
+/*
+ * Common Structures & Type Definitions
+ */
+
+typedef uint32_t OM_uint32;
+
+typedef char *gss_name_struct, *gss_name_t;
+
+typedef struct cred_st *gss_cred_id_t;
+typedef CtxtHandle *gss_ctx_id_t;
+
+typedef OM_uint32 gss_qop_t;
+typedef OM_uint32 gss_cred_usage_t;
+
+typedef struct gss_buffer_desc_struct
+{
+	size_t length;
+	void *value;
+}
+gss_buffer_desc, *gss_buffer_t;
+
+typedef struct gss_OID_desc_struct
+{
+	OM_uint32 length;
+	void *elements;
+}
+gss_OID_desc, *gss_OID;
+
+typedef struct gss_OID_set_desc_struct
+{
+	size_t  count;
+	gss_OID elements;
+}
+gss_OID_set_desc, *gss_OID_set;
+
+typedef struct gss_channel_bindings_struct 
+{
+	OM_uint32 initiator_addrtype;
+	gss_buffer_desc initiator_address;
+	OM_uint32 acceptor_addrtype;
+	gss_buffer_desc acceptor_address;
+	gss_buffer_desc application_data;
+} 
+gss_channel_bindings_desc, *gss_channel_bindings_t;
+
+/*
+ * Input & Return Flags 
+ */
+
+/* Credential Usage Indication Options */
+#define GSS_C_BOTH      0
+#define GSS_C_INITIATE  1
+#define GSS_C_ACCEPT    2
+
+/* Context Flag Options */
+#define GSS_C_DELEG_FLAG        1
+#define GSS_C_MUTUAL_FLAG       2
+#define GSS_C_REPLAY_FLAG       4
+#define GSS_C_SEQUENCE_FLAG     8
+#define GSS_C_CONF_FLAG         16
+#define GSS_C_INTEG_FLAG        32
+#define GSS_C_ANON_FLAG         64
+#define GSS_C_PROT_READY_FLAG   128
+#define GSS_C_TRANS_FLAG        256
+#define GSS_C_DELEG_POLICY_FLAG 32768
+
+/* Display Status Code Types */
+#define GSS_C_GSS_CODE  1
+#define GSS_C_MECH_CODE 2
+
+/* Convenience Null Castless Comparison Options */
+#define GSS_C_NO_NAME             ((gss_name_t) 0)
+#define GSS_C_NO_BUFFER           ((gss_buffer_t) 0)
+#define GSS_C_NO_OID              ((gss_OID) 0)
+#define GSS_C_NO_OID_SET          ((gss_OID_set) 0)
+#define GSS_C_NO_CONTEXT          ((gss_ctx_id_t) 0)
+#define GSS_C_NO_CREDENTIAL       ((gss_cred_id_t) 0)
+#define GSS_C_NO_CHANNEL_BINDINGS ((gss_channel_bindings_t) 0)
+
+/* Convenience Initializer For Empty Buffer */
+#define GSS_C_EMPTY_BUFFER {0, NULL}
+
+/* Default Quality of Protection Code */
+#define GSS_C_QOP_DEFAULT 0
+
+ /* Infinite Context / Credential Value */
+#define GSS_C_INDEFINITE ((OM_uint32) 0xfffffffful)
+
+/*
+ * Status & Return Code Processing
+ */
+
+#define GSS_S_COMPLETE 0
+
+#define GSS_C_CALLING_ERROR_OFFSET 24
+#define GSS_C_ROUTINE_ERROR_OFFSET 16
+#define GSS_C_SUPPLEMENTARY_OFFSET 0
+#define GSS_C_CALLING_ERROR_MASK ((OM_uint32) 0377ul)
+#define GSS_C_ROUTINE_ERROR_MASK ((OM_uint32) 0377ul)
+
+#define GSS_CALLING_ERROR(x)      ((x) & (GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET))
+#define GSS_ROUTINE_ERROR(x)      ((x) & (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET))
+#define GSS_ERROR(x)              ((x) & ((GSS_C_CALLING_ERROR_MASK << GSS_C_CALLING_ERROR_OFFSET) | (GSS_C_ROUTINE_ERROR_MASK << GSS_C_ROUTINE_ERROR_OFFSET)))
+
+#define GSS_S_BAD_MECH             (((OM_uint32)  1ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_NAME             (((OM_uint32)  2ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_NAMETYPE         (((OM_uint32)  3ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_BINDINGS         (((OM_uint32)  4ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_STATUS           (((OM_uint32)  5ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_SIG              (((OM_uint32)  6ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_NO_CRED              (((OM_uint32)  7ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_NO_CONTEXT           (((OM_uint32)  8ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_DEFECTIVE_TOKEN      (((OM_uint32)  9ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_DEFECTIVE_CREDENTIAL (((OM_uint32) 10ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_CREDENTIALS_EXPIRED  (((OM_uint32) 11ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_CONTEXT_EXPIRED      (((OM_uint32) 12ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_FAILURE              (((OM_uint32) 13ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_BAD_QOP              (((OM_uint32) 14ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_UNAUTHORIZED         (((OM_uint32) 15ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_UNAVAILABLE          (((OM_uint32) 16ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_DUPLICATE_ELEMENT    (((OM_uint32) 17ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+#define GSS_S_NAME_NOT_MN          (((OM_uint32) 18ul) << GSS_C_ROUTINE_ERROR_OFFSET)
+
+#define GSS_S_CONTINUE_NEEDED      (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 0))
+#define GSS_S_DUPLICATE_TOKEN      (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 1))
+#define GSS_S_OLD_TOKEN            (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 2))
+#define GSS_S_UNSEQ_TOKEN          (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 3))
+#define GSS_S_GAP_TOKEN            (1ul << (GSS_C_SUPPLEMENTARY_OFFSET + 4))
+
+/* 
+ * Function Prototypes 
+ */
+
+OM_uint32 
+gss_accept_sec_context(_Out_ OM_uint32 * minor_status, _Inout_opt_ gss_ctx_id_t * context_handle,
+	_In_opt_ gss_cred_id_t acceptor_cred_handle, _In_ gss_buffer_t input_token_buffer, 
+	_In_opt_ gss_channel_bindings_t input_chan_bindings, _Out_opt_ gss_name_t * src_name, 
+	_Out_opt_ gss_OID * mech_type, _Outptr_ gss_buffer_t output_token, _Out_ OM_uint32 * ret_flags, 
+	_Out_opt_ OM_uint32 * time_rec, _Outptr_opt_ gss_cred_id_t * delegated_cred_handle);
+
+OM_uint32
+gss_acquire_cred(_Out_ OM_uint32 *minor_status, _In_opt_ gss_name_t desired_name, 
+	_In_opt_ OM_uint32 time_req, _In_opt_ gss_OID_set desired_mechs, _In_ gss_cred_usage_t cred_usage,
+	_Outptr_opt_ gss_cred_id_t * output_cred_handle, _Outptr_opt_ gss_OID_set *actual_mechs, 
+	_Out_opt_ OM_uint32 *time_rec);
+
+OM_uint32 
+gss_add_oid_set_member(_Out_ OM_uint32 * minor_status, _In_ gss_OID member_oid, 
+	_In_ gss_OID_set * oid_set);
+
+OM_uint32
+gss_create_empty_oid_set(_Out_ OM_uint32 * minor_status, _Outptr_ gss_OID_set * oid_set);
+
+OM_uint32 
+gss_delete_sec_context(_Out_ OM_uint32 * minor_status, _Inout_ gss_ctx_id_t * context_handle,
+	_Inout_opt_ gss_buffer_t output_token);
+
+OM_uint32 
+gss_display_name(_Out_ OM_uint32 * minor_status, _In_ gss_name_t input_name, 
+	_Out_ gss_buffer_t output_name_buffer, _Out_ gss_OID * output_name_type);
+
+OM_uint32 
+gss_display_status(_In_ OM_uint32 * minor_status, _In_ OM_uint32 status_value,
+	_In_ int status_type, _In_opt_ gss_OID mech_type, _Out_ OM_uint32 * message_context, 
+	_Inout_ gss_buffer_t status_string);
+
+OM_uint32 
+gss_export_name(_Out_ OM_uint32 * minor_status, _In_ const gss_name_t input_name, 
+	_Inout_ gss_buffer_t exported_name);
+
+OM_uint32 
+gss_get_mic(_Out_ OM_uint32 * minor_status, _In_ gss_ctx_id_t context_handle, 
+	_In_opt_ gss_qop_t qop_req, _In_ gss_buffer_t message_buffer, 
+	_Out_ gss_buffer_t message_token);
+
+OM_uint32 
+gss_import_name(_Out_ OM_uint32 * minor_status, _In_ gss_buffer_t input_name_buffer,
+	_In_ gss_OID input_name_type, _Out_ gss_name_t * output_name);
+
+OM_uint32 
+gss_indicate_mechs(_Out_ OM_uint32 * minor_status, _Outptr_ gss_OID_set * mech_set);
+
+OM_uint32 
+gss_release_buffer(_Out_ OM_uint32 * minor_status, _Inout_ gss_buffer_t buffer);
+
+OM_uint32 
+gss_release_cred(_Out_ OM_uint32 * minor_status, _Inout_opt_ gss_cred_id_t * cred_handle);
+
+OM_uint32 
+gss_release_name(_Out_ OM_uint32 * minor_status, _Inout_ gss_name_t * input_name);
+
+OM_uint32 
+gss_release_oid_set(_Out_ OM_uint32 * minor_status, _In_ gss_OID_set * set);
+
+OM_uint32 
+gss_test_oid_set_member(_Out_ OM_uint32 * minor_status, _In_ gss_OID member, 
+	_In_ gss_OID_set set, _Out_ int * present);
+
+OM_uint32 
+gss_verify_mic(_Out_ OM_uint32 * minor_status, _In_ gss_ctx_id_t context_handle, 
+	_In_ gss_buffer_t message_buffer, _Out_opt_ gss_buffer_t message_token, 
+	_Inout_ gss_qop_t * qop_state);
+
+extern gss_OID GSS_C_NT_HOSTBASED_SERVICE;
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/libgen.h b/contrib/win32/win32compat/inc/libgen.h
new file mode 100644
index 000000000..b83e65db3
--- /dev/null
+++ b/contrib/win32/win32compat/inc/libgen.h
@@ -0,0 +1,3 @@
+
+
+char *basename(char *path);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/net/if.h b/contrib/win32/win32compat/inc/net/if.h
new file mode 100644
index 000000000..6f70f09be
--- /dev/null
+++ b/contrib/win32/win32compat/inc/net/if.h
@@ -0,0 +1 @@
+#pragma once
diff --git a/contrib/win32/win32compat/inc/netdb.h b/contrib/win32/win32compat/inc/netdb.h
new file mode 100644
index 000000000..65ea0c408
--- /dev/null
+++ b/contrib/win32/win32compat/inc/netdb.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_NETDB_H
+#define COMPAT_NETDB_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/netinet/in.h b/contrib/win32/win32compat/inc/netinet/in.h
new file mode 100644
index 000000000..929218138
--- /dev/null
+++ b/contrib/win32/win32compat/inc/netinet/in.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_IN_H
+#define COMPAT_IN_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/netinet/in_systm.h b/contrib/win32/win32compat/inc/netinet/in_systm.h
new file mode 100644
index 000000000..e8cca1056
--- /dev/null
+++ b/contrib/win32/win32compat/inc/netinet/in_systm.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_IN_SYSTM_H
+#define COMPAT_IN_SYSTM_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/netinet/ip.h b/contrib/win32/win32compat/inc/netinet/ip.h
new file mode 100644
index 000000000..7b39a3bf2
--- /dev/null
+++ b/contrib/win32/win32compat/inc/netinet/ip.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_IP_H
+#define COMPAT_IP_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/netinet/tcp.h b/contrib/win32/win32compat/inc/netinet/tcp.h
new file mode 100644
index 000000000..ac933f100
--- /dev/null
+++ b/contrib/win32/win32compat/inc/netinet/tcp.h
@@ -0,0 +1,7 @@
+#ifndef COMPAT_TCP_H
+#define COMPAT_TCP_H 1
+
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/poll.h b/contrib/win32/win32compat/inc/poll.h
new file mode 100644
index 000000000..5deeeb7b7
--- /dev/null
+++ b/contrib/win32/win32compat/inc/poll.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "sys\types.h"
+#include "sys\socket.h"
+
+/* created to #def out decarations in open-bsd.h (that are defined in winsock2.h) */
+
+int poll(struct pollfd *, nfds_t, int);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/pwd.h b/contrib/win32/win32compat/inc/pwd.h
new file mode 100644
index 000000000..98964db02
--- /dev/null
+++ b/contrib/win32/win32compat/inc/pwd.h
@@ -0,0 +1,50 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Compatibility header to give us pwd-like functionality on Win32
+* A lot of passwd fields are not applicable in Windows, neither are some API calls based on this structure
+* Ideally, usage of this structure needs to be replaced in core SSH code to an ssh_user interface,
+* that each platform can extend and implement.
+*/
+
+#ifndef COMPAT_PWD_H
+#define COMPAT_PWD_H 1
+
+#include "sys\types.h"
+
+struct passwd {
+	char	*pw_name;	/* user's login name */
+	char	*pw_passwd;	/* password? */
+	char	*pw_gecos;	/* ??? */
+	uid_t	pw_uid;		/* numerical user ID */
+	gid_t	pw_gid;		/* numerical group ID */
+	char	*pw_dir;	/* initial working directory */
+	char	*pw_shell;	/* path to shell */
+};
+
+/*start - declarations not applicable in Windows */
+uid_t w32_getuid(void);
+gid_t getgid(void);
+uid_t geteuid(void);
+gid_t getegid(void);
+int setuid(uid_t uid);
+int setgid(gid_t gid);
+int seteuid(uid_t uid);
+int setegid(gid_t gid);
+char *user_from_uid(uid_t uid, int nouser);
+struct passwd *getpwent(void);
+void setpwent(void);
+
+/*end - declarations not applicable in Windows */
+
+struct passwd *w32_getpwuid(uid_t uid);
+struct passwd *w32_getpwnam(const char *username);
+struct passwd *getpwent(void);
+void endpwent(void);
+char *get_username(const PSID sid);
+
+#define getpwuid w32_getpwuid
+#define getpwnam w32_getpwnam
+#define getuid w32_getuid
+
+#endif
diff --git a/contrib/win32/win32compat/inc/resolv.h b/contrib/win32/win32compat/inc/resolv.h
new file mode 100644
index 000000000..0b449b6b5
--- /dev/null
+++ b/contrib/win32/win32compat/inc/resolv.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_RESOLV_H
+#define COMPAT_RESOLV_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/signal.h b/contrib/win32/win32compat/inc/signal.h
new file mode 100644
index 000000000..f5891da51
--- /dev/null
+++ b/contrib/win32/win32compat/inc/signal.h
@@ -0,0 +1,110 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* POSIX header and needed function definitions
+*/
+#ifndef COMPAT_SIGNAL_H
+#define COMPAT_SIGNAL_H 1
+
+
+/* signal related defs*/
+/* supported signal types */
+#define W32_SIGINT		0   
+#define W32_SIGSEGV		1	  
+
+#define W32_SIGPIPE		2
+#define W32_SIGCHLD		3
+#define W32_SIGALRM		4
+#define W32_SIGTSTP		5 
+
+#define W32_SIGHUP		6 
+#define W32_SIGQUIT		7 
+#define W32_SIGTERM		8
+#define W32_SIGTTIN		9
+#define W32_SIGTTOU		10
+#define W32_SIGWINCH	        11
+
+#define W32_SIGMAX		12
+/* these signals are not supposed to be raised on Windows*/
+#define W32_SIGSTOP             13
+#define W32_SIGABRT             14
+#define W32_SIGFPE              15
+#define W32_SIGILL              16
+#define W32_SIGKILL             17
+#define W32_SIGUSR1             18
+#define W32_SIGUSR2             19
+
+/* singprocmask "how" codes*/
+#define SIG_BLOCK		0
+#define SIG_UNBLOCK		1
+#define SIG_SETMASK		2
+
+typedef void(*sighandler_t)(int);
+typedef int sigset_t;
+#define sigemptyset(set) (memset( (set), 0, sizeof(sigset_t)))
+#define sigaddset(set, sig) ( (*(set)) |= (0x80000000 >> (sig)))
+#define sigismember(set, sig) ( (*(set) & (0x80000000 >> (sig)))?1:0 )
+#define sigdelset(set, sig) ( (*(set)) &= (~( 0x80000000 >> (sig)) ) )
+
+/* signal action codes*/
+#define W32_SIG_ERR		((sighandler_t)-1)
+#define W32_SIG_DFL		((sighandler_t)0)
+#define W32_SIG_IGN		((sighandler_t)1)
+
+#define signal(a, b) mysignal(a, b)
+sighandler_t w32_signal(int signum, sighandler_t handler);
+sighandler_t mysignal(int signum, sighandler_t handler);
+char* strsignal(int);
+
+int w32_raise(int sig);
+#define raise(a)	w32_raise(a)
+
+int w32_kill(int pid, int sig);
+#define kill(a,b)	w32_kill((a), (b))
+#define killpg(a,b)	w32_kill((a), (b))
+
+int w32_sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
+#define sigprocmask(a,b,c) w32_sigprocmask((a), (b), (c))
+
+struct sigaction {
+    void     (*sa_handler)(int);
+    void     (*sa_sigaction)(int, void *, void *);
+    sigset_t   sa_mask;
+    int        sa_flags;
+    void     (*sa_restorer)(void); /* reserved */
+};
+
+int sigaction(int signum, const struct sigaction * act, struct sigaction * oldact);
+
+#define SIGINT	W32_SIGINT		
+#define SIGSEGV	W32_SIGSEGV		
+#define SIGPIPE	W32_SIGPIPE		
+#define SIGCHLD	W32_SIGCHLD		
+#define SIGALRM	W32_SIGALRM		
+#define SIGTSTP	W32_SIGTSTP		 
+#define SIGHUP	W32_SIGHUP		
+#define SIGQUIT	W32_SIGQUIT		 
+#define SIGTERM	W32_SIGTERM		
+#define SIGTTIN	W32_SIGTTIN		
+#define SIGTTOU	W32_SIGTTOU		
+#define SIGWINCH W32_SIGWINCH
+#define SIGSTOP  W32_SIGSTOP
+#define SIGSTOP W32_SIGSTOP            
+#define SIGABRT W32_SIGABRT 
+#define SIGFPE W32_SIGFPE 
+#define SIGILL W32_SIGILL 
+#define SIGKILL W32_SIGKILL
+#define SIGUSR1 W32_SIGUSR1
+#define SIGUSR2 W32_SIGUSR2
+
+#define SIG_DFL	W32_SIG_DFL
+#define SIG_IGN	W32_SIG_IGN
+#define SIG_ERR W32_SIG_ERR
+
+#define _NSIG (W32_SIGMAX + 1)
+
+/* TOTO - implement http://www.manpagez.com/man/3/sys_siglist/*/
+#undef NSIG
+#define NSIG 0
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/spawn.h b/contrib/win32/win32compat/inc/spawn.h
new file mode 100644
index 000000000..dabbb5b62
--- /dev/null
+++ b/contrib/win32/win32compat/inc/spawn.h
@@ -0,0 +1,77 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Declarations of POSIX spawn family of functions
+*/
+#pragma once
+#include "sys\types.h"
+
+#define POSIX_SPAWN_RESETIDS			0x1
+#define POSIX_SPAWN_SETPGROUP			0x2
+#define POSIX_SPAWN_SETSIGDEF			0x4
+#define POSIX_SPAWN_SETSIGMASK			0x8
+#define POSIX_SPAWN_SETSCHEDPARAM		0x10
+#define POSIX_SPAWN_SETSCHEDULER		0x20
+
+#define MAX_INHERITED_FDS  10
+typedef struct
+{	
+	/* stdio to be redirected*/
+	int stdio_redirect[3];
+	/* number of additinal fds to be duplicated/inherited*/
+	int num_aux_fds;
+	/* additional fds to be duplicated/inherited */
+	struct {
+		int parent_fd[MAX_INHERITED_FDS];
+		int child_fd[MAX_INHERITED_FDS];
+	}aux_fds_info;
+}posix_spawn_file_actions_t;
+
+typedef struct
+{
+	int flags;
+}posix_spawnattr_t;
+
+int
+posix_spawn(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]);
+
+int
+__posix_spawn_asuser(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], char* user);
+
+int
+posix_spawnp(pid_t *pidp, const char *file, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]);
+
+int
+posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions);
+
+int
+posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *file_actions);
+
+int
+posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes);
+
+int
+posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes);
+
+int
+posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *file_actions, int fildes, const char *path, int oflag, mode_t mode);
+
+int
+posix_spawnattr_init(posix_spawnattr_t *attr);
+
+int
+posix_spawnattr_destroy(posix_spawnattr_t *attr); 
+
+int
+posix_spawnattr_getflags(const posix_spawnattr_t *attr, short *flags);
+
+int
+posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags);
+
+int posix_spawnattr_getpgroup(const posix_spawnattr_t * attr, pid_t * pgroup);
+
+int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup);
+
+
+
+
diff --git a/contrib/win32/win32compat/inc/stdio.h b/contrib/win32/win32compat/inc/stdio.h
new file mode 100644
index 000000000..269ece845
--- /dev/null
+++ b/contrib/win32/win32compat/inc/stdio.h
@@ -0,0 +1,22 @@
+#include "crtheaders.h"
+#include STDIO_H
+
+/* stdio.h overrides */
+FILE* w32_fopen_utf8(const char *, const char *);
+#define fopen w32_fopen_utf8
+
+char* w32_fgets(char *str, int n, FILE *stream);
+#define fgets w32_fgets
+
+int w32_setvbuf(FILE *stream,char *buffer, int mode, size_t size);
+#define setvbuf w32_setvbuf
+
+/* stdio.h additional definitions */
+#define popen _popen
+#define pclose _pclose
+
+FILE* w32_fdopen(int fd, const char *mode);
+#define fdopen(a,b)	w32_fdopen((a), (b))
+
+int w32_rename(const char *old_name, const char *new_name);
+#define rename w32_rename
diff --git a/contrib/win32/win32compat/inc/stdlib.h b/contrib/win32/win32compat/inc/stdlib.h
new file mode 100644
index 000000000..1e42b9eed
--- /dev/null
+++ b/contrib/win32/win32compat/inc/stdlib.h
@@ -0,0 +1,9 @@
+#include "crtheaders.h"
+#include STDLIB_H
+
+#define environ _environ
+void freezero(void *, size_t);
+int setenv(const char *name, const char *value, int rewrite);
+#define system w32_system
+int w32_system(const char *command);
+char* realpath(const char *pathname, char *resolved);
diff --git a/contrib/win32/win32compat/inc/string.h b/contrib/win32/win32compat/inc/string.h
new file mode 100644
index 000000000..96e6783dc
--- /dev/null
+++ b/contrib/win32/win32compat/inc/string.h
@@ -0,0 +1,16 @@
+#include "crtheaders.h"
+#include STRING_H
+#include "utf.h"
+
+/* string.h overrides */
+#define strcasecmp _stricmp
+#define strncasecmp _strnicmp
+char *w32_strerror(int);
+#define strerror w32_strerror
+#define strdup _strdup
+#define ERROR_MSG_MAXLEN 94 /* https://msdn.microsoft.com/en-us/library/51sah927.aspx */
+
+static char errorBuf[ERROR_MSG_MAXLEN];
+
+char *strndup(const char*, size_t);
+char * strrstr(const char *, const char *);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/strings.h b/contrib/win32/win32compat/inc/strings.h
new file mode 100644
index 000000000..e0e5ac195
--- /dev/null
+++ b/contrib/win32/win32compat/inc/strings.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#define bzero(p,l) memset((void *)(p),0,(size_t)(l))
+
+void
+explicit_bzero(void *b, size_t len);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/sys/ioctl.h b/contrib/win32/win32compat/inc/sys/ioctl.h
new file mode 100644
index 000000000..9db1862aa
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/ioctl.h
@@ -0,0 +1,17 @@
+#ifndef COMPAT_IOCTL_H
+#define COMPAT_IOCTL_H 1
+
+
+/*ioctl macros and structs*/
+#define TIOCGWINSZ 1
+struct winsize {
+	unsigned short ws_row;          /* rows, in characters */
+	unsigned short ws_col;          /* columns, in character */
+	unsigned short ws_xpixel;       /* horizontal size, pixels */
+	unsigned short ws_ypixel;       /* vertical size, pixels */
+};
+
+int w32_ioctl(int d, int request, ...);
+#define ioctl w32_ioctl
+
+#endif
diff --git a/contrib/win32/win32compat/inc/sys/param.h b/contrib/win32/win32compat/inc/sys/param.h
new file mode 100644
index 000000000..6f70f09be
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/param.h
@@ -0,0 +1 @@
+#pragma once
diff --git a/contrib/win32/win32compat/inc/sys/resource.h b/contrib/win32/win32compat/inc/sys/resource.h
new file mode 100644
index 000000000..68799dea4
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/resource.h
@@ -0,0 +1,6 @@
+#ifndef COMPAT_RESOURCE_H
+#define COMPAT_RESOURCE_H 1
+
+/* Compatibility header to avoid lots of #ifdef _WIN32's in includes.h */
+
+#endif
diff --git a/contrib/win32/win32compat/inc/sys/select.h b/contrib/win32/win32compat/inc/sys/select.h
new file mode 100644
index 000000000..6996f5f6d
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/select.h
@@ -0,0 +1,34 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* POSIX header and needed function definitions 
+*/
+#pragma once
+
+/* total fds that can be allotted */
+#define MAX_FDS 256  /* a 2^n number */
+
+typedef struct w32_fd_set_ {
+	unsigned char bitmap[MAX_FDS >> 3];
+}w32_fd_set;
+
+#define fd_set w32_fd_set
+
+#undef FD_ZERO
+#define FD_ZERO(set) (memset( (set), 0, sizeof(w32_fd_set)))
+#undef FD_SET
+#define FD_SET(fd,set) ( (set)->bitmap[(fd) >> 3] |= (0x80 >> ((fd) % 8)))
+#undef FD_ISSET
+#define FD_ISSET(fd, set) (( (set)->bitmap[(fd) >> 3] & (0x80 >> ((fd) % 8)))?1:0)
+#undef FD_CLR
+#define FD_CLR(fd, set) ((set)->bitmap[(fd) >> 3] &= (~(0x80 >> ((fd) % 8))))
+
+#undef FD_SETSIZE
+#define FD_SETSIZE MAX_FDS
+
+int w32_select(int fds, w32_fd_set * , w32_fd_set * , w32_fd_set * ,
+	const struct timeval *);
+#define select(a,b,c,d,e)	w32_select((a), (b), (c), (d), (e))
+
+
+
diff --git a/contrib/win32/win32compat/inc/sys/socket.h b/contrib/win32/win32compat/inc/sys/socket.h
new file mode 100644
index 000000000..d12966466
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/socket.h
@@ -0,0 +1,75 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* POSIX header and needed function definitions
+*/
+
+#pragma once
+#include <WinSock2.h>
+#include <WS2tcpip.h>
+
+/* Shutdown constants */
+#define SHUT_WR SD_SEND
+#define SHUT_RD SD_RECEIVE
+#define SHUT_RDWR SD_BOTH
+
+/* Other constants */
+#define IN_LOOPBACKNET	127 /* 127.* is the loopback network */
+#define MAXHOSTNAMELEN	64
+
+#define EPFNOSUPPORT	        WSAEPFNOSUPPORT
+
+/*network i/o*/
+int w32_socket(int domain, int type, int protocol);
+#define socket(a,b,c)		w32_socket((a), (b), (c))
+
+int w32_accept(int fd, struct sockaddr* addr, int* addrlen);
+#define accept(a,b,c)		w32_accept((a), (b), (c))
+
+int w32_setsockopt(int fd, int level, int optname, const void* optval, int optlen);
+#define setsockopt(a,b,c,d,e)	w32_setsockopt((a), (b), (c), (d), (e))
+
+int w32_getsockopt(int fd, int level, int optname, void* optval, int* optlen);
+#define getsockopt(a,b,c,d,e)	w32_getsockopt((a), (b), (c), (d), (e))
+
+int w32_getsockname(int fd, struct sockaddr* name, int* namelen);
+#define getsockname(a,b,c)	w32_getsockname((a), (b), (c))
+
+int w32_getpeername(int fd, struct sockaddr* name, int* namelen);
+#define getpeername(a,b,c)	w32_getpeername((a), (b), (c))
+
+int w32_listen(int fd, int backlog);
+#define listen(a,b)		    w32_listen((a), (b))
+
+int w32_bind(int fd, const struct sockaddr *name, int namelen);
+#define bind(a,b,c)		    w32_bind((a), (b), (c))
+
+int w32_connect(int fd, const struct sockaddr* name, int namelen);
+#define connect(a,b,c)		w32_connect((a), (b), (c))
+
+int w32_recv(int fd, void *buf, size_t len, int flags);
+#define recv(a,b,c,d)		w32_recv((a), (b), (c), (d))
+
+int w32_send(int fd, const void *buf, size_t len, int flags);
+#define send(a,b,c,d)		w32_send((a), (b), (c), (d))
+
+int w32_shutdown(int fd, int how);
+#define shutdown(a,b)		w32_shutdown((a), (b))
+
+int w32_socketpair(int domain, int type, int protocol, int sv[2]);
+#define socketpair(a,b,c,d)	w32_socketpair((a), (b), (c), (d))
+
+void w32_freeaddrinfo(struct addrinfo *);
+#define freeaddrinfo        w32_freeaddrinfo
+
+int w32_getaddrinfo(const char *, const char *,
+	const struct addrinfo *, struct addrinfo **);
+#define getaddrinfo         w32_getaddrinfo
+
+struct w32_pollfd {
+	int  fd;
+	short   events;
+	short   revents;
+};
+#define pollfd w32_pollfd
+
diff --git a/contrib/win32/win32compat/inc/sys/stat.h b/contrib/win32/win32compat/inc/sys/stat.h
new file mode 100644
index 000000000..5e654fa70
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/stat.h
@@ -0,0 +1,62 @@
+#pragma once
+#include "..\crtheaders.h"
+#include "types.h"
+#include SYS_STAT_H
+
+#define _S_IFLNK  0xA000 // symbolic link
+#define _S_IFSOCK 0xC000 // socket
+
+#define S_IFMT   _S_IFMT
+#define S_IFDIR  _S_IFDIR
+#define S_IFCHR  _S_IFCHR
+#define S_IFREG  _S_IFREG
+#define S_IREAD  _S_IREAD
+#define S_IWRITE _S_IWRITE
+#define S_IEXEC  _S_IEXEC
+#define S_IFLNK  _S_IFLNK
+#define S_IFSOCK _S_IFSOCK
+
+# define S_ISUID            0x800 
+# define S_ISGID            0x400
+
+#define READ_PERMISSIONS (FILE_READ_DATA | FILE_READ_ATTRIBUTES | FILE_READ_EA)
+#define WRITE_PERMISSIONS (FILE_WRITE_DATA | FILE_APPEND_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA)
+#define EXECUTE_PERMISSIONS (READ_PERMISSIONS | FILE_EXECUTE)
+
+int w32_fstat(int fd, struct w32_stat *buf);
+#define fstat(a,b)	w32_fstat((a), (b))
+
+int w32_stat(const char *path, struct w32_stat *buf);
+#define stat w32_stat
+
+int w32_lstat(const char *path, struct w32_stat *buf);
+#define lstat w32_lstat
+
+int w32_mkdir(const char *pathname, unsigned short mode);
+#define mkdir w32_mkdir
+
+int w32_chmod(const char *, mode_t);
+#define chmod w32_chmod
+
+int w32_fchmod(int fd, mode_t mode);
+#define fchmod w32_fchmod
+
+
+struct w32_stat {
+	dev_t     st_dev;     /* ID of device containing file */
+	unsigned short     st_ino;     /* inode number */
+	unsigned short    st_mode;    /* protection */
+	short    st_nlink;   /* number of hard links */
+	short     st_uid;     /* user ID of owner */
+	short     st_gid;     /* group ID of owner */
+	dev_t     st_rdev;    /* device ID (if special file) */
+	__int64     st_size;    /* total size, in bytes */
+	__int64    st_atime;   /* time of last access */
+	__int64    st_mtime;   /* time of last modification */
+	__int64    st_ctime;   /* time of last status change */
+};
+
+
+void strmode(mode_t mode, char *p);
+
+int get_others_file_permissions(wchar_t * file_name, int isReadOnlyFile);
diff --git a/contrib/win32/win32compat/inc/sys/statvfs.h b/contrib/win32/win32compat/inc/sys/statvfs.h
new file mode 100644
index 000000000..8f14361a9
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/statvfs.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#define ST_RDONLY	1
+#define ST_NOSUID	2
+typedef unsigned long fsblkcnt_t;
+typedef unsigned long fsfilcnt_t;
+
+struct statvfs {
+	unsigned long f_bsize;	/* File system block size. */
+	unsigned long f_frsize;	/* Fundamental file system block size. */
+	fsblkcnt_t f_blocks;	/* Total number of blocks on file system in */
+				/* units of f_frsize. */
+	fsblkcnt_t    f_bfree;	/* Total number of free blocks. */
+	fsblkcnt_t    f_bavail;	/* Number of free blocks available to  */
+				/* non-privileged process.  */
+	fsfilcnt_t    f_files;	/* Total number of file serial numbers. */
+	fsfilcnt_t    f_ffree;	/* Total number of free file serial numbers. */
+	fsfilcnt_t    f_favail;	/* Number of file serial numbers available to */
+				/* non-privileged process. */
+	unsigned long f_fsid;	/* File system ID. */
+	unsigned long f_flag;	/* BBit mask of f_flag values. */
+	unsigned long f_namemax;/*  Maximum filename length. */
+};
+
+int statvfs(const char *, struct statvfs *);
+int fstatvfs(int, struct statvfs *);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/sys/time.h b/contrib/win32/win32compat/inc/sys/time.h
new file mode 100644
index 000000000..9d1b1ee10
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/time.h
@@ -0,0 +1,9 @@
+#include <sys\utime.h>
+
+#define utimbuf _utimbuf
+#define utimes w32_utimes
+
+int usleep(unsigned int);
+int gettimeofday(struct timeval *, void *);
+int nanosleep(const struct timespec *, struct timespec *);
+int w32_utimes(const char *, struct timeval *);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/sys/types.h b/contrib/win32/win32compat/inc/sys/types.h
new file mode 100644
index 000000000..b3919f664
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/types.h
@@ -0,0 +1,24 @@
+#define __STDC__ 1
+#include "..\crtheaders.h"
+#include SYS_TYPES_H
+
+typedef _dev_t dev_t;
+typedef long long off_t;
+typedef unsigned int uid_t;
+typedef unsigned int gid_t;
+
+typedef unsigned short _mode_t;
+typedef _mode_t mode_t;
+typedef int ssize_t;
+typedef int pid_t;
+
+typedef unsigned int	nfds_t;
+
+/* copied from Windows SDK corecrt_wstdio.h to accomodate FILE definition via types.h in Unix */
+#ifndef _FILE_DEFINED
+#define _FILE_DEFINED
+typedef struct _iobuf
+{
+	void* _Placeholder;
+} FILE;
+#endif
diff --git a/contrib/win32/win32compat/inc/sys/uio.h b/contrib/win32/win32compat/inc/sys/uio.h
new file mode 100644
index 000000000..2ce48ba12
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/uio.h
@@ -0,0 +1,7 @@
+#pragma once
+
+struct iovec
+{
+	void *iov_base;
+	size_t iov_len;
+};
diff --git a/contrib/win32/win32compat/inc/sys/un.h b/contrib/win32/win32compat/inc/sys/un.h
new file mode 100644
index 000000000..42f09b8ce
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/un.h
@@ -0,0 +1,7 @@
+#pragma once
+
+struct	sockaddr_un {
+	short	sun_family;		/* AF_UNIX */
+	char	sun_path[108];		/* path name (gag) */
+};
+
diff --git a/contrib/win32/win32compat/inc/sys/wait.h b/contrib/win32/win32compat/inc/sys/wait.h
new file mode 100644
index 000000000..0ae600d71
--- /dev/null
+++ b/contrib/win32/win32compat/inc/sys/wait.h
@@ -0,0 +1,21 @@
+#pragma once
+
+//#define _W_INT(w)	(*(int*)&(w))	/* convert union wait to int */
+//#define WIFEXITED(w)	(!((_W_INT(w)) & 0377))
+//#define WIFSTOPPED(w)	((_W_INT(w)) & 0100)
+//#define WIFSIGNALED(w)	(!WIFEXITED(w) && !WIFSTOPPED(w))
+//#define WEXITSTATUS(w)	(int)(WIFEXITED(w) ? ((_W_INT(w) >> 8) & 0377) : -1)
+//#define WTERMSIG(w)	(int)(WIFSIGNALED(w) ? (_W_INT(w) & 0177) : -1)
+
+#define WIFEXITED(w)	TRUE
+#define WIFSTOPPED(w)	TRUE
+#define WIFSIGNALED(w)	FALSE
+#define WEXITSTATUS(w)	w
+#define WTERMSIG(w)	-1
+#define WNOHANG 1
+#define WUNTRACED 2
+
+/* wait pid options */
+#define WNOHANG 1
+
+int waitpid(int pid, int *status, int options);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/syslog.h b/contrib/win32/win32compat/inc/syslog.h
new file mode 100644
index 000000000..6d8fd9a46
--- /dev/null
+++ b/contrib/win32/win32compat/inc/syslog.h
@@ -0,0 +1,28 @@
+#pragma once
+
+
+/* Compatibility header to give us some syslog-like functionality on Win32 */
+
+#define LOG_CRIT	(2)				/* critical */
+#define LOG_ERR		(3)				/* errors */
+#define LOG_WARNING	(4)				/* warnings */
+#define	LOG_INFO	(6)				/* informational */
+#define LOG_DEBUG	(7)				/* debug messages */
+#define LOG_USER	(1 << 3)		/* user level messages */
+#define LOG_DAEMON	(3 << 3)		/* daemons/servers */
+#define LOG_AUTH	(4 << 3)		/* security messages */
+#define LOG_LOCAL0	(16 << 3)		/* reserved for local use */
+#define LOG_LOCAL1	(17 << 3)		/* reserved for local use */
+#define LOG_LOCAL2	(18 << 3)		/* reserved for local use */
+#define LOG_LOCAL3	(19 << 3)		/* reserved for local use */
+#define LOG_LOCAL4	(20 << 3)		/* reserved for local use */
+#define LOG_LOCAL5	(21 << 3)		/* reserved for local use */
+#define LOG_LOCAL6	(22 << 3)		/* reserved for local use */
+#define LOG_LOCAL7	(23 << 3)		/* reserved for local use */
+
+#define LOG_PID		0x01			/* log the pid */
+
+void openlog	(const char *, unsigned int, int);
+void closelog	(void);
+void syslog		(int, const char *, const char *);
+
diff --git a/contrib/win32/win32compat/inc/termios.h b/contrib/win32/win32compat/inc/termios.h
new file mode 100644
index 000000000..9d961dbd8
--- /dev/null
+++ b/contrib/win32/win32compat/inc/termios.h
@@ -0,0 +1,110 @@
+#ifndef COMPAT_TERMIOS_H
+#define COMPAT_TERMIOS_H 1
+
+#define B0	    0x00000000
+#define B50	    0x00000001
+#define B75	    0x00000002
+#define B110	0x00000003
+#define B134	0x00000004
+#define B150	0x00000005
+#define B200	0x00000006
+#define B300	0x00000007
+#define B600	0x00000008
+#define B1200	0x00000009
+#define B1800	0x0000000a
+#define B2400	0x0000000b
+#define B4800	0x0000000c
+#define B9600	0x0000000d
+#define B19200	0x0000000e
+#define B38400	0x0000000f
+
+#define BRKINT	0x00000100
+#define ICRNL	0x00000200
+#define IGNBRK	0x00000400
+#define IGNCR	0x00000800
+#define IGNPAR	0x00001000
+#define INLCR	0x00002000
+#define INPCK	0x00004000
+#define ISTRIP	0x00008000
+#define IXOFF	0x00010000
+#define IXON	0x00020000
+#define PARMRK	0x00040000
+#ifndef _POSIX_SOURCE
+#define	IXANY	0x00000800	/* any char will restart after stop */
+#define IMAXBEL	0x00002000	/* ring bell on input queue full */
+#endif  /*_POSIX_SOURCE */
+
+#define OPOST	0x00000100
+
+#define CLOCAL	0x00000100
+#define CREAD	0x00000200
+#define CS5	0x00000000
+#define CS6	0x00000400
+#define CS7	0x00000800
+#define CS8	0x00000c00
+#define CSIZE	0x00000c00
+#define CSTOPB	0x00001000
+#define HUPCL	0x00002000
+#define PARENB	0x00004000
+#define PARODD	0x00008000
+
+#define ECHO	0x00000100
+#define ECHOE	0x00000200
+#define ECHOK	0x00000400
+#define ECHONL	0x00000800
+#define ICANON	0x00001000
+#define IEXTEN	0x00002000
+#define ISIG	0x00004000
+#define NOFLSH	0x00008000
+#define TOSTOP	0x00010000
+
+#define TCIFLUSH	1
+#define TCOFLUSH	2
+#define TCIOFLUSH	3
+#define TCOOFF		1
+#define TCOON		2
+#define TCIOFF		3
+#define TCION		4
+
+#define TCSADRAIN	1
+#define TCSAFLUSH	2
+#define TCSANOW		3
+
+/* Compatibility header to allow some termios functionality to compile without #ifdefs */
+
+#define VDISCARD	1
+#define VEOL		2
+#define VEOL2		3
+#define VEOF		4
+#define VERASE		5
+#define VINTR		6
+#define VKILL		7
+#define VLNEXT		8
+#define VMIN		9
+#define VQUIT		10
+#define VREPRINT	11
+#define VSTART		12
+#define VSTOP		13
+#define VSUSP		14
+#define VSWTC		15
+#define VTIME		16
+#define VWERASE		17
+#define NCCS		18
+
+typedef unsigned char cc_t;
+typedef unsigned int  tcflag_t;
+typedef unsigned int  speed_t;
+
+struct termios
+{
+  tcflag_t	c_iflag;
+  tcflag_t	c_oflag;
+  tcflag_t	c_cflag;
+  tcflag_t	c_lflag;
+  char		c_line;
+  cc_t		c_cc[NCCS];
+  speed_t	c_ispeed;
+  speed_t	c_ospeed;
+};
+
+#endif
diff --git a/contrib/win32/win32compat/inc/time.h b/contrib/win32/win32compat/inc/time.h
new file mode 100644
index 000000000..80c469310
--- /dev/null
+++ b/contrib/win32/win32compat/inc/time.h
@@ -0,0 +1,9 @@
+#include "crtheaders.h"
+#include TIME_H
+
+#define localtime w32_localtime
+#define ctime w32_ctime
+
+struct tm *localtime_r(const time_t *, struct tm *);
+struct tm *w32_localtime(const time_t* sourceTime);
+char *w32_ctime(const time_t* sourceTime);
diff --git a/contrib/win32/win32compat/inc/unistd.h b/contrib/win32/win32compat/inc/unistd.h
new file mode 100644
index 000000000..85d9a6c24
--- /dev/null
+++ b/contrib/win32/win32compat/inc/unistd.h
@@ -0,0 +1,110 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* POSIX header and needed function definitions
+*/
+#pragma once
+#include <stddef.h>
+#include "sys\types.h"
+#include "fcntl.h"
+#include "spawn.h"
+
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
+#define SFTP_SERVER_LOG_FD STDERR_FILENO+1
+
+int w32_ftruncate(int, off_t);
+#define ftruncate(a, b) w32_ftruncate((a), (b))
+
+#define pipe w32_pipe
+int w32_pipe(int *pfds);
+
+#define read w32_read
+int w32_read(int fd, void *dst, size_t max);
+
+#define write w32_write
+int w32_write(int fd, const void *buf, size_t max);
+
+#define writev w32_writev
+int w32_writev(int fd, const struct iovec *iov, int iovcnt);
+
+int w32_isatty(int fd);
+/* can't do this #define isatty w32_isatty
+* as there is a variable in code named isatty*/
+#define isatty(a)	w32_isatty((a))
+
+int w32_close(int fd);
+#define close w32_close
+
+int w32_dup(int oldfd);
+#define dup w32_dup
+
+int w32_dup2(int oldfd, int newfd);
+#define dup2 w32_dup2
+
+#define sleep(sec) Sleep(1000 * sec)
+
+unsigned int w32_alarm(unsigned int seconds);
+#define alarm w32_alarm
+
+long w32_lseek(int fd, unsigned __int64 offset, int origin);
+#define lseek w32_lseek
+
+#define getdtablesize() MAX_FDS
+
+int w32_gethostname(char *, size_t);
+#define gethostname w32_gethostname
+
+int w32_fsync(int fd);
+#define fsync(a) w32_fsync((a))
+
+int w32_symlink(const char *target, const char *linkpath);
+#define symlink w32_symlink
+
+int w32_chown(const char *pathname, unsigned int owner, unsigned int group);
+#define chown w32_chown
+
+int w32_fchown(int fd, unsigned int owner, unsigned int group);
+#define fchown w32_fchown
+
+int w32_unlink(const char *path);
+#define unlink w32_unlink
+
+int w32_rmdir(const char *pathname);
+#define rmdir w32_rmdir
+
+int w32_chdir(const char *dirname);
+#define chdir w32_chdir
+
+char *w32_getcwd(char *buffer, int maxlen);
+#define getcwd w32_getcwd
+
+int w32_readlink(const char *path, char *link, int linklen);
+#define readlink w32_readlink
+
+int w32_link(const char *oldpath, const char *newpath);
+#define link w32_link
+
+int getpeereid(int, uid_t*, gid_t*);
+
+int daemon(int nochdir, int noclose);
+char *crypt(const char *key, const char *salt);
+int chroot(const char *path);
+
+/* 
+ * readpassphrase.h definitions 
+ * cannot create a separate header due to the way
+ * its included in openbsdcompat.h
+ */
+
+#define RPP_ECHO_OFF    0x00		/* Turn off echo (default). */
+#define RPP_ECHO_ON     0x01		/* Leave echo on. */
+#define RPP_REQUIRE_TTY 0x02		/* Fail if there is no tty. */
+#define RPP_FORCELOWER  0x04		/* Force input to lower case. */
+#define RPP_FORCEUPPER  0x08		/* Force input to upper case. */
+#define RPP_SEVENBIT    0x10		/* Strip the high bit from input. */
+#define RPP_STDIN       0x20		/* Read from stdin, not /dev/tty */
+
+char * readpassphrase(const char *, char *, size_t, int);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/inc/utf.h b/contrib/win32/win32compat/inc/utf.h
new file mode 100644
index 000000000..2feab1447
--- /dev/null
+++ b/contrib/win32/win32compat/inc/utf.h
@@ -0,0 +1,13 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* UTF-16 <--> UTF-8 definitions
+*/
+#pragma once
+#ifndef UTF_H
+#define UTF_H 1
+
+wchar_t* utf8_to_utf16(const char *);
+char* utf16_to_utf8(const wchar_t*);
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/libwin32compat.q b/contrib/win32/win32compat/libwin32compat.q
new file mode 100644
index 000000000..8b277f0dd
--- /dev/null
+++ b/contrib/win32/win32compat/libwin32compat.q
@@ -0,0 +1 @@
+!<arch>
diff --git a/contrib/win32/win32compat/lsa_missingdefs.h b/contrib/win32/win32compat/lsa_missingdefs.h
new file mode 100644
index 000000000..87472fcfd
--- /dev/null
+++ b/contrib/win32/win32compat/lsa_missingdefs.h
@@ -0,0 +1,55 @@
+/*
+* Missing public definitions from Ntsecapi.h
+*/
+
+
+typedef enum _LSA_SID_NAME_MAPPING_OPERATION_TYPE {
+	LsaSidNameMappingOperation_Add,
+	LsaSidNameMappingOperation_Remove,
+	LsaSidNameMappingOperation_AddMultiple,
+} LSA_SID_NAME_MAPPING_OPERATION_TYPE, *PLSA_SID_NAME_MAPPING_OPERATION_TYPE;
+
+typedef enum _LSA_SID_NAME_MAPPING_OPERATION_ERROR {
+	LsaSidNameMappingOperation_Success,
+	LsaSidNameMappingOperation_NonMappingError,
+	LsaSidNameMappingOperation_NameCollision,
+	LsaSidNameMappingOperation_SidCollision,
+	LsaSidNameMappingOperation_DomainNotFound,
+	LsaSidNameMappingOperation_DomainSidPrefixMismatch,
+	LsaSidNameMappingOperation_MappingNotFound,
+} LSA_SID_NAME_MAPPING_OPERATION_ERROR, *PLSA_SID_NAME_MAPPING_OPERATION_ERROR;
+
+typedef struct _LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT {
+	UNICODE_STRING      DomainName;
+	UNICODE_STRING      AccountName;
+	PSID		    Sid;
+	ULONG               Flags;
+} LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT;
+
+typedef struct _LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT {
+	UNICODE_STRING  DomainName;
+	UNICODE_STRING  AccountName;
+} LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT;
+
+typedef union _LSA_SID_NAME_MAPPING_OPERATION_INPUT {
+	LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT            AddInput;
+	LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT         RemoveInput;
+} LSA_SID_NAME_MAPPING_OPERATION_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_INPUT;
+
+typedef struct _LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT {
+	LSA_SID_NAME_MAPPING_OPERATION_ERROR    ErrorCode;
+} LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT;
+
+typedef LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT LSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT;
+typedef LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT LSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT;
+
+typedef union _LSA_SID_NAME_MAPPING_OPERATION_OUTPUT {
+	LSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT           AddOutput;
+	LSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT        RemoveOutput;
+} LSA_SID_NAME_MAPPING_OPERATION_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT;
+
+NTSTATUS WINAPI LsaManageSidNameMapping(
+	LSA_SID_NAME_MAPPING_OPERATION_TYPE    OpType,
+	PLSA_SID_NAME_MAPPING_OPERATION_INPUT  OpInput,
+	PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT *OpOutput
+);
diff --git a/contrib/win32/win32compat/misc.c b/contrib/win32/win32compat/misc.c
new file mode 100644
index 000000000..2467ddffe
--- /dev/null
+++ b/contrib/win32/win32compat/misc.c
@@ -0,0 +1,2163 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Author: Bryan Berns <berns@uwalumni.com>
+*   Modified group detection use s4u token information 
+*
+* Copyright(c) 2016 Microsoft Corp.
+* All rights reserved
+*
+* Misc Unix POSIX routine implementations for Windows
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#define UMDF_USING_NTSTATUS 
+#define SECURITY_WIN32
+#include <Windows.h>
+#include <stdio.h>
+#include <time.h>
+#include <Shlwapi.h>
+#include <conio.h>
+#include <LM.h>
+#include <Sddl.h>
+#include <Aclapi.h>
+#include <security.h>
+#include <ntstatus.h>
+#include <malloc.h>
+
+#include "inc\unistd.h"
+#include "inc\sys\stat.h"
+#include "inc\sys\statvfs.h"
+#include "inc\sys\time.h"
+#include "misc_internal.h"
+#include "inc\dlfcn.h"
+#include "inc\dirent.h"
+#include "inc\sys\types.h"
+#include "inc\sys\ioctl.h"
+#include "inc\fcntl.h"
+#include "inc\utf.h"
+#include "debug.h"
+#include "w32fd.h"
+#include "inc\string.h"
+#include "inc\time.h"
+#include "..\..\..\sshfileperm.h"
+
+#include <wchar.h>
+
+static char* s_programdir = NULL;
+
+/* Maximum reparse buffer info size. The max user defined reparse
+ * data is 16KB, plus there's a header. 
+ */
+#define MAX_REPARSE_SIZE 17000 
+#define IO_REPARSE_TAG_SYMBOLIC_LINK IO_REPARSE_TAG_RESERVED_ZERO 
+#define IO_REPARSE_TAG_MOUNT_POINT (0xA0000003L) /* winnt ntifs */
+#define IO_REPARSE_TAG_HSM (0xC0000004L) /* winnt ntifs */
+#define IO_REPARSE_TAG_SIS (0x80000007L) /* winnt ntifs */
+#define REPARSE_MOUNTPOINT_HEADER_SIZE 8
+
+ /* Difference in us between UNIX Epoch and Win32 Epoch */
+#define EPOCH_DELTA  116444736000000000ULL /* in 100 nsecs intervals */
+#define RATE_DIFF 10000000ULL /* 100 nsecs */
+
+#define NSEC_IN_SEC 1000000000ULL // 10**9
+#define USEC_IN_SEC 1000000ULL // 10**6
+
+/* Windows CRT defines error string messages only till 43 in errno.h
+ * This is an extended list that defines messages for EADDRINUSE through EWOULDBLOCK
+ */
+char* _sys_errlist_ext[] = {
+	"Address already in use",				/* EADDRINUSE      100 */
+	"Address not available",				/* EADDRNOTAVAIL   101 */
+	"Address family not supported",				/* EAFNOSUPPORT    102 */
+	"Connection already in progress",			/* EALREADY        103 */
+	"Bad message",						/* EBADMSG         104 */
+	"Operation canceled",					/* ECANCELED       105 */
+	"Connection aborted",					/* ECONNABORTED    106 */
+	"Connection refused",					/* ECONNREFUSED    107 */
+	"Connection reset",					/* ECONNRESET      108 */
+	"Destination address required",				/* EDESTADDRREQ    109 */
+	"Host is unreachable",					/* EHOSTUNREACH    110 */
+	"Identifier removed",					/* EIDRM           111 */
+	"Operation in progress",				/* EINPROGRESS     112 */
+	"Socket is connected",					/* EISCONN         113 */
+	"Too many levels of symbolic links",			/* ELOOP           114 */
+	"Message too long",					/* EMSGSIZE        115 */
+	"Network is down",					/* ENETDOWN        116 */
+	"Connection aborted by network",			/* ENETRESET       117 */
+	"Network unreachable",					/* ENETUNREACH     118 */
+	"No buffer space available",				/* ENOBUFS         119 */
+	"No message is available on the STREAM head read queue",/* ENODATA         120 */
+	"Link has been severed",				/* ENOLINK         121 */
+	"No message of the desired type",			/* ENOMSG          122 */
+	"Protocol not available",				/* ENOPROTOOPT     123 */
+	"No STREAM resources",					/* ENOSR           124 */
+	"Not a STREAM",						/* ENOSTR          125 */
+	"The socket is not connected",				/* ENOTCONN        126 */
+	"enotrecoverable",					/* ENOTRECOVERABLE 127 */
+	"Not a socket",						/* ENOTSOCK        128 */
+	"Operation not supported",				/* ENOTSUP         129 */
+	"Operation not supported on socket",			/* EOPNOTSUPP      130 */
+	"eother",						/* EOTHER          131 */
+	"Value too large to be stored in data type",		/* EOVERFLOW       132 */
+	"eownerdead",						/* EOWNERDEAD      133 */
+	"Protocol error",					/* EPROTO          134 */
+	"Protocol not supported",				/* EPROTONOSUPPORT 135 */
+	"Protocol wrong type for socket",			/* EPROTOTYPE      136 */
+	"Timer expired",					/* ETIME           137 */
+	"Connection timed out",					/* ETIMEDOUT       138 */
+	"Text file busy",					/* ETXTBSY         139 */
+	"Operation would block"					/* EWOULDBLOCK     140 */
+};
+
+/* chroot state */
+char* chroot_path = NULL;
+int chroot_path_len = 0;
+/* UTF-16 version of the above */
+wchar_t* chroot_pathw = NULL;
+
+int
+usleep(unsigned int useconds)
+{
+	Sleep(useconds / 1000);
+	return 1;
+}
+
+static LONGLONG
+timespec_to_nsec(const struct timespec *req)
+{
+	LONGLONG sec = req->tv_sec;
+	return sec * NSEC_IN_SEC + req->tv_nsec;
+}
+
+
+int
+nanosleep(const struct timespec *req, struct timespec *rem)
+{
+	HANDLE timer;
+	LARGE_INTEGER li;
+
+	if (req->tv_sec < 0 || req->tv_nsec < 0 || req->tv_nsec > 999999999) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	if ((timer = CreateWaitableTimerW(NULL, TRUE, NULL)) == NULL) {
+		errno = EFAULT;
+		return -1;
+	}
+
+	/* convert timespec to 100ns intervals */
+	li.QuadPart = -(timespec_to_nsec(req) / 100);
+	if (!SetWaitableTimer(timer, &li, 0, NULL, NULL, FALSE)) {
+		CloseHandle(timer);
+		errno = EFAULT;
+		return -1;
+	}
+
+	/* TODO - use wait_for_any_event, since we want to wake up on interrupts*/
+	switch (WaitForSingleObject(timer, INFINITE)) {
+	case WAIT_OBJECT_0:
+		CloseHandle(timer);
+		return 0;
+	default:
+		CloseHandle(timer);
+		errno = EFAULT;
+		return -1;
+	}
+}
+
+/* This routine is contributed by  * Author: NoMachine <developers@nomachine.com>
+ * Copyright (c) 2009, 2010 NoMachine
+ * All rights reserved
+ */
+static int
+gettimeofday(struct timeval *tv, void *tz)
+{
+	union {
+		FILETIME ft;
+		unsigned long long ns;
+	} timehelper;
+	unsigned long long us;
+
+	/* Fetch time since Jan 1, 1601 in 100ns increments */
+	GetSystemTimeAsFileTime(&timehelper.ft);	
+
+	/* Remove the epoch difference & convert 100ns to us */
+	us = (timehelper.ns - EPOCH_DELTA) / 10;
+
+	/* Stuff result into the timeval */
+	tv->tv_sec = (long)(us / USEC_IN_SEC);
+	tv->tv_usec = (long)(us % USEC_IN_SEC);
+
+	return 0;
+}
+
+static void
+explicit_bzero(void *b, size_t len)
+{
+	SecureZeroMemory(b, len);
+}
+
+static DWORD last_dlerror = ERROR_SUCCESS;
+
+HMODULE
+dlopen(const char *filename, int flags)
+{
+	wchar_t *wfilename = utf8_to_utf16(filename);
+	if (wfilename == NULL) {
+		last_dlerror = ERROR_INVALID_PARAMETER;
+		return NULL;
+	}
+
+	HMODULE module = LoadLibraryW(wfilename);
+	if (module == NULL)
+		last_dlerror = GetLastError();
+
+	free(wfilename);
+	return module;
+}
+
+int
+dlclose(HMODULE handle)
+{
+	FreeLibrary(handle);
+	return 0;
+}
+
+void *
+dlsym(HMODULE handle, const char *symbol)
+{
+	void *ptr = GetProcAddress(handle, symbol);
+	if (ptr == NULL)
+		last_dlerror = GetLastError();
+	return ptr;
+}
+
+char *
+dlerror()
+{
+	static char *message = NULL;
+	if (message != NULL) {
+		free(message);
+		message = NULL;
+	}
+	if (last_dlerror == ERROR_SUCCESS)
+		return NULL;
+
+	wchar_t *wmessage = NULL;
+	DWORD length = FormatMessageW(
+		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
+		NULL, last_dlerror, 0, (wchar_t *) &wmessage, 0, NULL);
+	last_dlerror = ERROR_SUCCESS;
+
+	if (length == 0)
+		goto error;
+
+	if (wmessage[length - 1] == L'\n')
+		wmessage[length - 1] = L'\0';
+	if (length > 1 && wmessage[length - 2] == L'\r')
+		wmessage[length - 2] = L'\0';
+
+	message = utf16_to_utf8(wmessage);
+	LocalFree(wmessage);
+
+	if (message == NULL)
+		goto error;
+
+	return message;
+
+error:
+	return "Failed to format error message";
+}
+
+/*fopen on Windows to mimic https://linux.die.net/man/3/fopen
+* only r, w, a, a+ are supported for now
+*/
+FILE *
+w32_fopen_utf8(const char *input_path, const char *mode)
+{
+	wchar_t *wmode = NULL, *wpath = NULL;
+	FILE* f = NULL;
+	char utf8_bom[] = { 0xEF,0xBB,0xBF };
+	char first3_bytes[3];
+	int status = 1;
+	errno_t r = 0;
+	int nonfs_dev = 0; /* opening a non file system device */
+
+	if (mode == NULL || (mode[1] != '\0' && strncmp(mode, "a+", 2) != 0)) {
+		errno = ENOTSUP;
+		return NULL;
+	}
+
+	if(NULL == input_path) { 
+		errno = EINVAL;
+		debug3("fopen - ERROR:%d", errno);
+		return NULL; 
+	}
+
+	/* if opening null device, point to Windows equivalent */
+	if (strncmp(input_path, NULL_DEVICE, sizeof(NULL_DEVICE)) == 0
+		|| strncmp(input_path, NULL_DEVICE_WIN, sizeof(NULL_DEVICE_WIN)) == 0) {
+		nonfs_dev = 1;
+		wpath = utf8_to_utf16(NULL_DEVICE_WIN);
+	}
+	else
+		wpath = resolved_path_utf16(input_path);
+	
+	wmode = utf8_to_utf16(mode);
+	if (wpath == NULL || wmode == NULL)
+		goto cleanup;
+
+	if ((_wfopen_s(&f, wpath, wmode) != 0) || (f == NULL)) {
+		debug3("Failed to open file:%S error:%d", wpath, errno);
+		goto cleanup;
+	}	
+
+	if (chroot_pathw && !nonfs_dev) {
+		/* ensure final path is within chroot */
+		HANDLE h = (HANDLE)_get_osfhandle(_fileno(f));
+		if (!file_in_chroot_jail(h)) {
+			debug3("%s is not in chroot jail", input_path);
+			fclose(f);
+			f = NULL;
+			errno = EACCES;
+			goto cleanup;
+		}
+	}
+
+	/* BOM adjustments for file streams*/
+	if (mode[0] == 'w' && fseek(f, 0, SEEK_SET) != EBADF) {
+		/* write UTF-8 BOM - should we ?*/
+		/*if (fwrite(utf8_bom, sizeof(utf8_bom), 1, f) != 1) {
+			fclose(f);
+			goto cleanup;
+		}*/
+
+	} else if (mode[0] == 'r' && fseek(f, 0, SEEK_SET) != EBADF) {
+		/* read out UTF-8 BOM if present*/
+		if (fread(first3_bytes, 3, 1, f) != 1 ||
+			memcmp(first3_bytes, utf8_bom, 3) != 0) {
+			fseek(f, 0, SEEK_SET);
+		}
+	}
+
+cleanup:
+
+	if (wpath) 
+		free(wpath);
+	if (wmode)
+		free(wmode);
+
+	return f;
+}
+
+/*
+* fgets to support Unicode input 
+* each UTF-16 char may bloat up to 4 utf-8 chars. We cannot determine if the length of 
+* input unicode string until it is readed and converted to utf8 string.
+* There is a risk to miss on unicode char when last unicode char read from console
+* does not fit the remain space in str. use cautiously. 
+*/
+char*
+ w32_fgets(char *str, int n, FILE *stream) {
+	if (!str || !n || !stream) return NULL;
+
+	HANDLE h = (HANDLE)_get_osfhandle(_fileno(stream));
+	wchar_t* str_w = NULL;
+	char *ret = NULL, *str_tmp = NULL, *cp = NULL;
+	int actual_read = 0;
+	errno_t r = 0;
+
+	if (h != NULL && h != INVALID_HANDLE_VALUE
+	    && GetFileType(h) == FILE_TYPE_CHAR) {
+
+		/* Allocate memory for one UTF-16 char (up to 4 bytes) and a terminate char (\0) */
+		if ((str_w = malloc(3 * sizeof(wchar_t))) == NULL) {
+			errno = ENOMEM;
+			goto cleanup;
+		}
+		/* prepare for Unicode input */
+		_setmode(_fileno(stream), O_U16TEXT);
+		cp = str;
+		/*
+		* each UTF-16 char may bloat up to 4 utf-8 chars
+		* read one wide chars at time from console and convert it to utf8
+		* stop reading until reach '\n' or the converted utf8 string length is n-1
+		*/
+		do {
+			if (str_tmp) {
+				free(str_tmp);
+				str_tmp = NULL;
+			}
+			if (fgetws(str_w, 2, stream) == NULL)
+				goto cleanup;
+			if ((str_tmp = utf16_to_utf8(str_w)) == NULL) {
+				debug3("utf16_to_utf8 failed!");
+				errno = ENOMEM;
+				goto cleanup;
+			}
+			
+			if((actual_read + (int)strlen(str_tmp)) >= n)
+				break;
+			if ((r = memcpy_s(cp, n - actual_read, str_tmp, strlen(str_tmp))) != 0) {
+				debug3("memcpy_s failed with error: %d.", r);
+				goto cleanup;
+			}
+			actual_read += (int)strlen(str_tmp);
+			cp += strlen(str_tmp);
+			
+		} while ((actual_read < n - 1) && *str_tmp != '\n');
+		*cp = '\0';
+
+		if (actual_read > n - 1) {
+			/* shouldn't happen. but handling in case */
+			debug3("actual_read %d exceeds the limit:%d", actual_read, n-1);
+			errno = EINVAL;
+			goto cleanup;
+		}		
+		ret = str;
+	}
+	else
+		ret = fgets(str, n, stream);
+cleanup:
+	if (str_w)
+		free(str_w);
+	if (str_tmp)
+		free(str_tmp);
+	return ret;
+}
+
+/* Account for differences between Unix's and Windows versions of setvbuf */
+int 
+w32_setvbuf(FILE *stream, char *buffer, int mode, size_t size) {
+	
+	/* BUG: setvbuf on console stream interferes with Unicode I/O	*/
+	HANDLE h = (HANDLE)_get_osfhandle(_fileno(stream));
+	
+	if (h != NULL && h != INVALID_HANDLE_VALUE
+	    && GetFileType(h) == FILE_TYPE_CHAR)
+		return 0;
+
+	/* BUG: setvbuf on file stream is interfering with w32_fopen */
+	/* short circuit for now*/
+	return 0;
+
+	/*
+	 * if size is 0, set no buffering. 
+	 * Windows does not differentiate __IOLBF and _IOFBF
+	 */
+	if (size == 0)
+		return setvbuf(stream, NULL, _IONBF, 0);
+	else
+		return setvbuf(stream, buffer, mode, size);
+}
+
+int
+daemon(int nochdir, int noclose)
+{
+	FreeConsole();
+	return 0;
+}
+
+int
+w32_ioctl(int d, int request, ...)
+{
+	va_list valist;
+	va_start(valist, request);
+
+	switch (request) {
+	case TIOCGWINSZ: {
+		struct winsize* wsize = va_arg(valist, struct winsize*);
+		CONSOLE_SCREEN_BUFFER_INFO c_info;
+		if (wsize == NULL || !GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &c_info)) {
+			errno = EINVAL;
+			return -1;
+		}
+
+		wsize->ws_col = c_info.dwSize.X;
+		wsize->ws_row = c_info.srWindow.Bottom - c_info.srWindow.Top + 1;
+		wsize->ws_xpixel = 640;
+		wsize->ws_ypixel = 480;
+
+		return 0;
+	}
+	default:
+		errno = ENOTSUP;
+		return -1;
+	}
+}
+
+/* p should be at least 12 bytes long*/
+void
+strmode(mode_t mode, char *p)
+{
+	/* print type */
+	switch (mode & S_IFMT) {
+	case S_IFDIR:			/* directory */
+		*p++ = 'd';
+		break;
+	case S_IFCHR:			/* character special */
+		*p++ = 'c';
+		break;
+	case S_IFREG:			/* regular */
+		*p++ = '-';
+		break;
+	case S_IFLNK:			/* symbolic link */
+		*p++ = 'l';
+		break;			
+#ifdef S_IFSOCK
+	case S_IFSOCK:			/* socket */
+		*p++ = 's';
+		break;
+#endif
+	case _S_IFIFO:			/* fifo */
+		*p++ = 'p';
+		break;
+	default:			/* unknown */
+		*p++ = '?';
+		break;
+	}
+
+	/* group, other are not applicable on the windows */
+
+	/* usr */
+	if (mode & S_IREAD)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWRITE)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	if (mode & S_IEXEC)
+		*p++ = 'x';
+	else
+		*p++ = '-';
+
+	const char *permissions = "****** ";	
+	for(int i = 0; i < (int)strlen(permissions); i++)
+		*p++ = permissions[i];
+	
+	*p = '\0';
+}
+
+int
+w32_chmod(const char *pathname, mode_t mode)
+{
+	/* TODO - 
+	 * _wchmod() doesn't behave like unix "chmod" command.
+	 * _wchmod() only toggles the read-only bit and it doesn't touch ACL.
+	 */	
+	int ret;
+	wchar_t *resolvedPathName_utf16 = resolved_path_utf16(pathname);
+	if (resolvedPathName_utf16 == NULL) 
+		return -1;
+
+	ret = _wchmod(resolvedPathName_utf16, mode);
+	free(resolvedPathName_utf16);
+	return ret;
+}
+
+int
+w32_chown(const char *pathname, unsigned int owner, unsigned int group)
+{
+	/* TODO - implement this */
+	errno = EOPNOTSUPP;
+	return -1;
+}
+
+int 
+w32_fchown( int fd, unsigned int owner, unsigned int group)
+{
+	/* TODO - implement this */
+	errno = EOPNOTSUPP;
+	return -1;
+}
+
+/* Convert a UNIX time into a Windows file time */
+void
+unix_time_to_file_time(ULONG t, LPFILETIME pft)
+{
+	ULONGLONG ull;
+	ull = UInt32x32To64(t, RATE_DIFF) + EPOCH_DELTA;
+
+	pft->dwLowDateTime = (DWORD)ull;
+	pft->dwHighDateTime = (DWORD)(ull >> 32);
+}
+
+/* Convert a Windows file time into a UNIX time_t */
+void
+file_time_to_unix_time(const LPFILETIME pft, time_t * winTime)
+{
+	*winTime = ((long long)pft->dwHighDateTime << 32) + pft->dwLowDateTime;
+	*winTime -= EPOCH_DELTA;
+	*winTime /= RATE_DIFF;		 /* Nano to seconds resolution */
+}
+
+static BOOL
+is_root_or_empty(wchar_t * path)
+{
+	wchar_t * path_start;
+	int len;
+	if (!path) 
+		return FALSE;
+	len = (int)wcslen(path);
+	if((len > 1) && __ascii_iswalpha(path[0]) && path[1] == L':')
+		path_start = path + 2;
+	else
+		path_start = path;
+	/*path like  c:\, /, \ are root directory*/
+	if ((*path_start == L'\0') || ((*path_start == L'\\' || *path_start == L'/' ) && path_start[1] == L'\0'))
+		return TRUE;
+	return FALSE;
+}
+
+static BOOL
+has_executable_extension(wchar_t * path)
+{
+	wchar_t * last_dot;
+	if (!path)
+		return FALSE;
+
+	last_dot = wcsrchr(path, L'.');
+	if (!last_dot)
+		return FALSE;
+	if (_wcsnicmp(last_dot, L".exe", 4) != 0 && _wcsnicmp(last_dot, L".cmd", 4) != 0 &&
+	_wcsnicmp(last_dot, L".bat", 4) != 0 && _wcsnicmp(last_dot, L".com", 4) != 0)
+		return FALSE; 
+	return TRUE;
+}
+
+int
+file_attr_to_st_mode(wchar_t * path, DWORD attributes)
+{
+	int mode = S_IREAD;
+	BOOL isReadOnlyFile = FALSE;
+	if ((attributes & FILE_ATTRIBUTE_DIRECTORY) != 0 || is_root_or_empty(path))
+		mode |= S_IFDIR | _S_IEXEC;
+	else {
+		mode |= S_IFREG;
+		/* See if file appears to be an executable by checking its extension */
+		if (has_executable_extension(path))
+			mode |= _S_IEXEC;
+
+	}
+	if (!(attributes & FILE_ATTRIBUTE_READONLY))
+		mode |= S_IWRITE;
+	else
+		isReadOnlyFile = TRUE;
+
+	// We don't populate the group permissions as its not applicable to windows OS.
+	// propagate owner read/write/execute bits to other fields.	
+	mode |= get_others_file_permissions(path, isReadOnlyFile);
+
+	return mode;
+}
+
+static int
+settimes(wchar_t * path, FILETIME *cretime, FILETIME *acttime, FILETIME *modtime)
+{
+	HANDLE handle;
+	handle = CreateFileW(path, GENERIC_WRITE, FILE_SHARE_WRITE,
+		NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
+
+	if (handle == INVALID_HANDLE_VALUE) {
+		/* TODO - convert Win32 error to errno */
+		errno = GetLastError();
+		debug3("w32_settimes - CreateFileW ERROR:%d", errno);
+		return -1;
+	}
+
+	if (SetFileTime(handle, cretime, acttime, modtime) == 0) {
+		errno = GetLastError();
+		debug3("w32_settimes - SetFileTime ERROR:%d", errno);
+		CloseHandle(handle);
+		return -1;
+	}
+
+	CloseHandle(handle);
+	return 0;
+}
+
+int
+w32_utimes(const char *filename, struct timeval *tvp)
+{
+	int ret;
+	FILETIME acttime, modtime;
+	wchar_t *resolvedPathName_utf16 = resolved_path_utf16(filename);
+	if (resolvedPathName_utf16 == NULL) 
+		return -1;
+
+	memset(&acttime, 0, sizeof(FILETIME));
+	memset(&modtime, 0, sizeof(FILETIME));
+
+	unix_time_to_file_time((ULONG)tvp[0].tv_sec, &acttime);
+	unix_time_to_file_time((ULONG)tvp[1].tv_sec, &modtime);
+	ret = settimes(resolvedPathName_utf16, NULL, &acttime, &modtime);
+	free(resolvedPathName_utf16);
+	return ret;
+}
+
+int
+w32_symlink(const char *target, const char *linkpath)
+{
+	return fileio_symlink(target, linkpath);
+}
+
+int
+w32_link(const char *oldpath, const char *newpath)
+{
+	return fileio_link(oldpath, newpath);
+}
+
+int
+w32_rename(const char *old_name, const char *new_name)
+{
+	if (old_name == NULL || new_name == NULL) {
+		errno = EFAULT;
+		return -1;
+	}
+
+	wchar_t *resolvedOldPathName_utf16 = resolved_path_utf16(old_name);
+	wchar_t *resolvedNewPathName_utf16 = resolved_path_utf16(new_name);
+
+	if (NULL == resolvedOldPathName_utf16 || NULL == resolvedNewPathName_utf16) 
+		return -1;
+	
+	/*
+	 * To be consistent with POSIX rename(), if the new_name is directory
+	 * and it is empty then delete it so that MoveFileEx will succeed.
+	 */
+	struct _stat64 st_new;
+	struct _stat64 st_old;
+	if ((fileio_stat(new_name, &st_new) != -1) &&
+	    (fileio_stat(old_name, &st_old) != -1) &&
+	    ((st_old.st_mode & _S_IFMT) == _S_IFDIR) &&
+	    ((st_new.st_mode & _S_IFMT) == _S_IFDIR)) {
+			DIR *dirp = opendir(new_name);
+			if (NULL != dirp) {
+				struct dirent *dp = readdir(dirp);
+				closedir(dirp);
+
+				if (dp == NULL)
+					w32_rmdir(new_name);
+		}
+	}
+
+	const int returnStatus = MoveFileExW(resolvedOldPathName_utf16, resolvedNewPathName_utf16, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED);
+
+	free(resolvedOldPathName_utf16);
+	free(resolvedNewPathName_utf16);
+
+	/* Adjust errors and return codes to be consistent with rename() syscall */
+	if (returnStatus == 0) {
+		errno = errno_from_Win32LastError();
+		return -1;
+	}
+	
+	return 0;
+}
+
+int
+w32_unlink(const char *path)
+{
+	wchar_t *resolvedPathName_utf16 = resolved_path_utf16(path);
+	if (NULL == resolvedPathName_utf16) 
+		return -1;
+
+	int returnStatus = _wunlink(resolvedPathName_utf16);
+	free(resolvedPathName_utf16);
+
+	return returnStatus;
+}
+
+int
+w32_rmdir(const char *path)
+{
+	wchar_t *resolvedPathName_utf16 = resolved_path_utf16(path);
+	if (NULL == resolvedPathName_utf16) 
+		return -1;
+
+	int returnStatus = _wrmdir(resolvedPathName_utf16);
+	free(resolvedPathName_utf16);
+
+	return returnStatus;
+}
+
+int
+w32_chdir(const char *dirname_utf8)
+{
+	wchar_t *dirname_utf16 = resolved_path_utf16(dirname_utf8);
+	if (dirname_utf16 == NULL) 
+		return -1;
+
+	int returnStatus = _wchdir(dirname_utf16);
+	free(dirname_utf16);
+
+	return returnStatus;
+}
+
+char *
+w32_getcwd(char *buffer, int maxlen)
+{
+	if(!buffer) return NULL;
+
+	wchar_t wdirname[PATH_MAX];
+	char* putf8 = NULL;
+
+	if (_wgetcwd(wdirname, PATH_MAX) == NULL)
+		return NULL;
+
+	if ((putf8 = utf16_to_utf8(wdirname)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	if ((int)strlen(putf8) >= maxlen) {
+		errno = ERANGE;
+		free(putf8);
+		return NULL;
+	}
+
+	if (strcpy_s(buffer, maxlen, putf8))
+		return NULL;
+	free(putf8);
+
+	to_lower_case(buffer);
+
+	if (chroot_path) {
+		/* ensure we are within chroot jail */
+		char c = buffer[chroot_path_len];
+		if ((int)strlen(buffer) < chroot_path_len ||
+		    memcmp(chroot_path, buffer, chroot_path_len) != 0 ||
+		    (c != '\0' && c!= '\\') ) {
+			errno = EOTHER;
+			error("cwd is not currently within chroot");
+			return NULL;
+		}
+
+		/* is cwd chroot ?*/
+		if (c == '\0') {
+			buffer[0] = '\\';
+			buffer[1] = '\0';
+		}
+		else {
+			char *tail = buffer + chroot_path_len;
+			memmove_s(buffer, maxlen, tail, strlen(tail) + 1);
+		}
+	} 
+
+	return buffer;
+}
+
+int
+w32_mkdir(const char *path_utf8, unsigned short mode)
+{
+	int curmask;
+	wchar_t *path_utf16 = resolved_path_utf16(path_utf8);
+	if (path_utf16 == NULL) 
+		return -1;
+
+	int returnStatus = _wmkdir(path_utf16);
+	if (returnStatus < 0) {
+		free(path_utf16);
+		return -1;
+	}
+
+	errno_t error = _umask_s(0, &curmask);
+	if(!error)
+		_umask_s(curmask, &curmask);
+
+	returnStatus = _wchmod(path_utf16, mode & ~curmask & (_S_IREAD | _S_IWRITE));
+	free(path_utf16);
+
+	return returnStatus;
+}
+
+int
+w32_stat(const char *input_path, struct w32_stat *buf)
+{
+	return fileio_stat(input_path, (struct _stat64*)buf);
+}
+
+int
+w32_lstat(const char *input_path, struct w32_stat *buf)
+{
+	return fileio_lstat(input_path, (struct _stat64*)buf);
+}
+
+/* if file is symbolic link, copy its link into "link" */
+int
+w32_readlink(const char *path, char *link, int linklen)
+{
+	return fileio_readlink(path, link, linklen);
+}
+
+/* convert forward slash to back slash */
+void
+convertToBackslash(char *str)
+{
+	while (*str) {
+		if (*str == '/')
+			*str = '\\';
+		str++;
+	}
+}
+
+void
+convertToBackslashW(wchar_t *str)
+{
+	while (*str) {
+		if (*str == L'/')
+			*str = L'\\';
+		str++;
+	}
+}
+
+/* convert back slash to forward slash */
+void
+convertToForwardslash(char *str)
+{
+	while (*str) {
+		if (*str == '\\')
+			*str = '/';
+		str++;
+	}
+}
+
+/*
+ * This method will resolves references to /./, /../ and extra '/' characters in the null-terminated string named by
+ *  path to produce a canonicalized absolute pathname.
+ */
+char *
+realpath(const char *inputpath, char * resolved)
+{
+	wchar_t* temppath_utf16 = NULL;
+	wchar_t* resolved_utf16 = NULL;
+	char path[PATH_MAX] = { 0, }, tempPath[PATH_MAX] = { 0, }, *ret = NULL;
+	int is_win_path = 1;
+
+	if (!inputpath || !resolved)
+		return NULL;
+	
+	size_t path_len = strlen(inputpath);
+	resolved[0] = '\0';
+
+	if (path_len > PATH_MAX) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	if (is_bash_test_env() && bash_to_win_path(inputpath, path, _countof(path)))
+		is_win_path = 0;
+
+	if (is_win_path) {
+		if (_strnicmp(inputpath, PROGRAM_DATA, strlen(PROGRAM_DATA)) == 0) {
+			strcpy_s(path, PATH_MAX, __progdata);
+			strcat_s(path, PATH_MAX, &inputpath[strlen(PROGRAM_DATA)]);
+		} else {
+			memcpy_s(path, PATH_MAX, inputpath, strlen(inputpath));
+		}
+	}
+
+	path_len = strlen(path);
+	if (path_len > PATH_MAX) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	/* resolve root directory to the same */
+	if (path_len == 1 && (path[0] == '/' || path[0] == '\\')) {
+		resolved[0] = '/';
+		resolved[1] = '\0';
+		ret = resolved;
+		goto done;
+	}
+
+	/* resolve this common case scenario to root */
+	/* "cd .." from within a drive root */
+	if (path_len == 6 && !chroot_path) {
+		char *tmplate = "/x:/..";
+		strcat_s(resolved, PATH_MAX, path);
+		resolved[1] = 'x';
+		if (strcmp(tmplate, resolved) == 0) {
+			resolved[0] = '/';
+			resolved[1] = '\0';
+			ret = resolved;
+			goto done;
+		}
+	}
+
+	if (chroot_path) {
+		resolved[0] = '\0';
+		strcat_s(resolved, PATH_MAX, chroot_path);
+		/* if path is relative, add cwd within chroot */
+		if (path[0] != '/' && path[0] != '\\') {
+			w32_getcwd(resolved + chroot_path_len, PATH_MAX - chroot_path_len);
+			strcat_s(resolved, PATH_MAX, "/");
+		}
+		/* TODO - This logic will fail if the chroot_path is more than PATH_MAX/2.
+		 * resolved variable is of PATH_MAX.
+		 * We first copy chroot_path to resolved variable then incoming path (which can be again chroot_path).
+		 * In this case strcat_s will thrown a run time insufficient buffer exception.
+		 */
+		strcat_s(resolved, PATH_MAX, path);
+	}
+	else if ((path_len >= 2) && (path[0] == '/') && path[1] && (path[2] == ':')) {
+		if((errno = strncpy_s(resolved, PATH_MAX, path + 1, path_len)) != 0 ) /* skip the first '/' */ {
+			debug3("memcpy_s failed with error: %d.", errno);
+			goto done;
+		}
+	}
+	else if(( errno = strncpy_s(resolved, PATH_MAX, path, path_len + 1)) != 0) {
+		debug3("memcpy_s failed with error: %d.", errno);
+		goto done;
+	}
+
+	if ((resolved[0]) && (resolved[1] == ':') && (resolved[2] == '\0')) { /* make "x:" as "x:\\" */
+		resolved[2] = '\\';
+		resolved[3] = '\0';
+	}
+
+	/* note: _wfullpath() is required to resolve paths containing unicode characters */
+	if ((resolved_utf16 = utf8_to_utf16(resolved)) == NULL ||
+		(temppath_utf16 = _wfullpath(NULL, resolved_utf16, 0)) == NULL ||
+		WideCharToMultiByte(CP_UTF8, 0, temppath_utf16, -1, tempPath, sizeof(tempPath), NULL, NULL) == 0) {
+		errno = EINVAL;
+		goto done;
+	}
+
+	if (chroot_path) {
+		if (strlen(tempPath) < strlen(chroot_path)) {
+			errno = EACCES;
+			goto done;
+		}
+		if (memcmp(chroot_path, tempPath, strlen(chroot_path)) != 0) {
+			errno = EACCES;
+			goto done;
+		}
+
+		resolved[0] = '\0';
+		
+		if (strlen(tempPath) == strlen(chroot_path))
+			/* realpath is the same as chroot_path */
+			strcat_s(resolved, PATH_MAX, "\\");
+		else
+			strcat_s(resolved, PATH_MAX, tempPath + strlen(chroot_path));
+
+		if (resolved[0] != '\\') {
+			errno = EACCES;
+			goto done;
+		}
+
+		convertToForwardslash(resolved);
+		ret = resolved;
+		goto done;
+	}
+	else {
+		convertToForwardslash(tempPath);
+		resolved[0] = '/'; /* will be our first slash in /x:/users/test1 format */
+		if ((errno = strncpy_s(resolved + 1, PATH_MAX - 1, tempPath, sizeof(tempPath) - 1)) != 0) {
+			debug3("memcpy_s failed with error: %d.", errno);
+			goto done;
+		}
+		ret = resolved;
+		goto done;
+	}
+
+done:
+	if (resolved_utf16 != NULL)
+		free(resolved_utf16);
+	if (temppath_utf16 != NULL)
+		free(temppath_utf16);
+	return ret;
+}
+
+/* on error returns NULL and sets errno */
+char* 
+resolved_path_utf8(const char *input_path)
+{
+	wchar_t *resolved_path_w = resolved_path_utf16(input_path);
+	char *resolved_path = NULL;
+
+	if (resolved_path_w) {
+		resolved_path = utf16_to_utf8(resolved_path_w);
+		free(resolved_path_w);
+	}
+
+	return resolved_path;
+}
+
+/* on error returns NULL and sets errno */
+wchar_t*
+resolved_path_utf16(const char *input_path)
+{
+	wchar_t *resolved_path = NULL;
+	char real_path[PATH_MAX];
+
+	if (!input_path) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	if (realpath(input_path, real_path) == NULL)
+		return NULL;
+
+	if (chroot_path) {
+		char actual_path[PATH_MAX] = { 0 };
+		strcat_s(actual_path, _countof(actual_path), chroot_path);
+		strcat_s(actual_path, _countof(actual_path), real_path);
+		resolved_path = utf8_to_utf16(actual_path);
+	} else {
+		if ((strlen(real_path) == 1) && (real_path[0] == '/'))
+			resolved_path = utf8_to_utf16(real_path);
+		else
+			resolved_path = utf8_to_utf16(real_path + 1); /* account for preceding / in real_path */
+	}
+
+	return resolved_path;
+}
+
+int
+statvfs(const char *path, struct statvfs *buf)
+{
+	DWORD sectorsPerCluster;
+	DWORD bytesPerSector;
+	DWORD freeClusters;
+	DWORD totalClusters;
+
+	wchar_t* path_utf16 = resolved_path_utf16(path);
+	if (path_utf16 == NULL)
+		return -1;
+
+	if (GetDiskFreeSpaceW(path_utf16, &sectorsPerCluster, &bytesPerSector,
+	    &freeClusters, &totalClusters)) {
+		debug5("path              : [%s]", path);
+		debug5("sectorsPerCluster : [%lu]", sectorsPerCluster);
+		debug5("bytesPerSector    : [%lu]", bytesPerSector);
+		debug5("bytesPerCluster   : [%lu]", sectorsPerCluster * bytesPerSector);
+		debug5("freeClusters      : [%lu]", freeClusters);
+		debug5("totalClusters     : [%lu]", totalClusters);
+
+		buf->f_bsize = sectorsPerCluster * bytesPerSector;
+		buf->f_frsize = sectorsPerCluster * bytesPerSector;
+		buf->f_blocks = totalClusters;
+		buf->f_bfree = freeClusters;
+		buf->f_bavail = freeClusters;
+		buf->f_files = -1;
+		buf->f_ffree = -1;
+		buf->f_favail = -1;
+		buf->f_fsid = 0;
+		buf->f_flag = 0;
+		buf->f_namemax = PATH_MAX - 1;
+
+		free(path_utf16);
+		return 0;
+	} else {
+		debug5("ERROR: Cannot get free space for [%s]. Error code is : %d.", path, GetLastError());
+		errno = errno_from_Win32LastError();
+		free(path_utf16);
+		return -1;
+	}
+}
+
+int
+fstatvfs(int fd, struct statvfs *buf)
+{
+	errno = ENOTSUP;
+	return -1;
+}
+
+char *
+w32_strerror(int errnum)
+{
+	if (errnum >= EADDRINUSE  && errnum <= EWOULDBLOCK)
+		return _sys_errlist_ext[errnum - EADDRINUSE];
+	
+	strerror_s(errorBuf, ERROR_MSG_MAXLEN, errnum);
+	return errorBuf;
+}
+
+char *
+readpassphrase(const char *prompt, char *outBuf, size_t outBufLen, int flags)
+{
+	int current_index = 0;
+	int utf8_read = 0;
+	char utf8_char[4];
+	wchar_t ch;
+	wchar_t* wtmp = NULL;
+
+	if (outBufLen == 0) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	while (_kbhit()) _getwch();
+
+	wtmp = utf8_to_utf16(prompt);
+	if (wtmp == NULL)
+		fatal("unable to alloc memory");
+
+	_cputws(wtmp);
+	free(wtmp);
+
+	while (current_index < (int)outBufLen - 1) {
+		ch = _getwch();
+		
+		if (ch == L'\r') {
+			if (_kbhit()) _getwch(); /* read linefeed if its there */
+			break;
+		} else if (ch == L'\n') {
+			break;
+		} else if (ch == L'\b') { /* backspace */
+			if (current_index > 0) {
+				if (flags & RPP_ECHO_ON)
+					wprintf_s(L"%c \b", ch);
+
+				/* overwrite last character - remove any utf8 extended chars */
+				while (current_index > 0 && (outBuf[current_index - 1] & 0xC0) == 0x80)
+					current_index--;
+
+				/* overwrite last character - remove first utf8 byte */
+				if (current_index > 0)
+					current_index--;
+			}
+		} else if (ch == L'\003') { /* exit on Ctrl+C */
+			fatal("");
+		} else {
+			if (flags & RPP_SEVENBIT)
+				ch &= 0x7f;
+
+			if (iswalpha(ch)) {
+				if(flags & RPP_FORCELOWER)
+					ch = towlower(ch);
+				if(flags & RPP_FORCEUPPER)
+					ch = towupper(ch);
+			}
+
+			/* convert unicode to utf8 characters */
+			int utf8_char_size = sizeof(utf8_char);
+			if ((utf8_read = WideCharToMultiByte(CP_UTF8, 0, &ch, 1, utf8_char, sizeof(utf8_char), NULL, NULL)) == 0)
+				fatal("character conversion failed");
+
+			/* append to output buffer if the characters fit */
+			if (current_index + utf8_read >= outBufLen - 1) break;
+			memcpy(&outBuf[current_index], utf8_char, utf8_read);
+			current_index += utf8_read;
+
+			if(flags & RPP_ECHO_ON)
+				wprintf_s(L"%c", ch);
+		}
+	}
+
+	outBuf[current_index] = '\0';
+	_cputs("\n");
+
+	return outBuf;
+}
+
+void 
+invalid_parameter_handler(const wchar_t* expression, const wchar_t* function, const wchar_t* file, unsigned int line, uintptr_t pReserved)
+{	
+	debug3("Invalid parameter in function: %ls. File: %ls Line: %d.", function, file, line);
+	debug3("Expression: %s", expression);
+}
+
+void
+to_lower_case(char *s)
+{
+	for (; *s; s++)
+		*s = tolower((u_char)*s);
+}
+
+void 
+to_wlower_case(wchar_t *s)
+{
+	for (; *s; s++)
+		*s = towlower(*s);
+}
+
+static int
+get_final_mode(int allow_mode, int deny_mode)
+{	
+	// If deny permissions are not specified then return allow permissions.
+	if (!deny_mode) return allow_mode;
+
+	// If allow permissions are not specified then return allow permissions (0).
+	if (!allow_mode) return allow_mode;
+	
+	if(deny_mode & S_IROTH)
+		allow_mode = allow_mode & ~S_IROTH;
+
+	if (deny_mode & S_IWOTH)
+		allow_mode = allow_mode & ~S_IWOTH;
+
+	if (deny_mode & S_IXOTH)
+		allow_mode = allow_mode & ~S_IXOTH;
+
+	return allow_mode;
+}
+
+int
+get_others_file_permissions(wchar_t * file_name, int isReadOnlyFile)
+{
+	PSECURITY_DESCRIPTOR pSD = NULL;
+	PSID owner_sid = NULL, current_trustee_sid = NULL;
+	PACL dacl = NULL;
+	DWORD error_code = ERROR_SUCCESS;
+	BOOL is_valid_sid = FALSE, is_valid_acl = FALSE;
+	int ret = 0, allow_mode_world = 0, allow_mode_auth_users = 0, deny_mode_world = 0, deny_mode_auth_users = 0;
+	wchar_t *w_sid = NULL;
+
+	/*Get the owner sid of the file.*/
+	if ((error_code = GetNamedSecurityInfoW(file_name, SE_FILE_OBJECT,
+		OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+		&owner_sid, NULL, &dacl, NULL, &pSD)) != ERROR_SUCCESS) {
+		debug3("failed to retrieve the owner sid and dacl of file: %ls with error code: %d", file_name, error_code);
+		goto cleanup;
+	}
+
+	if (((is_valid_sid = IsValidSid(owner_sid)) == FALSE) || dacl == NULL ||
+		((is_valid_acl = IsValidAcl(dacl)) == FALSE)) {
+		debug3("IsValidSid: %d; NULL Acl: %d; IsValidAcl: %d", is_valid_sid, dacl == NULL, is_valid_acl);
+		goto cleanup;
+	}
+
+	for (DWORD i = 0; i < dacl->AceCount; i++) {
+		PVOID current_ace = NULL;
+		PACE_HEADER current_aceHeader = NULL;
+		ACCESS_MASK current_access_mask = 0;
+		int mode_tmp = 0;
+		if (!GetAce(dacl, i, &current_ace)) {
+			debug3("GetAce() failed");
+			goto cleanup;
+		}
+
+		current_aceHeader = (PACE_HEADER)current_ace;
+		/* only interested in Allow ACE */
+		if (current_aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE) {
+			PACCESS_ALLOWED_ACE pAllowedAce = (PACCESS_ALLOWED_ACE)current_ace;
+			current_trustee_sid = &(pAllowedAce->SidStart);
+			current_access_mask = pAllowedAce->Mask;
+		} else if (current_aceHeader->AceType == ACCESS_DENIED_ACE_TYPE) {
+			PACCESS_DENIED_ACE pDeniedAce = (PACCESS_DENIED_ACE)current_ace;
+			current_trustee_sid = &(pDeniedAce->SidStart);
+			current_access_mask = pDeniedAce->Mask;
+		} else continue;
+		
+		if (!(IsWellKnownSid(current_trustee_sid, WinWorldSid) || 
+		    IsWellKnownSid(current_trustee_sid, WinAuthenticatedUserSid)))
+			continue;
+		
+		if ((current_access_mask & READ_PERMISSIONS) == READ_PERMISSIONS)
+			mode_tmp |= S_IROTH;
+
+		if (!isReadOnlyFile && ((current_access_mask & WRITE_PERMISSIONS) == WRITE_PERMISSIONS))
+			mode_tmp |= S_IWOTH;
+
+		if ((current_access_mask & EXECUTE_PERMISSIONS) == EXECUTE_PERMISSIONS)
+			mode_tmp |= S_IXOTH;
+
+		if (IsWellKnownSid(current_trustee_sid, WinWorldSid)) {
+			if(current_aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
+				allow_mode_world |= mode_tmp;
+			else
+				deny_mode_world |= mode_tmp;
+		} else if (IsWellKnownSid(current_trustee_sid, WinAuthenticatedUserSid)) {
+			if (current_aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
+				allow_mode_auth_users |= mode_tmp;
+			else
+				deny_mode_auth_users |= mode_tmp;
+		}
+	}
+	
+	allow_mode_world = get_final_mode(allow_mode_world, deny_mode_world);
+	allow_mode_auth_users = get_final_mode(allow_mode_auth_users, deny_mode_auth_users);
+
+	ret = allow_mode_world ? allow_mode_world : allow_mode_auth_users;
+cleanup:
+	if (pSD)
+		LocalFree(pSD);
+	return ret;
+}
+
+/* Windows absolute paths - \abc, /abc, c:\abc, c:/abc, __PROGRAMDATA__\openssh\sshd_config */
+int
+is_absolute_path(const char *path)
+{
+	int retVal = 0;
+	if(*path == '\"' || *path == '\'') /* skip double quote if path is "c:\abc" */
+		path++;
+
+	if (*path == '/' || *path == '\\' || (*path != '\0' && __isascii(*path) && isalpha(*path) && path[1] == ':') ||
+	    ((strlen(path) >= strlen(PROGRAM_DATA)) && (memcmp(path, PROGRAM_DATA, strlen(PROGRAM_DATA)) == 0)))
+		retVal = 1;
+
+	return retVal;
+}
+
+/* return -1 - in case of failure, 0 - success */
+int
+create_directory_withsddl(wchar_t *path_w, wchar_t *sddl_w)
+{
+	if (GetFileAttributesW(path_w) == INVALID_FILE_ATTRIBUTES) {
+		PSECURITY_DESCRIPTOR pSD = NULL;
+		SECURITY_ATTRIBUTES sa;
+		memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+		sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+		sa.bInheritHandle = FALSE;
+
+		if (ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl_w, SDDL_REVISION, &pSD, NULL) == FALSE) {
+			error("ConvertStringSecurityDescriptorToSecurityDescriptorW failed with error code %d", GetLastError());
+			return -1;
+		}
+
+		if (IsValidSecurityDescriptor(pSD) == FALSE) {
+			error("IsValidSecurityDescriptor return FALSE");
+			return -1;
+		}
+
+		sa.lpSecurityDescriptor = pSD;
+		if (!CreateDirectoryW(path_w, &sa)) {
+			error("Failed to create directory:%ls error:%d", path_w, GetLastError());
+			return -1;
+		}
+	}
+	else {
+		// directory already exists; need to confirm permissions are correct
+		if (check_secure_folder_permission(path_w, 1) != 0) {
+			error("Directory already exists but folder permissions are invalid");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/* return -1 - in case of failure, 0 - success */
+int
+copy_file(char *source, char *destination)
+{
+	if (!source || !destination) return 0;
+
+	struct stat st;
+	if ((stat(source, &st) >= 0) && (stat(destination, &st) < 0)) {
+		wchar_t *source_w = utf8_to_utf16(source);
+		if (!source_w) {
+			error("%s utf8_to_utf16() has failed to convert string:%s", __func__, source_w);
+			return -1;
+		}
+
+		wchar_t *destination_w = utf8_to_utf16(destination);
+		if (!destination_w) {
+			error("%s utf8_to_utf16() has failed to convert string:%s", __func__, destination_w);
+			return -1;
+		}
+
+		if (!CopyFileW(source_w, destination_w, FALSE)) {
+			error("Failed to copy %ls to %ls, error:%d", source_w, destination_w, GetLastError());
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+struct tm *
+localtime_r(const time_t *timep, struct tm *result)
+{
+	return localtime_s(result, timep) == 0 ? result : NULL;
+}
+
+struct tm *
+w32_localtime(const time_t* sourceTime)
+{
+	struct tm* destTime = (struct tm*)malloc(sizeof(struct tm));
+	if (destTime == NULL)
+	{
+		return NULL;
+	}
+	return localtime_s(destTime, sourceTime) == 0 ? destTime : NULL;
+}
+
+char*
+w32_ctime(const time_t* sourceTime)
+{
+	char *destTime = malloc(26);
+	if (destTime == NULL)
+	{
+		return NULL;
+	}
+	return ctime_s(destTime, 26, sourceTime) == 0 ? destTime : NULL;
+}
+
+void
+freezero(void *ptr, size_t sz)
+{
+	if (ptr == NULL)
+		return;
+	explicit_bzero(ptr, sz);
+	free(ptr);
+}
+
+int 
+setenv(const char *name, const char *value, int rewrite)
+{
+	errno_t result = 0;
+
+	/* If rewrite is 0, then set only if the variable name doesn't already exist in environment */
+	if (!rewrite) {
+		char *envValue = NULL;
+		size_t len = 0;
+		_dupenv_s(&envValue, &len, name);
+
+		if (envValue)
+			return result; /* return success (as per setenv manpage) */
+	}
+
+	if (!(result = _putenv_s(name, value)))
+		return 0;
+	else {
+		error("failed to set the environment variable:%s to value:%s, error:%d", name, value, result);
+		errno = result;
+		return -1;
+	}
+}
+
+int
+chroot(const char *path)
+{
+	char cwd[PATH_MAX];
+
+	if (strcmp(path, ".") == 0) {
+		if (w32_getcwd(cwd, PATH_MAX) == NULL)
+			return -1;
+		path = (const char *)cwd;
+	} else if (*(path + 1) != ':') {
+		errno = ENOTSUP;
+		error("chroot only supports absolute paths");
+		return -1;
+	} else {
+		/* TODO - ensure path exists and is a directory */
+	}
+
+	if ((chroot_path = _strdup(path)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	to_lower_case(chroot_path);
+	convertToBackslash(chroot_path);
+
+	/* strip trailing \ */
+	if (chroot_path[strlen(chroot_path) - 1] == '\\')
+		chroot_path[strlen(chroot_path) - 1] = '\0';
+
+	chroot_path_len = (int) strlen(chroot_path);
+
+	if ((chroot_pathw = utf8_to_utf16(chroot_path)) == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	/* TODO - set the env variable just in time in a posix_spawn_chroot like API */
+#define POSIX_CHROOTW L"c28fc6f98a2c44abbbd89d6a3037d0d9_POSIX_CHROOT"
+	_wputenv_s(POSIX_CHROOTW, chroot_pathw);
+
+	return 0;
+}
+
+/*
+ * Am I running as SYSTEM ?
+ * a security sensitive call - fatal exits if it cannot definitively conclude 
+ */
+int 
+am_system()
+{
+	HANDLE proc_token = NULL;
+	DWORD info_len;
+	TOKEN_USER* info = NULL;
+	static int running_as_system = -1;
+
+	if (running_as_system != -1)
+		return running_as_system;
+
+	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &proc_token) == FALSE ||
+		GetTokenInformation(proc_token, TokenUser, NULL, 0, &info_len) == TRUE ||
+		(info = (TOKEN_USER*)malloc(info_len)) == NULL) {  	// CodeQL [SM02320]: GetTokenInformation will initialize info
+			fatal("unable to know if I am running as system");
+	}
+
+	if (GetTokenInformation(proc_token, TokenUser, info, info_len, &info_len) == FALSE) 
+		fatal("unable to know if I am running as system");
+
+	if (IsWellKnownSid(info->User.Sid, WinLocalSystemSid))
+		running_as_system = 1;
+	else
+		running_as_system = 0;
+
+	CloseHandle(proc_token);
+	free(info);
+	return running_as_system;
+}
+
+/*
+ * Returns SID of user/group. If psid argument is NULL, allocates a new one,
+ * otherwise saves SID into the supplied memory area.
+ * Sets psid_len (if non-NULL) to the actual SID size.
+ * Caller should free() return value if psid argument was NULL.
+ */
+PSID
+lookup_sid(const wchar_t* name_utf16, PSID psid, DWORD * psid_len)
+{
+	PSID ret = NULL, alloc_psid = NULL, target_psid;
+	DWORD sid_len = 0;
+	SID_NAME_USE n_use;
+	WCHAR dom[DNLEN + 1] = L"";
+	DWORD dom_len = DNLEN + 1;
+	wchar_t* name_utf16_modified = NULL;
+	BOOL resolveAsAdminsSid = 0, r;
+
+	LookupAccountNameW(NULL, name_utf16, NULL, &sid_len, dom, &dom_len, &n_use); // CodeQL [SM02313]: false positive n_use will not be uninitialized
+
+	if (sid_len == 0 && _wcsicmp(name_utf16, L"administrators") == 0) {
+		CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, NULL, &sid_len);
+		resolveAsAdminsSid = 1;
+		debug3_f("resolveAsAdminsSid:%d", resolveAsAdminsSid);
+	}
+
+	if (sid_len == 0) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	target_psid = psid;
+	if (target_psid == NULL) {
+		if ((alloc_psid = malloc(sid_len)) == NULL) {
+			errno = ENOMEM;
+			error_f("Failed to allocate memory");
+			goto cleanup;
+		}
+		target_psid = alloc_psid;
+	}
+
+	if (resolveAsAdminsSid)
+		r = CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, target_psid, &sid_len);
+	else
+		r = LookupAccountNameW(NULL, name_utf16, target_psid, &sid_len, dom, &dom_len, &n_use);
+
+	if (!r) {
+		error_f("Failed to retrieve SID for user:%S error:%d", name_utf16, GetLastError());
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	if (n_use == SidTypeDomain) {
+		// Additionally check the case when name is the same as computer name and
+		// thus same as local domain. Try to resolve <name>\<name>.
+		/* fetch the computer name so we can determine if the specified user is local or not */
+		wchar_t computer_name[CNLEN + 1];
+		DWORD computer_name_size = ARRAYSIZE(computer_name);
+		if (GetComputerNameW(computer_name, &computer_name_size) == 0) {
+			error_f("GetComputerNameW() failed with error:%d", GetLastError());
+			goto cleanup;
+		}
+
+		if (_wcsicmp(name_utf16, computer_name) != 0) {
+			errno = ENOENT;
+			error_f("Invalid account type: %d for user:%S", n_use, name_utf16);
+			goto cleanup;
+		}
+
+		debug3_f("local user name is same as machine name");
+		size_t name_size = wcslen(name_utf16) * 2U + 2U;
+		name_utf16_modified = malloc(name_size * sizeof(wchar_t));
+		if (name_utf16_modified == NULL)
+		{
+			errno = ENOMEM;
+			error_f("Failed to allocate memory");
+			goto cleanup;
+		}
+		name_utf16_modified[0] = L'\0';
+		wcscat_s(name_utf16_modified, name_size, name_utf16);
+		wcscat_s(name_utf16_modified, name_size, L"\\");
+		wcscat_s(name_utf16_modified, name_size, name_utf16);
+
+		ret = lookup_sid(name_utf16_modified, psid, psid_len);
+	}
+	else {
+		if (psid_len != NULL)
+			*psid_len = sid_len;
+
+		alloc_psid = NULL;
+		ret = target_psid;
+	}
+
+cleanup:
+
+	if (name_utf16_modified)
+		free(name_utf16_modified);
+	if (alloc_psid)
+		free(alloc_psid);
+
+	return ret;
+}
+
+/* 
+ * returns SID of user/group or current user if (user = NULL) 
+ * caller should free() return value
+ */
+PSID
+get_sid(const char* name)
+{
+	HANDLE token = NULL;
+	TOKEN_USER* info = NULL;
+	DWORD info_len = 0;
+	PSID ret = NULL, psid = NULL;
+	wchar_t* name_utf16 = NULL;
+
+	if (name) {
+		if ((name_utf16 = utf8_to_utf16(name)) == NULL)
+			goto cleanup;
+
+		psid = lookup_sid(name_utf16, NULL, NULL);
+	}
+	else {
+		if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &token) == FALSE ||
+		    GetTokenInformation(token, TokenUser, NULL, 0, &info_len) == TRUE) { // CodeQL [SM02320]: GetTokenInformation will initialize info
+			errno = EOTHER;
+			goto cleanup;
+		}
+
+		if ((info = (TOKEN_USER*)malloc(info_len)) == NULL) { // CodeQL [SM02320]: GetTokenInformation will initialize info
+			errno = ENOMEM;
+			goto cleanup;
+		};
+
+		if (GetTokenInformation(token, TokenUser, info, info_len, &info_len) == FALSE) {
+			errno = errno_from_Win32LastError();
+			goto cleanup;
+		}
+
+		if ((psid = malloc(GetLengthSid(info->User.Sid))) == NULL) {
+			errno = ENOMEM;
+			goto cleanup;
+		}
+
+		if (!CopySid(GetLengthSid(info->User.Sid), psid, info->User.Sid)) {
+			errno = errno_from_Win32LastError();
+			goto cleanup;
+		}
+	}
+
+	ret = psid;
+	psid = NULL;
+cleanup:
+
+	if (token)
+		CloseHandle(token);
+	if (name_utf16)
+		free(name_utf16);
+	if (psid)
+		free(psid);
+	if (info)
+		free(info);
+
+	return ret;
+}
+
+/* Interpret scp and sftp executables*/
+char *
+build_exec_command(const char * command)
+{
+	enum cmd_type { CMD_OTHER, CMD_SFTP, CMD_SCP } command_type = CMD_OTHER;
+	char *cmd_sp = NULL;
+	int len = 0, command_len;
+	const char *command_args = NULL;
+
+	if (!command)
+		return NULL;
+
+	command_len = (int)strlen(command);
+	/*TODO - replace numbers below with readable compile time operators*/
+	if (command_len >= 13 && _memicmp(command, "internal-sftp", 13) == 0) {
+		command_type = CMD_SFTP;
+		command_args = command + 13;
+	}
+	else if (command_len >= 11 && _memicmp(command, "sftp-server", 11) == 0) {
+		command_type = CMD_SFTP;
+
+		/* account for possible .exe extension */
+		if (command_len >= 15 && _memicmp(command + 11, ".exe", 4) == 0)
+			command_args = command + 15;
+		else
+			command_args = command + 11;
+	}
+	else if (command_len >= 3 && _memicmp(command, "scp", 3) == 0) {
+		command_type = CMD_SCP;
+
+		/* account for possible .exe extension */
+		if (command_len >= 7 && _memicmp(command + 3, ".exe", 4) == 0)
+			command_args = command + 7;
+		else
+			command_args = command + 3;
+	}
+
+	len = command_len + 5; /* account for possible .exe addition and null term */
+	if ((cmd_sp = malloc(len)) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	memset(cmd_sp, '\0', len);
+	if (command_type == CMD_SCP) {
+		strcpy_s(cmd_sp, len, "scp.exe");
+		strcat_s(cmd_sp, len, command_args);
+	}
+	else if (command_type == CMD_SFTP) {
+		strcpy_s(cmd_sp, len, "sftp-server.exe");
+		strcat_s(cmd_sp, len, command_args);
+	}
+	else
+		strcpy_s(cmd_sp, len, command);
+	return cmd_sp;
+}
+
+/*
+* cmd is internally decoarated with a set of '"'
+* to account for any spaces within the commandline
+* the double quotes and backslash is escaped if needed
+* this decoration is done only when additional arguments are passed in argv
+*/
+char *
+build_commandline_string(const char* cmd, char *const argv[], BOOLEAN prepend_module_path)
+{
+	char *cmdline, *t, *tmp = NULL, *path = NULL, *ret = NULL;
+	char * const *t1;
+	DWORD cmdline_len = 0, path_len = 0;
+	int add_module_path = 0;
+
+	if (!cmd) {
+		error("%s invalid argument cmd:%s", __func__, cmd);
+		return NULL;
+	}
+
+	if (!(path = _strdup(cmd))) {
+		error("failed to duplicate %s", cmd);
+		return NULL;
+	}
+
+	path_len = (DWORD)strlen(path);
+
+	if (is_bash_test_env()) {
+		memset(path, 0, path_len + 1);
+		bash_to_win_path(cmd, path, path_len + 1);
+		path_len = (DWORD)strlen(path);
+	}
+
+	if (!is_absolute_path(path) && prepend_module_path)
+		add_module_path = 1;
+
+	/* compute total cmdline len*/
+	if (add_module_path)
+		cmdline_len += (DWORD)strlen(__progdir) + 1 + (DWORD)strlen(path) + 1 + 2;
+	else
+		cmdline_len += (DWORD)strlen(path) + 1 + 2;
+
+	if (argv) {
+		t1 = argv;
+		while (*t1) {
+			char *p = *t1++;
+			for (int i = 0; i < (int)strlen(p); i++) {
+				if (p[i] == '\\') {
+					char * b = p + i;
+					int additional_backslash = 0;
+					int backslash_count = 0;
+					/*
+					Backslashes are interpreted literally, unless they immediately
+					precede a double quotation mark.
+					*/
+					while (b != NULL && *b == '\\') {
+						backslash_count++;
+						b++;
+						if (b != NULL &&  *b == '\"') {
+							additional_backslash = 1;
+							break;
+						}
+					}
+					cmdline_len += backslash_count * (additional_backslash + 1);
+					i += backslash_count - 1;
+				}
+				else if (p[i] == '\"')
+					/* backslash will be added for every double quote.*/
+					cmdline_len += 2;
+				else
+					cmdline_len++;
+			}
+			cmdline_len += 1 + 2; /*for "around cmd arg and traling space*/
+		}
+	}
+
+	if ((cmdline = malloc(cmdline_len)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	t = cmdline;
+
+	*t++ = '\"';
+	if (add_module_path) {
+		/* add current module path to start if needed */
+		memcpy(t, __progdir, strlen(__progdir));
+		t += strlen(__progdir);
+		*t++ = '\\';
+	}
+
+	if (path[0] != '\"') {
+		/* If path is <executable_path> <arg> then we should add double quotes after <executable_path> i.e., "<executable_path>" <arg> should be passed to CreateProcess().
+		* Example - If path is C:\cygwin64\bin\bash.exe /cygdrive/e/openssh-portable-latestw_all/openssh-portable/regress/scp-ssh-wrapper.sh then
+		*           we should pass "C:\cygwin64\bin\bash.exe" /cygdrive/e/openssh-portable-latestw_all/openssh-portable/regress/scp-ssh-wrapper.sh
+		*           to the CreateProcess() otherwise CreateProcess() will fail with error code 2.
+		*/
+		if (strstr(path, ".exe") && (tmp = strstr(strstr(path, ".exe"), " ")))
+		{
+			size_t tmp_pos = tmp - path;
+			memcpy(t, path, tmp_pos);
+			t += tmp_pos;
+			*t++ = '\"';
+			memcpy(t, tmp, strlen(path) - tmp_pos);
+			t += (strlen(path) - tmp_pos);
+		}
+		else {
+			memcpy(t, path, path_len);
+			t += path_len;
+			*t++ = '\"';
+		}
+	}
+	else {
+		/*path already contains "*/
+		memcpy(t, path + 1, path_len - 1);
+		t += path_len - 1;
+	}
+
+	*t = '\0';
+	t = cmdline + strlen(cmdline);
+
+	if (argv) {
+		t1 = argv;
+		while (*t1) {
+			*t++ = ' ';
+			char * p1 = *t1++;
+			BOOL add_quotes = FALSE;
+			/* leave as is if the command is surrounded by single quotes*/
+			if (p1[0] != '\'')
+				for (int i = 0; i < (int)strlen(p1); i++) {
+					if (p1[i] == ' ') {
+						add_quotes = TRUE;
+						break;
+					}
+				}
+			if (add_quotes)
+				*t++ = '\"';
+			for (int i = 0; i < (int)strlen(p1); i++) {
+				if (p1[i] == '\\') {
+					char * b = p1 + i;
+					int additional_backslash = 0;
+					int backslash_count = 0;
+					/*
+					* Backslashes are interpreted literally, unless they immediately
+					* precede a double quotation mark.
+					*/
+					while (b != NULL && *b == '\\') {
+						backslash_count++;
+						b++;
+						if (b != NULL && *b == '\"') {
+							additional_backslash = 1;
+							break;
+						}
+					}
+					i += backslash_count - 1;
+					int escaped_backslash_count = backslash_count * (additional_backslash + 1);
+					while (escaped_backslash_count--)
+						*t++ = '\\';
+				}
+				else if (p1[i] == '\"') {
+					/* Add backslash for every double quote.*/
+					*t++ = '\\';
+					*t++ = '\"';
+				}
+				else
+					*t++ = p1[i];
+			}
+			if (add_quotes)
+				*t++ = '\"';
+		}
+	}
+	*t = '\0';
+	ret = cmdline;
+	cmdline = NULL;
+cleanup:
+	if (path)
+		free(path);
+	if (cmdline)
+		free(cmdline);
+	return ret;
+}
+
+BOOL
+is_bash_test_env()
+{
+	char *envValue = NULL;
+	size_t len = 0;
+	BOOL retVal = FALSE;
+	_dupenv_s(&envValue, &len, "SSH_TEST_ENVIRONMENT");
+
+	if ((NULL != envValue) && atoi(envValue))
+		retVal = TRUE;
+
+	if (envValue)
+		free(envValue);
+
+	return retVal;
+}
+
+int
+bash_to_win_path(const char *in, char *out, const size_t out_len)
+{
+	int retVal = 0;
+	const size_t cygwin_path_prefix_len = strlen(CYGWIN_PATH_PREFIX);
+	memset(out, 0, out_len);
+	if (_strnicmp(in, CYGWIN_PATH_PREFIX, cygwin_path_prefix_len) == 0) {
+		out[0] = in[cygwin_path_prefix_len];
+		out[1] = ':';
+		strcat_s(out, out_len, &in[cygwin_path_prefix_len + 1]);
+		retVal = 1;
+	} else
+		strcpy_s(out, out_len, in);
+
+	return retVal;
+}
+
+int
+getpeereid(int s, uid_t *euid, gid_t *egid)
+{
+	verbose("%s is not supported", __func__);
+	errno = ENOTSUP;
+	return -1;
+}
+
+int
+getrrsetbyname(const char *hostname, unsigned int rdclass,
+	unsigned int rdtype, unsigned int flags,
+	struct rrsetinfo **res)
+{
+	verbose("%s is not supported", __func__);
+	errno = ENOTSUP;
+	return -1;
+}
+
+int 
+fnmatch(const char *pattern, const char *string, int flags)
+{
+	int r = -1;
+	wchar_t *pw = NULL, *sw = NULL;
+
+	if (flags) {
+		verbose("%s is not supported with flags", __func__);
+		goto done;
+	}
+
+	pw = utf8_to_utf16(pattern);
+	sw = utf8_to_utf16(string);
+	if (!pw || !sw)
+		goto done;
+	convertToBackslashW(pw);
+	convertToBackslashW(sw);
+	if (PathMatchSpecW(sw, pw))
+		r = 0;
+done:
+	if (pw)
+		free(pw);
+	if (sw)
+		free(sw);
+	return r;
+}
+
+void
+freerrset(struct rrsetinfo *rrset)
+{
+	verbose("%s is not supported", __func__);
+	return;
+}
+
+void
+debug_assert_internal()
+{
+	/* debug break on non-release builds */
+#ifndef NDEBUG
+	DebugBreak();
+#endif
+}
+
+char
+*crypt(const char *key, const char *salt)
+{
+	verbose("%s is not supported", __func__);
+	errno = ENOTSUP;
+	return NULL;
+}
+
+int
+w32_system(const char *command)
+{
+	int ret = -1;
+	wchar_t *command_w = NULL;
+
+	if (!command) {
+		errno = ENOTSUP;
+		goto cleanup;
+	}
+
+	if ((command_w = utf8_to_utf16(command)) == NULL)
+		goto cleanup;
+
+	ret = _wsystem(command_w);
+
+cleanup:
+	if (command_w)
+		free(command_w);
+
+	return ret;
+}
+
+char *
+strrstr(const char *inStr, const char *pattern)
+{
+	char *tmp = NULL, *last = NULL;
+	tmp = (char *) inStr;
+	while(tmp = strstr(tmp, pattern))
+		last = tmp++;
+
+	return last;
+}
+
diff --git a/contrib/win32/win32compat/misc_internal.h b/contrib/win32/win32compat/misc_internal.h
new file mode 100644
index 000000000..0761cf86f
--- /dev/null
+++ b/contrib/win32/win32compat/misc_internal.h
@@ -0,0 +1,85 @@
+#pragma once
+#include <VersionHelpers.h>
+
+#define SSH_REGISTRY_ROOT L"SOFTWARE\\OpenSSH"
+#define GOTO_CLEANUP_IF(_cond_,_err_) do {  \
+    if ((_cond_)) {                         \
+        hr = _err_;                         \
+        goto cleanup;                       \
+    }                                       \
+} while(0)
+
+#define NULL_DEVICE "/dev/null"
+#define NULL_DEVICE_WIN "NUL"
+
+#define IsWin7OrLess() (!IsWindows8OrGreater())
+
+#define IS_INVALID_HANDLE(h) ( ((NULL == h) || (INVALID_HANDLE_VALUE == h)) ? 1 : 0 )
+#define IS_VALID_HANDLE(h) (!IS_INVALID_HANDLE(h))
+#define PROGRAM_DATA "__PROGRAMDATA__"
+#define PROGRAM_DATAW L"__PROGRAMDATA__"
+#define CYGWIN_PATH_PREFIX "/cygdrive/"
+
+#define errno_from_Win32LastError() errno_from_Win32Error(GetLastError())
+
+/* maximum potential size for paths when long paths are enabled */
+#define PATH_MAX 32768
+
+/* maximum size for user principal name as defined in ad schema */
+#define MAX_UPN_LEN 1024
+
+/* PTY windows size event type (for conhost and ssh-shellhost) */
+#define PTY_SIGNAL_RESIZE_WINDOW  8u
+
+/* maximum command line length */
+#define MAX_CMD_LEN 8191
+
+/* prog paths */
+extern char* __progname;
+extern char* __progdir;
+extern wchar_t* __wprogdir;
+
+/* %programdata% value */
+extern char* __progdata;
+extern wchar_t* __wprogdata;
+
+static char *machine_domain_name;
+
+extern char* chroot_path;
+extern int chroot_path_len;
+extern wchar_t* chroot_pathw;
+
+/* removes first '/' for Windows paths that are unix styled. Ex: /c:/ab.cd */
+wchar_t * resolved_path_utf16(const char *);
+char* resolved_path_utf8(const char *);
+void w32posix_initialize();
+void w32posix_done();
+void init_prog_paths();
+void convertToBackslash(char *str);
+void convertToBackslashW(wchar_t *str);
+void convertToForwardslash(char *str);
+int errno_from_Win32Error(int);
+void unix_time_to_file_time(ULONG, LPFILETIME);
+void file_time_to_unix_time(const LPFILETIME, time_t *);
+int file_attr_to_st_mode(wchar_t * path, DWORD attributes);
+void invalid_parameter_handler(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
+void to_lower_case(char *s);
+void to_wlower_case(wchar_t *s);
+HANDLE get_user_token(const char* user, int impersonation);
+int load_user_profile(HANDLE user_token, char* user);
+int create_directory_withsddl(wchar_t *path, wchar_t *sddl);
+int is_absolute_path(const char *);
+int file_in_chroot_jail(HANDLE);
+PSID lookup_sid(const wchar_t* name_utf16, PSID psid, DWORD * psid_len);
+PSID get_sid(const char*);
+int am_system();
+int is_conpty_supported();
+int exec_command_with_pty(int * pid, char* cmd, int in, int out, int err, unsigned int col, unsigned int row, int ttyfd);
+char * build_exec_command(const char * command);
+char * build_commandline_string(const char* cmd, char *const argv[], BOOLEAN prepend_module_path);
+char* get_custom_lsa_package();
+wchar_t* get_final_path_by_handle(HANDLE h);
+int lookup_principal_name(const wchar_t * sam_account_name, wchar_t * user_principal_name);
+BOOL is_bash_test_env();
+int bash_to_win_path(const char *in, char *out, const size_t out_len);
+void debug_assert_internal();
diff --git a/contrib/win32/win32compat/no-ops.c b/contrib/win32/win32compat/no-ops.c
new file mode 100644
index 000000000..a179d0ddf
--- /dev/null
+++ b/contrib/win32/win32compat/no-ops.c
@@ -0,0 +1,118 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Definitions of all SSH/POSIX calls that are otherwise no-ops in Windows
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "inc\sys\types.h"
+
+/* uuidswap.c defs */
+void
+temporarily_use_uid(struct passwd *pw)
+{
+	return;
+}
+
+void
+permanently_drop_suid(uid_t uid)
+{
+	return;
+}
+
+void
+restore_uid(void)
+{
+	return;
+}
+
+void
+permanently_set_uid(struct passwd *pw)
+{
+	return;
+}
+
+
+/* mux.c defs */
+int muxserver_sock = -1;
+typedef struct Channel Channel;
+unsigned int muxclient_command = 0;
+void
+muxserver_listen(void)
+{
+	return;
+}
+
+void
+mux_exit_message(Channel *c, int exitval)
+{
+	return;
+}
+
+void
+mux_tty_alloc_failed(Channel *c)
+{
+	return;
+}
+
+void
+muxclient(const char *path)
+{
+	return;
+}
+
+int
+innetgr(const char *netgroup, const char *host, const char *user, const char *domain)
+{
+	return -1;
+}
+
+
+/* sshd.c */
+int
+initgroups(const char *user, gid_t group)
+{
+	return 0;
+}
+
+int
+setgroups(gid_t group, char* name)
+{
+	return 0;
+}
+
+int
+setsid(void)
+{
+	return 0;
+}
+
+int
+startup_handler(void)
+{
+	return 0;
+}
+
diff --git a/contrib/win32/win32compat/openssh-events.h b/contrib/win32/win32compat/openssh-events.h
new file mode 100644
index 000000000..fa3658a1b
--- /dev/null
+++ b/contrib/win32/win32compat/openssh-events.h
@@ -0,0 +1,497 @@
+//**********************************************************************`
+//* This is an include file generated by Message Compiler.             *`
+//*                                                                    *`
+//* Copyright (c) Microsoft Corporation. All Rights Reserved.          *`
+//**********************************************************************`
+#pragma once
+#include <wmistr.h>
+#include <evntrace.h>
+#include "evntprov.h"
+//
+//  Initial Defs
+//
+#if !defined(ETW_INLINE)
+#define ETW_INLINE DECLSPEC_NOINLINE __inline
+#endif
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+//
+// Allow Diasabling of code generation
+//
+#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+#if  !defined(McGenDebug)
+#define McGenDebug(a,b)
+#endif 
+
+
+#if !defined(MCGEN_TRACE_CONTEXT_DEF)
+#define MCGEN_TRACE_CONTEXT_DEF
+typedef struct _MCGEN_TRACE_CONTEXT
+{
+    TRACEHANDLE            RegistrationHandle;
+    TRACEHANDLE            Logger;
+    ULONGLONG              MatchAnyKeyword;
+    ULONGLONG              MatchAllKeyword;
+    ULONG                  Flags;
+    ULONG                  IsEnabled;
+    UCHAR                  Level; 
+    UCHAR                  Reserve;
+    USHORT                 EnableBitsCount;
+    PULONG                 EnableBitMask;
+    const ULONGLONG*       EnableKeyWords;
+    const UCHAR*           EnableLevel;
+} MCGEN_TRACE_CONTEXT, *PMCGEN_TRACE_CONTEXT;
+#endif
+
+#if !defined(MCGEN_LEVEL_KEYWORD_ENABLED_DEF)
+#define MCGEN_LEVEL_KEYWORD_ENABLED_DEF
+FORCEINLINE
+BOOLEAN
+McGenLevelKeywordEnabled(
+    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
+    _In_ UCHAR Level,
+    _In_ ULONGLONG Keyword
+    )
+{
+    //
+    // Check if the event Level is lower than the level at which
+    // the channel is enabled.
+    // If the event Level is 0 or the channel is enabled at level 0,
+    // all levels are enabled.
+    //
+
+    if ((Level <= EnableInfo->Level) || // This also covers the case of Level == 0.
+        (EnableInfo->Level == 0)) {
+
+        //
+        // Check if Keyword is enabled
+        //
+
+        if ((Keyword == (ULONGLONG)0) ||
+            ((Keyword & EnableInfo->MatchAnyKeyword) &&
+             ((Keyword & EnableInfo->MatchAllKeyword) == EnableInfo->MatchAllKeyword))) {
+            return TRUE;
+        }
+    }
+
+    return FALSE;
+
+}
+#endif
+
+#if !defined(MCGEN_EVENT_ENABLED_DEF)
+#define MCGEN_EVENT_ENABLED_DEF
+FORCEINLINE
+BOOLEAN
+McGenEventEnabled(
+    _In_ PMCGEN_TRACE_CONTEXT EnableInfo,
+    _In_ PCEVENT_DESCRIPTOR EventDescriptor
+    )
+{
+
+    return McGenLevelKeywordEnabled(EnableInfo, EventDescriptor->Level, EventDescriptor->Keyword);
+
+}
+#endif
+
+
+//
+// EnableCheckMacro
+//
+#ifndef MCGEN_ENABLE_CHECK
+#define MCGEN_ENABLE_CHECK(Context, Descriptor) (Context.IsEnabled &&  McGenEventEnabled(&Context, &Descriptor))
+#endif
+
+#if !defined(MCGEN_CONTROL_CALLBACK)
+#define MCGEN_CONTROL_CALLBACK
+
+DECLSPEC_NOINLINE __inline
+VOID
+__stdcall
+McGenControlCallbackV2(
+    _In_ LPCGUID SourceId,
+    _In_ ULONG ControlCode,
+    _In_ UCHAR Level,
+    _In_ ULONGLONG MatchAnyKeyword,
+    _In_ ULONGLONG MatchAllKeyword,
+    _In_opt_ PEVENT_FILTER_DESCRIPTOR FilterData,
+    _Inout_opt_ PVOID CallbackContext
+    )
+/*++
+
+Routine Description:
+
+    This is the notification callback for Vista.
+
+Arguments:
+
+    SourceId - The GUID that identifies the session that enabled the provider. 
+
+    ControlCode - The parameter indicates whether the provider 
+                  is being enabled or disabled.
+
+    Level - The level at which the event is enabled.
+
+    MatchAnyKeyword - The bitmask of keywords that the provider uses to 
+                      determine the category of events that it writes.
+
+    MatchAllKeyword - This bitmask additionally restricts the category 
+                      of events that the provider writes. 
+
+    FilterData - The provider-defined data.
+
+    CallbackContext - The context of the callback that is defined when the provider 
+                      called EtwRegister to register itself.
+
+Remarks:
+
+    ETW calls this function to notify provider of enable/disable
+
+--*/
+{
+    PMCGEN_TRACE_CONTEXT Ctx = (PMCGEN_TRACE_CONTEXT)CallbackContext;
+    ULONG Ix;
+#ifndef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
+    UNREFERENCED_PARAMETER(SourceId);
+    UNREFERENCED_PARAMETER(FilterData);
+#endif
+
+    if (Ctx == NULL) {
+        return;
+    }
+
+    switch (ControlCode) {
+
+        case EVENT_CONTROL_CODE_ENABLE_PROVIDER:
+            Ctx->Level = Level;
+            Ctx->MatchAnyKeyword = MatchAnyKeyword;
+            Ctx->MatchAllKeyword = MatchAllKeyword;
+            Ctx->IsEnabled = EVENT_CONTROL_CODE_ENABLE_PROVIDER;
+
+            for (Ix = 0; Ix < Ctx->EnableBitsCount; Ix += 1) {
+                if (McGenLevelKeywordEnabled(Ctx, Ctx->EnableLevel[Ix], Ctx->EnableKeyWords[Ix]) != FALSE) {
+                    Ctx->EnableBitMask[Ix >> 5] |= (1 << (Ix % 32));
+                } else {
+                    Ctx->EnableBitMask[Ix >> 5] &= ~(1 << (Ix % 32));
+                }
+            }
+            break;
+
+        case EVENT_CONTROL_CODE_DISABLE_PROVIDER:
+            Ctx->IsEnabled = EVENT_CONTROL_CODE_DISABLE_PROVIDER;
+            Ctx->Level = 0;
+            Ctx->MatchAnyKeyword = 0;
+            Ctx->MatchAllKeyword = 0;
+            if (Ctx->EnableBitsCount > 0) {
+                RtlZeroMemory(Ctx->EnableBitMask, (((Ctx->EnableBitsCount - 1) / 32) + 1) * sizeof(ULONG));
+            }
+            break;
+ 
+        default:
+            break;
+    }
+
+#ifdef MCGEN_PRIVATE_ENABLE_CALLBACK_V2
+    //
+    // Call user defined callback
+    //
+    MCGEN_PRIVATE_ENABLE_CALLBACK_V2(
+        SourceId,
+        ControlCode,
+        Level,
+        MatchAnyKeyword,
+        MatchAllKeyword,
+        FilterData,
+        CallbackContext
+        );
+#endif
+   
+    return;
+}
+
+#endif
+#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+//+
+// Provider OpenSSH Event Count 5
+//+
+EXTERN_C __declspec(selectany) const GUID OpenSSH = {0xc4b57d35, 0x0636, 0x4bc3, {0xa2, 0x62, 0x37, 0x0f, 0x24, 0x9f, 0x98, 0x02}};
+
+//
+// Channel
+//
+#define OpenSSH_Admin 0x10
+#define OpenSSH_Operational 0x11
+#define OpenSSH_Debug 0x12
+
+//
+// Levels
+//
+#define Debug 0x10
+
+//
+// Event Descriptors
+//
+EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR CRITICAL_Event = {0x1, 0x0, 0x10, 0x1, 0x0, 0x0, 0x8000000000000000};
+#define CRITICAL_Event_value 0x1
+EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR ERROR_Event = {0x2, 0x0, 0x10, 0x2, 0x0, 0x0, 0x8000000000000000};
+#define ERROR_Event_value 0x2
+EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR WARNING_Event = {0x3, 0x0, 0x11, 0x3, 0x0, 0x0, 0x4000000000000000};
+#define WARNING_Event_value 0x3
+EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR INFO_Event = {0x4, 0x0, 0x11, 0x4, 0x0, 0x0, 0x4000000000000000};
+#define INFO_Event_value 0x4
+EXTERN_C __declspec(selectany) const EVENT_DESCRIPTOR DEBUG_Event = {0x6, 0x0, 0x12, 0x10, 0x0, 0x0, 0x2000000000000000};
+#define DEBUG_Event_value 0x6
+
+//
+// Note on Generate Code from Manifest Windows Vista and above
+//
+//Structures :  are handled as a size and pointer pairs. The macro for the event will have an extra 
+//parameter for the size in bytes of the structure. Make sure that your structures have no extra padding.
+//
+//Strings: There are several cases that can be described in the manifest. For array of variable length 
+//strings, the generated code will take the count of characters for the whole array as an input parameter. 
+//
+//SID No support for array of SIDs, the macro will take a pointer to the SID and use appropriate 
+//GetLengthSid function to get the length.
+//
+
+//
+// Allow Diasabling of code generation
+//
+#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+
+//
+// Globals 
+//
+
+
+//
+// Event Enablement Bits
+//
+
+EXTERN_C __declspec(selectany) DECLSPEC_CACHEALIGN ULONG OpenSSHEnableBits[1];
+EXTERN_C __declspec(selectany) const ULONGLONG OpenSSHKeywords[5] = {0x8000000000000000, 0x8000000000000000, 0x4000000000000000, 0x4000000000000000, 0x2000000000000000};
+EXTERN_C __declspec(selectany) const UCHAR OpenSSHLevels[5] = {1, 2, 3, 4, 16};
+EXTERN_C __declspec(selectany) MCGEN_TRACE_CONTEXT OpenSSH_Context = {0, 0, 0, 0, 0, 0, 0, 0, 5, OpenSSHEnableBits, OpenSSHKeywords, OpenSSHLevels};
+
+EXTERN_C __declspec(selectany) REGHANDLE OpenSSHHandle = (REGHANDLE)0;
+
+#if !defined(McGenEventRegisterUnregister)
+#define McGenEventRegisterUnregister
+DECLSPEC_NOINLINE __inline
+ULONG __stdcall
+McGenEventRegister(
+    _In_ LPCGUID ProviderId,
+    _In_opt_ PENABLECALLBACK EnableCallback,
+    _In_opt_ PVOID CallbackContext,
+    _Inout_ PREGHANDLE RegHandle
+    )
+/*++
+
+Routine Description:
+
+    This function register the provider with ETW USER mode.
+
+Arguments:
+    ProviderId - Provider Id to be register with ETW.
+
+    EnableCallback - Callback to be used.
+
+    CallbackContext - Context for this provider.
+
+    RegHandle - Pointer to Registration handle.
+
+Remarks:
+
+    If the handle != NULL will return ERROR_SUCCESS
+
+--*/
+{
+    ULONG Error;
+
+
+    if (*RegHandle) {
+        //
+        // already registered
+        //
+        return ERROR_SUCCESS;
+    }
+
+    Error = EventRegister( ProviderId, EnableCallback, CallbackContext, RegHandle); 
+
+    return Error;
+}
+
+
+DECLSPEC_NOINLINE __inline
+ULONG __stdcall
+McGenEventUnregister(_Inout_ PREGHANDLE RegHandle)
+/*++
+
+Routine Description:
+
+    Unregister from ETW USER mode
+
+Arguments:
+            RegHandle this is the pointer to the provider context
+Remarks:
+            If Provider has not register RegHandle = NULL,
+            return ERROR_SUCCESS
+--*/
+{
+    ULONG Error;
+
+
+    if(!(*RegHandle)) {
+        //
+        // Provider has not registerd
+        //
+        return ERROR_SUCCESS;
+    }
+
+    Error = EventUnregister(*RegHandle); 
+    *RegHandle = (REGHANDLE)0;
+    
+    return Error;
+}
+#endif
+//
+// Register with ETW Vista +
+//
+#ifndef EventRegisterOpenSSH
+#define EventRegisterOpenSSH() McGenEventRegister(&OpenSSH, McGenControlCallbackV2, &OpenSSH_Context, &OpenSSHHandle) 
+#endif
+
+//
+// UnRegister with ETW
+//
+#ifndef EventUnregisterOpenSSH
+#define EventUnregisterOpenSSH() McGenEventUnregister(&OpenSSHHandle) 
+#endif
+
+//
+// Enablement check macro for CRITICAL_Event
+//
+
+#define EventEnabledCRITICAL_Event() ((OpenSSHEnableBits[0] & 0x00000001) != 0)
+
+//
+// Event Macro for CRITICAL_Event
+//
+#define EventWriteCRITICAL_Event(process, payload)\
+        EventEnabledCRITICAL_Event() ?\
+        Template_zz(OpenSSHHandle, &CRITICAL_Event, process, payload)\
+        : ERROR_SUCCESS\
+
+//
+// Enablement check macro for ERROR_Event
+//
+
+#define EventEnabledERROR_Event() ((OpenSSHEnableBits[0] & 0x00000002) != 0)
+
+//
+// Event Macro for ERROR_Event
+//
+#define EventWriteERROR_Event(process, payload)\
+        EventEnabledERROR_Event() ?\
+        Template_zz(OpenSSHHandle, &ERROR_Event, process, payload)\
+        : ERROR_SUCCESS\
+
+//
+// Enablement check macro for WARNING_Event
+//
+
+#define EventEnabledWARNING_Event() ((OpenSSHEnableBits[0] & 0x00000004) != 0)
+
+//
+// Event Macro for WARNING_Event
+//
+#define EventWriteWARNING_Event(process, payload)\
+        EventEnabledWARNING_Event() ?\
+        Template_zz(OpenSSHHandle, &WARNING_Event, process, payload)\
+        : ERROR_SUCCESS\
+
+//
+// Enablement check macro for INFO_Event
+//
+
+#define EventEnabledINFO_Event() ((OpenSSHEnableBits[0] & 0x00000008) != 0)
+
+//
+// Event Macro for INFO_Event
+//
+#define EventWriteINFO_Event(process, payload)\
+        EventEnabledINFO_Event() ?\
+        Template_zz(OpenSSHHandle, &INFO_Event, process, payload)\
+        : ERROR_SUCCESS\
+
+//
+// Enablement check macro for DEBUG_Event
+//
+
+#define EventEnabledDEBUG_Event() ((OpenSSHEnableBits[0] & 0x00000010) != 0)
+
+//
+// Event Macro for DEBUG_Event
+//
+#define EventWriteDEBUG_Event(process, payload)\
+        EventEnabledDEBUG_Event() ?\
+        Template_zz(OpenSSHHandle, &DEBUG_Event, process, payload)\
+        : ERROR_SUCCESS\
+
+#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+
+
+//
+// Allow Diasabling of code generation
+//
+#ifndef MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+
+//
+// Template Functions 
+//
+//
+//Template from manifest : 2StrTemplate
+//
+#ifndef Template_zz_def
+#define Template_zz_def
+ETW_INLINE
+ULONG
+Template_zz(
+    _In_ REGHANDLE RegHandle,
+    _In_ PCEVENT_DESCRIPTOR Descriptor,
+    _In_opt_ PCWSTR  _Arg0,
+    _In_opt_ PCWSTR  _Arg1
+    )
+{
+#define ARGUMENT_COUNT_zz 2
+
+    EVENT_DATA_DESCRIPTOR EventData[ARGUMENT_COUNT_zz];
+
+    EventDataDescCreate(&EventData[0], 
+                        (_Arg0 != NULL) ? _Arg0 : L"NULL",
+                        (_Arg0 != NULL) ? (ULONG)((wcslen(_Arg0) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));
+
+    EventDataDescCreate(&EventData[1], 
+                        (_Arg1 != NULL) ? _Arg1 : L"NULL",
+                        (_Arg1 != NULL) ? (ULONG)((wcslen(_Arg1) + 1) * sizeof(WCHAR)) : (ULONG)sizeof(L"NULL"));
+
+    return EventWrite(RegHandle, Descriptor, ARGUMENT_COUNT_zz, EventData);
+}
+#endif
+
+#endif // MCGEN_DISABLE_PROVIDER_CODE_GENERATION
+
+#if defined(__cplusplus)
+};
+#endif
+
+#define MSG_level_Critical                   0x50000001L
+#define MSG_level_Error                      0x50000002L
+#define MSG_level_Warning                    0x50000003L
+#define MSG_level_Informational              0x50000004L
+#define MSG_OpenSSH_level_Debug_message      0x50000010L
+#define MSG_OpenSSH_event_message            0xB0000001L
diff --git a/contrib/win32/win32compat/pwd.c b/contrib/win32/win32compat/pwd.c
new file mode 100644
index 000000000..4b8fb3d8f
--- /dev/null
+++ b/contrib/win32/win32compat/pwd.c
@@ -0,0 +1,472 @@
+/*
+ * Author: NoMachine <developers@nomachine.com>
+ *
+ * Author: Bryan Berns <berns@uwalumni.com>
+ *   Normalized and optimized login routines and added support for
+ *   internet-linked accounts.
+ *
+ * Copyright (c) 2009, 2011 NoMachine
+ * All rights reserved
+ *
+ * Support functions and system calls' replacements needed to let the
+ * software run on Win32 based operating systems.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <Windows.h>
+#include <stdio.h>
+#include <LM.h>
+#include <sddl.h>
+#include <DsGetDC.h>
+#define SECURITY_WIN32
+#include <security.h>
+
+#include "inc\pwd.h"
+#include "inc\grp.h"
+#include "inc\utf.h"
+#include "misc_internal.h"
+#include "debug.h"
+
+static struct passwd pw;
+static char* pw_shellpath = NULL;
+char* shell_command_option = NULL;
+char* shell_arguments = NULL;
+BOOLEAN arg_escape = TRUE;
+
+/* returns 0 on success, and -1 with errno set on failure */
+static int
+set_defaultshell()
+{
+	HKEY reg_key = 0;
+	int tmp_len, ret = -1;
+	REGSAM mask = STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_WOW64_64KEY;
+	wchar_t path_buf[PATH_MAX], option_buf[PATH_MAX], arg_buf[PATH_MAX];
+	char *pw_shellpath_local = NULL, *command_option_local = NULL, *shell_arguments_local = NULL;
+
+	errno = 0;
+
+	/* if already set, return success */
+	if (pw_shellpath != NULL)
+		return 0;
+
+	path_buf[0] = L'\0';
+	option_buf[0] = L'\0';
+	arg_buf[0] = L'\0';
+
+	tmp_len = _countof(path_buf);
+	if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE, SSH_REGISTRY_ROOT, 0, mask, &reg_key) == ERROR_SUCCESS) &&
+	    (RegQueryValueExW(reg_key, L"DefaultShell", 0, NULL, (LPBYTE)path_buf, &tmp_len) == ERROR_SUCCESS) &&
+	    (path_buf[0] != L'\0')) {
+		/* fetched default shell path from registry */
+		tmp_len = _countof(option_buf);
+		DWORD size = sizeof(DWORD);
+		DWORD escape_option = 1;
+		if (RegQueryValueExW(reg_key, L"DefaultShellCommandOption", 0, NULL, (LPBYTE)option_buf, &tmp_len) != ERROR_SUCCESS)
+			option_buf[0] = L'\0';
+
+		tmp_len = _countof(arg_buf);
+		if (RegQueryValueExW(reg_key, L"DefaultShellArguments", 0, NULL, (LPBYTE)arg_buf, &tmp_len) != ERROR_SUCCESS)
+			arg_buf[0] = L'\0';
+
+		if (RegQueryValueExW(reg_key, L"DefaultShellEscapeArguments", 0, NULL, (LPBYTE)&escape_option, &size) == ERROR_SUCCESS)
+			arg_escape = (escape_option != 0) ? TRUE : FALSE;
+	} else {
+		if (!GetSystemDirectoryW(path_buf, _countof(path_buf))) {
+			errno = GetLastError();
+			goto cleanup;
+		}
+		if (wcscat_s(path_buf, _countof(path_buf), L"\\cmd.exe") != 0)
+			goto cleanup;
+	}
+
+	if ((pw_shellpath_local = utf16_to_utf8(path_buf)) == NULL)
+		goto cleanup;
+
+	if (option_buf[0] != L'\0')
+		if ((command_option_local = utf16_to_utf8(option_buf)) == NULL)
+			goto cleanup;
+
+	if (arg_buf[0] != L'\0')
+		if ((shell_arguments_local = utf16_to_utf8(arg_buf)) == NULL)
+			goto cleanup;
+
+	convertToBackslash(pw_shellpath_local);
+	to_lower_case(pw_shellpath_local);
+	pw_shellpath = pw_shellpath_local;
+	pw_shellpath_local = NULL;
+	shell_command_option = command_option_local;
+	shell_arguments = shell_arguments_local;
+	command_option_local = NULL;
+	shell_arguments_local = NULL;
+
+	ret = 0;
+cleanup:
+	if (pw_shellpath_local)
+		free(pw_shellpath_local);
+
+	if (command_option_local)
+		free(command_option_local);
+
+	if (shell_arguments_local)
+		free(shell_arguments_local);
+
+	return ret;
+}
+
+
+int
+initialize_pw()
+{
+	if (set_defaultshell() != 0)
+		return -1;
+
+	if (pw.pw_shell != pw_shellpath) {
+		memset(&pw, 0, sizeof(pw));
+		pw.pw_shell = pw_shellpath;
+		pw.pw_passwd = "\0";
+		/* pw_uid = 0 for root on Unix and SSH code has specific restrictions for root
+		 * that are not applicable in Windows */
+		pw.pw_uid = 1;
+	}
+	return 0;
+}
+
+static void 
+clean_pw()
+{
+	if (pw.pw_name)
+		free(pw.pw_name);
+	if (pw.pw_dir)
+		free(pw.pw_dir);
+	pw.pw_name = NULL;
+	pw.pw_dir = NULL;
+}
+
+static int
+reset_pw()
+{
+	if (initialize_pw() != 0)
+		return -1;
+
+	clean_pw();
+
+	return 0;
+}
+
+static struct passwd*
+get_passwd(const wchar_t * user_utf16, PSID sid)
+{
+	wchar_t user_resolved[DNLEN + 1 + UNLEN + 1];
+	struct passwd *ret = NULL;
+	wchar_t *sid_string = NULL, *tmp = NULL, *user_utf16_modified = NULL;
+	wchar_t reg_path[PATH_MAX], profile_home[PATH_MAX], profile_home_exp[PATH_MAX];
+	DWORD reg_path_len = PATH_MAX;
+	HKEY reg_key = 0;	
+	
+	BYTE binary_sid[SECURITY_MAX_SID_SIZE];
+	DWORD sid_size = ARRAYSIZE(binary_sid);
+	WCHAR domain_name[DNLEN + 1] = L"";
+	DWORD domain_name_size = DNLEN + 1;
+	SID_NAME_USE account_type = 0;
+
+	errno = 0;
+	if (reset_pw() != 0)
+		return NULL;
+	
+	/*
+	 * We support both "domain\user" and "domain/user" formats.
+	 * But win32 APIs only accept domain\user format so convert it.
+	 */
+	if (user_utf16) {
+		user_utf16_modified = _wcsdup(user_utf16);
+		if (!user_utf16_modified) {
+			errno = ENOMEM;
+			error("%s failed to duplicate %s", __func__, user_utf16);
+			goto cleanup;
+		}
+
+		if (tmp = wcsstr(user_utf16_modified, L"/"))
+			*tmp = L'\\';
+	}
+
+	/* skip forward lookup on name if sid was passed in */
+	if (sid != NULL)
+		CopySid(sizeof(binary_sid), binary_sid, sid);
+	/* else attempt to lookup the account; this will verify the account is valid and
+	 * is will return its sid and the realm that owns it */
+	else if (lookup_sid(user_utf16_modified, binary_sid, &sid_size) == NULL) {
+		debug("%s: lookup_sid() failed: %d.", __FUNCTION__, errno);
+		goto cleanup;
+	}
+
+	/* convert the binary string to a string */
+	if (ConvertSidToStringSidW((PSID) binary_sid, &sid_string) == FALSE) {
+		errno = errno_from_Win32LastError();
+		goto cleanup;
+	}
+
+	/* lookup the account name from the sid */
+	WCHAR user_name[UNLEN + 1];
+	DWORD user_name_length = ARRAYSIZE(user_name);
+	domain_name_size = DNLEN + 1;
+	if (LookupAccountSidW(NULL, binary_sid, user_name, &user_name_length,
+	    domain_name, &domain_name_size, &account_type) == 0) {
+		errno = errno_from_Win32LastError();
+		debug("%s: LookupAccountSid() failed: %d.", __FUNCTION__, GetLastError());
+		goto cleanup;
+	}
+
+	/* verify passed account is actually a user account */
+	if (account_type != SidTypeUser) {
+		errno = ENOENT;
+		debug3("%s: Invalid account type: %d.", __FUNCTION__, account_type);
+		goto cleanup;
+	}
+
+	/* fetch the computer name so we can determine if the specified user is local or not */
+	wchar_t computer_name[CNLEN + 1];
+	DWORD computer_name_size = ARRAYSIZE(computer_name);
+	if (GetComputerNameW(computer_name, &computer_name_size) == 0) {
+		error_f("GetComputerNameW() failed with error:%d", GetLastError());
+		goto cleanup;
+	}
+
+	/* if standard local user name or system account, just use name without decoration */
+	const SID_IDENTIFIER_AUTHORITY nt_authority = SECURITY_NT_AUTHORITY;
+	if ((_wcsicmp(domain_name, computer_name) == 0) ||
+		((memcmp(&nt_authority, GetSidIdentifierAuthority((PSID)binary_sid), sizeof(SID_IDENTIFIER_AUTHORITY)) == 0) &&
+		 (((SID*)binary_sid)->SubAuthority[0] == SECURITY_LOCAL_SYSTEM_RID))) {
+		wcscpy_s(user_resolved, ARRAYSIZE(user_resolved), user_name);
+	}
+
+	/* put any other format in sam compatible format */
+	else
+		swprintf_s(user_resolved, ARRAYSIZE(user_resolved), L"%s\\%s", domain_name, user_name);
+
+	/* if one of below fails, set profile path to Windows directory */
+	if (swprintf_s(reg_path, PATH_MAX, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\%ls", sid_string) == -1 ||
+	    RegOpenKeyExW(HKEY_LOCAL_MACHINE, reg_path, 0, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_WOW64_64KEY, &reg_key) != 0 ||
+	    RegQueryValueExW(reg_key, L"ProfileImagePath", 0, NULL, (LPBYTE)profile_home, &reg_path_len) != 0 ||
+	    ExpandEnvironmentStringsW(profile_home, NULL, 0) > PATH_MAX ||
+	    ExpandEnvironmentStringsW(profile_home, profile_home_exp, PATH_MAX) == 0)
+		if (GetWindowsDirectoryW(profile_home_exp, PATH_MAX) == 0) {
+			debug3("GetWindowsDirectoryW failed with %d", GetLastError());
+			errno = EOTHER;
+			goto cleanup;
+		}
+
+	/* convert to utf8, make name lowercase, and assign to output structure*/
+	_wcslwr_s(user_resolved, wcslen(user_resolved) + 1);
+	if ((pw.pw_name = utf16_to_utf8(user_resolved)) == NULL ||
+	    (pw.pw_dir = utf16_to_utf8(profile_home_exp)) == NULL) {
+		clean_pw();
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	ret = &pw;
+
+cleanup:
+
+	if (sid_string)
+		LocalFree(sid_string);
+	if (reg_key)
+		RegCloseKey(reg_key);
+
+	return ret;
+}
+
+static struct passwd*
+getpwnam_placeholder(const char* user) {
+	wchar_t tmp_home[PATH_MAX];
+	char *pw_name = NULL, *pw_dir = NULL;
+	struct passwd* ret = NULL;
+
+	if (GetWindowsDirectoryW(tmp_home, PATH_MAX) == 0) {
+		debug3("GetWindowsDirectoryW failed with %d", GetLastError());
+		errno = EOTHER;
+		goto cleanup;
+	}
+	pw_name = _strdup(user);
+	pw_dir = utf16_to_utf8(tmp_home);
+
+	if (!pw_name || !pw_dir) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	pw.pw_name = pw_name;
+	pw_name = NULL;
+	pw.pw_dir = pw_dir;
+	pw_dir = NULL;
+
+	ret = &pw;
+cleanup:
+	if (pw_name)
+		free(pw_name);
+	if (pw_dir)
+		free(pw_dir);
+
+	return ret;
+}
+
+char *
+get_username(const PSID sid)
+{
+	if (!sid) {
+		error_f("sid is NULL");
+		return NULL;
+	}
+
+	struct passwd *p = get_passwd(NULL, sid);
+	if (p && p->pw_name)
+		return _strdup(p->pw_name);
+	else
+		return NULL;
+}
+
+struct passwd*
+w32_getpwnam(const char *user_utf8)
+{
+	struct passwd* ret = NULL;
+	wchar_t * user_utf16 = NULL;
+
+	user_utf16 = utf8_to_utf16(user_utf8);
+	if (user_utf16 == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	ret = get_passwd(user_utf16, NULL);
+	if (ret != NULL)
+		goto done;
+
+	/* for unpriviliged user account, create placeholder and return*/
+	if (_stricmp(user_utf8, "sshd") == 0) {
+		ret = getpwnam_placeholder(user_utf8);
+		goto done;
+	}
+
+	/* check if custom passwd auth is enabled */
+	if (get_custom_lsa_package())
+		ret = getpwnam_placeholder(user_utf8);
+
+done:
+	if (user_utf16)
+		free(user_utf16);
+	return ret;
+}
+
+struct passwd*
+w32_getpwuid(uid_t uid)
+{
+	struct passwd* ret = NULL;
+	PSID cur_user_sid = NULL;
+	
+	if ((cur_user_sid = get_sid(NULL)) == NULL)
+		goto cleanup;
+
+	ret = get_passwd(NULL, cur_user_sid);
+
+cleanup:
+	if (cur_user_sid)
+		free(cur_user_sid);
+
+	return ret;
+}
+
+char *
+group_from_gid(gid_t gid, int nogroup)
+{
+	return "-";
+}
+
+char *
+user_from_uid(uid_t uid, int nouser)
+{
+	return "-";
+}
+
+uid_t
+w32_getuid(void)
+{
+	return 1;
+}
+
+gid_t
+getgid(void)
+{
+	return 0;
+}
+
+uid_t
+geteuid(void)
+{
+	return 1;
+}
+
+gid_t
+getegid(void)
+{
+	return 0;
+}
+
+int
+setuid(uid_t uid)
+{
+	return 0;
+}
+
+int
+setgid(gid_t gid)
+{
+	return 0;
+}
+
+int
+seteuid(uid_t uid)
+{
+	return 0;
+}
+
+int
+setegid(gid_t gid)
+{
+	return 0;
+}
+
+struct passwd *getpwent(void)
+{
+	return NULL;
+}
+
+void setpwent(void)
+{
+	return;
+}
+
+void
+endpwent(void)
+{
+	return;
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/shell-host.c b/contrib/win32/win32compat/shell-host.c
new file mode 100644
index 000000000..f0093190e
--- /dev/null
+++ b/contrib/win32/win32compat/shell-host.c
@@ -0,0 +1,1507 @@
+/*
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+ * Primitive shell-host to support parsing of cmd.exe input and async IO redirection
+ *
+ * Author: Ray Heyes <ray.hayes@microsoft.com>
+ * PTY with ANSI emulation wrapper
+ *
+ * Copyright (c) 2017 Microsoft Corp.
+ * All rights reserved
+ *
+ * Shell-host is responsible for handling all the interactive and non-interactive cmds.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <Windows.h>
+#include <Strsafe.h>
+#include <stdio.h>
+#include <io.h>
+#include <Shlobj.h>
+#include <Sddl.h>
+#include <process.h>
+#include "misc_internal.h"
+#include "inc\utf.h"
+
+#define MAX_CONSOLE_COLUMNS 9999
+#define MAX_CONSOLE_ROWS 9999
+#define WM_APPEXIT WM_USER+1
+#define MAX_EXPECTED_BUFFER_SIZE 1024
+/* 4KB is the largest size for which writes are guaranteed to be atomic */
+#define BUFF_SIZE 4096
+
+#ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
+#define ENABLE_VIRTUAL_TERMINAL_PROCESSING  0x4
+#endif
+
+#ifndef ENABLE_VIRTUAL_TERMINAL_INPUT
+#define ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200
+#endif
+
+#define VK_A 0x41
+#define VK_B 0x42
+#define VK_C 0x43
+#define VK_D 0x44
+#define VK_E 0x45
+#define VK_F 0x46
+#define VK_G 0x47
+#define VK_H 0x48
+#define VK_I 0x49
+#define VK_J 0x4A
+#define VK_K 0x4B
+#define VK_L 0x4C
+#define VK_M 0x4D
+#define VK_N 0x4E
+#define VK_O 0x4F
+#define VK_P 0x50
+#define VK_Q 0x51
+#define VK_R 0x52
+#define VK_S 0x53
+#define VK_T 0x54
+#define VK_U 0x55
+#define VK_V 0x56
+#define VK_W 0x57
+#define VK_X 0x58
+#define VK_Y 0x59
+#define VK_Z 0x5A
+#define VK_0 0x30
+#define VK_1 0x31
+#define VK_2 0x32
+#define VK_3 0x33
+#define VK_4 0x34
+#define VK_5 0x35
+#define VK_6 0x36
+#define VK_7 0x37
+#define VK_8 0x38
+#define VK_9 0x39
+
+const int MAX_CTRL_SEQ_LEN = 7;
+const int MIN_CTRL_SEQ_LEN = 6;
+
+typedef BOOL(WINAPI *__t_SetCurrentConsoleFontEx)(
+	_In_ HANDLE               hConsoleOutput,
+	_In_ BOOL                 bMaximumWindow,
+	_In_ PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx
+	);
+__t_SetCurrentConsoleFontEx __SetCurrentConsoleFontEx;
+
+typedef BOOL(WINAPI *__t_UnhookWinEvent)(
+	_In_ HWINEVENTHOOK hWinEventHook
+	);
+__t_UnhookWinEvent __UnhookWinEvent;
+
+typedef HWINEVENTHOOK(WINAPI *__t_SetWinEventHook)(
+	_In_ UINT         eventMin,
+	_In_ UINT         eventMax,
+	_In_ HMODULE      hmodWinEventProc,
+	_In_ WINEVENTPROC lpfnWinEventProc,
+	_In_ DWORD        idProcess,
+	_In_ DWORD        idThread,
+	_In_ UINT         dwflags
+	);
+__t_SetWinEventHook __SetWinEventHook;
+
+typedef struct consoleEvent {
+	DWORD event;
+	HWND  hwnd;
+	LONG  idObject;
+	LONG  idChild;
+	void* prior;
+	void* next;
+} consoleEvent;
+
+struct key_translation {
+	wchar_t in[8];
+	int vk;
+	wchar_t out;
+	int in_key_len;
+	DWORD ctrlState;
+} key_translation;
+
+/* All the substrings should be in the end, otherwise ProcessIncomingKeys() will not work as expected */
+struct key_translation keys[] = {
+    { L"\r",         VK_RETURN,  L'\r', 0, 0},
+    { L"\n",         VK_RETURN,  L'\r', 0, 0 },
+    { L"\b",         VK_BACK,    L'\b', 0, 0 },
+    { L"\x7f",       VK_BACK,    L'\b', 0 , 0 },
+    { L"\t",         VK_TAB,     L'\t' , 0 , 0},
+    { L"\x1b[A",     VK_UP,       0 , 0 , 0},
+    { L"\x1b[B",     VK_DOWN,     0 , 0 , 0},
+    { L"\x1b[C",     VK_RIGHT,    0 , 0 , 0},
+    { L"\x1b[D",     VK_LEFT,     0 , 0 , 0},
+    { L"\x1b[F",     VK_END,      0 , 0 , 0},    /* KeyPad END */
+    { L"\x1b[H",     VK_HOME,     0 , 0 , 0},    /* KeyPad HOME */
+    { L"\x1b[Z",     VK_TAB,     L'\t' , 0 , SHIFT_PRESSED},
+    { L"\x1b[1~",    VK_HOME,     0 , 0 , 0},
+    { L"\x1b[2~",    VK_INSERT,   0 , 0 , 0},
+    { L"\x1b[3~",    VK_DELETE,   0 , 0 , 0},
+    { L"\x1b[4~",    VK_END,      0 , 0 , 0},
+    { L"\x1b[5~",    VK_PRIOR,    0 , 0 , 0},
+    { L"\x1b[6~",    VK_NEXT,     0 , 0 , 0},
+    { L"\x1b[11~",   VK_F1,       0 , 0 , 0},
+    { L"\x1b[12~",   VK_F2,       0 , 0 , 0},
+    { L"\x1b[13~",   VK_F3,       0 , 0 , 0},
+    { L"\x1b[14~",   VK_F4,       0 , 0 , 0},
+    { L"\x1b[15~",   VK_F5,       0 , 0 , 0},
+    { L"\x1b[17~",   VK_F6,       0 , 0 , 0},
+    { L"\x1b[18~",   VK_F7,       0 , 0 , 0},
+    { L"\x1b[19~",   VK_F8,       0 , 0 , 0},
+    { L"\x1b[20~",   VK_F9,       0 , 0 , 0},
+    { L"\x1b[21~",   VK_F10,      0 , 0 , 0},
+    { L"\x1b[23~",   VK_F11,      0 , 0 , 0},
+    { L"\x1b[24~",   VK_F12,      0 , 0 , 0},
+    { L"\x1bOA",     VK_UP,       0 , 0 , 0},
+    { L"\x1bOB",     VK_DOWN,     0 , 0 , 0},
+    { L"\x1bOC",     VK_RIGHT,    0 , 0 , 0},
+    { L"\x1bOD",     VK_LEFT,     0 , 0 , 0},
+    { L"\x1bOF",     VK_END,      0 , 0 , 0},    /* KeyPad END */
+    { L"\x1bOH",     VK_HOME,     0 , 0 , 0},    /* KeyPad HOME */
+    { L"\x1bOP",     VK_F1,       0 , 0 , 0},
+    { L"\x1bOQ",     VK_F2,       0 , 0 , 0},
+    { L"\x1bOR",     VK_F3,       0 , 0 , 0},
+    { L"\x1bOS",     VK_F4,       0 , 0 , 0},
+    { L"\x1",        VK_A,   L'\x1' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x2",        VK_B,   L'\x2' , 0 , LEFT_CTRL_PRESSED},
+    //{ L"\x3",        VK_C,   L'\x3' , 0 , LEFT_CTRL_PRESSED}, /* Control + C is handled differently */
+    { L"\x4",        VK_D,   L'\x4' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x5",        VK_E,   L'\x5' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x6",        VK_F,   L'\x6' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x7",        VK_G,   L'\x7' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x8",        VK_H,   L'\x8' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x9",        VK_I,   L'\x9' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xA",        VK_J,   L'\xA' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xB",        VK_K,   L'\xB' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xC",        VK_L,   L'\xC' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xD",        VK_M,   L'\xD' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xE",        VK_N,   L'\xE' , 0 , LEFT_CTRL_PRESSED},
+    { L"\xF",        VK_O,   L'\xF' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x10",       VK_P,   L'\x10' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x11",       VK_Q,   L'\x11' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x12",       VK_R,   L'\x12' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x13",       VK_S,   L'\x13' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x14",       VK_T,   L'\x14' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x15",       VK_U,   L'\x15' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x16",       VK_V,   L'\x16' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x17",       VK_W,   L'\x17' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x18",       VK_X,   L'\x18' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x19",       VK_Y,   L'\x19' , 0 , LEFT_CTRL_PRESSED},
+    { L"\x1A",       VK_Z,   L'\x1A' , 0 , LEFT_CTRL_PRESSED},
+    { L"\033a",      VK_A,   L'a', 0, LEFT_ALT_PRESSED},
+    { L"\033b",      VK_B,   L'b', 0, LEFT_ALT_PRESSED},
+    { L"\033c",      VK_C,   L'c', 0, LEFT_ALT_PRESSED},
+    { L"\033d",      VK_D,   L'd', 0, LEFT_ALT_PRESSED},
+    { L"\033e",      VK_E,   L'e', 0, LEFT_ALT_PRESSED},
+    { L"\033f",      VK_F,   L'f', 0, LEFT_ALT_PRESSED},
+    { L"\033g",      VK_G,   L'g', 0, LEFT_ALT_PRESSED},
+    { L"\033h",      VK_H,   L'h', 0, LEFT_ALT_PRESSED},
+    { L"\033i",      VK_I,   L'i', 0, LEFT_ALT_PRESSED},
+    { L"\033j",      VK_J,   L'j', 0, LEFT_ALT_PRESSED},
+    { L"\033k",      VK_K,   L'k', 0, LEFT_ALT_PRESSED},
+    { L"\033l",      VK_L,   L'l', 0, LEFT_ALT_PRESSED},
+    { L"\033m",      VK_M,   L'm', 0, LEFT_ALT_PRESSED},
+    { L"\033n",      VK_N,   L'n', 0, LEFT_ALT_PRESSED},
+    { L"\033o",      VK_O,   L'o', 0, LEFT_ALT_PRESSED},
+    { L"\033p",      VK_P,   L'p', 0, LEFT_ALT_PRESSED},
+    { L"\033q",      VK_Q,   L'q', 0, LEFT_ALT_PRESSED},
+    { L"\033r",      VK_R,   L'r', 0, LEFT_ALT_PRESSED},
+    { L"\033s",      VK_S,   L's', 0, LEFT_ALT_PRESSED},
+    { L"\033t",      VK_T,   L't', 0, LEFT_ALT_PRESSED},
+    { L"\033u",      VK_U,   L'u', 0, LEFT_ALT_PRESSED},
+    { L"\033v",      VK_V,   L'v', 0, LEFT_ALT_PRESSED},
+    { L"\033w",      VK_W,   L'w', 0, LEFT_ALT_PRESSED},
+    { L"\033x",      VK_X,   L'x', 0, LEFT_ALT_PRESSED},
+    { L"\033y",      VK_Y,   L'y', 0, LEFT_ALT_PRESSED},
+    { L"\033z",      VK_Z,   L'z', 0, LEFT_ALT_PRESSED},
+    { L"\0330",      VK_0,   L'0', 0, LEFT_ALT_PRESSED},
+    { L"\0331",      VK_1,   L'1', 0, LEFT_ALT_PRESSED},
+    { L"\0332",      VK_2,   L'2', 0, LEFT_ALT_PRESSED},
+    { L"\0333",      VK_3,   L'3', 0, LEFT_ALT_PRESSED},
+    { L"\0334",      VK_4,   L'4', 0, LEFT_ALT_PRESSED},
+    { L"\0335",      VK_5,   L'5', 0, LEFT_ALT_PRESSED},
+    { L"\0336",      VK_6,   L'6', 0, LEFT_ALT_PRESSED},
+    { L"\0337",      VK_7,   L'7', 0, LEFT_ALT_PRESSED},
+    { L"\0338",      VK_8,   L'8', 0, LEFT_ALT_PRESSED},
+    { L"\0339",      VK_9,   L'9', 0, LEFT_ALT_PRESSED},
+    { L"\033!",      VK_1,   L'!', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033@",      VK_2,   L'@', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033#",      VK_3,   L'#', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033$",      VK_4,   L'$', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033%",      VK_5,   L'%', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033^",      VK_6,   L'^', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033&",      VK_7,   L'&', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033*",      VK_8,   L'*', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033(",      VK_9,   L'(', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED },
+    { L"\033)",      VK_0,   L')', 0, LEFT_ALT_PRESSED | SHIFT_PRESSED }
+};
+
+static SHORT lastX = 0;
+static SHORT lastY = 0;
+static wchar_t system32_path[PATH_MAX + 1] = { 0, };
+
+SHORT currentLine = 0;
+consoleEvent* head = NULL;
+consoleEvent* tail = NULL;
+
+BOOL bRet = FALSE;
+BOOL bNoScrollRegion = FALSE;
+BOOL bStartup = TRUE;
+BOOL bHookEvents = FALSE;
+BOOL bFullScreen = FALSE;
+BOOL bUseAnsiEmulation = TRUE;
+
+HANDLE child_out = INVALID_HANDLE_VALUE;
+HANDLE child_in = INVALID_HANDLE_VALUE;
+HANDLE child_err = INVALID_HANDLE_VALUE;
+HANDLE pipe_in = INVALID_HANDLE_VALUE;
+HANDLE pipe_out = INVALID_HANDLE_VALUE;
+HANDLE pipe_ctrl = INVALID_HANDLE_VALUE;
+HANDLE child = INVALID_HANDLE_VALUE;
+HANDLE job = NULL;
+HANDLE hConsoleBuffer = INVALID_HANDLE_VALUE;
+HANDLE monitor_thread = INVALID_HANDLE_VALUE;
+HANDLE io_thread = INVALID_HANDLE_VALUE;
+HANDLE ux_thread = INVALID_HANDLE_VALUE;
+HANDLE ctrl_thread = INVALID_HANDLE_VALUE;
+
+DWORD child_exit_code = 0;
+DWORD hostProcessId = 0;
+DWORD hostThreadId = 0;
+DWORD childProcessId = 0;
+DWORD dwStatus = 0;
+DWORD in_cmd_len = 0;
+DWORD lastLineLength = 0;
+
+UINT cp = 0;
+UINT ViewPortY = 0;
+UINT lastViewPortY = 0;
+UINT savedViewPortY = 0;
+UINT savedLastViewPortY = 0;
+
+char in_cmd[MAX_CMD_LEN];
+
+CRITICAL_SECTION criticalSection;
+
+CONSOLE_SCREEN_BUFFER_INFOEX  consoleInfo;
+CONSOLE_SCREEN_BUFFER_INFOEX  nextConsoleInfo;
+STARTUPINFO inputSi;
+
+#define GOTO_CLEANUP_ON_FALSE(exp) do {	\
+	ret = (exp);			\
+	if (ret == FALSE)		\
+		goto cleanup;		\
+} while(0)
+
+#define GOTO_CLEANUP_ON_ERR(exp) do {	\
+	if ((exp) != 0)			\
+		goto cleanup;		\
+} while(0)
+
+void     
+debug3(const char *s, ...) {
+	return;
+}
+
+int
+ConSRWidth()
+{
+	CONSOLE_SCREEN_BUFFER_INFOEX  consoleBufferInfo;
+	ZeroMemory(&consoleBufferInfo, sizeof(consoleBufferInfo));
+	consoleBufferInfo.cbSize = sizeof(consoleBufferInfo);
+
+	GetConsoleScreenBufferInfoEx(child_out, &consoleBufferInfo);
+	return consoleBufferInfo.srWindow.Right;
+}
+
+void
+my_invalid_parameter_handler(const wchar_t* expression, const wchar_t* function,
+	 const wchar_t* file, unsigned int line, uintptr_t pReserved)
+{
+	wprintf_s(L"Invalid parameter in function: %s. File: %s Line: %d\n", function, file, line);
+	wprintf_s(L"Expression: %s\n", expression);
+}
+
+struct key_translation *
+FindKeyTransByMask(wchar_t prefix, const wchar_t * value, int vlen, wchar_t suffix)
+{
+	struct key_translation *k = NULL;
+	for (int i = 0; i < ARRAYSIZE(keys); i++) {
+		k = &keys[i];
+		if (k->in_key_len < vlen + 2) continue;
+		if (k->in[0] != L'\033') continue;
+		if (k->in[1] != prefix) continue;
+		if (k->in[vlen + 2] != suffix) continue;
+
+		if (vlen <= 1 && value[0] == k->in[2])
+			return k;
+		if (vlen > 1 && wcsncmp(&k->in[2], value, vlen) == 0)
+			return k;
+	}
+
+	return NULL;
+}
+
+int
+GetVirtualKeyByMask(wchar_t prefix, const wchar_t * value, int vlen, wchar_t suffix)
+{
+	struct key_translation * pk = FindKeyTransByMask(prefix, value, vlen, suffix);
+	return pk ? pk->vk : 0;
+}
+
+/*
+ * This function will handle the console keystrokes.
+ */
+void
+SendKeyStrokeEx(HANDLE hInput, int vKey, wchar_t character, DWORD ctrlState, BOOL keyDown)
+{
+	DWORD wr = 0;
+	INPUT_RECORD ir;
+
+	ir.EventType = KEY_EVENT;
+	ir.Event.KeyEvent.bKeyDown = keyDown;
+	ir.Event.KeyEvent.wRepeatCount = 1;
+	ir.Event.KeyEvent.wVirtualKeyCode = vKey;
+	ir.Event.KeyEvent.wVirtualScanCode = MapVirtualKeyA(vKey, MAPVK_VK_TO_VSC);
+	ir.Event.KeyEvent.dwControlKeyState = ctrlState;
+	ir.Event.KeyEvent.uChar.UnicodeChar = character;
+
+	WriteConsoleInputW(hInput, &ir, 1, &wr);
+}
+
+void
+SendKeyStroke(HANDLE hInput, int keyStroke, wchar_t character, DWORD ctrlState)
+{
+	SendKeyStrokeEx(hInput, keyStroke, character, ctrlState, TRUE);
+	SendKeyStrokeEx(hInput, keyStroke, character, ctrlState, FALSE);
+}
+
+void
+initialize_keylen()
+{
+	for(int i = 0; i < ARRAYSIZE(keys); i++)
+		keys[i].in_key_len = (int) wcsnlen(keys[i].in, _countof(keys[i].in));
+}
+
+int
+ProcessModifierKeySequence(wchar_t *buf, int buf_len)
+{
+	if(buf_len < MIN_CTRL_SEQ_LEN)
+		return 0;
+
+	int vkey = 0;	
+	int modifier_key = _wtoi((wchar_t *)&buf[buf_len - 2]);
+
+	if ((modifier_key < 2) && (modifier_key > 7))
+		return 0;
+
+	/* Decode special keys when pressed ALT/CTRL/SHIFT key */
+	if (buf[0] == L'\033' && buf[1] == L'[' && buf[buf_len - 3] == L';') {
+		if (buf[buf_len - 1] == L'~') {
+			/* VK_DELETE, VK_PGDN, VK_PGUP */
+			if (!vkey && buf_len == 6)
+				vkey = GetVirtualKeyByMask(L'[', &buf[2], 1, L'~');
+
+			/* VK_F1 ... VK_F12 */
+			if (!vkey && buf_len == 7)
+				vkey = GetVirtualKeyByMask(L'[', &buf[2], 2, L'~');
+		} else {
+			/* VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN */
+			if (!vkey && buf_len == 6 && buf[2] == L'1')
+				vkey = GetVirtualKeyByMask(L'[', &buf[5], 1, 0);
+
+			/* VK_F1 ... VK_F4 */
+			if (!vkey && buf_len == 6 && buf[2] == L'1' && isalpha(buf[5]))
+				vkey = GetVirtualKeyByMask(L'O', &buf[5], 1, 0);
+		}
+		if (vkey) {
+			switch (modifier_key)
+			{
+				case 2:
+					SendKeyStroke(child_in, vkey, 0, SHIFT_PRESSED);
+					break;
+				case 3:
+					SendKeyStroke(child_in, vkey, 0, LEFT_ALT_PRESSED);
+					break;
+				case 4:
+					SendKeyStroke(child_in, vkey, 0, SHIFT_PRESSED | LEFT_ALT_PRESSED);
+					break;
+				case 5:
+					SendKeyStroke(child_in, vkey, 0, LEFT_CTRL_PRESSED);
+					break;
+				case 6:
+					SendKeyStroke(child_in, vkey, 0, SHIFT_PRESSED | LEFT_CTRL_PRESSED);
+					break;
+				case 7:
+					SendKeyStroke(child_in, vkey, 0, LEFT_CTRL_PRESSED | LEFT_ALT_PRESSED);
+					break;				
+			}
+		}
+			
+	}
+
+	return vkey;
+}
+int
+CheckKeyTranslations(wchar_t *buf, int buf_len, int *index)
+{
+	for (int j = 0; j < ARRAYSIZE(keys); j++) {
+		if ((buf_len >= keys[j].in_key_len) && (wcsncmp(buf, keys[j].in, keys[j].in_key_len) == 0)) {
+			*index = j;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+void 
+ProcessIncomingKeys(char * ansikey)
+{
+	int buf_len = 0;
+	const wchar_t *ESC_SEQ = L"\x1b";
+	wchar_t *buf = utf8_to_utf16(ansikey);
+
+	if (!buf) {
+		printf_s("\nFailed to deserialize the client data, error:%d\n", GetLastError());
+		exit(255);
+	}
+
+	loop:
+	while (buf && ((buf_len=(int)wcslen(buf)) > 0)) {
+		int j = 0;
+		if (CheckKeyTranslations(buf, buf_len, &j)) {
+			SendKeyStroke(child_in, keys[j].vk, keys[j].out, keys[j].ctrlState);				
+			buf += keys[j].in_key_len;
+			goto loop;
+		}
+
+		/* Decode special keys when pressed CTRL key. CTRL sequences can be of size 6 or 7. */
+		if ((buf_len >= MAX_CTRL_SEQ_LEN) && ProcessModifierKeySequence(buf, MAX_CTRL_SEQ_LEN)) {
+			buf += MAX_CTRL_SEQ_LEN;
+			goto loop;
+		}
+
+		if ((buf_len >= (MAX_CTRL_SEQ_LEN - 1)) && ProcessModifierKeySequence(buf, MAX_CTRL_SEQ_LEN - 1)) {
+			buf += (MAX_CTRL_SEQ_LEN - 1);
+			goto loop;
+		}
+
+		if(wcsncmp(buf, ESC_SEQ, wcslen(ESC_SEQ)) == 0) {
+			wchar_t* p = buf + wcslen(ESC_SEQ);
+			/* Alt sequence */
+			if (CheckKeyTranslations(p, buf_len - (int)wcslen(ESC_SEQ), &j) && !(keys[j].ctrlState & LEFT_ALT_PRESSED)) {
+				SendKeyStroke(child_in, keys[j].vk, keys[j].out, keys[j].ctrlState| LEFT_ALT_PRESSED);
+				buf += wcslen(ESC_SEQ) +keys[j].in_key_len;
+				goto loop;
+			}
+
+			SendKeyStroke(child_in, VK_ESCAPE, L'\x1b', 0);
+			buf += wcslen(ESC_SEQ);
+			goto loop;
+		}
+
+		if (*buf == L'\x3') /*Ctrl+C - Raise Ctrl+C*/
+			GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);
+		else 
+			SendKeyStroke(child_in, 0, *buf, 0);
+
+		buf++;
+	}		
+}
+
+/*
+ * VT output routines
+ */
+void 
+SendLF(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\n", 1, &wr, NULL);
+}
+
+void 
+SendClearScreen(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\033[2J", 4, &wr, NULL);
+}
+
+void 
+SendClearScreenFromCursor(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\033[1J", 4, &wr, NULL);
+}
+
+void 
+SendHideCursor(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\033[?25l", 6, &wr, NULL);
+}
+
+void 
+SendShowCursor(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\033[?25h", 6, &wr, NULL);
+}
+
+void 
+SendCursorPositionRequest(HANDLE hInput)
+{
+	DWORD wr = 0;
+
+	if (bUseAnsiEmulation)
+		WriteFile(hInput, "\033[6n", 4, &wr, NULL);
+}
+
+void 
+SendSetCursor(HANDLE hInput, int X, int Y)
+{
+	DWORD wr = 0;
+	int out = 0;
+	char formatted_output[255];
+
+	out = _snprintf_s(formatted_output, sizeof(formatted_output), _TRUNCATE, "\033[%d;%dH", Y, X);
+	if (out > 0 && bUseAnsiEmulation)
+		WriteFile(hInput, formatted_output, out, &wr, NULL);
+}
+
+void 
+SendVerticalScroll(HANDLE hInput, int lines)
+{
+	DWORD wr = 0;
+	int out = 0;
+	char formatted_output[255];
+
+	LONG vn = abs(lines);
+	/* Not supporting the [S at the moment. */
+	if (lines > 0) {
+		out = _snprintf_s(formatted_output, sizeof(formatted_output), _TRUNCATE, "\033[%dT", vn);
+
+		if (out > 0 && bUseAnsiEmulation)
+			WriteFile(hInput, formatted_output, out, &wr, NULL);
+	}	
+}
+
+void 
+SendHorizontalScroll(HANDLE hInput, int cells)
+{
+	DWORD wr = 0;
+	int out = 0;
+	char formatted_output[255];
+
+	out = _snprintf_s(formatted_output, sizeof(formatted_output), _TRUNCATE, "\033[%dG", cells);
+
+	if (out > 0 && bUseAnsiEmulation)
+		WriteFile(hInput, formatted_output, out, &wr, NULL);
+}
+
+void 
+SendCharacter(HANDLE hInput, WORD attributes, wchar_t character)
+{
+	DWORD wr = 0;
+	DWORD out = 0;
+	DWORD current = 0;
+	char formatted_output[2048];
+	static WORD pattributes = 0;
+	USHORT Color = 0;
+	ULONG Status = 0;
+	PSTR Next;
+	size_t SizeLeft;
+
+	if (!character)
+		return;
+
+	Next = formatted_output;
+	SizeLeft = sizeof formatted_output;
+
+	/* Handle the foreground intensity */
+	if ((attributes & FOREGROUND_INTENSITY) != 0)
+		Color = 1;
+	else
+		Color = 0;
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, "\033[%u", Color);
+
+	/* Handle the background intensity */
+	if ((attributes & BACKGROUND_INTENSITY) != 0)
+		Color = 1;
+	else
+		Color = 39;
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, ";%u", Color);
+
+	/* Handle the underline */
+	if ((attributes & COMMON_LVB_UNDERSCORE) != 0)
+		Color = 4;
+	else
+		Color = 24;
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, ";%u", Color);
+
+	/* Handle reverse video */
+	if ((attributes & COMMON_LVB_REVERSE_VIDEO) != 0)
+		Color = 7;
+	else
+		Color = 27;
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, ";%u", Color);
+
+	/* Add background and foreground colors to buffer. */
+	Color = 30 +
+		4 * ((attributes & FOREGROUND_BLUE) != 0) +
+		2 * ((attributes & FOREGROUND_GREEN) != 0) +
+		1 * ((attributes & FOREGROUND_RED) != 0);
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, ";%u", Color);
+
+	Color = 40 +
+		4 * ((attributes & BACKGROUND_BLUE) != 0) +
+		2 * ((attributes & BACKGROUND_GREEN) != 0) +
+		1 * ((attributes & BACKGROUND_RED) != 0);
+
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, ";%u", Color);
+	
+	StringCbPrintfExA(Next, SizeLeft, &Next, &SizeLeft, 0, "%c", 'm');
+
+	if (bUseAnsiEmulation && attributes != pattributes)
+		WriteFile(hInput, formatted_output, (DWORD)(Next - formatted_output), &wr, NULL);
+
+	/* East asian languages have 2 bytes for each character, only use the first */
+	if (!(attributes & COMMON_LVB_TRAILING_BYTE)) {
+		char str[10];
+		int nSize = WideCharToMultiByte(CP_UTF8,
+			0,
+			&character,
+			1,
+			(LPSTR)str,
+			sizeof(str),
+			NULL,
+			NULL);
+
+		if (nSize > 0)
+			WriteFile(hInput, str, nSize, &wr, NULL);
+	}
+
+	pattributes = attributes;
+}
+
+void 
+SendBuffer(HANDLE hInput, CHAR_INFO *buffer, DWORD bufferSize)
+{
+	if (bufferSize <= 0)
+		return;
+
+	for (DWORD i = 0; i < bufferSize; i++)
+		SendCharacter(hInput, buffer[i].Attributes, buffer[i].Char.UnicodeChar);
+}
+
+void 
+CalculateAndSetCursor(HANDLE hInput, short x, short y, BOOL scroll)
+{
+	if (scroll && y > currentLine)
+		for (short n = currentLine; n < y; n++)
+			SendLF(hInput);
+
+	SendSetCursor(hInput, x + 1, y + 1);
+	currentLine = y;
+}
+
+void 
+SizeWindow(HANDLE hInput)
+{
+	SMALL_RECT srWindowRect;
+	COORD coordScreen;
+	BOOL bSuccess = FALSE;
+	/* The input window does not scroll currently to ease calculations on the paint/draw */
+	bNoScrollRegion = TRUE;
+
+	/* Set the default font to Consolas */
+	CONSOLE_FONT_INFOEX matchingFont;
+	matchingFont.cbSize = sizeof(matchingFont);
+	matchingFont.nFont = 0;
+	matchingFont.dwFontSize.X = 0;
+	matchingFont.dwFontSize.Y = 16;
+	matchingFont.FontFamily = FF_DONTCARE;
+	matchingFont.FontWeight = FW_NORMAL;	
+	wcscpy_s(matchingFont.FaceName, LF_FACESIZE, L"Consolas");
+
+	bSuccess = __SetCurrentConsoleFontEx(hInput, FALSE, &matchingFont);
+
+	/* This information is the live screen  */
+	ZeroMemory(&consoleInfo, sizeof(consoleInfo));
+	consoleInfo.cbSize = sizeof(consoleInfo);
+
+	bSuccess = GetConsoleScreenBufferInfoEx(hInput, &consoleInfo);
+
+	/* Get the largest size we can size the console window to */
+	coordScreen = GetLargestConsoleWindowSize(hInput);
+
+	/* Define the new console window size and scroll position */
+	if (inputSi.dwXCountChars == 0 || inputSi.dwYCountChars == 0) {
+		inputSi.dwXCountChars = 80;
+		inputSi.dwYCountChars = 25;
+	}
+
+	srWindowRect.Right = min((SHORT)inputSi.dwXCountChars, coordScreen.X) - 1;
+	srWindowRect.Bottom = min((SHORT)inputSi.dwYCountChars, coordScreen.Y) - 1;
+	srWindowRect.Left = srWindowRect.Top = (SHORT)0;
+
+	/* Define the new console buffer history to be the maximum possible */
+	coordScreen.X = srWindowRect.Right + 1;   /* buffer width must be equ window width */
+	coordScreen.Y = 9999;
+
+	if (SetConsoleWindowInfo(hInput, TRUE, &srWindowRect))
+		bSuccess = SetConsoleScreenBufferSize(hInput, coordScreen);
+	else {
+		if (SetConsoleScreenBufferSize(hInput, coordScreen))
+			bSuccess = SetConsoleWindowInfo(hInput, TRUE, &srWindowRect);
+	}
+
+	bSuccess = GetConsoleScreenBufferInfoEx(hInput, &consoleInfo);
+}
+
+unsigned __stdcall
+MonitorChild(_In_ LPVOID lpParameter)
+{
+	WaitForSingleObject(child, INFINITE);
+	GetExitCodeProcess(child, &child_exit_code);
+	PostThreadMessage(hostThreadId, WM_APPEXIT, 0, 0);
+	return 0;
+}
+
+unsigned __stdcall
+ControlThread(LPVOID p)
+{
+	/* 
+	* TODO - Enable the console resize logic.
+	* With the current resize logic, we have two issues
+	* 1) console screen buffer rows should be always 9999, irrespective of the user setting.
+	* 2) when ssh client window is resized it clears everything and gives a blank screen.
+	* For now we disable this logic.
+	*
+	* It looks to be a bug in our console hook event pty implementation.
+	*/
+	return 0;
+
+	//short type, row, col;
+	//DWORD len;
+	//COORD coord;
+	//SMALL_RECT rect;
+	//while (1) {
+	//	if (!ReadFile(pipe_ctrl, &type, 2, &len, NULL))
+	//		break;
+	//	if (type != PTY_SIGNAL_RESIZE_WINDOW)
+	//		break;
+	//	if (!ReadFile(pipe_ctrl, &col, 2, &len, NULL))
+	//		break;
+	//	if (!ReadFile(pipe_ctrl, &row, 2, &len, NULL))
+	//		break;
+	//	
+	//	/* 
+	//	 * when reducing width, console seemed to retain prior width 
+	//	 * while increasing width, however, it behaves right
+	//	 * 
+	//	 * hence setting it less by 1 and setting it again to the right
+	//	 * count
+	//	 */
+	//	
+	//	coord.X = col - 1;
+	//	coord.Y = row;
+	//	rect.Top = 0;
+	//	rect.Left = 0;
+	//	rect.Bottom = row - 1;
+	//	rect.Right = col - 2;
+	//	SetConsoleScreenBufferSize(child_out, coord);
+	//	SetConsoleWindowInfo(child_out, TRUE, &rect);
+
+	//	coord.X = col;
+	//	rect.Right = col - 1;
+	//	SetConsoleScreenBufferSize(child_out, coord);
+	//	SetConsoleWindowInfo(child_out, TRUE, &rect);
+	//}
+	//return 0;
+}
+
+DWORD 
+ProcessEvent(void *p)
+{
+	wchar_t chUpdate;
+	WORD  wAttributes;
+	WORD  wX;
+	WORD  wY;
+	DWORD dwProcessId;
+	DWORD wr = 0;
+	DWORD event;
+	HWND hwnd;
+	LONG idObject;
+	LONG idChild;
+	CHAR_INFO pBuffer[MAX_EXPECTED_BUFFER_SIZE] = {0,};
+	DWORD bufferSize;
+	SMALL_RECT readRect;
+	COORD coordBufSize;
+	COORD coordBufCoord;
+
+	if (!p)
+		return ERROR_INVALID_PARAMETER;
+
+	consoleEvent* current = (consoleEvent *)p;
+
+	if (!current)
+		return ERROR_INVALID_PARAMETER;
+
+	event = current->event;
+	hwnd = current->hwnd;
+	idObject = current->idObject;
+	idChild = current->idChild;
+
+	if (event < EVENT_CONSOLE_CARET || event > EVENT_CONSOLE_LAYOUT)
+		return ERROR_INVALID_PARAMETER;
+
+	if (child_out == INVALID_HANDLE_VALUE || child_out == NULL)
+		return ERROR_INVALID_PARAMETER;
+
+	GetWindowThreadProcessId(hwnd, &dwProcessId); // CodeQL [SM02313]: false positive dwProcessId will not be uninitialized
+
+	if (childProcessId != dwProcessId)
+		return ERROR_SUCCESS;
+
+	ZeroMemory(&consoleInfo, sizeof(consoleInfo));
+	consoleInfo.cbSize = sizeof(consoleInfo);
+
+	GetConsoleScreenBufferInfoEx(child_out, &consoleInfo);
+
+	UINT viewPortHeight = consoleInfo.srWindow.Bottom - consoleInfo.srWindow.Top + 1;
+	UINT viewPortWidth = consoleInfo.srWindow.Right - consoleInfo.srWindow.Left + 1;
+
+	switch (event) {
+	case EVENT_CONSOLE_CARET:
+	{
+		COORD co;
+		co.X = LOWORD(idChild);
+		co.Y = HIWORD(idChild);
+		
+		lastX = co.X;
+		lastY = co.Y;
+
+		if (lastX == 0 && lastY > currentLine)
+			CalculateAndSetCursor(pipe_out, lastX, lastY, TRUE);
+		else
+			SendSetCursor(pipe_out, lastX + 1, lastY + 1);
+
+		break;
+	}
+	case EVENT_CONSOLE_UPDATE_REGION:
+	{
+		readRect.Top = HIWORD(idObject);
+		readRect.Left = LOWORD(idObject);
+		readRect.Bottom = HIWORD(idChild);
+		readRect.Right = LOWORD(idChild);
+
+		readRect.Right = max(readRect.Right, ConSRWidth());
+
+		/* Detect a "cls" (Windows) */
+		if (!bStartup &&
+		    (readRect.Top == consoleInfo.srWindow.Top || readRect.Top == nextConsoleInfo.srWindow.Top)) {
+			BOOL isClearCommand = FALSE;
+			isClearCommand = (consoleInfo.dwSize.X == readRect.Right + 1) && (consoleInfo.dwSize.Y == readRect.Bottom + 1);
+
+			/* If cls then inform app to clear its buffers and return */
+			if (isClearCommand) {
+				SendClearScreen(pipe_out);
+				ViewPortY = 0;
+				lastViewPortY = 0;
+
+				return ERROR_SUCCESS;
+			}
+		}
+
+		/* Figure out the buffer size */		
+		coordBufSize.Y = readRect.Bottom - readRect.Top + 1;
+		coordBufSize.X = readRect.Right - readRect.Left + 1;
+
+		/*
+		 * Security check:  the maximum screen buffer size is 9999 columns x 9999 lines so check
+		 * the computed buffer size for overflow.  since the X and Y in the COORD structure
+		 * are shorts they could be negative.
+		 */
+		if (coordBufSize.X < 0 || coordBufSize.X > MAX_CONSOLE_COLUMNS ||
+		    coordBufSize.Y < 0 || coordBufSize.Y > MAX_CONSOLE_ROWS)
+			return ERROR_INVALID_PARAMETER;
+
+		/* Compute buffer size */
+		bufferSize = coordBufSize.X * coordBufSize.Y;
+		if (bufferSize > MAX_EXPECTED_BUFFER_SIZE) {
+			if (!bStartup) {
+				SendClearScreen(pipe_out);
+				ViewPortY = 0;
+				lastViewPortY = 0;
+			}
+			return ERROR_SUCCESS;
+		}
+		
+		/* The top left destination cell of the temporary buffer is row 0, col 0 */		
+		coordBufCoord.X = 0;
+		coordBufCoord.Y = 0;
+
+		/* Copy the block from the screen buffer to the temp. buffer */
+		if (!ReadConsoleOutput(child_out, pBuffer, coordBufSize, coordBufCoord, &readRect))
+			return GetLastError();
+
+		/* Set cursor location based on the reported location from the message */
+		CalculateAndSetCursor(pipe_out, readRect.Left, readRect.Top, TRUE);
+
+		/* Send the entire block */
+		SendBuffer(pipe_out, pBuffer, bufferSize);
+		lastViewPortY = ViewPortY;
+		lastLineLength = readRect.Left;		
+		
+		break;
+	}
+	case EVENT_CONSOLE_UPDATE_SIMPLE:
+	{
+		chUpdate = LOWORD(idChild);
+		wAttributes = HIWORD(idChild);
+		wX = LOWORD(idObject);
+		wY = HIWORD(idObject);
+		
+		readRect.Top = wY;
+		readRect.Bottom = wY;
+		readRect.Left = wX;
+		readRect.Right = ConSRWidth();
+		
+		/* Set cursor location based on the reported location from the message */
+		CalculateAndSetCursor(pipe_out, wX, wY, TRUE);
+				
+		coordBufSize.Y = readRect.Bottom - readRect.Top + 1;
+		coordBufSize.X = readRect.Right - readRect.Left + 1;
+		bufferSize = coordBufSize.X * coordBufSize.Y;
+
+		/* The top left destination cell of the temporary buffer is row 0, col 0 */
+		coordBufCoord.X = 0;
+		coordBufCoord.Y = 0;
+
+		/* Copy the block from the screen buffer to the temp. buffer */
+		if (!ReadConsoleOutput(child_out, pBuffer, coordBufSize, coordBufCoord, &readRect))
+			return GetLastError();
+
+		SendBuffer(pipe_out, pBuffer, bufferSize);		
+
+		break;
+	}
+	case EVENT_CONSOLE_UPDATE_SCROLL:
+	{
+		DWORD out = 0;
+		LONG vd = idChild;
+		LONG hd = idObject;
+		LONG vn = abs(vd);
+
+		if (vd > 0) {
+			if (ViewPortY > 0)
+				ViewPortY -= vn;
+		} else {
+			ViewPortY += vn;
+		}
+
+		break;
+	}
+	case EVENT_CONSOLE_LAYOUT:
+	{
+		if (consoleInfo.dwMaximumWindowSize.X == consoleInfo.dwSize.X &&
+		    consoleInfo.dwMaximumWindowSize.Y == consoleInfo.dwSize.Y &&
+		    (consoleInfo.dwCursorPosition.X == 0 && consoleInfo.dwCursorPosition.Y == 0)) {
+			/* Screen has switched to fullscreen mode */
+			SendClearScreen(pipe_out);
+			savedViewPortY = ViewPortY;
+			savedLastViewPortY = lastViewPortY;
+			ViewPortY = 0;
+			lastViewPortY = 0;;
+			bFullScreen = TRUE;
+		} else {
+			/* Leave full screen mode if applicable */
+			if (bFullScreen) {
+				SendClearScreen(pipe_out);
+				ViewPortY = savedViewPortY;
+				lastViewPortY = savedLastViewPortY;
+				bFullScreen = FALSE;
+			}
+		}
+		break;
+	}
+	}
+
+	return ERROR_SUCCESS;
+}
+
+unsigned __stdcall
+ProcessEventQueue(LPVOID p)
+{
+	while (1) {
+		while (head) {
+			EnterCriticalSection(&criticalSection);
+			consoleEvent* current = head;
+			if (current) {
+				if (current->next) {
+					head = current->next;
+					head->prior = NULL;
+				} else {
+					head = NULL;
+					tail = NULL;
+				}
+			}
+
+			LeaveCriticalSection(&criticalSection);
+			if (current) {
+				ProcessEvent(current);
+				free(current);
+			}
+		}
+
+		if (child_in != INVALID_HANDLE_VALUE && child_in != NULL &&
+		    child_out != INVALID_HANDLE_VALUE && child_out != NULL) {
+			ZeroMemory(&consoleInfo, sizeof(consoleInfo));
+			consoleInfo.cbSize = sizeof(consoleInfo);
+
+			/* This information is the live buffer that's currently in use */
+			GetConsoleScreenBufferInfoEx(child_out, &consoleInfo);
+
+			/* Set the cursor to the last known good location according to the live buffer */
+			if (lastX != consoleInfo.dwCursorPosition.X ||
+			    lastY != consoleInfo.dwCursorPosition.Y)
+				SendSetCursor(pipe_out, consoleInfo.dwCursorPosition.X + 1, consoleInfo.dwCursorPosition.Y + 1);
+
+			lastX = consoleInfo.dwCursorPosition.X;
+			lastY = consoleInfo.dwCursorPosition.Y;
+		}
+		Sleep(100);
+	}
+	return 0;
+}
+
+void 
+QueueEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
+{
+	consoleEvent* current = NULL;
+
+	EnterCriticalSection(&criticalSection);
+	current = malloc(sizeof(consoleEvent)); // CodeQL [SM02320]: current struct fields initialized below
+	if (current) {
+		if (!head) {
+			current->event = event;
+			current->hwnd = hwnd;
+			current->idChild = idChild;
+			current->idObject = idObject;
+
+			/* No links head == tail */
+			current->next = NULL;
+			current->prior = NULL;
+
+			head = current;
+			tail = current;
+		}
+		else {
+			current->event = event;
+			current->hwnd = hwnd;
+			current->idChild = idChild;
+			current->idObject = idObject;
+
+			/* Current tail points to new tail */
+			tail->next = current;
+
+			/* New tail points to old tail */
+			current->prior = tail;
+			current->next = NULL;
+
+			/* Update the tail pointer to the new last event */
+			tail = current;
+		}
+	}
+	LeaveCriticalSection(&criticalSection);
+}
+
+void FreeQueueEvent()
+{
+	EnterCriticalSection(&criticalSection);
+	while (head) {
+		consoleEvent* current = head;
+		head = current->next;
+		free(current);
+	}
+	head = NULL;
+	tail = NULL;
+	LeaveCriticalSection(&criticalSection);
+}
+
+unsigned __stdcall
+ProcessPipes(LPVOID p)
+{
+	BOOL ret;
+	DWORD dwStatus;
+	char buf[128];
+
+	/* process data from pipe_in and route appropriately */
+	while (1) {
+		ZeroMemory(buf, sizeof(buf));
+		int rd = 0;
+
+		GOTO_CLEANUP_ON_FALSE(ReadFile(pipe_in, buf, sizeof(buf) - 1, &rd, NULL)); /* read bufsize-1 */
+		bStartup = FALSE;
+		if(rd > 0)
+			ProcessIncomingKeys(buf);
+	}
+
+cleanup:
+	/* pipe_in has ended */
+	PostThreadMessage(hostThreadId, WM_APPEXIT, 0, 0);
+	dwStatus = GetLastError();
+	return 0;
+}
+
+void CALLBACK 
+ConsoleEventProc(HWINEVENTHOOK hWinEventHook,
+    DWORD event,
+    HWND hwnd,
+    LONG idObject,
+    LONG idChild,
+    DWORD dwEventThread,
+    DWORD dwmsEventTime)
+{
+	QueueEvent(event, hwnd, idObject, idChild);
+}
+
+void
+ProcessMessages(void* p)
+{
+	DWORD dwStatus;
+	SECURITY_ATTRIBUTES sa;
+	MSG msg;
+
+	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+	sa.lpSecurityDescriptor = NULL;
+	sa.bInheritHandle = TRUE;
+
+	/* If we here then we are certain that we have a child process console, so we should be able to get child_in, child_out handles */
+	while (child_in == (HANDLE)-1) {
+		child_in = CreateFile(TEXT("CONIN$"), GENERIC_READ | GENERIC_WRITE,
+					FILE_SHARE_WRITE | FILE_SHARE_READ,
+					&sa, OPEN_EXISTING, 0, NULL);
+	}
+
+	while (child_out == (HANDLE)-1) {
+		child_out = CreateFile(TEXT("CONOUT$"), GENERIC_READ | GENERIC_WRITE,
+					FILE_SHARE_WRITE | FILE_SHARE_READ,
+					&sa, OPEN_EXISTING, 0, NULL);
+	}
+
+	child_err = child_out;
+	SizeWindow(child_out);
+	/* Get the current buffer information after all the adjustments */
+	GetConsoleScreenBufferInfoEx(child_out, &consoleInfo);
+	/* Loop for the console output events */
+	while (GetMessage(&msg, NULL, 0, 0)) {
+		if (msg.message == WM_APPEXIT)
+			break;
+		else {
+			TranslateMessage(&msg);
+			DispatchMessage(&msg);
+		}
+	}
+
+	/* cleanup */
+	dwStatus = GetLastError();
+	if (child_in != INVALID_HANDLE_VALUE)
+		CloseHandle(child_in);
+	if (child_out != INVALID_HANDLE_VALUE)
+		CloseHandle(child_out);
+}
+
+int 
+start_with_pty(wchar_t *command)
+{
+	STARTUPINFO si;
+	PROCESS_INFORMATION pi;
+	wchar_t *cmd = (wchar_t *)malloc(sizeof(wchar_t) * MAX_CMD_LEN);
+	SECURITY_ATTRIBUTES sa;
+	BOOL ret;
+	DWORD dwStatus;
+	HANDLE hEventHook = NULL;
+	HMODULE hm_kernel32 = NULL, hm_user32 = NULL;
+	wchar_t kernel32_dll_path[PATH_MAX]={0,}, user32_dll_path[PATH_MAX]={0,};
+
+	if (cmd == NULL) {
+		printf_s("ssh-shellhost is out of memory");
+		exit(255);
+	}
+
+	if (!GetSystemDirectoryW(system32_path, PATH_MAX)) {
+		printf_s("unable to retrieve system32 path\n");
+		exit(255);
+	}
+
+	GOTO_CLEANUP_ON_ERR(wcsncpy_s(kernel32_dll_path, _countof(kernel32_dll_path), system32_path, wcsnlen(system32_path, _countof(system32_path)) + 1));
+	GOTO_CLEANUP_ON_ERR(wcscat_s(kernel32_dll_path, _countof(kernel32_dll_path), L"\\kernel32.dll"));
+
+	GOTO_CLEANUP_ON_ERR(wcsncpy_s(user32_dll_path, _countof(user32_dll_path), system32_path, wcsnlen(system32_path, _countof(system32_path)) + 1));
+	GOTO_CLEANUP_ON_ERR(wcscat_s(user32_dll_path, _countof(user32_dll_path), L"\\user32.dll"));
+
+	if ((hm_kernel32 = LoadLibraryW(kernel32_dll_path)) == NULL ||
+	    (hm_user32 = LoadLibraryW(user32_dll_path)) == NULL ||
+	    (__SetCurrentConsoleFontEx = (__t_SetCurrentConsoleFontEx)GetProcAddress(hm_kernel32, "SetCurrentConsoleFontEx")) == NULL ||
+	    (__UnhookWinEvent = (__t_UnhookWinEvent)GetProcAddress(hm_user32, "UnhookWinEvent")) == NULL ||
+	    (__SetWinEventHook = (__t_SetWinEventHook)GetProcAddress(hm_user32, "SetWinEventHook")) == NULL) {
+		printf_s("cannot support a pseudo terminal. \n");
+		return -1;
+	}
+
+	pipe_in = GetStdHandle(STD_INPUT_HANDLE);
+	pipe_out = GetStdHandle(STD_OUTPUT_HANDLE);
+	pipe_ctrl = GetStdHandle(STD_ERROR_HANDLE);
+
+	/* copy pipe handles passed through std io*/
+	if ((pipe_in == INVALID_HANDLE_VALUE) || (pipe_out == INVALID_HANDLE_VALUE) || (pipe_ctrl == INVALID_HANDLE_VALUE))
+		return -1;
+
+	cp = GetConsoleCP();
+
+	/* 
+	 * Windows PTY sends cursor positions in absolute coordinates starting from <0,0>
+	 * We send a clear screen upfront to simplify client 
+	 */	
+	SendClearScreen(pipe_out);
+
+	ZeroMemory(&inputSi, sizeof(STARTUPINFO));
+	GetStartupInfo(&inputSi);
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.bInheritHandle = TRUE;
+	/* WM_APPEXIT */
+	hostThreadId = GetCurrentThreadId();
+	hostProcessId = GetCurrentProcessId();
+	InitializeCriticalSection(&criticalSection);
+	
+	/* 
+	 * Ignore the static code analysis warning C6387 
+	 * as per msdn, third argument can be NULL when we specify WINEVENT_OUTOFCONTEXT
+	 */
+#pragma warning(suppress: 6387)
+	hEventHook = __SetWinEventHook(EVENT_CONSOLE_CARET, EVENT_CONSOLE_END_APPLICATION, NULL,
+					ConsoleEventProc, 0, 0, WINEVENT_OUTOFCONTEXT);
+	memset(&si, 0, sizeof(STARTUPINFO));
+	memset(&pi, 0, sizeof(PROCESS_INFORMATION));
+	/* Copy our parent buffer sizes */
+	si.cb = sizeof(STARTUPINFO);
+	si.dwFlags = 0;
+	/* disable inheritance on pipe_in*/
+	GOTO_CLEANUP_ON_FALSE(SetHandleInformation(pipe_in, HANDLE_FLAG_INHERIT, 0));
+	
+	/*
+	* Launch via cmd.exe /c, otherwise known issues exist with color rendering in powershell
+	*/
+	_snwprintf_s(cmd, MAX_CMD_LEN, MAX_CMD_LEN, L"\"%ls\\cmd.exe\" /c \"%ls\"", system32_path, command);
+	
+	SetConsoleCtrlHandler(NULL, FALSE);
+	GOTO_CLEANUP_ON_FALSE(CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,
+				NULL, NULL, &si, &pi));
+	childProcessId = pi.dwProcessId;
+
+	FreeConsole();
+	Sleep(20);
+	while (!AttachConsole(pi.dwProcessId)) {
+		/* If user tries to execute a command (like dir) in pty session then we may run into this scenario. */
+		if (GetExitCodeProcess(pi.hProcess, &child_exit_code) && child_exit_code != STILL_ACTIVE)
+			goto cleanup;
+
+		Sleep(100);
+	}
+
+	/* monitor child exist */
+	child = pi.hProcess;
+	monitor_thread = (HANDLE) _beginthreadex(NULL, 0, MonitorChild, NULL, 0, NULL);
+	if (IS_INVALID_HANDLE(monitor_thread))
+		goto cleanup;
+
+	/* disable Ctrl+C hander in this process*/
+	SetConsoleCtrlHandler(NULL, TRUE);
+	
+	initialize_keylen();
+
+	io_thread = (HANDLE) _beginthreadex(NULL, 0, ProcessPipes, NULL, 0, NULL);
+	if (IS_INVALID_HANDLE(io_thread))
+		goto cleanup;
+
+	ux_thread = (HANDLE) _beginthreadex(NULL, 0, ProcessEventQueue, NULL, 0, NULL);
+	if (IS_INVALID_HANDLE(ux_thread))
+		goto cleanup;
+
+	ctrl_thread = (HANDLE)_beginthreadex(NULL, 0, ControlThread, NULL, 0, NULL);
+	if (IS_INVALID_HANDLE(ctrl_thread))
+		goto cleanup;
+
+	ProcessMessages(NULL);
+cleanup:
+	dwStatus = GetLastError();
+	if (child != INVALID_HANDLE_VALUE)
+		TerminateProcess(child, 0);
+
+	if (!IS_INVALID_HANDLE(monitor_thread)) {
+		WaitForSingleObject(monitor_thread, INFINITE);
+		CloseHandle(monitor_thread);
+	}
+	if (!IS_INVALID_HANDLE(ux_thread)) {
+		TerminateThread(ux_thread, S_OK);
+		CloseHandle(ux_thread);
+	}
+	if (!IS_INVALID_HANDLE(io_thread)) {
+		TerminateThread(io_thread, 0);
+		CloseHandle(io_thread);
+	}
+
+	if (!IS_INVALID_HANDLE(ctrl_thread)) {
+		TerminateThread(ctrl_thread, 0);
+		CloseHandle(ctrl_thread);
+	}
+
+	if (hEventHook)
+		__UnhookWinEvent(hEventHook);
+	
+	FreeConsole();
+	
+	if (child != INVALID_HANDLE_VALUE) {
+		CloseHandle(pi.hProcess);
+		CloseHandle(pi.hThread);
+	}
+	
+	FreeQueueEvent();
+	DeleteCriticalSection(&criticalSection);
+	
+	if(cmd != NULL)
+		free(cmd);
+
+	return child_exit_code;
+}
+
+/* implements a basic shell - launches given cmd using CreateProcess */
+int start_as_shell(wchar_t* cmd)
+{
+	STARTUPINFOW si;
+	PROCESS_INFORMATION pi;
+
+	memset(&si, 0, sizeof(STARTUPINFOW));
+	memset(&pi, 0, sizeof(PROCESS_INFORMATION));
+	si.cb = sizeof(STARTUPINFOW);
+
+	if (CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi) == FALSE) {
+		printf("ssh-shellhost cannot run '%ls', error: %d", cmd, GetLastError());
+		exit(255);
+	}
+
+	CloseHandle(pi.hThread);
+	/* close std io handles */
+	CloseHandle(GetStdHandle(STD_INPUT_HANDLE));
+	CloseHandle(GetStdHandle(STD_OUTPUT_HANDLE));
+	CloseHandle(GetStdHandle(STD_ERROR_HANDLE));
+	child_exit_code = 255;
+
+	/* wait for child to exit */
+	WaitForSingleObject(pi.hProcess, INFINITE);
+
+	if (!GetExitCodeProcess(pi.hProcess, &child_exit_code))
+		printf("ssh-shellhost unable to track child process, error: %d", GetLastError());
+
+	CloseHandle(pi.hProcess);
+	return child_exit_code;
+}
+
+/*
+ * Usage:
+ * Execute commandline with PTY 
+ *   ssh-shellhost.exe ---pty commandline
+ * Note that in PTY mode, stderr is taken as the control channel
+ * to receive Windows size change events
+ *
+ * Execute commandline like shell (plain IO redirection)
+ * Syntax mimics cmd.exe -c usage. Note the explicit double quotes
+ * around actual commandline to execute.
+ *   ssh-shellhost.exe -c "commandline"
+ * Ex.	ssh-shellhost.exe -c "notepad.exe file.txt"
+ *	ssh-shellhost.exe -c ""my program.exe" "arg 1" "arg 2""
+ */
+int 
+wmain(int ac, wchar_t **av)
+{
+	wchar_t *exec_command, *option, *cmdline = NULL;
+	int with_pty, len;
+
+	_set_invalid_parameter_handler(my_invalid_parameter_handler);
+
+	if (ac == 1)
+		goto usage;
+
+	if ((cmdline = _wcsdup(GetCommandLineW())) == NULL) {
+		printf("ssh-shellhost.exe ran out of memory");
+		exit(255);
+	}
+
+	if (option = wcsstr(cmdline, L" ---pty "))
+		with_pty = 1;
+	else if (option = wcsstr(cmdline, L" -c "))
+		with_pty = 0;
+	else
+		goto usage;
+
+	if (with_pty)
+		exec_command = option + wcslen(L" ---pty ");
+	else
+		exec_command = option + wcslen(L" -c ");
+
+	/* strip preceding white spaces */
+	while (*exec_command != L'\0' && *exec_command == L' ')
+		exec_command++;
+
+	if (*exec_command == L'\0')
+		goto usage;
+
+	if (with_pty)
+		return start_with_pty(exec_command);
+	else {
+		/* if commandline is enclosed in double quotes, remove them */
+		len = (int)wcslen(exec_command);
+		if (len > 2 && *exec_command == L'\"' && *(exec_command + len - 1) == L'\"') {
+			*(exec_command + len - 1) = L'\0';
+			exec_command++;
+		}
+		return start_as_shell(exec_command);
+	}
+usage:
+	printf("ssh-shellhost does not support command line: %ls", cmdline);
+	exit(255);
+}
diff --git a/contrib/win32/win32compat/signal.c b/contrib/win32/win32compat/signal.c
new file mode 100644
index 000000000..f069a234f
--- /dev/null
+++ b/contrib/win32/win32compat/signal.c
@@ -0,0 +1,352 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <errno.h>
+#include "w32fd.h"
+#include "signal_internal.h"
+#include "debug.h"
+
+/* Apply caution while changing this order of inclusion of below 2 signal.h headers */
+#include "inc\signal.h"
+#undef signal
+#undef raise
+#undef SIGINT
+#undef SIGILL
+#undef SIGPFE
+#undef SIGSEGV
+#undef SIGTERM
+#undef SIGFPE
+#undef SIGABRT
+#undef SIG_DFL
+#undef SIG_IGN
+#undef SIG_ERR
+#undef NSIG
+#include <signal.h>
+#undef NSIG
+#define NSIG 0
+
+
+/* pending signals to be processed */
+sigset_t pending_signals;
+/* signal handler table*/
+sighandler_t sig_handlers[W32_SIGMAX];
+extern struct _children children;
+
+static VOID CALLBACK
+sigint_APCProc(_In_ ULONG_PTR dwParam)
+{
+	debug5("SIGINT APCProc()");
+	sigaddset(&pending_signals, W32_SIGINT);
+}
+
+static VOID CALLBACK
+sigterm_APCProc(_In_ ULONG_PTR dwParam)
+{
+	debug5("SIGTERM APCProc()");
+	sigaddset(&pending_signals, W32_SIGTERM);
+}
+
+static VOID CALLBACK
+sigtstp_APCProc(_In_ ULONG_PTR dwParam)
+{
+	debug5("SIGTSTP APCProc()");
+	sigaddset(&pending_signals, W32_SIGTSTP);
+}
+
+BOOL WINAPI
+native_sig_handler(DWORD dwCtrlType)
+{
+	debug4("Native Ctrl+C handler, CtrlType %d", dwCtrlType);
+	switch (dwCtrlType) {
+	case CTRL_C_EVENT:
+		QueueUserAPC(sigint_APCProc, main_thread, (ULONG_PTR)NULL);
+		return TRUE;
+	case CTRL_BREAK_EVENT:
+		QueueUserAPC(sigtstp_APCProc, main_thread, (ULONG_PTR)NULL);
+		return TRUE;
+	case CTRL_CLOSE_EVENT:
+	case CTRL_LOGOFF_EVENT:
+	case CTRL_SHUTDOWN_EVENT:
+		QueueUserAPC(sigterm_APCProc, main_thread, (ULONG_PTR)NULL);
+		/* wait for main thread to terminate */
+		WaitForSingleObject(main_thread, INFINITE);
+		return TRUE;
+	default:
+		return FALSE;
+	}
+}
+
+static VOID CALLBACK
+sigwinch_APCProc(_In_ ULONG_PTR dwParam)
+{
+	debug5("SIGTERM APCProc()");
+	sigaddset(&pending_signals, SIGWINCH);
+}
+
+void
+queue_terminal_window_change_event()
+{
+	QueueUserAPC(sigwinch_APCProc, main_thread, (ULONG_PTR)NULL);
+}
+
+void
+sw_init_signal_handler_table()
+{
+	SetConsoleCtrlHandler(native_sig_handler, TRUE);
+	sigemptyset(&pending_signals);
+	/* this automatically sets all to W32_SIG_DFL (0)*/
+	memset(sig_handlers, 0, sizeof(sig_handlers));
+}
+
+sighandler_t
+mysignal(int signum, sighandler_t handler) {
+	return w32_signal(signum, handler);
+}
+
+char*
+strsignal(int sig)
+{
+	static char buf[16];
+
+	(void)snprintf(buf, sizeof(buf), "%d", sig);
+	return buf;
+}
+
+sighandler_t
+w32_signal(int signum, sighandler_t handler)
+{
+	sighandler_t prev;
+	debug4("signal() sig:%d, handler:%p", signum, handler);
+	if (signum >= W32_SIGMAX) {
+		errno = EINVAL;
+		return W32_SIG_ERR;
+	}
+
+	prev = sig_handlers[signum];
+	sig_handlers[signum] = handler;
+	return prev;
+}
+
+int
+w32_sigprocmask(int how, const sigset_t *set, sigset_t *oldset)
+{
+	/* this is only used by sshd to block SIGCHLD while doing waitpid() */
+	/* our implementation of waidpid() is never interrupted, so no need to implement this for now*/
+	debug5("sigprocmask() how:%d", how);
+	return 0;
+}
+
+int
+w32_raise(int sig)
+{
+	debug4("raise sig:%d", sig);
+	if (sig == W32_SIGSEGV)
+		return raise(SIGSEGV); /* raise native exception handler*/
+
+	if (sig >= W32_SIGMAX) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/* execute user specified disposition */
+	if (sig_handlers[sig] > W32_SIG_IGN) {
+		sig_handlers[sig](sig);
+		return 0;
+	}
+
+	/* if set to ignore, handle SIGCHLD since zombies need to be automatically reaped */
+	if (sig_handlers[sig] == W32_SIG_IGN) {
+		if (sig == W32_SIGCHLD)
+			sw_cleanup_child_zombies();
+		return 0;
+	}
+
+	/* execute any default handlers */
+	switch (sig) {
+	case W32_SIGCHLD:
+		/* do nothing for SIGCHLD */;
+		break;
+	default: /* exit process */
+		exit(0);
+	}
+
+	return 0;
+}
+
+/* processes pending signals, return -1 and errno=EINTR if any are processed*/
+static int
+sw_process_pending_signals()
+{
+	sigset_t pending_tmp = pending_signals;
+	BOOL sig_int = FALSE; /* has any signal actually interrupted */
+
+	debug5("process_signals()");
+	int i, exp[] = { W32_SIGCHLD , W32_SIGINT , W32_SIGALRM, W32_SIGTERM, W32_SIGTSTP, W32_SIGWINCH };
+
+	/* check for expected signals*/
+	for (i = 0; i < (sizeof(exp) / sizeof(exp[0])); i++)
+		sigdelset(&pending_tmp, exp[i]);
+	if (pending_tmp) {
+		/* unexpected signals queued up */
+		error("process_signals() - ERROR unexpected signals in queue: %d", pending_tmp);
+		errno = ENOTSUP;
+		debug_assert_internal();
+		return -1;
+	}
+
+	/* take pending_signals local to prevent recursion in wait_for_any* loop */
+	pending_tmp = pending_signals;
+	pending_signals = 0;
+	for (i = 0; i < (sizeof(exp) / sizeof(exp[0])); i++) {
+		if (sigismember(&pending_tmp, exp[i])) {
+			if (sig_handlers[exp[i]] != W32_SIG_IGN) {
+				w32_raise(exp[i]);
+				/* dont error EINTR for SIG_ALRM, */
+				/* sftp client is not expecting it */
+				if (exp[i] != W32_SIGALRM)
+					sig_int = TRUE;
+			} else if (exp[i] == W32_SIGCHLD) /*if SIGCHLD is SIG_IGN, reap zombies*/
+				sw_cleanup_child_zombies();
+
+			sigdelset(&pending_tmp, exp[i]);
+		}
+	}
+
+
+	/* by now all pending signals should have been taken care of*/
+	if (pending_tmp)
+		debug_assert_internal();
+
+	if (sig_int) {
+		debug4("process_queued_signals: WARNING - A signal has interrupted and was processed");
+		errno = EINTR;
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ * Main wait routine used by all blocking calls.
+ * It wakes up on
+ * - any signals (errno = EINTR )
+ * - any of the supplied events set
+ * - any APCs caused by IO completions
+ * - time out
+ * - Returns 0 on IO completion and timeout, -1 on rest
+ *  if milli_seconds is 0, this function returns 0, its called with 0
+ *  to execute any scheduled APCs
+*/
+int
+wait_for_any_event(HANDLE* events, int num_events, DWORD milli_seconds)
+{
+	HANDLE all_events[MAXIMUM_WAIT_OBJECTS_ENHANCED];
+	DWORD live_children = children.num_children - children.num_zombies;
+	DWORD num_all_events = num_events + live_children;
+	errno_t r = 0;
+
+	if (num_all_events > MAXIMUM_WAIT_OBJECTS_ENHANCED) {
+		debug3("wait_for_any_event() - ERROR max events reached");
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	if ((r = memcpy_s(all_events, MAXIMUM_WAIT_OBJECTS_ENHANCED * sizeof(HANDLE), children.handles, live_children * sizeof(HANDLE)) != 0) ||
+	( r = memcpy_s(all_events + live_children, (MAXIMUM_WAIT_OBJECTS_ENHANCED - live_children) * sizeof(HANDLE), events, num_events * sizeof(HANDLE)) != 0)) {
+		debug3("memcpy_s failed with error: %d.", r);
+		return -1;
+	}
+
+	DWORD ret = wait_for_multiple_objects_enhanced(num_all_events, all_events, milli_seconds, TRUE);
+	if ((ret >= WAIT_OBJECT_0_ENHANCED) && (ret <= WAIT_OBJECT_0_ENHANCED + num_all_events - 1)) {
+		/* woken up by event signaled
+		 * is this due to a child process going down
+		 */
+		if (live_children && ((ret - WAIT_OBJECT_0_ENHANCED) < live_children)) {
+			sigaddset(&pending_signals, W32_SIGCHLD);
+			sw_child_to_zombie(ret - WAIT_OBJECT_0_ENHANCED);
+		}
+	} else if (ret == WAIT_IO_COMPLETION_ENHANCED) {
+		/* APC processed due to IO or signal*/
+	} else if (ret == WAIT_TIMEOUT_ENHANCED) {
+		/* timed out */
+		return 0;
+	} else { /* some other error*/
+		errno = EOTHER;
+		debug3("ERROR: unexpected wait end: %d", ret);
+		return -1;
+	}
+
+	if (pending_signals)
+		return sw_process_pending_signals();
+	
+	return 0;
+}
+
+
+int
+sw_initialize()
+{
+	memset(&children, 0, sizeof(children));
+	sw_init_signal_handler_table();
+	if (sw_init_timer() != 0)
+		return -1;
+	return 0;
+}
+
+/*
+ * This is a minimal implementation of sigaction.
+ * This is added to retrieve the current signal handler without actually setting the new signal handler, unlike w32_signal.
+ * The child process doesn't inherit the signal hanlders.
+*/
+int
+sigaction(int signum, const struct sigaction * act, struct sigaction * oldact)
+{
+	int r = -1;
+	if (signum == SIGKILL || signum == SIGSTOP) {
+		error_f("sigaction shouldn't be called for signum:%d", signum);
+		errno = EINVAL;
+		goto done;
+	}
+	
+	if (signum >= W32_SIGMAX) {
+		errno = EINVAL;
+		return r;
+	}
+
+	if (act)
+		oldact->sa_handler = w32_signal(signum, act->sa_handler);
+	else if (oldact)
+		oldact->sa_handler = sig_handlers[signum];
+
+	r = 0;
+done:
+	return r;
+}
diff --git a/contrib/win32/win32compat/signal_internal.h b/contrib/win32/win32compat/signal_internal.h
new file mode 100644
index 000000000..e60caf029
--- /dev/null
+++ b/contrib/win32/win32compat/signal_internal.h
@@ -0,0 +1,45 @@
+#include <Windows.h>
+#include <process.h>
+#include "misc_internal.h"
+
+/* child processes */
+#define MAX_CHILDREN 512
+
+struct _children {
+	/* 
+	 * array of handles and process_ids. 
+	 * initial (num_children - num_zombies) are alive 
+	 * rest are zombies 
+	 */
+	HANDLE handles[MAX_CHILDREN];
+	DWORD process_id[MAX_CHILDREN];
+	/* total children */
+	DWORD num_children;
+	/* #zombies */
+	/* (num_children - zombies) are live children */
+	DWORD num_zombies;
+};
+
+
+int sw_initialize();
+int register_child(HANDLE child, DWORD pid);
+int sw_remove_child_at_index(DWORD index);
+int sw_child_to_zombie(DWORD index);
+void sw_cleanup_child_zombies();
+
+struct _timer_info {
+	HANDLE timer;
+	ULONGLONG ticks_at_start; /* 0 if timer is not live */
+	__int64 run_time_sec; /* time in seconds, timer is set to go off from ticks_at_start */
+};
+int sw_init_timer();
+
+#define MAXIMUM_WAIT_OBJECTS_ENHANCED 1024
+#define WAIT_OBJECT_0_ENHANCED 0x00000000
+#define WAIT_ABANDONED_0_ENHANCED 0x10000000
+#define WAIT_TIMEOUT_ENHANCED 0x20000000
+#define WAIT_IO_COMPLETION_ENHANCED 0x30000000
+#define WAIT_FAILED_ENHANCED WAIT_FAILED
+
+DWORD wait_for_multiple_objects_enhanced(_In_ DWORD  nCount, _In_ const HANDLE *lpHandles,
+	_In_ DWORD dwMilliseconds, _In_ BOOL bAlertable);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/signal_sigalrm.c b/contrib/win32/win32compat/signal_sigalrm.c
new file mode 100644
index 000000000..c3a1836e3
--- /dev/null
+++ b/contrib/win32/win32compat/signal_sigalrm.c
@@ -0,0 +1,94 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright(c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Helper routines to support SIGALRM 
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "signal_internal.h"
+#include "inc\signal.h"
+#include "debug.h"
+
+struct _timer_info timer_info;
+extern sigset_t pending_signals;
+
+static VOID CALLBACK
+sigalrm_APC(_In_opt_ LPVOID lpArgToCompletionRoutine,
+	    _In_ DWORD dwTimerLowValue,
+	    _In_ DWORD dwTimerHighValue)
+{
+	sigaddset(&pending_signals, W32_SIGALRM);
+}
+
+unsigned int
+w32_alarm(unsigned int sec)
+{
+	LARGE_INTEGER due;
+	ULONGLONG sec_passed;
+	int ret = 0;
+
+	debug5("alarm() %d secs", sec);
+	errno = 0;
+	/* cancel any live timer if seconds is 0*/
+	if (sec == 0) {
+		CancelWaitableTimer(timer_info.timer);
+		timer_info.ticks_at_start = 0;
+		timer_info.run_time_sec = 0;
+		return 0;
+	}
+
+	due.QuadPart = -10000000LL; /* 1 sec in 100 nanosec intervals */
+	due.QuadPart *= sec;
+	/* this call resets the timer if it is already active */
+	if (!SetWaitableTimer(timer_info.timer, &due, 0, sigalrm_APC, NULL, FALSE)) {
+		debug3("alram() - ERROR SetWaitableTimer() %d", GetLastError());
+		return 0;;
+	}
+
+	/* if timer was already ative, return when it was due */
+	if (timer_info.ticks_at_start) {
+		sec_passed = (GetTickCount64() - timer_info.ticks_at_start) / 1000;
+		if (sec_passed < (ULONGLONG)timer_info.run_time_sec)
+			ret = (int) (timer_info.run_time_sec - sec_passed);
+	}
+	timer_info.ticks_at_start = GetTickCount64();
+	timer_info.run_time_sec = sec;
+	
+	return ret;
+}
+
+int
+sw_init_timer()
+{
+	memset(&timer_info, 0, sizeof(timer_info));
+	timer_info.timer = CreateWaitableTimer(NULL, TRUE, NULL);
+	if (timer_info.timer == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	return 0;
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/signal_sigchld.c b/contrib/win32/win32compat/signal_sigchld.c
new file mode 100644
index 000000000..f533677c4
--- /dev/null
+++ b/contrib/win32/win32compat/signal_sigchld.c
@@ -0,0 +1,251 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright(c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Helper routines to support SIGCLD and related routines implementation
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "signal_internal.h"
+#include "inc\sys\wait.h"
+#include "debug.h"
+#include "inc\signal.h"
+
+struct _children children;
+
+int
+register_child(HANDLE child, DWORD pid)
+{
+	DWORD first_zombie_index;
+
+	debug4("Register child %p pid %d, %d zombies of %d", child, pid,
+		children.num_zombies, children.num_children);
+	if (children.num_children == MAX_CHILDREN) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	if (children.num_zombies) {
+		first_zombie_index = children.num_children - children.num_zombies;
+		children.handles[children.num_children] = children.handles[first_zombie_index];
+		children.process_id[children.num_children] = children.process_id[first_zombie_index];
+
+		children.handles[first_zombie_index] = child;
+		children.process_id[first_zombie_index] = pid;
+	} else {
+		children.handles[children.num_children] = child;
+		children.process_id[children.num_children] = pid;
+	}
+
+	children.num_children++;
+	return 0;
+}
+
+int
+sw_remove_child_at_index(DWORD index)
+{
+	DWORD last_non_zombie;
+	debug4("Unregister child at index %d, %d zombies of %d", index,
+		children.num_zombies, children.num_children);
+
+	if ((index >= children.num_children) || (children.num_children == 0)) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	CloseHandle(children.handles[index]);
+	if (children.num_zombies == 0) {
+		children.handles[index] = children.handles[children.num_children - 1];
+		children.process_id[index] = children.process_id[children.num_children - 1];
+	} else {
+		/* if its a zombie */
+		if (index >= (children.num_children - children.num_zombies)) {
+			children.handles[index] = children.handles[children.num_children - 1];
+			children.process_id[index] = children.process_id[children.num_children - 1];
+			children.num_zombies--;
+		} else {
+			last_non_zombie = children.num_children - children.num_zombies - 1;
+			children.handles[index] = children.handles[last_non_zombie];
+			children.process_id[index] = children.process_id[last_non_zombie];
+
+			children.handles[last_non_zombie] = children.handles[children.num_children - 1];
+			children.process_id[last_non_zombie] = children.process_id[children.num_children - 1];
+		}
+	}
+
+	children.num_children--;
+	return 0;
+}
+
+int
+sw_child_to_zombie(DWORD index)
+{
+	DWORD last_non_zombie, zombie_pid;
+	HANDLE zombie_handle;
+
+	debug4("zombie'ing child at index %d, %d zombies of %d", index,
+		children.num_zombies, children.num_children);
+
+	if (index >= children.num_children) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	last_non_zombie = children.num_children - children.num_zombies - 1;
+	if (last_non_zombie != index) {
+		/* swap */
+		zombie_pid = children.process_id[index];
+		zombie_handle = children.handles[index];
+		children.handles[index] = children.handles[last_non_zombie];
+		children.process_id[index] = children.process_id[last_non_zombie];
+		children.handles[last_non_zombie] = zombie_handle;
+		children.process_id[last_non_zombie] = zombie_pid;
+	}
+	children.num_zombies++;
+	return 0;
+}
+
+int
+w32_kill(int pid, int sig)
+{
+	int child_index, i;
+	if (pid == GetCurrentProcessId())
+		return w32_raise(sig);
+
+	/*  for child processes - only SIGTERM supported*/
+	child_index = -1;
+	for (i = 0; i < (int)children.num_children; i++)
+		if (children.process_id[i] == pid) {
+			child_index = i;
+			break;
+		}
+
+	if (child_index != -1)
+		TerminateProcess(children.handles[child_index], 0);
+	return 0;
+}
+
+
+int
+waitpid(int pid, int *status, int options)
+{
+	DWORD index, ret, ret_id, exit_code = 0, timeout = 0;
+	HANDLE process = NULL;
+
+	debug5("waitpid - pid:%d, options:%d", pid, options);
+	if (options & (~WNOHANG)) {
+		errno = ENOTSUP;
+		debug_assert_internal();
+		return -1;
+	}
+
+	if ((pid < -1) || (pid == 0)) {
+		errno = ENOTSUP;
+		debug_assert_internal();
+		return -1;
+	}
+
+	if (children.num_children == 0) {
+		errno = ECHILD;
+		return -1;
+	}
+
+	if (pid > 0) {
+		if (options != 0) {
+			errno = ENOTSUP;
+			debug_assert_internal();
+			return -1;
+		}
+		/* find entry in table */
+		for (index = 0; index < children.num_children; index++)
+			if (children.process_id[index] == pid)
+				break;
+
+		if (index == children.num_children) {
+			errno = ECHILD;
+			return -1;
+		}
+
+		process = children.handles[index];
+
+		/* wait if process is still alive */
+		if (index < children.num_children - children.num_zombies) {
+			ret = WaitForSingleObject(process, INFINITE);
+			if (ret != WAIT_OBJECT_0)
+				debug_assert_internal();//fatal
+		}
+
+		ret_id = children.process_id[index];
+		GetExitCodeProcess(process, &exit_code);
+		/* process handle will be closed when its removed from list */
+		sw_remove_child_at_index(index);
+		if (status)
+			*status = exit_code;
+		return ret_id;
+	}
+
+	/* pid = -1*/
+	/* are there any existing zombies */
+	if (children.num_zombies) {
+		/* return one of them */
+		ret_id = children.process_id[children.num_children - 1];
+		GetExitCodeProcess(children.handles[children.num_children - 1], &exit_code);
+		if (status)
+			*status = exit_code;
+		sw_remove_child_at_index(children.num_children - 1);
+		return ret_id;
+	}
+
+	/* all children are alive. wait for one of them to exit */
+	timeout = INFINITE;
+	if (options & WNOHANG)
+		timeout = 0;
+	ret = wait_for_multiple_objects_enhanced(children.num_children, children.handles, timeout, FALSE);
+	if ((ret >= WAIT_OBJECT_0_ENHANCED) && (ret < (WAIT_OBJECT_0_ENHANCED + children.num_children))) {
+		index = ret - WAIT_OBJECT_0_ENHANCED;
+		process = children.handles[index];
+		ret_id = children.process_id[index];
+		GetExitCodeProcess(process, &exit_code);
+		/* process handle will be closed when its removed from list */
+		sw_remove_child_at_index(index);
+		if (status)
+			*status = exit_code;
+		return ret_id;
+	} else if (ret == WAIT_TIMEOUT_ENHANCED) {
+		/* TODO - assert that WNOHANG  was specified*/
+		return 0;
+	}
+
+	debug_assert_internal(); /* fatal */
+	return -1;
+}
+
+void
+sw_cleanup_child_zombies()
+{
+	int pid = 1;
+	while (pid > 0)
+		pid = waitpid(-1, NULL, WNOHANG);
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/signal_wait.c b/contrib/win32/win32compat/signal_wait.c
new file mode 100644
index 000000000..e45a7b3c3
--- /dev/null
+++ b/contrib/win32/win32compat/signal_wait.c
@@ -0,0 +1,234 @@
+/*
+* Author: Bryan Berns <berns@uwalumni.com>
+*
+* Partial replacement for WaitForMultipleObjectsEx that handles more than 64
+* objects.  This is tuned for OpenSSH use in (no need for 'wait-all' scenarios).
+* This is only safe to use for objects whose transitional state is not
+* automatically lost just by calling a WaitForMultipleObjects* or
+* WaitForSingleObjects*.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "signal_internal.h"
+
+typedef struct _wait_for_multiple_objects_struct {
+	/* synchronization management */
+	HANDLE thread_handle;
+	HANDLE wait_event;
+
+	/* native function parameters input and output */
+	DWORD num_handles;
+	const HANDLE * handles;
+	DWORD return_value;
+}
+wait_for_multiple_objects_struct;
+
+unsigned __stdcall
+wait_for_multiple_objects_thread(LPVOID lpParam)
+{
+	wait_for_multiple_objects_struct *waitstruct = 
+		(wait_for_multiple_objects_struct *) lpParam;
+
+	/* wait for bin to complete -- this is alertable for our interrupt cleanup routine */
+	waitstruct->return_value = WaitForMultipleObjectsEx(waitstruct->num_handles,
+		waitstruct->handles, FALSE, INFINITE, TRUE);
+
+	/* notify the main thread that an event was found */
+	SetEvent(waitstruct->wait_event);
+
+	return TRUE;
+}
+
+VOID CALLBACK
+wait_for_multiple_objects_interrupter(_In_ ULONG_PTR dwParam)
+{
+	/* we must explicitly exit the thread since the thread could have been received
+	 * the alert prior to the thread running in which case it is acknowledged when
+	 * the threads starts running instead of when it is waiting at
+	 * WaitForMultipleObjectsEx */
+	_endthreadex(0);
+}
+
+DWORD
+wait_for_multiple_objects_enhanced(_In_ DWORD  nCount, _In_ const HANDLE *lpHandles,
+	_In_ DWORD dwMilliseconds, _In_ BOOL bAlertable)
+{
+	/* number of separate bins / threads required to monitor execution */
+	const DWORD bin_size = MAXIMUM_WAIT_OBJECTS;
+	const DWORD bins_total = (nCount - 1) / bin_size + 1;
+	
+	DWORD return_value = WAIT_FAILED_ENHANCED;
+	HANDLE wait_event = NULL;
+	wait_for_multiple_objects_struct wait_bins[(MAXIMUM_WAIT_OBJECTS_ENHANCED - 1) / MAXIMUM_WAIT_OBJECTS + 1] = { 0 };
+	DWORD wait_ret;
+
+	/* protect against too many events */
+	if (nCount > MAXIMUM_WAIT_OBJECTS_ENHANCED)
+	{
+		return WAIT_FAILED_ENHANCED;
+	}
+
+	/* in the event that no events are passed and alterable, just do a sleep and
+	 * and wait for wakeup call.  This differs from the WaitForMultipleObjectsEx
+	 * call which would return an error if no events are passed to the function. */
+	if (nCount == 0 && bAlertable)
+	{
+		DWORD wait_ret = SleepEx(dwMilliseconds, TRUE);
+		if (wait_ret == 0)
+			return WAIT_TIMEOUT_ENHANCED;
+		else if (wait_ret == WAIT_IO_COMPLETION) 
+			return WAIT_IO_COMPLETION_ENHANCED;
+		else
+			return WAIT_FAILED_ENHANCED;
+	}
+	
+	/* if less than the normal maximum then just use the built-in function
+	 * to avoid the overhead of another thread */
+	if (nCount <= MAXIMUM_WAIT_OBJECTS) {
+
+		DWORD wait_ret = WaitForMultipleObjectsEx(nCount, lpHandles,
+			FALSE, dwMilliseconds, bAlertable);
+
+		if (wait_ret == WAIT_IO_COMPLETION) return WAIT_IO_COMPLETION_ENHANCED;
+		if (wait_ret == WAIT_TIMEOUT) return WAIT_TIMEOUT_ENHANCED;
+
+		/* translate normal offset to enhanced offset for abandoned threads */
+		if (wait_ret >= WAIT_ABANDONED_0 &&
+			wait_ret < WAIT_ABANDONED_0 + MAXIMUM_WAIT_OBJECTS) {
+			return WAIT_ABANDONED_0_ENHANCED + (wait_ret - WAIT_ABANDONED_0);
+		}
+
+		/* translate normal offset to enhanced offset for signaled threads */
+		if (wait_ret >= WAIT_OBJECT_0 &&
+			wait_ret < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS) {
+			return WAIT_OBJECT_0_ENHANCED + (wait_ret - WAIT_OBJECT_0);
+		}
+
+		return WAIT_FAILED_ENHANCED;
+	}
+
+	/* setup synchronization event to flag when the main thread should wake up */
+	wait_event = CreateEvent(NULL, TRUE, FALSE, NULL);
+	if (wait_event == NULL) {
+		goto cleanup;
+	}
+
+	/* initialize each thread that handles up to MAXIMUM_WAIT_OBJECTS each */
+	for (DWORD bin = 0; bin < bins_total; bin++) {
+
+		const int handles_processed = bin * bin_size;
+
+		wait_bins[bin].return_value = WAIT_FAILED - 1;
+		wait_bins[bin].wait_event = wait_event;
+		wait_bins[bin].handles = &(lpHandles[handles_processed]);
+		wait_bins[bin].num_handles = min(nCount - handles_processed, bin_size);
+
+		/* create a thread for this bin */
+		if ((wait_bins[bin].thread_handle = (HANDLE) _beginthreadex(NULL,
+			2048, wait_for_multiple_objects_thread,
+			(LPVOID) &(wait_bins[bin]), 0, NULL)) == NULL) {
+			goto cleanup;
+		}
+	}
+
+	/* wait for at least one thread to return; this will indicate that return
+	 * value will have been set in our bin array */
+	wait_ret = WaitForSingleObjectEx(wait_event, dwMilliseconds, bAlertable);
+
+	/* if io alert just skip to end */
+	if (wait_ret == WAIT_IO_COMPLETION) {
+		return_value = WAIT_IO_COMPLETION_ENHANCED;
+		goto cleanup;
+	}
+
+	/* if timeout just skip to end */
+	if (wait_ret == WAIT_TIMEOUT) {
+		return_value = WAIT_TIMEOUT_ENHANCED;
+		goto cleanup;
+	}
+
+	/* unexpected output result */
+	if (wait_ret != WAIT_OBJECT_0) {
+		return_value = WAIT_FAILED_ENHANCED;
+		goto cleanup;
+	}
+
+	/* only looking for one object events */
+	for (DWORD bin = 0; bin < bins_total; bin++) {
+
+		/* skip bins that have have the default, unprocessed status */
+		if (wait_bins[bin].return_value == WAIT_FAILED - 1)
+			continue;
+
+		/* return failure if a bin has been processed but returned an
+		 * invalid or unexpected status */
+		if (wait_bins[bin].return_value == WAIT_FAILED ||
+			wait_bins[bin].return_value == WAIT_IO_COMPLETION ||
+			wait_bins[bin].return_value == WAIT_TIMEOUT)
+		{
+			return_value = WAIT_FAILED_ENHANCED;
+			break;
+		}
+
+		/* translate normal offset to enhanced offset for abandoned threads */
+		if (wait_bins[bin].return_value >= WAIT_ABANDONED_0 &&
+			wait_bins[bin].return_value < WAIT_ABANDONED_0 + wait_bins[bin].num_handles) {
+			return_value = WAIT_ABANDONED_0_ENHANCED +
+				bin * bin_size + (wait_bins[bin].return_value - WAIT_ABANDONED_0);
+			break;
+		}
+
+		/* translate normal offset to enhanced offset for signaled threads */
+		if (wait_bins[bin].return_value >= WAIT_OBJECT_0 &&
+			wait_bins[bin].return_value < WAIT_OBJECT_0 + wait_bins[bin].num_handles) {
+			return_value = WAIT_OBJECT_0_ENHANCED +
+				bin * bin_size + (wait_bins[bin].return_value - WAIT_OBJECT_0);
+			break;
+		}
+	}
+
+cleanup:
+
+	/* interrupt any outstanding threads */
+	for (DWORD bin = 0; bin < bins_total; bin++) {
+		if (wait_bins[bin].thread_handle != NULL) {
+
+			/* send each thread that is still waiting a signal to wake up;
+			 * if the thread in not waiting and still has not fully
+			 * finished executing then it will just ignore the signal */
+			if (wait_bins[bin].return_value == (WAIT_FAILED - 1)) {
+				QueueUserAPC(wait_for_multiple_objects_interrupter,
+					wait_bins[bin].thread_handle, (ULONG_PTR)NULL);
+			}
+
+			/* we must wait for these threads to complete so we can
+			 * safely cleanup the shared resources */
+			WaitForSingleObject(wait_bins[bin].thread_handle, INFINITE);
+			CloseHandle(wait_bins[bin].thread_handle);
+		}
+	}
+
+	if (wait_event)
+		CloseHandle(wait_event);
+	return return_value;
+}
diff --git a/contrib/win32/win32compat/socketio.c b/contrib/win32/win32compat/socketio.c
new file mode 100644
index 000000000..c4eceaea8
--- /dev/null
+++ b/contrib/win32/win32compat/socketio.c
@@ -0,0 +1,1079 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <mswsock.h>
+#include <errno.h>
+#include <VersionHelpers.h>
+#include <stddef.h>
+#include "w32fd.h"
+#include "inc\utf.h"
+#include "misc_internal.h"
+#include "debug.h"
+
+#define INTERNAL_SEND_BUFFER_SIZE 70*1024 //70KB
+#define INTERNAL_RECV_BUFFER_SIZE 70*1024 //70KB
+#define errno_from_WSALastError() errno_from_WSAError(WSAGetLastError())
+
+/* state info that needs to be persisted for an inprocess acceptEx call*/
+struct acceptEx_context {
+	char lpOutputBuf[1024];
+	SOCKET accept_socket;
+	LPFN_ACCEPTEX lpfnAcceptEx;
+	LPFN_GETACCEPTEXSOCKADDRS lpfnGuidGetAcceptExSockaddrs;
+	DWORD bytes_received;
+};
+
+/* maps WSAError to errno */
+static int
+errno_from_WSAError(int wsaerrno)
+{
+	/* TODO - create a mapping table - more efficient */
+	switch (wsaerrno) {
+	case WSAEWOULDBLOCK:
+		return EAGAIN;
+	case WSAEFAULT:
+		return EFAULT;
+	case WSAEINVAL:
+		return EINVAL;
+	case WSAECONNABORTED:
+		return ECONNABORTED;
+	case WSAETIMEDOUT:
+		return ETIMEDOUT;
+	case WSAECONNREFUSED:
+		return ECONNREFUSED;
+	case WSAEINPROGRESS:
+		return EINPROGRESS;
+	case WSAESHUTDOWN:
+		return ECONNRESET;
+	case WSAENOTCONN:
+		return ENOTCONN;
+	case WSAECONNRESET:
+		return ECONNRESET;
+	default:
+		return wsaerrno - 10000;
+	}
+}
+
+/* called before any other calls to socketio_ functions */
+int
+socketio_initialize()
+{
+	WSADATA wsaData = { 0 };
+	return WSAStartup(MAKEWORD(2, 2), &wsaData);
+}
+
+/* cleanup */
+int
+socketio_done()
+{
+	WSACleanup();
+	return 0;
+}
+
+/* initiate async acceptEx*/
+/* TODO - always return 0, set error in context, accept() will pick it up*/
+int
+socketio_acceptEx(struct w32_io* pio)
+{
+	struct acceptEx_context *context;
+	struct sockaddr_storage addr; int addrlen = sizeof addr;
+	
+	debug5("acceptEx - io:%p", pio);
+	context = (struct acceptEx_context *)pio->internal.context;
+	ResetEvent(pio->read_overlapped.hEvent);
+
+	if (getsockname(pio->sock, (struct sockaddr*)&addr, &addrlen) == SOCKET_ERROR) {
+		errno = errno_from_WSALastError();
+		debug("acceptEx - getsockname() ERROR:%d, io:%p", WSAGetLastError(), pio);
+		return -1;		
+	}
+
+	/* create accepting socket */
+	context->accept_socket = socket(addr.ss_family, SOCK_STREAM, IPPROTO_TCP);
+	if (context->accept_socket == INVALID_SOCKET) {
+		errno = errno_from_WSALastError();
+		debug3("acceptEx - socket() ERROR:%d, io:%p", WSAGetLastError(), pio);
+		return -1;
+	}
+
+	if (TRUE == context->lpfnAcceptEx(pio->sock,
+					context->accept_socket,
+					context->lpOutputBuf,
+					0,
+					sizeof(SOCKADDR_STORAGE) + 16,
+					sizeof(SOCKADDR_STORAGE) + 16,
+					&context->bytes_received,
+					&pio->read_overlapped))
+	{
+		/* we are already connected. Set event so subsequent select will catch */
+		SetEvent(pio->read_overlapped.hEvent);
+	} else {
+		/* if overlapped io is in progress, we are good */
+		if (WSAGetLastError() != ERROR_IO_PENDING) {
+			errno = errno_from_WSALastError();
+			debug3("acceptEx - AcceptEx() ERROR:%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+	}
+
+	pio->read_details.pending = TRUE;
+	return 0;
+}
+
+void
+CALLBACK WSARecvCompletionRoutine(IN DWORD dwError,
+				IN DWORD cbTransferred,
+				IN LPWSAOVERLAPPED lpOverlapped,
+				IN DWORD dwFlags)
+{
+	struct w32_io* pio =
+		(struct w32_io*)((char*)lpOverlapped - offsetof(struct w32_io, read_overlapped));
+	debug4("WSARecvCompletionCB - io:%p, pending_state:%d, flags:%d, error:%d, received:%d",
+		pio, pio->read_details.pending, dwFlags, dwError, cbTransferred);
+	if (!dwError && !cbTransferred)
+		dwError = ERROR_GRACEFUL_DISCONNECT;
+	pio->read_details.error = dwError;
+	pio->read_details.remaining = cbTransferred;
+	pio->read_details.completed = 0;
+	pio->read_details.pending = FALSE;
+}
+
+/* initiates async receive operation*/
+/* TODO - always return 0, or make this a void func. any error should be put in context*/
+static int
+socketio_WSARecv(struct w32_io* pio, BOOL* completed, int len)
+{
+	int ret = 0;
+	WSABUF wsabuf;
+	DWORD recv_flags = 0;
+
+	debug5("WSARecv - pio: %p", pio);
+	if (completed)
+		*completed = FALSE;
+
+	/* initialize recv buffers if needed */
+	wsabuf.len = INTERNAL_RECV_BUFFER_SIZE;
+	if (pio->read_details.buf == NULL) {
+		wsabuf.buf = malloc(wsabuf.len);
+		if (!wsabuf.buf) {
+			errno = ENOMEM;
+			debug3("WSARecv - ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+
+		pio->read_details.buf = wsabuf.buf;
+		pio->read_details.buf_size = wsabuf.len;
+	} else
+		wsabuf.buf = pio->read_details.buf;
+
+	if (len)
+		wsabuf.len = min((ULONG)len, wsabuf.len);
+
+	ret = WSARecv(pio->sock, &wsabuf, 1, NULL, &recv_flags, &pio->read_overlapped, &WSARecvCompletionRoutine);
+	if (ret == 0) {
+		pio->read_details.pending = TRUE;
+		/* receive has completed but APC is pending to be scheduled */
+		debug4("WSARecv - WSARecv() returned 0, io:%p", pio);
+		if (completed)
+			*completed = TRUE;
+	} else { /* (ret == SOCKET_ERROR) */
+		if (WSAGetLastError() == WSA_IO_PENDING) {
+			/* io is initiated and pending */
+			debug4("WSARecv - reported IO pending");
+			pio->read_details.pending = TRUE;
+		} else {
+			errno = errno_from_WSALastError();
+			debug3("WSARecv - WSARecv() ERROR: io:%p %d", pio, WSAGetLastError());
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+/* implements socket() */
+struct w32_io*
+socketio_socket(int domain, int type, int protocol)
+{
+	struct w32_io *pio = (struct w32_io*)malloc(sizeof(struct w32_io));
+	if (!pio) {
+		errno = ENOMEM;
+		debug3("socket - ERROR:%d, io:%p", errno, pio);
+		return NULL;
+	}
+
+	memset(pio, 0, sizeof(struct w32_io));
+	pio->sock = socket(domain, type, protocol);
+	if (pio->sock == INVALID_SOCKET) {
+		errno = errno_from_WSALastError();
+		debug3("socket - socket() ERROR:%d, io:%p", WSAGetLastError(), pio);
+		free(pio);
+		return NULL;
+	}
+
+	pio->internal.state = SOCK_INITIALIZED;
+	return pio;
+}
+
+#define SET_ERRNO_ON_ERROR(expr) do {					\
+    int ret = (expr);							\
+    if (ret == SOCKET_ERROR) {						\
+        errno = errno_from_WSALastError();				\
+        debug3("%s - ERROR:%d", __FUNCTION__, WSAGetLastError());	\
+    }									\
+    return ret;								\
+} while (0) 
+
+/* implements setsockopt() */
+int
+socketio_setsockopt(struct w32_io* pio, int level, int optname, const char* optval, int optlen)
+{
+	if ((optname == SO_KEEPALIVE) || (optname == SO_REUSEADDR) ||
+	    (optname == TCP_NODELAY) || (optname == IPV6_V6ONLY))
+		SET_ERRNO_ON_ERROR(setsockopt(pio->sock, level, optname, optval, optlen));
+	else {
+		debug3("setsockop - ERROR: unsupported optname:%d io:%p", optname, pio);
+		errno = ENOTSUP;
+		return -1;
+	}
+}
+
+/* implements getsockopt() */
+int
+socketio_getsockopt(struct w32_io* pio, int level, int optname, char* optval, int* optlen)
+{
+	SET_ERRNO_ON_ERROR(getsockopt(pio->sock, level, optname, optval, optlen));
+}
+
+/* implements getsockname() */
+int
+socketio_getsockname(struct w32_io* pio, struct sockaddr* name, int* namelen)
+{
+	SET_ERRNO_ON_ERROR(getsockname(pio->sock, name, namelen));
+}
+
+/* implements getpeername */
+int
+socketio_getpeername(struct w32_io* pio, struct sockaddr* name, int* namelen)
+{
+	SET_ERRNO_ON_ERROR(getpeername(pio->sock, name, namelen));
+}
+
+/* implements listen() */
+int
+socketio_listen(struct w32_io* pio, int backlog)
+{
+	struct acceptEx_context* context;
+
+	if (SOCKET_ERROR == listen(pio->sock, backlog)) {
+		errno = errno_from_WSALastError();
+		debug3("listen - listen() ERROR:%d io:%p", WSAGetLastError(), pio);
+		return -1;
+	}
+
+	/* prep for accept*/
+	{
+		GUID GuidAcceptEx = WSAID_ACCEPTEX;
+		GUID GuidGetAcceptExSockaddrs = WSAID_GETACCEPTEXSOCKADDRS;
+		DWORD dwBytes;
+
+		context = (struct acceptEx_context*)malloc(sizeof(struct acceptEx_context));
+		if (context == NULL) {
+			errno = ENOMEM;
+			debug3("listen - ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+		memset(context, 0, sizeof(struct acceptEx_context));
+		if (SOCKET_ERROR == WSAIoctl(pio->sock,
+			SIO_GET_EXTENSION_FUNCTION_POINTER,
+			&GuidAcceptEx, sizeof(GuidAcceptEx),
+			&context->lpfnAcceptEx, sizeof(context->lpfnAcceptEx),
+			&dwBytes, NULL, NULL)) {
+			free(context);
+			errno = errno_from_WSALastError();
+			debug3("listen - Ioctl1 ERROR:%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+
+		if (SOCKET_ERROR == WSAIoctl(pio->sock,
+			SIO_GET_EXTENSION_FUNCTION_POINTER,
+			&GuidGetAcceptExSockaddrs, sizeof(GuidGetAcceptExSockaddrs),
+			&context->lpfnGuidGetAcceptExSockaddrs, sizeof(context->lpfnGuidGetAcceptExSockaddrs),
+			&dwBytes, NULL, NULL)) {
+			free(context);
+			errno = errno_from_WSALastError();
+			debug3("listen - Ioctl2 ERROR:%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+
+		pio->read_overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
+		if ((pio->read_overlapped.hEvent) == NULL) {
+			free(context);
+			errno = ENOMEM;
+			debug3("listen - CreateEvent() ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+
+		context->accept_socket = INVALID_SOCKET;
+		pio->internal.context = context;
+	}
+
+	pio->internal.state = SOCK_LISTENING;
+	return 0;
+}
+
+/* implements bind() */
+int
+socketio_bind(struct w32_io* pio, const struct sockaddr *name, int namelen)
+{
+	SET_ERRNO_ON_ERROR(bind(pio->sock, name, namelen));
+}
+
+/* implements recv() */
+int
+socketio_recv(struct w32_io* pio, void *buf, size_t len, int flags)
+{
+	BOOL completed = FALSE;
+	errno_t r = 0;
+	debug5("recv - io:%p state:%d", pio, pio->internal.state);
+
+	if ((buf == NULL) || (len == 0)) {
+		errno = EINVAL;
+		debug3("recv - ERROR: invalid arguments, buf:%p, len:%d, io:%p", buf, len, pio);
+		return -1;
+	}
+
+	if (flags != 0) {
+		errno = ENOTSUP;
+		debug3("recv - ERROR: flags are not currently supported, io:%p", pio);
+		return -1;
+	}
+
+	/* TODO - ensure socket is in accepted or connected state */
+	/* /io is initiated and pending */
+	if (pio->read_details.pending) {
+		/* if recv is now in blocking mode, wait for data to be available */
+		if (w32_io_is_blocking(pio)) {
+			debug4("recv - io is pending, call is blocking, io:%p", pio);
+			while (socketio_is_io_available(pio, TRUE) == FALSE) {
+				if (0 != wait_for_any_event(NULL, 0, INFINITE))
+					return -1;
+			}
+		} else {
+			errno = EAGAIN;
+			debug4("recv - io is already pending, io:%p", pio);
+			return -1;
+		}
+	}	
+
+	/* if we have some buffer copy it and return #bytes copied */
+	if (pio->read_details.remaining) {
+		int num_bytes_copied = min((int)len, pio->read_details.remaining);
+		if ((r = memcpy_s(buf, len, pio->read_details.buf + pio->read_details.completed,
+			num_bytes_copied)) != 0) {
+			debug4("memcpy_s failed with error: %d.", r);
+			return -1;
+		}
+		pio->read_details.remaining -= num_bytes_copied;
+		pio->read_details.completed += num_bytes_copied;
+		debug5("recv - returning %d bytes from prior completed IO, remaining:%d, io:%p",
+			num_bytes_copied, pio->read_details.remaining, pio);
+		return num_bytes_copied;
+	}
+
+	/* if there was an error on async call, return */
+	if (pio->read_details.error) {
+		if (pio->read_details.error == ERROR_GRACEFUL_DISCONNECT) {
+			debug4("recv - connection closed, io:%p", pio);
+			/* connection is closed */
+			return 0;
+		} else {
+			errno = errno_from_WSAError(pio->read_details.error);
+			debug3("recv - from CB ERROR:%d, io:%p", pio->read_details.error, pio);
+			pio->read_details.error = 0;
+			return -1;
+		}
+	}
+
+	if (0 != socketio_WSARecv(pio, &completed, (int)len))
+		return -1;
+
+	if (completed) {
+		/* Let APC be scheduled */
+		debug4("recv - Letting APC to execute, io:%p", pio);
+		SleepEx(0, TRUE);
+		if (pio->read_details.pending) {
+			/* this shouldn't be happening */
+			errno = EOTHER;
+			debug3("recv - ERROR: Unexpected IO state, io:%p", pio);
+			return -1;
+		}
+	}
+
+	if (w32_io_is_blocking(pio)) {
+		/* wait until io is done */
+		debug5("recv - socket in blocking mode, io:%p", pio);
+		while (socketio_is_io_available(pio, TRUE) == FALSE) {
+			if (0 != wait_for_any_event(NULL, 0, INFINITE))
+				return -1;
+		}
+	} else {
+		if (socketio_is_io_available(pio, TRUE) == FALSE) {
+			errno = EAGAIN;
+			debug4("recv - IO is pending, io:%p", pio);
+			return -1;
+		}
+	}
+
+	/*
+	 * by this time we should have some bytes in internal buffer
+	 * or an error from callback
+	 */
+	if (pio->read_details.error) {
+		if (pio->read_details.error == ERROR_GRACEFUL_DISCONNECT) {
+			/* connection is closed */
+			debug4("recv - connection closed(2), io:%p", pio);
+			return 0;
+		} else {
+			errno = errno_from_WSAError(pio->read_details.error);
+			pio->read_details.error = 0;
+			debug3("recv - from CB(2) ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+	}
+
+	if (pio->read_details.remaining) {
+		int num_bytes_copied = min((int)len, pio->read_details.remaining);
+		if ((r = memcpy_s(buf, len, pio->read_details.buf, num_bytes_copied)) != 0) {
+			debug3("memcpy_s failed with error: %d.", r);
+			return -1;
+		}
+		pio->read_details.remaining -= num_bytes_copied;
+		pio->read_details.completed = num_bytes_copied;
+		debug4("recv - (2) returning %d bytes from completed IO, remaining:%d, io:%p",
+			num_bytes_copied, pio->read_details.remaining, pio);
+		return num_bytes_copied;
+	} else {
+		/* this should not happen */
+		errno = EOTHER;
+		debug3("recv - (2) ERROR:Unexpected IO state, io:%p", pio);
+		return -1;
+	}
+}
+
+void
+CALLBACK WSASendCompletionRoutine(IN DWORD dwError,
+				IN DWORD cbTransferred,
+				IN LPWSAOVERLAPPED lpOverlapped,
+				IN DWORD dwFlags)
+{
+	struct w32_io* pio = (struct w32_io*)((char*)lpOverlapped - offsetof(struct w32_io, write_overlapped));
+	debug4("WSASendCB - io:%p, pending_state:%d, error:%d, sent:%d of remaining:%d",
+		pio, pio->write_details.pending, dwError, cbTransferred,
+		pio->write_details.remaining);
+	pio->write_details.error = dwError;
+	/* TODO - assert that remaining == cbTransferred */
+	if ((dwError == 0) && (pio->write_details.remaining != cbTransferred)) {
+		error("WSASendCB - ERROR: broken assumption, io:%p, sent:%d, remaining:%d", pio,
+			cbTransferred, pio->write_details.remaining);
+		debug_assert_internal();
+	}
+	pio->write_details.remaining -= cbTransferred;
+	pio->write_details.pending = FALSE;
+}
+
+/* implementation of send() */
+int
+socketio_send(struct w32_io* pio, const void *buf, size_t len, int flags)
+{
+	int ret = 0;
+	WSABUF wsabuf;
+	errno_t r = 0;
+		
+	debug5("send - io:%p state:%d", pio, pio->internal.state);
+
+	if ((buf == NULL) || (len == 0)) {
+		errno = EINVAL;
+		debug3("send - ERROR invalid arguments, buf:%p, len:%d, io:%p", buf, len, pio);
+		return -1;
+	}
+
+	if (flags != 0) {
+		errno = ENOTSUP;
+		debug3("send - ERROR: flags are not currently supported, io:%p", pio);
+		return -1;
+	}
+
+	/* TODO - ensure socket is in accepted or connected state */
+	/* if io is already pending */
+	if (pio->write_details.pending) {
+		if (w32_io_is_blocking(pio)) {
+			debug4("send - io is pending, call is blocking, io:%p", pio);
+			while (pio->write_details.pending)
+				if (wait_for_any_event(NULL, 0, INFINITE) == -1)
+					return -1;
+		} else {
+			errno = EAGAIN;
+			debug4("send - IO currently pending, EAGAIN, io:%p", pio);
+			return -1;
+		}
+	}
+
+	if (pio->write_details.error) {
+		errno = errno_from_WSAError(pio->write_details.error);
+		debug3("ERROR:%d, io:%p", pio->write_details.error, pio);
+		return -1;
+	}
+
+	/* initialize buffers if needed */
+	wsabuf.len = INTERNAL_SEND_BUFFER_SIZE;
+	if (pio->write_details.buf == NULL) {
+		wsabuf.buf = malloc(wsabuf.len);
+		if (!wsabuf.buf) {
+			errno = ENOMEM;
+			debug3("send - ERROR:%d, io:%p", errno, pio);
+			return -1;
+		}
+
+		pio->write_details.buf = wsabuf.buf;
+		pio->write_details.buf_size = wsabuf.len;
+	} else
+		wsabuf.buf = pio->write_details.buf;
+
+	wsabuf.len = min(wsabuf.len, (int)len);
+	if ((r = memcpy_s(wsabuf.buf, wsabuf.len, buf, wsabuf.len)) != 0) {
+		debug3("memcpy_s failed with error: %d.", r);
+		return -1;
+	}
+
+	/* TODO - implement flags support if needed */
+	ret = WSASend(pio->sock, &wsabuf, 1, NULL, 0, &pio->write_overlapped, &WSASendCompletionRoutine);
+
+	if (ret == 0) {
+		/* send has completed and APC is scheduled, let it run */
+		pio->write_details.pending = TRUE;
+		pio->write_details.remaining = wsabuf.len;
+		SleepEx(0, TRUE);
+		if ((pio->write_details.pending) || (pio->write_details.remaining != 0)) {
+			errno = EOTHER;
+			debug3("send - ERROR: Unexpected IO state, io:%p", pio);
+			return -1;
+		}
+
+		/* return num of bytes written */
+		return wsabuf.len;
+	} else {
+		if (WSAGetLastError() == WSA_IO_PENDING) {
+			/* io is initiated and pending */
+			debug4("send - WSASend reported IO pending, io:%p", pio);
+			pio->write_details.pending = TRUE;
+			pio->write_details.remaining = wsabuf.len;
+			if (w32_io_is_blocking(pio)) {
+				/* wait until io is done */
+				debug5("send - waiting as socket is in blocking mode, io:%p", pio);
+				while (pio->write_details.pending)
+					if (wait_for_any_event(NULL, 0, INFINITE) == -1) {
+						/* if interrupted but send has completed, we are good*/
+						if ((errno != EINTR) || (pio->write_details.pending))
+							return -1;
+						errno = 0;
+					}
+			}
+
+			debug5("send - returning %d, io:%p", wsabuf.len, pio);
+			return wsabuf.len;
+		} else {
+			errno = errno_from_WSALastError();
+			debug3("send - WSASend() ERROR:%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+	}
+}
+
+/* shutdown() implementation */
+int
+socketio_shutdown(struct w32_io* pio, int how)
+{
+	SET_ERRNO_ON_ERROR(shutdown(pio->sock, how));
+}
+
+/* socket close() implementation */
+int
+socketio_close(struct w32_io* pio)
+{
+	debug4("close - io:%p", pio);
+	closesocket(pio->sock);
+	/* wait for pending io to abort */
+	SleepEx(0, TRUE);
+	if ((pio->internal.state == SOCK_READY) &&
+	    (pio->read_details.pending || pio->write_details.pending)) {
+		error("close - IO is still pending on closed socket. read:%d, write:%d, io:%p",
+			pio->read_details.pending, pio->write_details.pending, pio);
+		debug_assert_internal();
+	}
+	if (pio->internal.state == SOCK_LISTENING) {
+		if (pio->read_overlapped.hEvent)
+			CloseHandle(pio->read_overlapped.hEvent);
+		if (pio->internal.context) {
+			struct acceptEx_context *ctx = (struct acceptEx_context*)pio->internal.context;
+			if (ctx->accept_socket != INVALID_SOCKET)
+				closesocket(ctx->accept_socket);
+			free(pio->internal.context);
+		}
+	} else if (pio->internal.state == SOCK_CONNECTING) {
+		if (pio->write_overlapped.hEvent)
+			CloseHandle(pio->write_overlapped.hEvent);
+	} else {
+		if (pio->read_details.buf)
+			free(pio->read_details.buf);
+
+		if (pio->write_details.buf)
+			free(pio->write_details.buf);
+	}
+
+	free(pio);
+	return 0;
+}
+
+/* accept() implementation */
+struct w32_io*
+socketio_accept(struct w32_io* pio, struct sockaddr* addr, int* addrlen)
+{
+	struct w32_io *accept_io = NULL;
+	int iResult = 0;
+	struct acceptEx_context* context;
+	struct sockaddr *local_address, *remote_address;
+	int local_address_len, remote_address_len;
+	errno_t r = 0;
+
+	debug5("accept - io:%p", pio);
+	/* start io if not already started */
+	if (pio->read_details.pending == FALSE) {
+		if (socketio_acceptEx(pio) != 0)
+			return NULL;
+	}
+
+	if (w32_io_is_blocking(pio)) {
+		/* block until accept io is complete */
+		while (FALSE == socketio_is_io_available(pio, TRUE))
+			if (-1 == wait_for_any_event(&pio->read_overlapped.hEvent,
+				1, INFINITE))
+				return NULL;
+	} else {
+		/* if i/o is not ready */
+		if (FALSE == socketio_is_io_available(pio, TRUE)) {
+			errno = EAGAIN;
+			debug4("accept is pending, io:%p", pio);
+			return NULL;
+		}
+	}
+
+	context = (struct acceptEx_context*)pio->internal.context;
+	pio->read_details.pending = FALSE;
+	ResetEvent(pio->read_overlapped.hEvent);
+
+	if (pio->read_details.error) {
+		errno = errno_from_WSAError(pio->read_details.error);
+		debug3("accept - ERROR: async io completed with error: %d, io:%p", pio->read_details.error, pio);
+		pio->read_details.error = 0;
+		goto on_error;
+	}
+
+	if (0 != setsockopt(context->accept_socket, SOL_SOCKET,
+		SO_UPDATE_ACCEPT_CONTEXT, (char*)&pio->sock, sizeof(pio->sock))) {
+		errno = errno_from_WSALastError();
+		debug3("accept - ERROR: setsockopt failed:%d, io:%p", WSAGetLastError(), pio);
+		goto on_error;
+	}
+
+	accept_io = (struct w32_io*)malloc(sizeof(struct w32_io));
+	if (!accept_io) {
+		errno = ENOMEM;
+		debug3("accept - ERROR:%d, io:%p", errno, pio);
+		goto on_error;
+	}
+	memset(accept_io, 0, sizeof(struct w32_io));
+
+	accept_io->sock = context->accept_socket;
+	accept_io->internal.state = SOCK_READY;
+	context->accept_socket = INVALID_SOCKET;
+	debug4("accept io:%p", accept_io);
+
+	if ((addr != NULL) && (addrlen != NULL)) {
+		context->lpfnGuidGetAcceptExSockaddrs(context->lpOutputBuf, 0,
+			sizeof(SOCKADDR_STORAGE) + 16,
+			sizeof(SOCKADDR_STORAGE) + 16, &local_address,
+			&local_address_len, &remote_address, &remote_address_len);
+		if (remote_address_len) {
+			if((r = memcpy_s(addr, remote_address_len, remote_address, remote_address_len)) != 0) {
+				debug3("memcpy_s failed with error: %d.", r);
+				goto on_error;
+			}
+			*addrlen = remote_address_len;
+		}
+	}
+	return accept_io;
+
+on_error:
+	if (context->accept_socket != INVALID_SOCKET) {
+		closesocket(context->accept_socket);
+		context->accept_socket = INVALID_SOCKET;
+	}
+
+	return NULL;
+}
+
+/* initiates an async connect*/
+int
+socketio_connectex(struct w32_io* pio, const struct sockaddr* name, int namelen)
+{
+
+	struct sockaddr_in tmp_addr4;
+	struct sockaddr_in6 tmp_addr6;
+	SOCKADDR* tmp_addr;
+	size_t tmp_addr_len;
+	DWORD tmp_bytes;
+	GUID connectex_guid = WSAID_CONNECTEX;
+	LPFN_CONNECTEX ConnectEx;
+
+	debug5("connectex - io:%p", pio);
+	if (name->sa_family == AF_INET6) {
+		ZeroMemory(&tmp_addr6, sizeof(tmp_addr6));
+		tmp_addr6.sin6_family = AF_INET6;
+		tmp_addr6.sin6_port = 0;
+		tmp_addr = (SOCKADDR*)&tmp_addr6;
+		tmp_addr_len = sizeof(tmp_addr6);
+	} else if (name->sa_family == AF_INET) {
+		ZeroMemory(&tmp_addr4, sizeof(tmp_addr4));
+		tmp_addr4.sin_family = AF_INET;
+		tmp_addr4.sin_port = 0;
+		tmp_addr = (SOCKADDR*)&tmp_addr4;
+		tmp_addr_len = sizeof(tmp_addr4);
+	} else {
+		errno = ENOTSUP;
+		debug3("connectex - ERROR: unsuppored address family:%d, io:%p", name->sa_family, pio);
+		return -1;
+	}
+
+	if (SOCKET_ERROR == bind(pio->sock, tmp_addr, (int)tmp_addr_len)) {
+		errno = errno_from_WSALastError();
+		/* 
+		 * When use bind_address or bind_interface, this bind will return WSAEINVAL. But it doesn't matter.
+		 * https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind
+		 */
+		if (errno != EINVAL) {
+			debug3("connectex - ERROR: bind failed :%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+	}
+
+	if (SOCKET_ERROR == WSAIoctl(pio->sock, SIO_GET_EXTENSION_FUNCTION_POINTER,
+		&connectex_guid, sizeof(connectex_guid),
+		&ConnectEx, sizeof(ConnectEx),
+		&tmp_bytes, NULL, NULL)) {
+		errno = errno_from_WSALastError();
+		debug3("connectex - ioctl ERROR:%d, io:%p", WSAGetLastError(), pio);
+		return -1;
+	}
+
+	if ((!pio->write_overlapped.hEvent)
+		&& ((pio->write_overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)) {
+		errno = ENOMEM;
+		debug3("connectex - ERROR CreateEvent failed:%d, io:%p", errno, pio);
+		return -1;
+	}
+
+	ResetEvent(pio->write_overlapped.hEvent);
+	if (TRUE == ConnectEx(pio->sock, name, namelen, NULL, 0, NULL,
+		&pio->write_overlapped)) {
+		/* set completion event to indicates that async connect has completed */
+		SetEvent(pio->write_overlapped.hEvent);
+	} else {
+		if (WSAGetLastError() != ERROR_IO_PENDING) {
+			CloseHandle(pio->write_overlapped.hEvent);
+			pio->write_overlapped.hEvent = 0;
+			errno = errno_from_WSALastError();
+			debug3("connectex - ERROR ConnectEx() :%d, io:%p", WSAGetLastError(), pio);
+			return -1;
+		}
+	}
+
+	pio->write_details.pending = TRUE;
+	pio->internal.state = SOCK_CONNECTING;
+	return 0;
+}
+
+/* connect implementation */
+int
+socketio_connect(struct w32_io* pio, const struct sockaddr* name, int namelen)
+{
+
+	debug5("connect - io:%p", pio);
+	if (pio->write_details.pending == FALSE) {
+		if (-1 == socketio_connectex(pio, name, namelen))
+			return -1;
+	}
+
+	if (w32_io_is_blocking(pio)) {
+		/*  block until connect io is complete */
+		while (FALSE == socketio_is_io_available(pio, TRUE)) {
+			if (-1 == wait_for_any_event(&pio->write_overlapped.hEvent, 1, INFINITE))
+				return -1;
+		}
+	} else {
+		/* if i/o is not ready */
+		if (FALSE == socketio_is_io_available(pio, TRUE)) {
+			errno = EINPROGRESS;
+			debug4("connect - in progress, io:%p", pio);
+			return -1;
+		}
+	}
+
+	return socketio_finish_connect(pio);
+}
+
+int
+socketio_finish_connect(struct w32_io* pio)
+{
+	DWORD wsa_error = 0;
+	debug5("finish_connect, io:%p", pio);
+
+	if (pio->write_details.error) {
+		wsa_error = pio->write_details.error;
+		debug3("finish_connect - ERROR: async io completed with error: %d, io:%p", wsa_error, pio);
+		goto done;
+	}
+
+	if (0 != setsockopt(pio->sock, SOL_SOCKET, SO_UPDATE_CONNECT_CONTEXT, NULL, 0)) {
+		wsa_error = WSAGetLastError();
+		debug3("finish_connect - ERROR: setsockopt failed:%d, io:%p", wsa_error, pio);
+		goto done;
+	}
+
+done:
+	CloseHandle(pio->write_overlapped.hEvent);
+	pio->write_overlapped.hEvent = 0;
+	pio->write_details.pending = FALSE;
+
+	if (wsa_error) {
+		pio->read_details.error = wsa_error;
+		pio->write_details.error = wsa_error;
+		errno = errno_from_WSAError(wsa_error);
+	} else /* reset write_detail that were previously used for async connect */
+		ZeroMemory(&pio->write_details, sizeof(pio->write_details));
+
+	pio->internal.state = SOCK_READY;
+	return (wsa_error? -1 : 0);
+}
+
+/* checks if a given io is ready/available */
+BOOL
+socketio_is_io_available(struct w32_io* pio, BOOL rd)
+{
+	if ((pio->internal.state == SOCK_LISTENING) ||
+	    (pio->internal.state == SOCK_CONNECTING)) {
+		DWORD numBytes = 0;
+		DWORD flags;
+		BOOL sock_listening = (pio->internal.state == SOCK_LISTENING);
+		OVERLAPPED *overlapped = sock_listening ? &pio->read_overlapped : &pio->write_overlapped;
+		BOOL pending = sock_listening ? pio->read_details.pending : pio->write_details.pending;
+
+		if (pending) {
+			/* if there is an error to be picked up */
+			if (sock_listening) {
+				if (pio->read_details.error)
+					return TRUE;
+			} else {
+				if (pio->write_details.error)
+					return TRUE;
+			}
+		}
+
+		if (WSAGetOverlappedResult(pio->sock, overlapped, &numBytes, FALSE, &flags))
+			return TRUE;
+		else if (WSAGetLastError() != WSA_IO_INCOMPLETE) {
+			if (sock_listening)
+				pio->read_details.error = WSAGetLastError();
+			else
+				pio->write_details.error = WSAGetLastError();
+			return TRUE;
+		}
+
+		return FALSE;
+	} else if (rd) {
+		if (pio->read_details.remaining || pio->read_details.error)
+			return TRUE;
+		else
+			return FALSE;
+	} else
+		return (pio->write_details.pending == FALSE) ? TRUE : FALSE;
+}
+
+/*start async io (if needed) for accept and recv*/
+void
+socketio_on_select(struct w32_io* pio, BOOL rd)
+{
+	enum w32_io_sock_state sock_state = pio->internal.state;
+	debug4("on_select - io:%p type:%d rd:%d", pio, pio->type, rd);
+
+	/* nothing to do for writes (that includes connect) */
+	if (!rd)
+		return;
+
+	/* listening socket - acceptEx if needed */
+	if (sock_state == SOCK_LISTENING) {
+		if (pio->read_details.pending == FALSE)
+			if (socketio_acceptEx(pio) != 0) {
+				/* set error, accept will pick it*/
+				pio->read_details.error = errno;
+				errno = 0;
+				pio->read_details.pending = TRUE;
+				SetEvent(pio->read_overlapped.hEvent);
+				return;
+			}
+	} else if(sock_state == SOCK_READY) {
+		/* connected socket - WSARecv if needed */
+		if ((!pio->read_details.pending) && (!socketio_is_io_available(pio, rd)) && (socketio_WSARecv(pio, NULL, 0) != 0))
+		{
+			/* set error, recv() will pick it */
+			pio->read_details.error = errno;
+			errno = 0;
+			return;
+		}
+	}
+}
+
+int
+w32_gethostname(char *name_utf8, size_t len)
+{
+	char* tmp_name_utf8 = NULL;
+
+	if (IsWindows8OrGreater()) {
+		/* TODO - GetHostNameW not present in Win7, do GetProcAddr on Win8+*/
+	        /*
+		wchar_t name_utf16[256];
+		if (GetHostNameW(name_utf16, 256) == SOCKET_ERROR) {
+	                errno = errno_from_WSALastError();
+	                return -1;
+	        }
+
+	        if ((tmp_name_utf8 = utf16_to_utf8(name_utf16)) == NULL ||
+	                strlen(tmp_name_utf8) >= len) {
+	                errno = EFAULT; //??
+	                return -1;
+	        }
+
+	        memcpy(name_utf8, tmp_name_utf8, strlen(tmp_name_utf8) + 1);
+	        free(tmp_name_utf8);
+	        return 0; */
+		return gethostname(name_utf8, (int)len);
+	} else
+		return gethostname(name_utf8, (int)len);
+}
+
+void
+w32_freeaddrinfo(struct addrinfo *ai)
+{
+	struct addrinfo *cur;
+	while (ai) {
+		cur = ai;
+		ai = ai->ai_next;
+		if (cur->ai_addr)
+			free(cur->ai_addr);
+		if (cur->ai_canonname)
+			free(cur->ai_canonname);
+		free(cur);
+	}
+}
+
+int
+w32_getaddrinfo(const char *node_utf8, const char *service_utf8,
+		const struct addrinfo *hints, struct addrinfo **res)
+{
+	int ret = 0;
+	wchar_t *node_utf16 = NULL, *service_utf16 = NULL;
+	struct addrinfoW *info_w = NULL;
+	*res = NULL;
+
+	if ((node_utf8 && (node_utf16 = utf8_to_utf16(node_utf8)) == NULL) ||
+		(service_utf8 && (service_utf16 = utf8_to_utf16(service_utf8)) == NULL)) {
+		ret = EAI_MEMORY;
+		goto done;
+	}
+
+	if ((ret = GetAddrInfoW(node_utf16, service_utf16, (ADDRINFOW*)hints, &info_w)) != 0)
+		goto done;
+
+	/* copy info_w to res */
+	{
+		struct addrinfoW **cur_w = &info_w;
+		struct addrinfo **cur = res;
+
+		while (*cur_w) {
+			if ((*cur = malloc(sizeof(struct addrinfo))) == NULL) {
+				ret = EAI_MEMORY;
+				goto done;
+			}
+			if (memcpy_s(*cur, sizeof(struct addrinfo), *cur_w, sizeof(struct addrinfo))) {
+				ret = EAI_MEMORY;
+				goto done;
+			}
+			(*cur)->ai_next = NULL;
+			if (((*cur_w)->ai_canonname && ((*cur)->ai_canonname = utf16_to_utf8((*cur_w)->ai_canonname)) == NULL) ||
+			    ((*cur_w)->ai_addrlen && ((*cur)->ai_addr = malloc((*cur_w)->ai_addrlen)) == NULL)) {
+				ret = EAI_MEMORY;
+				goto done;
+
+			}
+			if ((*cur_w)->ai_addrlen)
+				if (memcpy_s((*cur)->ai_addr, (*cur_w)->ai_addrlen, (*cur_w)->ai_addr, (*cur_w)->ai_addrlen)) {
+					ret = EAI_MEMORY;
+					goto done;
+				}
+			cur_w = &(*cur_w)->ai_next;
+			cur = &(*cur)->ai_next;
+		}
+	}
+
+done:
+	if (node_utf16)
+		free(node_utf16);
+	if (service_utf16)
+		free(service_utf16);
+	if (info_w)
+		FreeAddrInfoW(info_w);
+	if (ret != 0 && *res) {
+		w32_freeaddrinfo(*res);
+		*res = NULL;
+	}
+	return ret;
+}
diff --git a/contrib/win32/win32compat/spawn-ext.c b/contrib/win32/win32compat/spawn-ext.c
new file mode 100644
index 000000000..19b569ff8
--- /dev/null
+++ b/contrib/win32/win32compat/spawn-ext.c
@@ -0,0 +1,34 @@
+#include <Windows.h>
+#include "misc_internal.h"
+#include "inc\unistd.h"
+#include "debug.h"
+
+int posix_spawn_internal(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], HANDLE user_token, BOOLEAN prepend_module_path);
+
+int
+__posix_spawn_asuser(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], char* user)
+{
+	extern HANDLE password_auth_token;
+	extern HANDLE sspi_auth_user;
+
+	int r = -1;
+	/* use token generated from password auth if already present */
+	HANDLE user_token = NULL;
+	
+	if (password_auth_token)
+		user_token = password_auth_token;
+	else if (sspi_auth_user) 
+		user_token = sspi_auth_user;
+
+	if (!user_token && (user_token = get_user_token(user, 1)) == NULL) {
+		error("unable to get security token for user %s", user);
+		errno = EOTHER;
+		return -1;
+	}
+	if (strcmp(user, "sshd"))
+		load_user_profile(user_token, user);
+	
+	r = posix_spawn_internal(pidp, path, file_actions, attrp, argv, envp, user_token, TRUE);
+	CloseHandle(user_token);
+	return r;
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/spawn.c b/contrib/win32/win32compat/spawn.c
new file mode 100644
index 000000000..38a3b3ef5
--- /dev/null
+++ b/contrib/win32/win32compat/spawn.c
@@ -0,0 +1,97 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Implementation of POSIX spawn family of functions
+*/
+#include <Windows.h>
+#include "inc\spawn.h"
+#include "inc\unistd.h"
+
+int
+posix_spawn_file_actions_init(posix_spawn_file_actions_t *file_actions)
+{
+	memset(file_actions, 0, sizeof(posix_spawn_file_actions_t));
+	file_actions->stdio_redirect[0] = 0;
+	file_actions->stdio_redirect[1] = 1;
+	file_actions->stdio_redirect[2] = 2;
+	return 0;
+}
+
+int
+posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *file_actions)
+{
+	return 0;
+}
+
+int
+posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *file_actions, int fildes)
+{
+	errno = ENOTSUP;
+	return -1;
+}
+
+int
+posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *file_actions, int fildes, int newfildes)
+{
+	if (newfildes <= STDERR_FILENO) {
+		file_actions->stdio_redirect[newfildes] = fildes;
+		return 0;
+	}
+
+	if (file_actions->num_aux_fds == MAX_INHERITED_FDS) {
+		errno = ENOMEM;
+		return -1;
+	}
+	
+	file_actions->aux_fds_info.parent_fd[file_actions->num_aux_fds] = fildes;
+	file_actions->aux_fds_info.child_fd[file_actions->num_aux_fds] = newfildes;
+	file_actions->num_aux_fds++;
+	return 0;
+}
+
+int
+posix_spawn_file_actions_addopen(posix_spawn_file_actions_t *file_actions, int fildes, const char *path, int oflag, mode_t mode)
+{
+	errno = ENOTSUP;
+	return -1;
+}
+
+int
+posix_spawnattr_init(posix_spawnattr_t *attr)
+{
+	memset(attr, 0, sizeof(posix_spawnattr_t));
+	return 0;
+}
+
+int
+posix_spawnattr_destroy(posix_spawnattr_t *attr)
+{
+	memset(attr, 0, sizeof(posix_spawnattr_t));
+	return 0;
+}
+
+int
+posix_spawnattr_getflags(const posix_spawnattr_t *attr, short *flags)
+{
+	errno = ENOTSUP;
+	return -1;
+}
+
+int
+posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags)
+{
+	if (flags != POSIX_SPAWN_SETPGROUP) {
+		errno = ENOTSUP;
+		return -1;
+	}
+	attr->flags = flags;
+	return 0;
+}
+
+int posix_spawnattr_getpgroup(const posix_spawnattr_t * attr, pid_t * pgroup) {
+	return 0;
+}
+
+int posix_spawnattr_setpgroup(posix_spawnattr_t *attr, pid_t pgroup) {
+	return 0;
+}
diff --git a/contrib/win32/win32compat/ssh-agent/agent-main.c b/contrib/win32/win32compat/ssh-agent/agent-main.c
new file mode 100644
index 000000000..2b001cd00
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/agent-main.c
@@ -0,0 +1,218 @@
+/*
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+ * ssh-agent implementation on Windows
+ * NT Service routines
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "agent.h"
+#include "..\misc_internal.h"
+#include "..\Debug.h"
+#include <wchar.h>
+
+#pragma warning(push, 3)
+
+int remote_add_provider;
+
+int scm_start_service(DWORD, LPWSTR*);
+
+SERVICE_TABLE_ENTRYW dispatch_table[] =
+{
+	{ L"ssh-agent", (LPSERVICE_MAIN_FUNCTIONW)scm_start_service },
+	{ NULL, NULL }
+};
+static SERVICE_STATUS_HANDLE service_status_handle;
+static SERVICE_STATUS service_status;
+
+
+static VOID 
+ReportSvcStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)
+{
+	service_status.dwCurrentState = dwCurrentState;
+	service_status.dwWin32ExitCode = dwWin32ExitCode;
+	service_status.dwWaitHint = dwWaitHint;
+
+	if (dwCurrentState == SERVICE_START_PENDING)
+		service_status.dwControlsAccepted = 0;
+	else
+		service_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+
+	if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED))
+		service_status.dwCheckPoint = 0;
+	else
+		service_status.dwCheckPoint = 1;
+
+	SetServiceStatus(service_status_handle, &service_status);
+}
+
+static VOID WINAPI 
+service_handler(DWORD dwControl)
+{
+	switch (dwControl)
+	{
+	case SERVICE_CONTROL_STOP: {
+		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 500);
+		agent_shutdown();
+		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
+		return;
+	}
+	case SERVICE_CONTROL_INTERROGATE:
+		break;
+	default:
+		break;
+	}
+
+	ReportSvcStatus(service_status.dwCurrentState, NO_ERROR, 0);
+}
+
+BOOL WINAPI 
+ctrl_c_handler(_In_ DWORD dwCtrlType) 
+{
+	/* for any Ctrl type, shutdown agent*/
+	debug4("Ctrl+C received");
+	agent_shutdown();
+	return TRUE;
+}
+
+/*set current working directory to module path*/
+static void
+fix_cwd()
+{
+	wchar_t path[PATH_MAX] = { 0 };
+	int i, lastSlashPos = 0;
+	GetModuleFileNameW(NULL, path, PATH_MAX);
+	for (i = 0; path[i]; i++) {
+		if (path[i] == L'/' || path[i] == L'\\')
+			lastSlashPos = i;
+	}
+
+	path[lastSlashPos] = 0;
+	_wchdir(path);
+}
+
+extern void sanitise_stdfd(void);
+
+int 
+wmain(int argc, wchar_t **wargv)
+{
+	_set_invalid_parameter_handler(invalid_parameter_handler);
+	w32posix_initialize();
+	fix_cwd();
+	/* Check if -Oallow-remote-pkcs11 has been passed in for all scenarios */
+	if (argc >= 2) {
+		for (int i = 0; i < argc; i++) {
+			if (wcsncmp(wargv[i], L"-O", 2) == 0) {
+				if (wcsncmp(wargv[i], L"-Oallow-remote-pkcs11", 21) == 0) {
+					remote_add_provider = 1;
+				}
+				else {
+					fatal("Unknown -O option; only allow-remote-pkcs11 is supported");
+				}
+			}
+		}
+	}
+	if (!StartServiceCtrlDispatcherW(dispatch_table)) {
+		if (GetLastError() == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT) {
+			/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */
+			sanitise_stdfd();
+
+			/*
+			 * agent is not spawned by SCM
+			 * Its either started in debug mode or a worker child
+			 * If running in debug mode, args are (any order): -d, -dd, or -ddd and -Oallow-remote-pkcs11 (optional)
+			 * If a worker child, args are (in this order): int (connection handle) and -Oallow-remote-pkcs11 (optional) 
+			 */
+
+			if (argc >= 2) {
+				for (int i = 0; i < argc; i++) {
+					if (wcsncmp(wargv[i], L"-ddd", 4) == 0) {
+						log_init("ssh-agent", 7, 1, 1);
+					}
+					else if (wcsncmp(wargv[i], L"-dd", 3) == 0) {
+						log_init("ssh-agent", 6, 1, 1);
+					}
+					else if (wcsncmp(wargv[i], L"-d", 2) == 0) {
+						log_init("ssh-agent", 5, 1, 1);
+					}
+
+					/* Set Ctrl+C handler if starting in debug mode */
+					if (wcsncmp(wargv[i], L"-d", 2) == 0) {
+						SetConsoleCtrlHandler(ctrl_c_handler, TRUE);
+						agent_start(TRUE);
+						return 0;
+					}
+
+					/*agent process is likely a spawned child*/
+					char* h = 0;
+					h += _wtoi(*(wargv + i));
+					if (h != 0) {
+						log_init("ssh-agent", 3, 1, 0);
+						agent_process_connection(h);
+						return 0;
+					}
+				}
+			}
+			/* to support linux compat scenarios where ssh-agent.exe is typically launched per session*/
+			/* - just start ssh-agent service if needed */
+			{
+				SC_HANDLE sc_handle, svc_handle;
+
+				if ((sc_handle = OpenSCManagerW(NULL, NULL, SERVICE_START)) == NULL ||
+					(svc_handle = OpenServiceW(sc_handle, L"ssh-agent", SERVICE_START)) == NULL) {
+					fatal("unable to open service handle");
+					return -1;
+				}
+
+				if (StartService(svc_handle, 0, NULL) == FALSE && GetLastError() != ERROR_SERVICE_ALREADY_RUNNING) {
+					fatal("unable to start ssh-agent service, error :%d", GetLastError());
+					return -1;
+				}
+
+				return 0;
+			}
+		}
+		else
+			return -1;
+	}
+	return 0;
+}
+
+int 
+scm_start_service(DWORD num, LPWSTR* args) 
+{
+	service_status_handle = RegisterServiceCtrlHandlerW(L"ssh-agent", service_handler);
+	ZeroMemory(&service_status, sizeof(service_status));
+	service_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 300);
+	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
+	log_init("ssh-agent", 3, 1, 0);
+	agent_start(FALSE);
+	return 0;
+}
+
+#pragma warning(pop)
diff --git a/contrib/win32/win32compat/ssh-agent/agent-request.h b/contrib/win32/win32compat/ssh-agent/agent-request.h
new file mode 100644
index 000000000..79cc8f8f2
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/agent-request.h
@@ -0,0 +1,25 @@
+typedef unsigned char u_int8_t;
+typedef unsigned short u_int16_t;
+typedef unsigned int u_int32_t;
+typedef unsigned __int64 u_int64_t;
+#define __attribute__(a)
+#include <stdint.h>
+#include "sshkey.h"
+#include "sshbuf.h"
+#include <openssl/bn.h>
+#include "authfd.h"
+#include "digest.h"
+
+
+/* key management */
+int process_unsupported_request(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_add_identity(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_request_identities(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_sign_request(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_remove_key(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_remove_all(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_add_smartcard_key(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_remove_smartcard_key(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+int process_extension(struct sshbuf*, struct sshbuf*, struct agent_connection*);
+
+/* auth */
diff --git a/contrib/win32/win32compat/ssh-agent/agent.c b/contrib/win32/win32compat/ssh-agent/agent.c
new file mode 100644
index 000000000..adac352c9
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/agent.c
@@ -0,0 +1,410 @@
+/*
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+ * ssh-agent implementation on Windows
+ * 
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "config.h"
+#include "agent.h"
+#include <sddl.h>
+#include <UserEnv.h>
+#include "..\misc_internal.h"
+#include <pwd.h>
+
+#define BUFSIZE 5 * 1024
+
+extern int remote_add_provider;
+
+char* sshagent_con_username;
+HANDLE sshagent_client_primary_token;
+
+static HANDLE ioc_port = NULL;
+static BOOL debug_mode = FALSE;
+
+#define AGENT_PIPE_ID L"\\\\.\\pipe\\openssh-ssh-agent"
+
+static HANDLE event_stop_agent;
+static OVERLAPPED ol;
+static 	HANDLE pipe;
+static	SECURITY_ATTRIBUTES sa;
+
+static size_t nsession_ids;
+static struct hostkey_sid *session_ids;
+static struct dest_constraint *dest_constraints;
+static size_t ndest_constraints;
+
+static void
+agent_cleanup() 
+{
+	if (ol.hEvent != NULL)
+		CloseHandle(ol.hEvent);
+	if (pipe != INVALID_HANDLE_VALUE)
+		CloseHandle(pipe);
+	if (ioc_port)
+		CloseHandle(ioc_port);
+	return;
+}
+
+static DWORD WINAPI 
+iocp_work(LPVOID lpParam) 
+{
+	DWORD bytes;
+	struct agent_connection* con = NULL;
+	OVERLAPPED *p_ol;
+	while (1) {
+		con = NULL;
+		p_ol = NULL;
+		if (GetQueuedCompletionStatus(ioc_port, &bytes, &(ULONG_PTR)con, &p_ol, INFINITE) == FALSE) {
+			debug("iocp error: %d on %p", GetLastError(), con);
+			if (con)
+				agent_connection_on_error(con, GetLastError());
+			else
+				return 0;
+		}
+		else
+			agent_connection_on_io(con, bytes, p_ol);
+	}
+}
+
+static void 
+agent_listen_loop() 
+{
+	DWORD  r;
+	HANDLE wait_events[2];
+
+	wait_events[0] = event_stop_agent;
+	wait_events[1] = ol.hEvent;
+
+	wchar_t* sddl_str;
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+	/*
+	 * SDDL - GA to System and Builtin/Admins and restricted access to Authenticated users
+	 * 0x12019b - FILE_GENERIC_READ/WRITE minus FILE_CREATE_PIPE_INSTANCE
+	 */
+	sddl_str = L"D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;0x12019b;;;AU)";
+	if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl_str, SDDL_REVISION_1,
+		&sa.lpSecurityDescriptor, &sa.nLength))
+		fatal("cannot convert sddl ERROR:%d", GetLastError());
+
+	sa.bInheritHandle = FALSE;
+
+	while (1) {
+		pipe = CreateNamedPipeW(
+			AGENT_PIPE_ID,		  // pipe name 
+			PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,       // read/write access 
+			PIPE_TYPE_BYTE |       // message type pipe 
+			PIPE_READMODE_BYTE |   // message-read mode 
+			PIPE_WAIT,                // blocking mode 
+			PIPE_UNLIMITED_INSTANCES, // max. instances  
+			BUFSIZE,                  // output buffer size 
+			BUFSIZE,                  // input buffer size 
+			0,                        // client time-out 
+			&sa);
+
+		if (pipe == INVALID_HANDLE_VALUE) {
+			verbose("cannot create listener pipe ERROR:%d", GetLastError());
+			SetEvent(event_stop_agent);
+		} else if (ConnectNamedPipe(pipe, &ol) != FALSE) {
+			verbose("ConnectNamedPipe returned TRUE unexpectedly ");
+			SetEvent(event_stop_agent);
+		}
+				
+		if (GetLastError() == ERROR_PIPE_CONNECTED) {
+			debug("Client has already connected");
+			SetEvent(ol.hEvent);
+		} else if (GetLastError() != ERROR_IO_PENDING) {
+			debug("ConnectNamedPipe failed ERROR: %d", GetLastError());
+			SetEvent(event_stop_agent);
+		}
+
+		r = WaitForMultipleObjects(2, wait_events, FALSE, INFINITE);
+		if (r == WAIT_OBJECT_0) {
+			/*received signal to shutdown*/
+			debug("shutting down");
+			agent_cleanup();
+			return;
+		} else if ((r > WAIT_OBJECT_0) && (r <= (WAIT_OBJECT_0 + 1))) {
+			/* process incoming connection */
+			HANDLE con = pipe;
+			DWORD client_pid = 0;
+			pipe = INVALID_HANDLE_VALUE;
+			GetNamedPipeClientProcessId(con, &client_pid);
+			verbose("client pid %d connected", client_pid);
+			if (debug_mode) {
+				agent_process_connection(con);
+				agent_cleanup();
+				return;
+			} else {
+				/* spawn a child to take care of this*/
+				wchar_t path[PATH_MAX], module_path[PATH_MAX];
+				PROCESS_INFORMATION pi;
+				STARTUPINFOW si;
+
+				si.cb = sizeof(STARTUPINFOW);
+				memset(&si, 0, sizeof(STARTUPINFOW));
+				GetModuleFileNameW(NULL, module_path, PATH_MAX);
+				SetHandleInformation(con, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
+				if (remote_add_provider == 1) {
+					if (swprintf_s(path, PATH_MAX, L"%s %d %s", module_path, (int)(intptr_t)con, L"-Oallow-remote-pkcs11") == -1)
+						verbose("Failed to create child process %ls ERROR:%d", module_path, GetLastError());
+				}
+				else {
+					if (swprintf_s(path, PATH_MAX, L"%s %d", module_path, (int)(intptr_t)con) == -1)
+						verbose("Failed to create child process %ls ERROR:%d", module_path, GetLastError());
+				}
+				if (CreateProcessW(NULL, path, NULL, NULL, TRUE, DETACHED_PROCESS, NULL, NULL, &si, &pi) == FALSE) {
+					verbose("Failed to create child process %ls ERROR:%d", module_path, GetLastError());
+				} else {
+					debug("spawned worker %d for agent client pid %d ", pi.dwProcessId, client_pid);
+					CloseHandle(pi.hProcess);
+					CloseHandle(pi.hThread);
+				}
+				SetHandleInformation(con, HANDLE_FLAG_INHERIT, 0);
+				CloseHandle(con);				
+			}
+			
+		} else {
+			fatal("wait on events ended with %d ERROR:%d", r, GetLastError());
+		}
+
+	}
+}
+
+void 
+agent_cleanup_connection(struct agent_connection* con) 
+{
+	debug("connection %p clean up", con);
+	CloseHandle(con->pipe_handle);
+	if (con->client_impersonation_token)
+			CloseHandle(con->client_impersonation_token);
+	if (con->client_process_handle)
+		CloseHandle(con->client_process_handle);
+
+	for (size_t i = 0; i < con->nsession_ids; i++) {
+		sshkey_free(con->session_ids[i].key);
+		sshbuf_free(con->session_ids[i].sid);
+	}
+	free(con->session_ids);
+	con->nsession_ids = 0;
+	
+	free(con);
+	CloseHandle(ioc_port);
+	ioc_port = NULL;
+
+	if(sshagent_con_username) {
+		free(sshagent_con_username);
+		sshagent_con_username = NULL;
+	}
+
+#ifdef ENABLE_PKCS11
+	if (sshagent_client_primary_token)
+		CloseHandle(sshagent_client_primary_token);
+
+	pkcs11_terminate();
+#endif
+}
+
+void 
+agent_shutdown() 
+{
+	SetEvent(event_stop_agent);
+}
+
+void
+agent_start(BOOL dbg_mode) 
+{
+	int r;
+	HKEY agent_root = NULL;
+	DWORD process_id = GetCurrentProcessId();
+	wchar_t* sddl_str;
+	
+	verbose("%s pid:%d, dbg:%d", __FUNCTION__, process_id, dbg_mode);
+	debug_mode = dbg_mode;
+
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+
+	// SDDL - FullAcess to System and Builtin/Admins
+	sddl_str = L"D:PAI(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)";
+	if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl_str, SDDL_REVISION_1,
+	    &sa.lpSecurityDescriptor, &sa.nLength))
+		fatal("cannot convert sddl ERROR:%d", GetLastError());
+	if ((r = RegCreateKeyExW(HKEY_LOCAL_MACHINE, SSH_AGENT_ROOT, 0, 0, 0, KEY_WRITE, &sa, &agent_root, 0)) != ERROR_SUCCESS)
+		fatal("cannot create agent root reg key, ERROR:%d", r);
+	if ((r = RegSetValueExW(agent_root, L"ProcessID", 0, REG_DWORD, (BYTE*)&process_id, 4)) != ERROR_SUCCESS)
+		fatal("cannot publish agent master process id ERROR:%d", r);
+	if ((event_stop_agent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
+		fatal("cannot create global stop event ERROR:%d", GetLastError());
+	if ((ol.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
+		fatal("cannot create event ERROR:%d", GetLastError());
+	pipe = INVALID_HANDLE_VALUE;
+	sa.bInheritHandle = FALSE;
+	agent_listen_loop();
+}
+
+static char*
+con_type_to_string(struct agent_connection* con)
+{
+	switch (con->client_type) {
+	case UNKNOWN:
+		return "unknown";
+	case NONADMIN_USER:
+		return "restricted user";
+	case ADMIN_USER:
+		return "administrator";
+	case SYSTEM:
+		return "system";
+	case SERVICE:
+		return "service";
+	default:
+		return "unexpected";
+	}
+}
+
+static int
+get_con_client_info(struct agent_connection* con)
+{
+	int r = -1;
+	char sid[SECURITY_MAX_SID_SIZE];
+	ULONG client_pid;
+	DWORD reg_dom_len = 0, info_len = 0, sid_size;
+	DWORD sshd_sid_len = 0;
+	PSID sshd_sid = NULL;
+	HANDLE client_primary_token = NULL, client_impersonation_token = NULL, client_process_handle = NULL;
+	TOKEN_USER* info = NULL;
+	BOOL isMember = FALSE;
+
+	if (GetNamedPipeClientProcessId(con->pipe_handle, &client_pid) == FALSE ||
+		(client_process_handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_DUP_HANDLE, FALSE, client_pid)) == NULL ||
+		OpenProcessToken(client_process_handle, TOKEN_QUERY | TOKEN_DUPLICATE, &client_primary_token) == FALSE ||
+		DuplicateToken(client_primary_token, SecurityImpersonation, &client_impersonation_token) == FALSE) {
+		error("cannot retrieve client impersonation token");
+		goto done;
+	}
+
+	if (GetTokenInformation(client_primary_token, TokenUser, NULL, 0, &info_len) == TRUE ||
+		(info = (TOKEN_USER*)malloc(info_len)) == NULL) // CodeQL [SM02320]: GetTokenInformation will initialize info
+		goto done;
+
+	if (GetTokenInformation(client_primary_token, TokenUser, info, info_len, &info_len) == FALSE)
+		goto done;
+	
+	/* check if its localsystem */
+	if (IsWellKnownSid(info->User.Sid, WinLocalSystemSid)) {
+		con->client_type = SYSTEM;
+		r = 0;
+		goto done;
+	}
+
+	/* check if its LS or NS */
+	if (IsWellKnownSid(info->User.Sid, WinNetworkServiceSid) ||
+		IsWellKnownSid(info->User.Sid, WinLocalServiceSid)) {
+		con->client_type = SERVICE;
+		r = 0;
+		goto done;
+	}
+
+	// Get client primary token
+	if (DuplicateTokenEx(client_primary_token, TOKEN_QUERY | TOKEN_ASSIGN_PRIMARY | TOKEN_DUPLICATE, NULL, SecurityImpersonation, TokenPrimary, &sshagent_client_primary_token) == FALSE) {
+		error_f("Failed to duplicate the primary token. error:%d", GetLastError());
+	}
+
+	// Get username
+	sshagent_con_username= get_username(info->User.Sid);
+	if (sshagent_con_username)
+		debug_f("sshagent_con_username: %s", sshagent_con_username);
+	else
+		error_f("Failed to get the userName");
+
+	/* check if its admin */
+	{
+		sid_size = SECURITY_MAX_SID_SIZE;
+		if (CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, sid, &sid_size) == FALSE)
+			goto done;
+		if (CheckTokenMembership(client_impersonation_token, sid, &isMember) == FALSE)
+			goto done;
+		if (isMember) {
+			con->client_type = ADMIN_USER;
+			r = 0;
+			goto done;
+		}
+	}
+
+	/* none of above */
+	con->client_type = NONADMIN_USER;
+	r = 0;
+done:
+	debug("client type: %s", con_type_to_string(con));
+	con->nsession_ids = 0;
+
+	if (sshd_sid)
+		free(sshd_sid);
+	if (info)
+		free(info);
+	if (client_primary_token)
+		CloseHandle(client_primary_token);
+
+	if (r == 0) {
+		con->client_process_handle = client_process_handle;
+		con->client_impersonation_token = client_impersonation_token;
+	}
+	else {
+		if (client_process_handle)
+			CloseHandle(client_process_handle);
+		if (client_impersonation_token)
+			CloseHandle(client_impersonation_token);
+	}
+
+	return r;
+}
+
+void 
+agent_process_connection(HANDLE pipe) 
+{
+	struct agent_connection* con;
+	verbose("%s pipe:%p", __FUNCTION__, pipe);
+
+	if ((ioc_port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, (ULONG_PTR)NULL, 0)) == NULL)
+		fatal("cannot create ioc port ERROR:%d", GetLastError());
+
+	if ((con = malloc(sizeof(struct agent_connection))) == NULL)
+		fatal("failed to alloc");
+
+	memset(con, 0, sizeof(struct agent_connection));
+	con->pipe_handle = pipe;
+	if (CreateIoCompletionPort(pipe, ioc_port, (ULONG_PTR)con, 0) != ioc_port)
+		fatal("failed to assign pipe to ioc_port");
+
+	/* get client details */
+	if (get_con_client_info(con) == -1)
+		fatal("failed to retrieve client details");
+
+	agent_connection_on_io(con, 0, &con->ol);
+	iocp_work(NULL);
+}
+
diff --git a/contrib/win32/win32compat/ssh-agent/agent.h b/contrib/win32/win32compat/ssh-agent/agent.h
new file mode 100644
index 000000000..5313d7e6e
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/agent.h
@@ -0,0 +1,65 @@
+#include <Windows.h>
+#include <stdio.h>
+#include "Debug.h"
+#include "misc_internal.h"
+
+#define MAX_MESSAGE_SIZE 256 * 1024
+
+#define SSH_AGENT_ROOT SSH_REGISTRY_ROOT L"\\Agent"
+#define SSH_KEYS_KEY L"Keys"
+#define SSH_KEYS_ROOT SSH_AGENT_ROOT L"\\" SSH_KEYS_KEY
+#define SSH_PKCS11_PROVIDERS_KEY L"PKCS11_Providers"
+#define SSH_PKCS11_PROVIDERS_ROOT SSH_AGENT_ROOT L"\\" SSH_PKCS11_PROVIDERS_KEY
+/* Maximum number of recorded session IDs/hostkeys per connection */
+#define AGENT_MAX_SESSION_IDS		16
+/* Maximum size of session ID */
+#define AGENT_MAX_SID_LEN		128
+/* Maximum number of destination constraints to accept on a key */
+#define AGENT_MAX_DEST_CONSTRAINTS	1024
+
+#define HEADER_SIZE 4
+
+struct hostkey_sid {
+	struct sshkey *key;
+	struct sshbuf *sid;
+	int forwarded;
+};
+
+struct agent_connection {
+	OVERLAPPED ol;
+	HANDLE pipe_handle;
+	HANDLE client_impersonation_token;
+	HANDLE client_process_handle;
+	struct {
+		DWORD num_bytes;
+		DWORD transferred;
+		char buf[MAX_MESSAGE_SIZE];
+		DWORD buf_size;
+	} io_buf;
+	enum {
+		LISTENING = 0,
+		READING_HEADER,
+		READING,
+		WRITING,
+		DONE
+	} state;
+	enum { /* retain this order */
+		UNKNOWN = 0,
+		NONADMIN_USER, /* client is running as a nonadmin user */
+		ADMIN_USER, /* client is running as admin */
+		SYSTEM, /* client is running as System */
+		SERVICE, /* client is running as LS or NS */
+	} client_type;
+	
+	size_t nsession_ids;
+	struct hostkey_sid *session_ids;
+};
+
+void agent_connection_on_io(struct agent_connection*, DWORD, OVERLAPPED*);
+void agent_connection_on_error(struct agent_connection* , DWORD);
+void agent_connection_disconnect(struct agent_connection*);
+
+void agent_start(BOOL);
+void agent_process_connection(HANDLE);
+void agent_shutdown();
+void agent_cleanup_connection(struct agent_connection*);
diff --git a/contrib/win32/win32compat/ssh-agent/connection.c b/contrib/win32/win32compat/ssh-agent/connection.c
new file mode 100644
index 000000000..d8977a15d
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/connection.c
@@ -0,0 +1,199 @@
+/*
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+ * ssh-agent implementation on Windows
+ * 
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "agent.h"
+#include "agent-request.h"
+#include "config.h"
+
+#pragma warning(push, 3)
+
+int process_request(struct agent_connection*);
+
+#define ABORT_CONNECTION_RETURN(c) do {	\
+	c->state = DONE;		\
+	agent_cleanup_connection(c);	\
+	return;				\
+} while (0)
+
+void 
+agent_connection_on_error(struct agent_connection* con, DWORD error) 
+{
+	ABORT_CONNECTION_RETURN(con);
+}
+
+void 
+agent_connection_on_io(struct agent_connection* con, DWORD bytes, OVERLAPPED* ol) 
+{
+	/* process error */
+	debug3("connection io %p #bytes:%d state:%d", con, bytes, con->state);
+	if ((bytes == 0) && (GetOverlappedResult(con->pipe_handle, ol, &bytes, FALSE) == FALSE))
+		ABORT_CONNECTION_RETURN(con);
+	if (con->state == DONE)
+		debug_assert_internal();
+
+	switch (con->state) {		
+	case LISTENING:
+	case WRITING:
+		/* Writing is done, read next request */
+		/* assert on assumption that write always completes on sending all bytes*/
+		if (bytes != con->io_buf.num_bytes)
+			debug_assert_internal();
+		con->state = READING_HEADER;
+		ZeroMemory(&con->io_buf, sizeof(con->io_buf));
+		if (!ReadFile(con->pipe_handle, con->io_buf.buf,
+			HEADER_SIZE,  NULL, &con->ol) && (GetLastError() != ERROR_IO_PENDING)) 
+			ABORT_CONNECTION_RETURN(con);
+		break;
+	case READING_HEADER:
+		con->io_buf.transferred += bytes;
+		if (con->io_buf.transferred == HEADER_SIZE) {
+			con->io_buf.num_bytes = PEEK_U32(con->io_buf.buf);
+			con->io_buf.transferred = 0;
+			if (con->io_buf.num_bytes > MAX_MESSAGE_SIZE)
+				ABORT_CONNECTION_RETURN(con);
+
+			con->state = READING;
+			if (!ReadFile(con->pipe_handle, con->io_buf.buf,
+				con->io_buf.num_bytes, NULL, &con->ol)&&(GetLastError() != ERROR_IO_PENDING)) 
+				ABORT_CONNECTION_RETURN(con);
+		} else {
+			if (!ReadFile(con->pipe_handle, con->io_buf.buf + con->io_buf.num_bytes,
+				HEADER_SIZE - con->io_buf.num_bytes, NULL, &con->ol)&& (GetLastError() != ERROR_IO_PENDING)) 
+				ABORT_CONNECTION_RETURN(con);
+		}
+		break;
+	case READING:
+		con->io_buf.transferred += bytes;
+		if (con->io_buf.transferred == con->io_buf.num_bytes) {
+			if (process_request(con) != 0) {
+				ABORT_CONNECTION_RETURN(con);
+			}
+			con->state = WRITING;
+			if (!WriteFile(con->pipe_handle, con->io_buf.buf,
+				con->io_buf.num_bytes, NULL, &con->ol)&& (GetLastError() != ERROR_IO_PENDING) )
+				ABORT_CONNECTION_RETURN(con);
+		} else {
+			if (!ReadFile(con->pipe_handle, con->io_buf.buf + con->io_buf.transferred,
+				con->io_buf.num_bytes - con->io_buf.transferred, NULL, &con->ol)&& (GetLastError() != ERROR_IO_PENDING)) 
+				ABORT_CONNECTION_RETURN(con);
+		}
+		break;
+	default:
+		debug_assert_internal();
+	}		
+}
+
+void 
+agent_connection_disconnect(struct agent_connection* con) 
+{
+	CancelIoEx(con->pipe_handle, NULL);
+	DisconnectNamedPipe(con->pipe_handle);
+}
+
+static int
+process_request(struct agent_connection* con) 
+{
+	int r = -1;
+	struct sshbuf *request = NULL, *response = NULL;
+	u_char type;
+	errno_t err = 0;
+
+	request = sshbuf_from(con->io_buf.buf, con->io_buf.num_bytes);
+	response = sshbuf_new();
+	if ((request == NULL) || (response == NULL))
+		goto done;
+
+	if (sshbuf_get_u8(request, &type) != 0)
+		return -1;
+	debug("process agent request type %d", type);
+
+	switch (type) {
+	case SSH_AGENTC_REQUEST_RSA_IDENTITIES:
+	case SSH_AGENTC_RSA_CHALLENGE:
+	case SSH_AGENTC_ADD_RSA_IDENTITY:
+	case SSH_AGENTC_REMOVE_RSA_IDENTITY:
+	case SSH_AGENTC_REMOVE_ALL_RSA_IDENTITIES:
+		r = process_unsupported_request(request, response, con);
+		break;
+	case SSH2_AGENTC_ADD_IDENTITY:
+	case SSH2_AGENTC_ADD_ID_CONSTRAINED:
+		r =  process_add_identity(request, response, con);
+		break;
+	case SSH2_AGENTC_REQUEST_IDENTITIES:
+		r = process_request_identities(request, response, con);
+		break;
+	case SSH2_AGENTC_SIGN_REQUEST:
+		r = process_sign_request(request, response, con);
+		break;
+	case SSH2_AGENTC_REMOVE_IDENTITY:
+		r = process_remove_key(request, response, con);
+		break;
+	case SSH2_AGENTC_REMOVE_ALL_IDENTITIES:
+		r = process_remove_all(request, response, con);
+		break;
+#ifdef ENABLE_PKCS11
+	case SSH_AGENTC_ADD_SMARTCARD_KEY:
+	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
+		r = process_add_smartcard_key(request, response, con);
+		break;
+	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
+		r = process_remove_smartcard_key(request, response, con);
+		break;
+#endif /* ENABLE_PKCS11 */
+	case SSH_AGENTC_EXTENSION:
+		r = process_extension(request, response, con);
+		break;
+	default:
+		debug("unknown agent request %d", type);
+		r = -1;
+		break;
+	}
+
+done:
+	if (request)
+		sshbuf_free(request);
+
+	ZeroMemory(&con->io_buf, sizeof(con->io_buf));
+	if (r == 0) {
+		POKE_U32(con->io_buf.buf, (u_int32_t)sshbuf_len(response));
+		if ((err = memcpy_s(con->io_buf.buf + 4, sizeof(con->io_buf.buf) - 4, sshbuf_ptr(response), sshbuf_len(response))) != 0) {
+			debug("memcpy_s failed with error: %d.", err);
+			r = -1;
+		}
+		con->io_buf.num_bytes = (DWORD)sshbuf_len(response) + 4;
+	}
+	
+	if (response)
+		sshbuf_free(response);
+
+	return r;
+}
+
+#pragma warning(pop)
diff --git a/contrib/win32/win32compat/ssh-agent/keyagent-request.c b/contrib/win32/win32compat/ssh-agent/keyagent-request.c
new file mode 100644
index 000000000..0304f589f
--- /dev/null
+++ b/contrib/win32/win32compat/ssh-agent/keyagent-request.c
@@ -0,0 +1,1071 @@
+/*
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+ * ssh-agent implementation on Windows
+ * 
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "agent.h"
+#include "agent-request.h"
+#include "config.h"
+#include <sddl.h>
+#ifdef ENABLE_PKCS11
+#include "ssh-pkcs11.h"
+#endif
+#include "xmalloc.h"
+
+#pragma warning(push, 3)
+
+#define MAX_KEY_LENGTH 255
+#define MAX_VALUE_NAME_LENGTH 16383
+#define MAX_VALUE_DATA_LENGTH 2048
+
+extern int remote_add_provider;
+
+/* 
+ * get registry root where keys are stored 
+ * user keys are stored in user's hive
+ * while system keys (host keys) in HKLM
+ */
+
+extern struct sshkey *
+lookup_key(const struct sshkey *k);
+
+extern void
+add_key(struct sshkey *k, char *name);
+
+extern void
+del_all_keys();
+
+static int
+get_user_root(struct agent_connection* con, HKEY *root)
+{
+	int r = 0;
+	LONG ret;
+	*root = HKEY_LOCAL_MACHINE;
+	
+	if (con->client_type <= ADMIN_USER) {
+		if (ImpersonateLoggedOnUser(con->client_impersonation_token) == FALSE)
+			return -1;
+		*root = NULL;
+		/* 
+		 * TODO - check that user profile is loaded, 
+		 * otherwise, this will return default profile 
+		 */
+		if ((ret = RegOpenCurrentUser(KEY_ALL_ACCESS, root)) != ERROR_SUCCESS) {
+			debug("unable to open user's registry hive, ERROR - %d", ret);
+			r = -1;
+		}
+			
+		RevertToSelf();
+	}
+	return r;
+}
+
+static int
+convert_blob(struct agent_connection* con, const char *blob, DWORD blen, char **eblob, DWORD *eblen, int encrypt) {
+	int success = 0;
+	DATA_BLOB in, out;
+	errno_t r = 0;
+
+	if (con->client_type <= ADMIN_USER)
+		if (ImpersonateLoggedOnUser(con->client_impersonation_token) == FALSE)
+			return -1;
+
+	in.cbData = blen;
+	in.pbData = (char*)blob;
+	out.cbData = 0;
+	out.pbData = NULL;
+
+	if (encrypt) {
+		if (!CryptProtectData(&in, NULL, NULL, 0, NULL, 0, &out)) {
+			debug("cannot encrypt data");
+			goto done;
+		}
+	} else {
+		if (!CryptUnprotectData(&in, NULL, NULL, 0, NULL, 0, &out)) {
+			debug("cannot decrypt data");
+			goto done;
+		}
+	}
+
+	*eblob = malloc(out.cbData);
+	if (*eblob == NULL) 
+		goto done;
+
+	if((r = memcpy_s(*eblob, out.cbData, out.pbData, out.cbData)) != 0) {
+		debug("memcpy_s failed with error: %d.", r);
+		goto done;
+	}
+	*eblen = out.cbData;
+	success = 1;
+done:
+	if (out.pbData)
+		LocalFree(out.pbData);
+	if (con->client_type <= ADMIN_USER)
+		RevertToSelf();
+	return success? 0: -1;
+}
+
+/*
+ * in user_root sub tree under key_name key
+ * remove all sub keys with value name value_name_to_remove
+ * and value data value_data_to_remove
+ */
+static int
+remove_matching_subkeys_from_registry(HKEY user_root, wchar_t const* key_name, wchar_t const* value_name_to_remove, char const* value_data_to_remove) {
+	int index = 0, success = 0;
+	DWORD data_len;
+	HKEY root = 0, sub = 0;
+	char *data = NULL;
+	wchar_t sub_name[MAX_KEY_LENGTH];
+	DWORD sub_name_len = MAX_KEY_LENGTH;
+	LSTATUS retCode;
+
+	if (RegOpenKeyExW(user_root, key_name, 0, DELETE | KEY_ENUMERATE_SUB_KEYS | KEY_WOW64_64KEY, &root) != 0) {
+		goto done;
+	}
+
+	while (1) {
+		sub_name_len = MAX_KEY_LENGTH;
+		if (sub) {
+			RegCloseKey(sub);
+			sub = NULL;
+		}
+		if ((retCode = RegEnumKeyExW(root, index++, sub_name, &sub_name_len, NULL, NULL, NULL, NULL)) == 0) {
+			if (RegOpenKeyExW(root, sub_name, 0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &sub) == 0 &&
+				RegQueryValueExW(sub, value_name_to_remove, 0, NULL, NULL, &data_len) == 0 &&
+				data_len <= MAX_VALUE_DATA_LENGTH) {
+
+				if (data)
+					free(data);
+				data = NULL;
+
+				if ((data = malloc(data_len + 1)) == NULL ||
+					RegQueryValueExW(sub, value_name_to_remove, 0, NULL, data, &data_len) != 0)
+					goto done;
+				data[data_len] = '\0';
+				if (strncmp(data, value_data_to_remove, data_len) == 0) {
+					if (RegDeleteTreeW(root, sub_name) != 0)
+						goto done;
+					--index;
+				}
+			}
+		}
+		else {
+			if (retCode == ERROR_NO_MORE_ITEMS)
+				success = 1;
+			break;
+		}
+	}
+done:
+	if (data)
+		free(data);
+	if (root)
+		RegCloseKey(root);
+	if (sub)
+		RegCloseKey(sub);
+	return success ? 0 : -1;
+}
+
+/*
+ * in user_root sub tree under key_name key
+ * check whether sub_key_name sub key exists
+ */
+static int
+is_reg_sub_key_exists(HKEY user_root, wchar_t const* key_name, char const* sub_key_name) {
+	int rv = 0;
+	HKEY root = 0, sub = 0;
+
+	if (RegOpenKeyExW(user_root, key_name, 0, STANDARD_RIGHTS_READ | KEY_WOW64_64KEY, &root) != 0 ||
+		RegOpenKeyExA(root, sub_key_name, 0, STANDARD_RIGHTS_READ | KEY_WOW64_64KEY, &sub) != 0 || !sub) {
+		rv = 0;
+		goto done;
+	}
+
+	rv = 1;
+done:
+	if (root)
+		RegCloseKey(root);
+	return rv;
+}
+
+#define REG_KEY_SDDL L"D:P(A;; GA;;; SY)(A;; GA;;; BA)"
+
+int
+process_unsupported_request(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con)
+{
+	int r = 0;
+	debug("ssh protocol 1 is not supported");
+	if (sshbuf_put_u8(response, SSH_AGENT_FAILURE) != 0)
+		r = -1;
+	return r;
+}
+
+static int
+parse_key_constraint_extension(struct sshbuf *m)
+{
+	char *ext_name = NULL, *skprovider = NULL;
+	int r;
+
+	if ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {
+		error_fr(r, "parse constraint extension");
+		goto out;
+	}
+	debug_f("constraint ext %s", ext_name);
+	if (strcmp(ext_name, "sk-provider@openssh.com") == 0) {
+		if ((r = sshbuf_get_cstring(m, &skprovider, NULL)) != 0) {
+			error_fr(r, "parse %s", ext_name);
+			goto out;
+		}
+		if (strcmp(skprovider, "internal") != 0) {
+			error_f("unsupported sk-provider: %s", skprovider);
+			r = SSH_ERR_FEATURE_UNSUPPORTED;
+			goto out;
+		}
+	} else {
+		error_f("unsupported constraint \"%s\"", ext_name);
+		r = SSH_ERR_FEATURE_UNSUPPORTED;
+		goto out;
+	}
+	/* success */
+	r = 0;
+ out:
+	free(ext_name);
+	return r;
+}
+
+static int
+parse_key_constraints(struct sshbuf *m)
+{
+	int r;
+	u_char ctype;
+
+	while (sshbuf_len(m)) {
+		if ((r = sshbuf_get_u8(m, &ctype)) != 0) {
+			error("get constraint type returned %d", r);
+			return r;
+		}
+		switch (ctype) {
+		case SSH_AGENT_CONSTRAIN_EXTENSION:
+			if ((r = parse_key_constraint_extension(m)) != 0)
+				return r;
+			break;
+		default:
+			error("Unknown constraint %d", ctype);
+			return SSH_ERR_FEATURE_UNSUPPORTED;
+		}
+	}
+
+	return 0;
+}
+
+int
+process_add_identity(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	struct sshkey* key = NULL;
+	int r = 0, blob_len, eblob_len, request_invalid = 0, success = 0;
+	size_t comment_len, pubkey_blob_len;
+	u_char *pubkey_blob = NULL;
+	char *thumbprint = NULL, *comment;
+	const char *blob;
+	char* eblob = NULL;
+	HKEY reg = 0, sub = 0, user_root = 0;
+	SECURITY_ATTRIBUTES sa;
+
+	/* parse input request */
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	blob = sshbuf_ptr(request);
+	if (sshkey_private_deserialize(request, &key) != 0 ||
+	   (blob_len = (sshbuf_ptr(request) - blob) & 0xffffffff) == 0 ||
+	    sshbuf_get_cstring(request, &comment, &comment_len) != 0) {
+		debug("key add request is invalid");
+		request_invalid = 1;
+		goto done;
+	}
+
+	if ((r = parse_key_constraints(request)) != 0) {
+		if (r != SSH_ERR_FEATURE_UNSUPPORTED)
+			request_invalid = 1;
+		goto done;
+	}
+
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+	if ((!ConvertStringSecurityDescriptorToSecurityDescriptorW(REG_KEY_SDDL, SDDL_REVISION_1, &sa.lpSecurityDescriptor, &sa.nLength)) ||
+	    sshkey_to_blob(key, &pubkey_blob, &pubkey_blob_len) != 0 ||
+	    convert_blob(con, blob, blob_len, &eblob, &eblob_len, 1) != 0 ||
+	    ((thumbprint = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL) ||
+	    get_user_root(con, &user_root) != 0 ||
+	    RegCreateKeyExW(user_root, SSH_KEYS_ROOT, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &reg, NULL) != 0 ||
+	    RegCreateKeyExA(reg, thumbprint, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &sub, NULL) != 0 ||
+	    RegSetValueExW(sub, NULL, 0, REG_BINARY, eblob, eblob_len) != 0 ||
+	    RegSetValueExW(sub, L"pub", 0, REG_BINARY, pubkey_blob, (DWORD)pubkey_blob_len) != 0 ||
+	    RegSetValueExW(sub, L"type", 0, REG_DWORD, (BYTE*)&key->type, 4) != 0 ||
+	    RegSetValueExW(sub, L"comment", 0, REG_BINARY, comment, (DWORD)comment_len) != 0 ) {
+		error("failed to add key to store");
+		goto done;
+	}
+
+	debug("added key to store");
+	success = 1;
+done:
+	r = 0;
+	if (request_invalid)
+		r = -1;
+	else if (sshbuf_put_u8(response, success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE) != 0)
+		r = -1;
+
+	/* delete created reg key if not succeeded*/
+	if ((success == 0) && reg && thumbprint)
+		RegDeleteKeyExA(reg, thumbprint, KEY_WOW64_64KEY, 0);
+
+	if (eblob)
+		free(eblob);
+	if (sa.lpSecurityDescriptor)
+		LocalFree(sa.lpSecurityDescriptor);
+	if (key)
+		sshkey_free(key);
+	if (thumbprint)
+		free(thumbprint);
+	if (user_root)
+		RegCloseKey(user_root);
+	if (reg)
+		RegCloseKey(reg);
+	if (sub)
+		RegCloseKey(sub);
+	if (pubkey_blob)
+		free(pubkey_blob);
+	return r;
+}
+
+static int sign_blob(const struct sshkey *pubkey, u_char ** sig, size_t *siglen,
+	const u_char *blob, size_t blen, u_int flags, struct agent_connection* con) 
+{
+	HKEY reg = 0, sub = 0, user_root = 0;
+	int r = 0, success = 0;
+	struct sshkey* prikey = NULL;
+	char *thumbprint = NULL, *regdata = NULL, *algo = NULL;
+	DWORD regdatalen = 0, keyblob_len = 0;
+	struct sshbuf* tmpbuf = NULL;
+	char *keyblob = NULL;
+	const char *sk_provider = NULL;
+#ifdef ENABLE_PKCS11
+	int is_pkcs11_key = 0;
+#endif /* ENABLE_PKCS11 */
+
+	*sig = NULL;
+	*siglen = 0;
+
+#ifdef ENABLE_PKCS11
+	if ((prikey = lookup_key(pubkey)) == NULL) {
+#endif /* ENABLE_PKCS11 */
+		if ((thumbprint = sshkey_fingerprint(pubkey, SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL ||
+			get_user_root(con, &user_root) != 0 ||
+			RegOpenKeyExW(user_root, SSH_KEYS_ROOT,
+				0, STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_WOW64_64KEY | KEY_ENUMERATE_SUB_KEYS, &reg) != 0 ||
+			RegOpenKeyExA(reg, thumbprint, 0,
+				STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS | KEY_WOW64_64KEY, &sub) != 0 ||
+			RegQueryValueExW(sub, NULL, 0, NULL, NULL, &regdatalen) != ERROR_SUCCESS ||
+			(regdata = malloc(regdatalen)) == NULL ||
+			RegQueryValueExW(sub, NULL, 0, NULL, regdata, &regdatalen) != ERROR_SUCCESS ||
+			convert_blob(con, regdata, regdatalen, &keyblob, &keyblob_len, FALSE) != 0 ||
+			(tmpbuf = sshbuf_from(keyblob, keyblob_len)) == NULL ||
+			sshkey_private_deserialize(tmpbuf, &prikey) != 0) {
+				error("cannot retrieve and deserialize key from registry");
+				goto done;
+			}
+#ifdef ENABLE_PKCS11
+	}
+	else
+		is_pkcs11_key = 1;
+#endif /* ENABLE_PKCS11 */
+	if (flags & SSH_AGENT_RSA_SHA2_256)
+		algo = "rsa-sha2-256";
+	else if (flags & SSH_AGENT_RSA_SHA2_512)
+		algo = "rsa-sha2-512";
+
+	if (sshkey_is_sk(prikey))
+		sk_provider = "internal";
+	if (sshkey_sign(prikey, sig, siglen, blob, blen, algo, sk_provider, NULL, 0) != 0) {
+		error("cannot sign using retrieved key");
+		goto done;
+	}
+
+	success = 1;
+
+done:
+	if (keyblob)
+		free(keyblob);
+	if (regdata)
+		free(regdata);
+	if (tmpbuf)
+		sshbuf_free(tmpbuf);
+#ifdef ENABLE_PKCS11
+	if (!is_pkcs11_key)
+#endif /* ENABLE_PKCS11 */
+		if (prikey)
+			sshkey_free(prikey);
+	if (thumbprint)
+		free(thumbprint);
+	if (user_root)
+		RegCloseKey(user_root);
+	if (reg)
+		RegCloseKey(reg);
+	if (sub)
+		RegCloseKey(sub);
+
+	return success ? 0 : -1;
+}
+
+int
+process_sign_request(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	u_char *blob, *data, *signature = NULL;
+	size_t blen, dlen, slen = 0;
+	u_int flags = 0;
+	int r, request_invalid = 0, success = 0;
+	struct sshkey *key = NULL;
+
+#ifdef ENABLE_PKCS11
+	int i, count = 0, index = 0;;
+	wchar_t sub_name[MAX_KEY_LENGTH];
+	DWORD sub_name_len = MAX_KEY_LENGTH;
+	DWORD pin_len, epin_len, provider_len;
+	char *pin = NULL, *npin = NULL, *epin = NULL, *provider = NULL;
+	HKEY root = 0, sub = 0, user_root = 0;
+	struct sshkey **keys = NULL;
+	SECURITY_ATTRIBUTES sa = { 0, NULL, 0 };
+
+	pkcs11_init(0);
+
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+	if ((!ConvertStringSecurityDescriptorToSecurityDescriptorW(REG_KEY_SDDL, SDDL_REVISION_1, &sa.lpSecurityDescriptor, &sa.nLength)) ||
+		get_user_root(con, &user_root) != 0 ||
+		RegCreateKeyExW(user_root, SSH_PKCS11_PROVIDERS_ROOT, 0, 0, 0, KEY_WRITE | STANDARD_RIGHTS_READ | KEY_ENUMERATE_SUB_KEYS | KEY_WOW64_64KEY, &sa, &root, NULL) != 0) {
+		goto done;
+	}
+
+	while (1) {
+		sub_name_len = MAX_KEY_LENGTH;
+		if (sub) {
+			RegCloseKey(sub);
+			sub = NULL;
+		}
+		if (RegEnumKeyExW(root, index++, sub_name, &sub_name_len, NULL, NULL, NULL, NULL) == 0) {
+			if (RegOpenKeyExW(root, sub_name, 0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &sub) == 0 &&
+				RegQueryValueExW(sub, L"provider", 0, NULL, NULL, &provider_len) == 0 &&
+				RegQueryValueExW(sub, L"pin", 0, NULL, NULL, &epin_len) == 0) {
+				if ((epin = malloc(epin_len + 1)) == NULL ||
+					(provider = malloc(provider_len + 1)) == NULL ||
+					RegQueryValueExW(sub, L"provider", 0, NULL, provider, &provider_len) != 0 ||
+					RegQueryValueExW(sub, L"pin", 0, NULL, epin, &epin_len) != 0)
+					goto done;
+				provider[provider_len] = '\0';
+				epin[epin_len] = '\0';
+				if (convert_blob(con, epin, epin_len, &pin, &pin_len, 0) != 0 ||
+					(npin = realloc(pin, pin_len + 1)) == NULL) {
+					goto done;
+				}
+				pin = npin;
+				pin[pin_len] = '\0';
+				count = pkcs11_add_provider(provider, pin, &keys, NULL);
+				for (i = 0; i < count; i++) {
+					add_key(keys[i], provider);
+				}
+				free(keys);
+				if (provider)
+					free(provider);
+				if (pin) {
+					SecureZeroMemory(pin, (DWORD)pin_len);
+					free(pin);
+				}
+				if (epin) {
+					SecureZeroMemory(epin, (DWORD)epin_len);
+					free(epin);
+				}
+				provider = NULL;
+				pin = NULL;
+				epin = NULL;
+			}
+		}
+		else
+			break;
+	}
+#endif /* ENABLE_PKCS11 */
+
+	if (sshbuf_get_string_direct(request, &blob, &blen) != 0 ||
+	    sshbuf_get_string_direct(request, &data, &dlen) != 0 ||
+	    sshbuf_get_u32(request, &flags) != 0 ||
+	    sshkey_from_blob(blob, blen, &key) != 0) {
+		debug("sign request is invalid");
+		request_invalid = 1;
+		goto done;
+	}
+
+	if (sign_blob(key, &signature, &slen, data, dlen, flags, con) != 0)
+		goto done;
+
+	success = 1;
+done:
+	r = 0;
+	if (request_invalid)
+		r = -1;
+	else {
+		if (success) {
+			if (sshbuf_put_u8(response, SSH2_AGENT_SIGN_RESPONSE) != 0 ||
+			    sshbuf_put_string(response, signature, slen) != 0) {
+				r = -1;
+			}
+		} else if (sshbuf_put_u8(response, SSH_AGENT_FAILURE) != 0)
+				r = -1;
+	}
+
+	if (key)
+		sshkey_free(key);
+	if (signature)
+		free(signature);
+#ifdef ENABLE_PKCS11
+	del_all_keys();
+	pkcs11_terminate();
+	if (provider)
+		free(provider);
+	if (pin) {
+		SecureZeroMemory(pin, (DWORD)pin_len);
+		free(pin);
+	}
+	if (epin) {
+		SecureZeroMemory(epin, (DWORD)epin_len);
+		free(epin);
+	}
+	if (user_root)
+		RegCloseKey(user_root);
+	if (root)
+		RegCloseKey(root);
+	if (sub)
+		RegCloseKey(sub);
+#endif /* ENABLE_PKCS11 */
+	return r;
+}
+
+int
+process_remove_key(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	HKEY user_root = 0, root = 0;
+	char *blob, *thumbprint = NULL;
+	size_t blen;
+	int r = 0, success = 0, request_invalid = 0;
+	struct sshkey *key = NULL;
+
+	if (sshbuf_get_string_direct(request, &blob, &blen) != 0 ||
+	    sshkey_from_blob(blob, blen, &key) != 0) { 
+		request_invalid = 1;
+		goto done;
+	}
+
+	if ((thumbprint = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL ||
+	    get_user_root(con, &user_root) != 0 ||
+	    RegOpenKeyExW(user_root, SSH_KEYS_ROOT, 0,
+		DELETE | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WOW64_64KEY, &root) != 0 ||
+	    RegDeleteTreeA(root, thumbprint) != 0)
+		goto done;
+	success = 1;
+done:
+	r = 0;
+	if (request_invalid)
+		r = -1;
+	else if (sshbuf_put_u8(response, success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE) != 0)
+		r = -1;
+
+	if (key)
+		sshkey_free(key);
+	if (user_root)
+		RegCloseKey(user_root);
+	if (root)
+		RegCloseKey(root);
+	if (thumbprint)
+		free(thumbprint);
+	return r;
+}
+int 
+process_remove_all(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	HKEY user_root = 0, root = 0;
+	int r = 0;
+
+	if (get_user_root(con, &user_root) != 0 ||
+	    RegOpenKeyExW(user_root, SSH_AGENT_ROOT, 0,
+		   DELETE | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WOW64_64KEY, &root) != 0) {
+		goto done;
+	}
+
+	RegDeleteTreeW(root, SSH_KEYS_KEY);
+	RegDeleteTreeW(root, SSH_PKCS11_PROVIDERS_KEY);
+done:
+	r = 0;
+	if (sshbuf_put_u8(response, SSH_AGENT_SUCCESS) != 0)
+		r = -1;
+
+	if (user_root)
+		RegCloseKey(user_root);
+	if (root)
+		RegCloseKey(root);
+	return r;
+}
+
+#ifdef ENABLE_PKCS11
+int process_add_smartcard_key(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con)
+{
+	char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];
+	int i, count = 0, r = 0, request_invalid = 0, success = 0;
+	struct sshkey **keys = NULL;
+	struct sshkey* key = NULL;
+	size_t pubkey_blob_len, provider_len, pin_len, epin_len;
+	u_char *pubkey_blob = NULL;
+	char *thumbprint = NULL;
+	char *epin = NULL;
+	HKEY reg = 0, sub = 0, user_root = 0;
+	SECURITY_ATTRIBUTES sa = { 0, NULL, 0 };
+
+	pkcs11_init(0);
+
+	if ((r = sshbuf_get_cstring(request, &provider, &provider_len)) != 0 ||
+		(r = sshbuf_get_cstring(request, &pin, &pin_len)) != 0 ||
+		pin_len > 256) {
+		error("add smartcard request is invalid");
+		request_invalid = 1;
+		goto done;
+	}
+
+	if (con->nsession_ids != 0 && !remote_add_provider) {
+		verbose("failed PKCS#11 add of \"%.100s\": remote addition of "
+		    "providers is disabled", provider);
+		goto done;
+	}
+	
+	if (realpath(provider, canonical_provider) == NULL) {
+		error("failed PKCS#11 add of \"%.100s\": realpath: %s",
+			provider, strerror(errno));
+		request_invalid = 1;
+		goto done;
+	}
+
+	// Remove 'drive root' if exists
+	if (canonical_provider[0] == '/')
+		memmove(canonical_provider, canonical_provider + 1, strlen(canonical_provider));
+
+	count = pkcs11_add_provider(canonical_provider, pin, &keys, NULL);
+	if (count <= 0) {
+		error_f("failed to add key to store. count:%d", count);
+		goto done;
+	}
+
+	// If HKCU registry already has the provider then remove the provider and associated keys.
+	// This allows customers to add new keys.
+	if (get_user_root(con, &user_root) != 0 ||
+		is_reg_sub_key_exists(user_root, SSH_PKCS11_PROVIDERS_ROOT, canonical_provider)) {
+		remove_matching_subkeys_from_registry(user_root, SSH_KEYS_ROOT, L"comment", canonical_provider);
+		remove_matching_subkeys_from_registry(user_root, SSH_PKCS11_PROVIDERS_ROOT, L"provider", canonical_provider);
+	}
+
+	for (i = 0; i < count; i++) {
+		key = keys[i];
+		if (sa.lpSecurityDescriptor)
+			LocalFree(sa.lpSecurityDescriptor);
+		if (reg) {
+			RegCloseKey(reg);
+			reg = NULL;
+		}
+		if (sub) {
+			RegCloseKey(sub);
+			sub = NULL;
+		}
+		memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+		sa.nLength = sizeof(sa);
+		if ((!ConvertStringSecurityDescriptorToSecurityDescriptorW(REG_KEY_SDDL, SDDL_REVISION_1, &sa.lpSecurityDescriptor, &sa.nLength)) ||
+			sshkey_to_blob(key, &pubkey_blob, &pubkey_blob_len) != 0 ||
+			((thumbprint = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL) ||
+			RegCreateKeyExW(user_root, SSH_KEYS_ROOT, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &reg, NULL) != 0 ||
+			RegCreateKeyExA(reg, thumbprint, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &sub, NULL) != 0 ||
+			RegSetValueExW(sub, NULL, 0, REG_BINARY, pubkey_blob, (DWORD)pubkey_blob_len) != 0 ||
+			RegSetValueExW(sub, L"pub", 0, REG_BINARY, pubkey_blob, (DWORD)pubkey_blob_len) != 0 ||
+			RegSetValueExW(sub, L"type", 0, REG_DWORD, (BYTE*)&key->type, 4) != 0 ||
+			RegSetValueExW(sub, L"comment", 0, REG_BINARY, canonical_provider, (DWORD)strlen(canonical_provider)) != 0) {
+			error_f("failed to add key to store");
+			goto done;
+		}
+	}
+
+	debug("added smartcard keys to store");
+
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+	if ((!ConvertStringSecurityDescriptorToSecurityDescriptorW(REG_KEY_SDDL, SDDL_REVISION_1, &sa.lpSecurityDescriptor, &sa.nLength)) ||
+		convert_blob(con, pin, (DWORD)pin_len, &epin, (DWORD*)&epin_len, 1) != 0 ||
+		RegCreateKeyExW(user_root, SSH_PKCS11_PROVIDERS_ROOT, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &reg, NULL) != 0 ||
+		RegCreateKeyExA(reg, canonical_provider, 0, 0, 0, KEY_WRITE | KEY_WOW64_64KEY, &sa, &sub, NULL) != 0 ||
+		RegSetValueExW(sub, L"provider", 0, REG_BINARY, canonical_provider, (DWORD)strlen(canonical_provider)) != 0 ||
+		RegSetValueExW(sub, L"pin", 0, REG_BINARY, epin, (DWORD)epin_len) != 0) {
+		error("failed to add pkcs11 provider to store");
+		goto done;
+	}
+
+	debug("added pkcs11 provider to store");
+	success = 1;
+done:
+	r = 0;
+	if (request_invalid)
+		r = -1;
+	else if (sshbuf_put_u8(response, success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE) != 0)
+		r = -1;
+
+	/* delete created reg keys if not succeeded*/
+	if ((success == 0) && reg) {
+		if (thumbprint)
+			RegDeleteKeyExA(reg, thumbprint, KEY_WOW64_64KEY, 0);
+		if (canonical_provider)
+			RegDeleteKeyExA(reg, canonical_provider, KEY_WOW64_64KEY, 0);
+	}
+
+	pkcs11_terminate();
+
+	if (sa.lpSecurityDescriptor)
+		LocalFree(sa.lpSecurityDescriptor);
+	for (i = 0; i < count; i++)
+		sshkey_free(keys[i]);
+	if (keys)
+		free(keys);
+	if (thumbprint)
+		free(thumbprint);
+	if (pubkey_blob)
+		free(pubkey_blob);
+	if (provider)
+		free(provider);
+	if (pin) {
+		SecureZeroMemory(pin, (DWORD)pin_len);
+		free(pin);
+	}
+	if (epin) {
+		SecureZeroMemory(epin, (DWORD)epin_len);
+		free(epin);
+	}
+	if (user_root)
+		RegCloseKey(user_root);
+	if (reg)
+		RegCloseKey(reg);
+	if (sub)
+		RegCloseKey(sub);
+	return r;
+}
+
+int process_remove_smartcard_key(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con)
+{
+	char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX];
+	int r = 0, request_invalid = 0, success = 0, index = 0;
+	HKEY user_root = 0;
+
+	if ((r = sshbuf_get_cstring(request, &provider, NULL)) != 0 ||
+		(r = sshbuf_get_cstring(request, &pin, NULL)) != 0) {
+		error("remove smartcard request is invalid");
+		request_invalid = 1;
+		goto done;
+	}
+
+	if (realpath(provider, canonical_provider) == NULL) {
+		error("failed PKCS#11 add of \"%.100s\": realpath: %s",
+			provider, strerror(errno));
+		request_invalid = 1;
+		goto done;
+	}
+
+	// Remove 'drive root' if exists
+	if (canonical_provider[0] == '/')
+		memmove(canonical_provider, canonical_provider + 1, strlen(canonical_provider));
+
+	if (get_user_root(con, &user_root) != 0 ||
+		!is_reg_sub_key_exists(user_root, SSH_PKCS11_PROVIDERS_ROOT, canonical_provider))
+		goto done;
+
+	if (remove_matching_subkeys_from_registry(user_root, SSH_KEYS_ROOT, L"comment", canonical_provider) != 0 ||
+		remove_matching_subkeys_from_registry(user_root, SSH_PKCS11_PROVIDERS_ROOT, L"provider", canonical_provider) != 0) {
+		goto done;
+	}
+
+	success = 1;
+done:
+	r = 0;
+	if (request_invalid)
+		r = -1;
+	else if (sshbuf_put_u8(response, success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE) != 0)
+		r = -1;
+	if (provider)
+		free(provider);
+	if (pin)
+		free(pin);
+	if (user_root)
+		RegCloseKey(user_root);
+	return r;
+}
+#endif /* ENABLE_PKCS11 */
+
+int
+process_request_identities(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	int count = 0, index = 0, success = 0, r = 0;
+	HKEY root = NULL, sub = NULL, user_root = 0;
+	char* count_ptr = NULL;
+	wchar_t sub_name[MAX_KEY_LENGTH];
+	DWORD sub_name_len = MAX_KEY_LENGTH;
+	char *pkblob = NULL, *comment = NULL;
+	DWORD regdatalen = 0, commentlen = 0, key_count = 0;
+	struct sshbuf* identities;
+
+	if ((identities = sshbuf_new()) == NULL)
+		goto done;
+
+	if ( get_user_root(con, &user_root) != 0 ||
+	    RegOpenKeyExW(user_root, SSH_KEYS_ROOT, 0, STANDARD_RIGHTS_READ | KEY_ENUMERATE_SUB_KEYS | KEY_WOW64_64KEY, &root) != 0) {
+		success = 1;
+		goto done;
+	}
+
+	while (1) {
+		sub_name_len = MAX_KEY_LENGTH;
+		if (sub) {
+			RegCloseKey(sub);
+			sub = NULL;
+		}
+		if (RegEnumKeyExW(root, index++, sub_name, &sub_name_len, NULL, NULL, NULL, NULL) == 0) {
+			if (RegOpenKeyExW(root, sub_name, 0, KEY_QUERY_VALUE | KEY_WOW64_64KEY, &sub) == 0 &&
+				RegQueryValueExW(sub, L"pub", 0, NULL, NULL, &regdatalen) == 0 &&
+				RegQueryValueExW(sub, L"comment", 0, NULL, NULL, &commentlen) == 0) {
+				if (pkblob)
+					free(pkblob);
+				if (comment)
+					free(comment);
+				pkblob = NULL;
+				comment = NULL;
+
+				if ((pkblob = malloc(regdatalen)) == NULL ||
+					(comment = malloc(commentlen)) == NULL ||
+					RegQueryValueExW(sub, L"pub", 0, NULL, pkblob, &regdatalen) != 0 ||
+					RegQueryValueExW(sub, L"comment", 0, NULL, comment, &commentlen) != 0 ||
+					sshbuf_put_string(identities, pkblob, regdatalen) != 0 ||
+					sshbuf_put_string(identities, comment, commentlen) != 0)
+					goto done;
+
+				key_count++;
+			}
+		} else
+			break;
+
+	}
+
+	success = 1;
+done:
+	r = 0;
+	if (success) {
+		if (sshbuf_put_u8(response, SSH2_AGENT_IDENTITIES_ANSWER) != 0 ||
+			sshbuf_put_u32(response, key_count) != 0 ||
+			sshbuf_putb(response, identities) != 0)
+			goto done;
+	} else
+		r = -1;
+
+	if (pkblob)
+		free(pkblob);
+	if (comment)
+		free(comment);
+	if (identities)
+		sshbuf_free(identities);
+	if (user_root)
+		RegCloseKey(user_root);
+	if (root)
+		RegCloseKey(root);
+	if (sub)
+		RegCloseKey(sub);
+	return r;
+}
+
+extern int timingsafe_bcmp(const void* b1, const void* b2, size_t n);
+
+static int
+buf_equal(const struct sshbuf *a, const struct sshbuf *b)
+{
+	if (sshbuf_ptr(a) == NULL || sshbuf_ptr(b) == NULL)
+		return SSH_ERR_INVALID_ARGUMENT;
+	if (sshbuf_len(a) != sshbuf_len(b))
+		return SSH_ERR_INVALID_FORMAT;
+	if (timingsafe_bcmp(sshbuf_ptr(a), sshbuf_ptr(b), sshbuf_len(a)) != 0)
+		return SSH_ERR_INVALID_FORMAT;
+	return 0;
+}
+
+static int
+process_ext_session_bind(struct sshbuf* request, struct agent_connection* con)
+{
+	int r, sid_match, key_match;
+	struct sshkey *key = NULL;
+	struct sshbuf *sid = NULL, *sig = NULL;
+	char *fp = NULL;
+	size_t i;
+	u_char fwd = 0;
+
+	debug2_f("entering");
+	if ((r = sshkey_froms(request, &key)) != 0 ||
+	    (r = sshbuf_froms(request, &sid)) != 0 ||
+	    (r = sshbuf_froms(request, &sig)) != 0 ||
+	    (r = sshbuf_get_u8(request, &fwd)) != 0) {
+		error_fr(r, "parse");
+		goto out;
+	}
+	if ((fp = sshkey_fingerprint(key, SSH_FP_HASH_DEFAULT,
+	    SSH_FP_DEFAULT)) == NULL)
+		fatal_f("fingerprint failed");
+	/* check signature with hostkey on session ID */
+	if ((r = sshkey_verify(key, sshbuf_ptr(sig), sshbuf_len(sig),
+	    sshbuf_ptr(sid), sshbuf_len(sid), NULL, 0, NULL)) != 0) {
+		error_fr(r, "sshkey_verify for %s %s", sshkey_type(key), fp);
+		goto out;
+	}
+	/* check whether sid/key already recorded */
+	for (i = 0; i < con->nsession_ids; i++) {
+		if (!con->session_ids[i].forwarded) {
+			error_f("attempt to bind session ID to socket "
+			    "previously bound for authentication attempt");
+			r = -1;
+			goto out;
+		}
+		sid_match = buf_equal(sid, con->session_ids[i].sid) == 0;
+		key_match = sshkey_equal(key, con->session_ids[i].key);
+		if (sid_match && key_match) {
+			debug_f("session ID already recorded for %s %s",
+			    sshkey_type(key), fp);
+			r = 0;
+			goto out;
+		} else if (sid_match) {
+			error_f("session ID recorded against different key "
+			    "for %s %s", sshkey_type(key), fp);
+			r = -1;
+			goto out;
+		}
+		/*
+		 * new sid with previously-seen key can happen, e.g. multiple
+		 * connections to the same host.
+		 */
+	}
+	/* record new key/sid */
+	if (con->nsession_ids >= AGENT_MAX_SESSION_IDS) {
+		error_f("too many session IDs recorded");
+		goto out;
+	}
+	con->session_ids = xrecallocarray(con->session_ids, con->nsession_ids,
+	    con->nsession_ids + 1, sizeof(*con->session_ids));
+	i = con->nsession_ids++;
+	debug_f("recorded %s %s (slot %zu of %d)", sshkey_type(key), fp, i,
+	    AGENT_MAX_SESSION_IDS);
+	con->session_ids[i].key = key;
+	con->session_ids[i].forwarded = fwd != 0;
+	key = NULL; /* transferred */
+	/* can't transfer sid; it's refcounted and scoped to request's life */
+	if ((con->session_ids[i].sid = sshbuf_new()) == NULL)
+		fatal_f("sshbuf_new");
+	if ((r = sshbuf_putb(con->session_ids[i].sid, sid)) != 0)
+		fatal_fr(r, "sshbuf_putb session ID");
+	/* success */
+	r = 0;
+ out:
+	sshkey_free(key);
+	sshbuf_free(sid);
+	sshbuf_free(sig);
+	return r == 0 ? 1 : 0;
+}
+
+int
+process_extension(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con)
+{
+	int r, success = 0;
+	char *name;
+
+	debug2_f("entering");
+	if ((r = sshbuf_get_cstring(request, &name, NULL)) != 0) {
+		error_fr(r, "parse");
+		goto send;
+	}
+	if (strcmp(name, "session-bind@openssh.com") == 0)
+		success = process_ext_session_bind(request, con);
+	else
+		debug_f("unsupported extension \"%s\"", name);
+	free(name);
+send:
+	if ((r = sshbuf_put_u32(response, 1) != 0) ||
+		((r = sshbuf_put_u8(response, success ? SSH_AGENT_SUCCESS : SSH_AGENT_FAILURE)) != 0))
+		fatal_fr(r, "compose");
+
+	r = success ? 0 : -1;
+	
+	return r;
+}
+
+#if 0
+int process_keyagent_request(struct sshbuf* request, struct sshbuf* response, struct agent_connection* con) 
+{
+	u_char type;
+
+	if (sshbuf_get_u8(request, &type) != 0)
+		return -1;
+	debug2("process key agent request type %d", type);
+
+	switch (type) {
+	case SSH2_AGENTC_ADD_IDENTITY:
+		return process_add_identity(request, response, con);
+	case SSH2_AGENTC_REQUEST_IDENTITIES:
+		return process_request_identities(request, response, con);
+	case SSH2_AGENTC_SIGN_REQUEST:
+		return process_sign_request(request, response, con);
+	case SSH2_AGENTC_REMOVE_IDENTITY:
+		return process_remove_key(request, response, con);
+	case SSH2_AGENTC_REMOVE_ALL_IDENTITIES:
+		return process_remove_all(request, response, con);
+#ifdef ENABLE_PKCS11
+	case SSH_AGENTC_ADD_SMARTCARD_KEY:
+		return process_add_smartcard_key(request, response, con);
+	case SSH_AGENTC_ADD_SMARTCARD_KEY_CONSTRAINED:
+		return process_add_smartcard_key(request, response, con);
+	case SSH_AGENTC_REMOVE_SMARTCARD_KEY:
+		return process_remove_smartcard_key(request, response, con);
+		break;
+#endif /* ENABLE_PKCS11 */
+	default:
+		debug("unknown key agent request %d", type);
+		return -1;		
+	}
+}
+#endif
+
+#pragma warning(pop)
diff --git a/contrib/win32/win32compat/ssh_config/ssh_config b/contrib/win32/win32compat/ssh_config/ssh_config
new file mode 100644
index 000000000..42d6699b1
--- /dev/null
+++ b/contrib/win32/win32compat/ssh_config/ssh_config
@@ -0,0 +1,50 @@
+#	$OpenBSD: ssh_config,v 1.26 2010/01/11 01:39:46 dtucker Exp $
+
+# This is the ssh client system-wide configuration file.  See
+# ssh_config(5) for more information.  This file provides defaults for
+# users, and the values can be changed in per-user configuration files
+# or on the command line.
+
+# Configuration data is parsed as follows:
+#  1. command line options
+#  2. user-specific file
+#  3. system-wide file
+# Any configuration value is only changed the first time it is set.
+# Thus, host-specific definitions should be at the beginning of the
+# configuration file, and defaults at the end.
+
+# Site-wide defaults for some commonly used options.  For a comprehensive
+# list of available options, their meanings and defaults, please see the
+# ssh_config(5) man page.
+
+# Host *
+#   ForwardAgent no
+#   ForwardX11 no
+#   RhostsRSAAuthentication no
+#   RSAAuthentication yes
+#   PasswordAuthentication yes
+#   HostbasedAuthentication no
+#   GSSAPIAuthentication no
+#   GSSAPIDelegateCredentials no
+#   BatchMode no
+#   CheckHostIP yes
+#   AddressFamily any
+#   ConnectTimeout 0
+#   StrictHostKeyChecking ask
+#   IdentityFile ~/.ssh/identity
+#   IdentityFile ~/.ssh/id_rsa
+#   IdentityFile ~/.ssh/id_dsa
+#   Port 22
+#   Protocol 2,1
+#   Cipher 3des
+#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc
+#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160
+#   EscapeChar ~
+#   Tunnel no
+#   TunnelDevice any:any
+#   PermitLocalCommand no
+#   VisualHostKey no
+#   ProxyCommand ssh -q -W %h:%p gateway.example.com
+#UsePrivilegeSeparation no
+PubkeyAcceptedKeyTypes ssh-ed25519*,ssh-rsa*,ssh-dss*,ecdsa-sha2*
+
diff --git a/contrib/win32/win32compat/ssh_config/sshd_config b/contrib/win32/win32compat/ssh_config/sshd_config
new file mode 100644
index 000000000..5b9152606
--- /dev/null
+++ b/contrib/win32/win32compat/ssh_config/sshd_config
@@ -0,0 +1,122 @@
+#	$OpenBSD: sshd_config,v 1.84 2011/05/23 03:30:07 djm Exp $
+
+# This is the sshd server system-wide configuration file.  See
+# sshd_config(5) for more information.
+
+# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin
+
+# The strategy used for options in the default sshd_config shipped with
+# OpenSSH is to specify options with their default value where
+# possible, but leave them commented.  Uncommented options override the
+# default value.
+
+#Port 22
+#AddressFamily any
+#ListenAddress 0.0.0.0
+#ListenAddress ::
+
+# The default requires explicit activation of protocol 1
+#Protocol 2
+
+# HostKey for protocol version 1
+#HostKey /etc/ssh/ssh_host_key
+# HostKeys for protocol version 2
+#HostKey /etc/ssh/ssh_host_rsa_key
+#HostKey /etc/ssh/ssh_host_dsa_key
+#HostKey /etc/ssh/ssh_host_ecdsa_key
+
+# Lifetime and size of ephemeral version 1 server key
+#KeyRegenerationInterval 1h
+#ServerKeyBits 1024
+
+# Logging
+# obsoletes QuietMode and FascistLogging
+#SyslogFacility AUTH
+#LogLevel INFO
+
+# Authentication:
+
+#LoginGraceTime 2m
+#PermitRootLogin yes
+#StrictModes yes
+#MaxAuthTries 6
+#MaxSessions 10
+
+#RSAAuthentication yes
+#PubkeyAuthentication yes
+
+# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
+# but this is overridden so installations will only check .ssh/authorized_keys
+AuthorizedKeysFile	.ssh/authorized_keys
+
+# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
+#RhostsRSAAuthentication no
+# similar for protocol version 2
+#HostbasedAuthentication no
+# Change to yes if you don't trust ~/.ssh/known_hosts for
+# RhostsRSAAuthentication and HostbasedAuthentication
+#IgnoreUserKnownHosts no
+# Don't read the user's ~/.rhosts and ~/.shosts files
+#IgnoreRhosts yes
+
+# To disable tunneled clear text passwords, change to no here!
+#PasswordAuthentication yes
+#PermitEmptyPasswords no
+
+# Change to no to disable s/key passwords
+#ChallengeResponseAuthentication yes
+
+# Kerberos options
+#KerberosAuthentication no
+#KerberosOrLocalPasswd yes
+#KerberosTicketCleanup yes
+#KerberosGetAFSToken no
+
+# GSSAPI options
+#GSSAPIAuthentication no
+#GSSAPICleanupCredentials yes
+
+# Set this to 'yes' to enable PAM authentication, account processing, 
+# and session processing. If this is enabled, PAM authentication will 
+# be allowed through the ChallengeResponseAuthentication and
+# PasswordAuthentication.  Depending on your PAM configuration,
+# PAM authentication via ChallengeResponseAuthentication may bypass
+# the setting of "PermitRootLogin without-password".
+# If you just want the PAM account and session checks to run without
+# PAM authentication, then enable this but set PasswordAuthentication
+# and ChallengeResponseAuthentication to 'no'.
+#UsePAM no
+
+#AllowAgentForwarding yes
+#AllowTcpForwarding yes
+#GatewayPorts no
+#X11Forwarding no
+#X11DisplayOffset 10
+#X11UseLocalhost yes
+#PrintMotd yes
+#PrintLastLog yes
+#TCPKeepAlive yes
+#UseLogin no
+#UsePrivilegeSeparation yes
+#PermitUserEnvironment no
+#Compression delayed
+#ClientAliveInterval 0
+#ClientAliveCountMax 3
+#UseDNS yes
+#PidFile /var/run/sshd.pid
+#MaxStartups 10
+#PermitTunnel no
+#ChrootDirectory none
+
+# no default banner path
+#Banner none
+
+# override default of no subsystems
+#Subsystem	sftp	/usr/libexec/sftp-server
+Subsystem	sftp	/win32openssh/bin/sftp-server.exe
+
+# Example of overriding settings on a per-user basis
+#Match User anoncvs
+#	X11Forwarding no
+#	AllowTcpForwarding no
+#	ForceCommand cvs server
diff --git a/contrib/win32/win32compat/termio.c b/contrib/win32/win32compat/termio.c
new file mode 100644
index 000000000..f59bd95e0
--- /dev/null
+++ b/contrib/win32/win32compat/termio.c
@@ -0,0 +1,311 @@
+/*
+ * Author: Manoj Ampalam <manojamp@microsoft.com>
+ *  read() and write() on tty using worker threads to handle 
+ *  synchronous Windows Console IO
+ * 
+ * Author: Ray Hayes <ray.hayes@microsoft.com>
+ *  TTY/PTY support added by capturing all terminal input events
+ *
+ * Author: Balu <bagajjal@microsoft.com>
+ *  Misc fixes and code cleanup
+ *
+ * Author: Manoj Ampalam <manojamp@microsoft.com>
+ *  Extended support to other Windows IO that does not support 
+ *  overlapped IO. Ex. pipe handles returned by CreatePipe()
+ * 
+ * Copyright (c) 2017 Microsoft Corp.
+ * All rights reserved
+ *
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <Windows.h>
+#include <process.h>
+#include "w32fd.h"
+#include "tncon.h"
+#include "inc\utf.h"
+#include "debug.h"
+#include "tnnet.h"
+#include "misc_internal.h"
+
+#define TERM_IO_BUF_SIZE 2048
+
+extern int in_raw_mode;
+BOOL isFirstTime = TRUE;
+
+/* APC that gets queued on main thread when a sync Read completes on worker thread */
+static VOID CALLBACK
+ReadAPCProc(_In_ ULONG_PTR dwParam)
+{
+	struct w32_io* pio = (struct w32_io*)dwParam;
+	debug5("TermRead CB - io:%p, bytes: %d, pending: %d, error: %d", pio, pio->read_details.completed,
+		pio->read_details.pending, pio->sync_read_status.error);
+	pio->read_details.error = pio->sync_read_status.error;
+	pio->read_details.remaining = pio->sync_read_status.transferred;
+	pio->read_details.completed = 0;
+	pio->read_details.pending = FALSE;
+	WaitForSingleObject(pio->read_overlapped.hEvent, INFINITE);
+	CloseHandle(pio->read_overlapped.hEvent);
+	pio->read_overlapped.hEvent = 0;
+}
+
+/* Read worker thread */
+static unsigned __stdcall
+ReadThread(_In_ LPVOID lpParameter)
+{
+	int nBytesReturned = 0;
+	struct w32_io* pio = (struct w32_io*)lpParameter;
+
+	debug5("TermRead thread, io:%p", pio);
+	memset(&pio->sync_read_status, 0, sizeof(pio->sync_read_status));
+	if (FILETYPE(pio) == FILE_TYPE_CHAR) {
+		if (in_raw_mode) {
+			while (nBytesReturned == 0) {
+				nBytesReturned = ReadConsoleForTermEmul(WINHANDLE(pio),
+					pio->read_details.buf, pio->read_details.buf_size);
+			}
+			pio->sync_read_status.transferred = nBytesReturned;
+		}  else {
+			if (isFirstTime) {
+				isFirstTime = false;
+
+				DWORD dwAttributes;
+				/* open(dev/null) is showing up as FILE_TYPE_CHAR but is not a valid console handle */
+				if (GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &dwAttributes)) {
+					dwAttributes |= (ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT);
+					if (!SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), dwAttributes))
+						debug2("SetConsoleMode on STD_INPUT_HANDLE failed with %d", GetLastError());
+				} else if (GetLastError() != ERROR_INVALID_HANDLE)
+					debug2("GetConsoleMode on STD_INPUT_HANDLE failed with %d", GetLastError());
+
+			}
+
+			if (!ReadFile(WINHANDLE(pio), pio->read_details.buf,
+				pio->read_details.buf_size, &(pio->sync_read_status.transferred), NULL)) {
+				debug4("ReadThread - ReadFile failed, error:%d, io:%p", GetLastError(), pio); 
+				pio->sync_read_status.error = GetLastError();
+				goto done;
+			}
+
+			if (pio->sync_read_status.transferred) {
+				char *p = NULL;
+				if (p = strstr(pio->read_details.buf, "\r\n"))
+					*p++ = '\n';
+				else if (p = strstr(pio->read_details.buf, "\r"))
+					*p++ = '\n';
+
+				if (p) {
+					*p = '\0';
+					pio->sync_read_status.transferred = (DWORD)strlen(pio->read_details.buf);
+				}
+			}
+		}
+	} else {
+		if (!ReadFile(WINHANDLE(pio), pio->read_details.buf,
+		    pio->read_details.buf_size, &(pio->sync_read_status.transferred), NULL)) {
+			debug4("ReadThread - ReadFile failed, error:%d, io:%p", GetLastError(), pio); 
+			pio->sync_read_status.error = GetLastError();
+			goto done;
+		}
+
+		/* If there is no data to be read then set the error to ERROR_HANDLE_EOF */
+		if (!pio->sync_read_status.transferred) {
+			pio->sync_read_status.error = ERROR_HANDLE_EOF;
+		}
+	}
+
+done:
+	if (0 == QueueUserAPC(ReadAPCProc, main_thread, (ULONG_PTR)pio)) {		
+		pio->read_details.pending = FALSE;
+		pio->read_details.error = GetLastError();
+		debug_assert_internal();
+	}
+
+	return 0;
+}
+
+/* Initiates read on tty */
+int
+syncio_initiate_read(struct w32_io* pio)
+{
+	HANDLE read_thread;
+
+	debug5("syncio_initiate_read io:%p", pio);
+	if (pio->read_details.buf_size == 0) {
+		pio->read_details.buf = malloc(TERM_IO_BUF_SIZE);
+		if (pio->read_details.buf == NULL) {
+			errno = ENOMEM;
+			return -1;
+		}
+		pio->read_details.buf_size = TERM_IO_BUF_SIZE;
+	}
+
+	read_thread = (HANDLE) _beginthreadex(NULL, 0, ReadThread, pio, 0, NULL);
+	if (read_thread == NULL) {
+		errno = errno_from_Win32LastError();
+		debug3("TermRead initiate - ERROR _beginthreadex %d, io:%p", GetLastError(), pio);
+		return -1;
+	}
+
+	pio->read_overlapped.hEvent = read_thread;
+	pio->read_details.pending = TRUE;
+	return 0;
+}
+
+/* APC that gets queued on main thread when a sync Write completes on worker thread */
+static VOID CALLBACK 
+WriteAPCProc(_In_ ULONG_PTR dwParam)
+{
+	struct w32_io* pio = (struct w32_io*)dwParam;
+	debug5("TermWrite CB - io:%p, bytes: %d, pending: %d, error: %d", pio, pio->write_details.completed,
+		pio->write_details.pending, pio->sync_write_status.error);
+	pio->write_details.error = pio->sync_write_status.error;
+	pio->write_details.remaining -= pio->sync_write_status.transferred;
+	/* TODO- assert that reamining is 0 by now */
+	pio->write_details.completed = 0;
+	pio->write_details.pending = FALSE;
+	WaitForSingleObject(pio->write_overlapped.hEvent, INFINITE);
+	CloseHandle(pio->write_overlapped.hEvent);
+	pio->write_overlapped.hEvent = 0;
+}
+
+
+/* Write worker thread */
+static unsigned __stdcall
+WriteThread(_In_ LPVOID lpParameter)
+{
+	struct w32_io* pio = (struct w32_io*)lpParameter;
+	char *respbuf = NULL;
+	size_t resplen = 0;	
+	debug5("WriteThread thread, io:%p", pio);
+
+	if (FILETYPE(pio) == FILE_TYPE_CHAR) {
+		pio->write_details.buf[pio->sync_write_status.to_transfer] = '\0';
+		if (0 == in_raw_mode) {
+			wchar_t* t = utf8_to_utf16(pio->write_details.buf);
+			if (t != NULL)
+			{
+				WriteConsoleW(WINHANDLE(pio), t, (DWORD)wcslen(t), 0, 0);
+				free(t);
+			}
+		} else {
+			processBuffer(WINHANDLE(pio), pio->write_details.buf, pio->sync_write_status.to_transfer, &respbuf, &resplen);
+			/* TODO - respbuf is not null in some cases, this needs to be returned back via read stream */
+		}
+		pio->sync_write_status.transferred = pio->sync_write_status.to_transfer;
+	} else {
+		if (!WriteFile(WINHANDLE(pio), pio->write_details.buf, pio->sync_write_status.to_transfer,
+		    &(pio->sync_write_status.transferred), NULL)) {
+			pio->sync_write_status.error = GetLastError();
+			debug4("WriteThread - WriteFile %d, io:%p", GetLastError(), pio);
+		}
+	}
+
+	
+	if (0 == QueueUserAPC(WriteAPCProc, main_thread, (ULONG_PTR)pio)) {
+		error("WriteThread thread - ERROR QueueUserAPC failed %d, io:%p", GetLastError(), pio);
+		pio->write_details.pending = FALSE;
+		pio->write_details.error = GetLastError();
+		debug_assert_internal();
+	}
+
+	return 0;
+}
+
+/* Initiates write on tty */
+int
+syncio_initiate_write(struct w32_io* pio, DWORD num_bytes)
+{
+	HANDLE write_thread;
+	debug5("syncio_initiate_write initiate io:%p", pio);
+	memset(&(pio->sync_write_status), 0, sizeof(pio->sync_write_status));
+	pio->sync_write_status.to_transfer = num_bytes;
+	write_thread = (HANDLE)_beginthreadex(NULL, 0, WriteThread, pio, 0, NULL);
+	if (write_thread == NULL) {
+		errno = errno_from_Win32LastError();
+		debug3("syncio_initiate_write initiate - ERROR _beginthreadex %d, io:%p", GetLastError(), pio);
+		return -1;
+	}
+
+	pio->write_overlapped.hEvent = write_thread;
+	pio->write_details.pending = TRUE;
+	return 0;
+}
+
+static VOID CALLBACK
+InterruptThread(_In_ ULONG_PTR dwParam)
+{
+	_endthreadex(0);
+}
+
+/* close */
+int 
+syncio_close(struct w32_io* pio)
+{
+	debug4("syncio_close - pio:%p", pio);
+
+	/*
+	* Wait for io write operation that is called by worker thread to terminate
+	* to avoid the write operation being terminated prematurely by CancelIoEx.
+	* If you see any process waiting here indefinitely - its because no one
+	* is draining from other end of the pipe. This is an unfortunate
+	* consequence that should otherwise have very little impact on practical
+	* scenarios.
+	*/
+	if (pio->write_details.pending) {
+		WaitForSingleObject(pio->write_overlapped.hEvent, INFINITE);
+
+		/* drain queued APCs */
+		SleepEx(0, TRUE);
+	}
+
+	CancelIoEx(WINHANDLE(pio), NULL);
+
+	/* If io is pending, let worker threads exit. */
+	if (pio->read_details.pending) {
+		/*
+		Terminate the read thread at the below situations:
+		1. For console - the read thread is blocked by the while loop on raw mode
+		2. Function ReadFile on Win7 machine dees not return when no content to read in non-interactive mode.
+		*/
+		if (FILETYPE(pio) == FILE_TYPE_CHAR && (IsWin7OrLess() || in_raw_mode)) {
+			QueueUserAPC(InterruptThread, pio->read_overlapped.hEvent, (ULONG_PTR)NULL);
+			CancelSynchronousIo(pio->read_overlapped.hEvent);
+		}
+
+		WaitForSingleObject(pio->read_overlapped.hEvent, INFINITE);
+	}
+
+	/* drain queued APCs */
+	SleepEx(0, TRUE);
+
+	/* TODO - fix this, closing Console handles is interfering with TTY/PTY rendering */
+	if (FILETYPE(pio) != FILE_TYPE_CHAR)
+		CloseHandle(WINHANDLE(pio));
+	if (pio->read_details.buf)
+		free(pio->read_details.buf);
+	if (pio->write_details.buf)
+		free(pio->write_details.buf);
+	free(pio);
+	return 0;
+}
diff --git a/contrib/win32/win32compat/tncon.c b/contrib/win32/win32compat/tncon.c
new file mode 100644
index 000000000..8b5ec0dea
--- /dev/null
+++ b/contrib/win32/win32compat/tncon.c
@@ -0,0 +1,847 @@
+/*
+* Author: Ray Hayes <ray.hayes@microsoft.com>
+* ANSI TTY Reader - Maps Windows console input events to ANSI stream
+*
+* Author: Balu <bagajjal@microsoft.com>
+* Misc fixes and code cleanup
+*
+* Copyright (c) 2017 Microsoft Corp.
+* All rights reserved
+*
+* This file is responsible for console reading calls for building an emulator
+* over Windows Console.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <windows.h>
+#include "ansiprsr.h"
+#include "tncon.h"
+#include "tnnet.h"
+
+extern bool gbVTAppMode;
+extern BOOL isAnsiParsingRequired;
+extern BOOL isConsoleVTSeqAvailable;
+char *glob_out = NULL;
+int glob_outlen = 0;
+int glob_space = 0;
+unsigned char  NAWSSTR[] = { "\xff\xfa\x1f\x00\x00\x00\x00\xff\xf0" };
+extern int ScreenY;
+extern int ScreenX;
+extern int ScrollTop;
+extern int ScrollBottom;
+unsigned char tmp_buf[30];
+
+/* terminal global switches*/
+TelParams Parameters = {
+	0,		/* int fLogging */
+	NULL,		/* FILE *fplogfile */
+	NULL,		/* char *pInputFile */
+	NULL,		/* char *szDebugInputFile */
+	FALSE,		/* BOOL fDebugWait */
+	0,		/* int timeOut */
+	0,		/* int fLocalEcho */
+	0,		/* int fTreatLFasCRLF */
+	0,		/* int	fSendCROnly */
+	ENUM_LF,	/* int nReceiveCRLF */
+	'`',		/* char sleepChar */
+	'\035',		/* char menuChar; // CTRL-]  */
+	0,		/* SOCKET Socket */
+	FALSE,		/* BOOL bVT100Mode */
+	"\x01",		/* char *pAltKey */
+};
+
+TelParams* pParams = &Parameters;
+
+void queue_terminal_window_change_event();
+void GetVTSeqFromKeyStroke(INPUT_RECORD inputRecord);
+
+/* Write to a global buffer setup by ReadConsoleForTermEmul() */
+int
+WriteToBuffer(char* source, size_t len)
+{
+	while (len > 0) {
+		if (glob_outlen >= glob_space)
+			return glob_outlen;
+		*glob_out++ = *source++;
+		len--;
+		glob_outlen++;
+	}
+	return glob_outlen;
+}
+
+BOOL
+DataAvailable(HANDLE h)
+{
+	DWORD dwRet = WaitForSingleObjectEx(h, INFINITE, TRUE);
+	if (dwRet == WAIT_OBJECT_0)
+		return TRUE;
+	if (dwRet == WAIT_FAILED)
+		return FALSE;
+	return FALSE;
+}
+
+int
+GetModifierKey(DWORD dwControlKeyState)
+{
+	int modKey = 0;
+	if ((dwControlKeyState & LEFT_ALT_PRESSED) || (dwControlKeyState & RIGHT_ALT_PRESSED))
+		modKey += 2;
+
+	if (dwControlKeyState & SHIFT_PRESSED)
+		modKey += 1;
+
+	if ((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED))
+		modKey += 4;
+
+	if (modKey){
+		memset(tmp_buf, 0, sizeof(tmp_buf));
+		modKey++;
+	}		
+
+	return modKey;
+}
+
+int
+ReadConsoleForTermEmul(HANDLE hInput, char *destin, int destinlen)
+{
+	HANDLE hHandle[] = { hInput, NULL };
+	DWORD nHandle = 1;
+	DWORD dwInput = 0;
+	DWORD rc = 0;
+	unsigned char octets[20];
+	char aChar = 0;
+	INPUT_RECORD inputRecordArray[16];
+	int inputRecordArraySize = sizeof(inputRecordArray) / sizeof(INPUT_RECORD);
+	static WCHAR utf16_surrogatepair[2] = {0,};
+	int n = 0;
+
+	glob_out = destin;
+	glob_space = destinlen;
+	glob_outlen = 0;
+	while (DataAvailable(hInput)) {
+		if (glob_outlen >= destinlen)
+			return glob_outlen;
+		ReadConsoleInputW(hInput, inputRecordArray, inputRecordArraySize, &dwInput);
+
+		for (DWORD i=0; i < dwInput; i++) {
+			INPUT_RECORD inputRecord = inputRecordArray[i];
+
+			switch (inputRecord.EventType) {
+			case WINDOW_BUFFER_SIZE_EVENT:
+				queue_terminal_window_change_event();
+				break;
+
+			case FOCUS_EVENT:
+				/* FALLTHROUGH */
+			case MENU_EVENT:
+				break;
+
+			case KEY_EVENT:
+				if ((inputRecord.Event.KeyEvent.bKeyDown) ||
+				    (!inputRecord.Event.KeyEvent.bKeyDown && inputRecord.Event.KeyEvent.wVirtualKeyCode == VK_MENU)) {
+					if (IS_HIGH_SURROGATE(inputRecord.Event.KeyEvent.uChar.UnicodeChar)) {
+						utf16_surrogatepair[0] = inputRecord.Event.KeyEvent.uChar.UnicodeChar;
+						break; // break to read low surrogate.
+					}
+					else if (IS_LOW_SURROGATE(inputRecord.Event.KeyEvent.uChar.UnicodeChar)) {
+						utf16_surrogatepair[1] = inputRecord.Event.KeyEvent.uChar.UnicodeChar;
+					}
+
+					if (utf16_surrogatepair[0] && utf16_surrogatepair[1]) {
+						n = WideCharToMultiByte(
+							CP_UTF8,
+							0,
+							utf16_surrogatepair,
+							2,
+							(LPSTR)octets,
+							20,
+							NULL,
+							NULL);
+
+						WriteToBuffer((char *)octets, n);
+						utf16_surrogatepair[0] = utf16_surrogatepair[1] = L'\0';
+
+						break;
+					}
+
+					if (isConsoleVTSeqAvailable) {
+						if (inputRecord.Event.KeyEvent.uChar.UnicodeChar != L'\0' || inputRecord.Event.KeyEvent.wVirtualScanCode == 0) {
+							n = WideCharToMultiByte(
+								CP_UTF8,
+								0,
+								&(inputRecord.Event.KeyEvent.uChar.UnicodeChar),
+								1,
+								(LPSTR)octets,
+								20,
+								NULL,
+								NULL);
+
+							WriteToBuffer((char *)octets, n);
+						}
+					} else {
+						GetVTSeqFromKeyStroke(inputRecord);
+					}
+				}
+				break;
+			}
+		}
+		break;
+	}
+
+	return glob_outlen;
+}
+
+void
+GetVTSeqFromKeyStroke(INPUT_RECORD inputRecord)
+{
+	unsigned char octets[20];
+	BOOL bCapsOn = FALSE;
+	BOOL bShift = FALSE;
+	int modKey = 0;
+	char *FN_KEY = NULL;
+	char *SHIFT_FN_KEY = NULL;
+	char *ALT_FN_KEY = NULL;
+	char *CTRL_FN_KEY = NULL;
+	char *SHIFT_ALT_FN_KEY = NULL;
+	char *SHIFT_CTRL_FN_KEY = NULL;
+	char *ALT_CTRL_FN_KEY = NULL;
+	char *SHIFT_ALT_CTRL_FN_KEY = NULL;
+	DWORD dwControlKeyState = 0;
+	DWORD dwAltGrFlags = LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED;
+
+	int n = WideCharToMultiByte(
+		CP_UTF8,
+		0,
+		&(inputRecord.Event.KeyEvent.uChar.UnicodeChar),
+		1,
+		(LPSTR)octets,
+		20,
+		NULL,
+		NULL);
+
+	bCapsOn = (inputRecord.Event.KeyEvent.dwControlKeyState & CAPSLOCK_ON);
+	bShift = (inputRecord.Event.KeyEvent.dwControlKeyState & SHIFT_PRESSED);
+	dwControlKeyState = inputRecord.Event.KeyEvent.dwControlKeyState &
+		~(CAPSLOCK_ON | ENHANCED_KEY | NUMLOCK_ON | SCROLLLOCK_ON);
+
+	/* ignore the AltGr flags*/
+	if ((dwControlKeyState & dwAltGrFlags) == dwAltGrFlags)
+		dwControlKeyState = dwControlKeyState & ~dwAltGrFlags;
+
+	modKey = GetModifierKey(dwControlKeyState);
+
+	if (pParams->fLocalEcho)
+		ConWriteString((char *)octets, n);
+
+	switch (inputRecord.Event.KeyEvent.uChar.UnicodeChar) {
+	case 0xd:
+		if (pParams->nReceiveCRLF == ENUM_LF)
+			WriteToBuffer("\r", 1);
+		else
+			WriteToBuffer("\r\n", 2);
+		break;
+
+	case VK_ESCAPE:
+		WriteToBuffer((char *)ESCAPE_KEY, 1);
+		break;
+
+	default:
+		switch (inputRecord.Event.KeyEvent.wVirtualKeyCode) {
+		case VK_UP:
+			if (!modKey)
+				WriteToBuffer((char *)(gbVTAppMode ? APP_UP_ARROW : UP_ARROW), 3);
+			else {
+				/* ^[[1;mA */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'A';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_DOWN:
+			if (!modKey)
+				WriteToBuffer((char *)(gbVTAppMode ? APP_DOWN_ARROW : DOWN_ARROW), 3);
+			else {
+				/* ^[[1;mB */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'B';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_RIGHT:
+			if (!modKey)
+				WriteToBuffer((char *)(gbVTAppMode ? APP_RIGHT_ARROW : RIGHT_ARROW), 3);
+			else {
+				/* ^[[1;mC */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'C';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_LEFT:
+			if (!modKey)
+				WriteToBuffer((char *)(gbVTAppMode ? APP_LEFT_ARROW : LEFT_ARROW), 3);
+			else {
+				/* ^[[1;mD */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'D';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_END:
+			if (!modKey)
+				WriteToBuffer((char *)SELECT_KEY, 4);
+			else {
+				/* ^[[1;mF */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'F';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_HOME:
+			if (!modKey)
+				WriteToBuffer((char *)FIND_KEY, 4);
+			else {
+				/* ^[[1;mH */
+				char *p = "\033[1;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = 'H';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_INSERT:
+			if (!modKey)
+				WriteToBuffer((char *)INSERT_KEY, 4);
+			else {
+				/* ^[[2;m~ */
+				char *p = "\033[2;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = '~';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_DELETE:
+			if (!modKey)
+				WriteToBuffer((char *)REMOVE_KEY, 4);
+			else {
+				/* ^[[3;m~ */
+				char *p = "\033[3;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = '~';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_PRIOR: /* page up */
+			if (!modKey)
+				WriteToBuffer((char *)PREV_KEY, 4);
+			else {
+				/* ^[[5;m~ */
+				char *p = "\033[5;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = '~';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_NEXT: /* page down */
+			if (!modKey)
+				WriteToBuffer((char *)NEXT_KEY, 4);
+			else {
+				/* ^[[6;m~  */
+				char *p = "\033[6;";
+				strcpy_s(tmp_buf, sizeof(tmp_buf), p);
+				size_t index = strlen(p);
+				tmp_buf[index++] = modKey + '0';
+				tmp_buf[index] = '~';
+
+				WriteToBuffer(tmp_buf, index + 1);
+			}
+			break;
+		case VK_BACK:
+			WriteToBuffer((char *)BACKSPACE_KEY, 1);
+			break;
+		case VK_TAB:
+			if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_TAB_KEY, 3);
+			else
+				WriteToBuffer((char *)octets, n);
+			break;
+		case VK_ESCAPE:
+			WriteToBuffer((char *)ESCAPE_KEY, 1);
+			break;
+		case VK_SHIFT:
+		case VK_CONTROL:
+		case VK_CAPITAL:
+			break; /* NOP on these */
+		case VK_F1:
+			/* If isAnsiParsingRequired is false then we use XTERM VT sequence */
+			FN_KEY = isAnsiParsingRequired ? PF1_KEY : XTERM_PF1_KEY;
+			SHIFT_FN_KEY = isAnsiParsingRequired ? SHIFT_PF1_KEY : XTERM_SHIFT_PF1_KEY;
+			ALT_FN_KEY = isAnsiParsingRequired ? ALT_PF1_KEY : XTERM_ALT_PF1_KEY;
+			CTRL_FN_KEY = isAnsiParsingRequired ? CTRL_PF1_KEY : XTERM_CTRL_PF1_KEY;
+			SHIFT_ALT_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_PF1_KEY : XTERM_SHIFT_ALT_PF1_KEY;
+			SHIFT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_CTRL_PF1_KEY : XTERM_SHIFT_CTRL_PF1_KEY;
+			ALT_CTRL_FN_KEY = isAnsiParsingRequired ? ALT_CTRL_PF1_KEY : XTERM_ALT_CTRL_PF1_KEY;
+			SHIFT_ALT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_CTRL_PF1_KEY : XTERM_SHIFT_ALT_CTRL_PF1_KEY;
+
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)FN_KEY, strlen(FN_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_FN_KEY, strlen(SHIFT_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_FN_KEY, strlen(CTRL_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_FN_KEY, strlen(ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_FN_KEY, strlen(SHIFT_ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_FN_KEY, strlen(ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_FN_KEY, strlen(SHIFT_ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_FN_KEY, strlen(SHIFT_CTRL_FN_KEY));
+
+			break;
+		case VK_F2:
+			/* If isAnsiParsingRequired is false then we use XTERM VT sequence */
+			FN_KEY = isAnsiParsingRequired ? PF2_KEY : XTERM_PF2_KEY;
+			SHIFT_FN_KEY = isAnsiParsingRequired ? SHIFT_PF2_KEY : XTERM_SHIFT_PF2_KEY;
+			ALT_FN_KEY = isAnsiParsingRequired ? ALT_PF2_KEY : XTERM_ALT_PF2_KEY;
+			CTRL_FN_KEY = isAnsiParsingRequired ? CTRL_PF2_KEY : XTERM_CTRL_PF2_KEY;
+			SHIFT_ALT_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_PF2_KEY : XTERM_SHIFT_ALT_PF2_KEY;
+			SHIFT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_CTRL_PF2_KEY : XTERM_SHIFT_CTRL_PF2_KEY;
+			ALT_CTRL_FN_KEY = isAnsiParsingRequired ? ALT_CTRL_PF2_KEY : XTERM_ALT_CTRL_PF2_KEY;
+			SHIFT_ALT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_CTRL_PF2_KEY : XTERM_SHIFT_ALT_CTRL_PF2_KEY;
+
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)FN_KEY, strlen(FN_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_FN_KEY, strlen(SHIFT_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_FN_KEY, strlen(CTRL_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_FN_KEY, strlen(ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_FN_KEY, strlen(SHIFT_ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_FN_KEY, strlen(ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_FN_KEY, strlen(SHIFT_ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_FN_KEY, strlen(SHIFT_CTRL_FN_KEY));
+
+			break;
+		case VK_F3:
+			/* If isAnsiParsingRequired is false then we use XTERM VT sequence */
+			FN_KEY = isAnsiParsingRequired ? PF3_KEY : XTERM_PF3_KEY;
+			SHIFT_FN_KEY = isAnsiParsingRequired ? SHIFT_PF3_KEY : XTERM_SHIFT_PF3_KEY;
+			ALT_FN_KEY = isAnsiParsingRequired ? ALT_PF3_KEY : XTERM_ALT_PF3_KEY;
+			CTRL_FN_KEY = isAnsiParsingRequired ? CTRL_PF3_KEY : XTERM_CTRL_PF3_KEY;
+			SHIFT_ALT_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_PF3_KEY : XTERM_SHIFT_ALT_PF3_KEY;
+			SHIFT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_CTRL_PF3_KEY : XTERM_SHIFT_CTRL_PF3_KEY;
+			ALT_CTRL_FN_KEY = isAnsiParsingRequired ? ALT_CTRL_PF3_KEY : XTERM_ALT_CTRL_PF3_KEY;
+			SHIFT_ALT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_CTRL_PF3_KEY : XTERM_SHIFT_ALT_CTRL_PF3_KEY;
+
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)FN_KEY, strlen(FN_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_FN_KEY, strlen(SHIFT_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_FN_KEY, strlen(CTRL_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_FN_KEY, strlen(ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_FN_KEY, strlen(SHIFT_ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_FN_KEY, strlen(ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_FN_KEY, strlen(SHIFT_ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_FN_KEY, strlen(SHIFT_CTRL_FN_KEY));
+
+			break;
+		case VK_F4:
+			/* If isAnsiParsingRequired is false then we use XTERM VT sequence */
+			FN_KEY = isAnsiParsingRequired ? PF4_KEY : XTERM_PF4_KEY;
+			SHIFT_FN_KEY = isAnsiParsingRequired ? SHIFT_PF4_KEY : XTERM_SHIFT_PF4_KEY;
+			ALT_FN_KEY = isAnsiParsingRequired ? ALT_PF4_KEY : XTERM_ALT_PF4_KEY;
+			CTRL_FN_KEY = isAnsiParsingRequired ? CTRL_PF4_KEY : XTERM_CTRL_PF4_KEY;
+			SHIFT_ALT_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_PF4_KEY : XTERM_SHIFT_ALT_PF4_KEY;
+			SHIFT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_CTRL_PF4_KEY : XTERM_SHIFT_CTRL_PF4_KEY;
+			ALT_CTRL_FN_KEY = isAnsiParsingRequired ? ALT_CTRL_PF4_KEY : XTERM_ALT_CTRL_PF4_KEY;
+			SHIFT_ALT_CTRL_FN_KEY = isAnsiParsingRequired ? SHIFT_ALT_CTRL_PF4_KEY : XTERM_SHIFT_ALT_CTRL_PF4_KEY;
+
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)FN_KEY, strlen(FN_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_FN_KEY, strlen(SHIFT_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_FN_KEY, strlen(CTRL_FN_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_FN_KEY, strlen(ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_FN_KEY, strlen(SHIFT_ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_FN_KEY, strlen(ALT_CTRL_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_FN_KEY, strlen(SHIFT_ALT_FN_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_FN_KEY, strlen(SHIFT_CTRL_FN_KEY));
+
+			break;
+		case VK_F5:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF5_KEY, strlen(PF5_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF5_KEY, strlen(SHIFT_PF5_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF5_KEY, strlen(CTRL_PF5_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF5_KEY, strlen(ALT_PF5_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF5_KEY, strlen(SHIFT_ALT_CTRL_PF5_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF5_KEY, strlen(ALT_CTRL_PF5_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF5_KEY, strlen(SHIFT_ALT_PF5_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF5_KEY, strlen(SHIFT_CTRL_PF5_KEY));
+			break;
+		case VK_F6:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF6_KEY, strlen(PF6_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF6_KEY, strlen(SHIFT_PF6_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF6_KEY, strlen(CTRL_PF6_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF6_KEY, strlen(ALT_PF6_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF6_KEY, strlen(SHIFT_ALT_CTRL_PF6_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF6_KEY, strlen(ALT_CTRL_PF6_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF6_KEY, strlen(SHIFT_ALT_PF6_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF6_KEY, strlen(SHIFT_CTRL_PF6_KEY));
+			break;
+		case VK_F7:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF7_KEY, strlen(PF7_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF7_KEY, strlen(SHIFT_PF7_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF7_KEY, strlen(CTRL_PF7_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF7_KEY, strlen(ALT_PF7_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF7_KEY, strlen(SHIFT_ALT_CTRL_PF7_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF7_KEY, strlen(ALT_CTRL_PF7_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF7_KEY, strlen(SHIFT_ALT_PF7_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF7_KEY, strlen(SHIFT_CTRL_PF7_KEY));
+			break;
+		case VK_F8:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF8_KEY, strlen(PF8_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF8_KEY, strlen(SHIFT_PF8_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF8_KEY, strlen(CTRL_PF8_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF8_KEY, strlen(ALT_PF8_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF8_KEY, strlen(SHIFT_ALT_CTRL_PF8_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF8_KEY, strlen(ALT_CTRL_PF8_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF8_KEY, strlen(SHIFT_ALT_PF8_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF8_KEY, strlen(SHIFT_CTRL_PF8_KEY));
+			break;
+		case VK_F9:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF9_KEY, strlen(PF9_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF9_KEY, strlen(SHIFT_PF9_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF9_KEY, strlen(CTRL_PF9_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF9_KEY, strlen(ALT_PF9_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF9_KEY, strlen(SHIFT_ALT_CTRL_PF9_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF9_KEY, strlen(ALT_CTRL_PF9_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF9_KEY, strlen(SHIFT_ALT_PF9_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF9_KEY, strlen(SHIFT_CTRL_PF9_KEY));
+			break;
+		case VK_F10:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF10_KEY, strlen(PF10_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF10_KEY, strlen(SHIFT_PF10_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF10_KEY, strlen(CTRL_PF10_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF10_KEY, strlen(ALT_PF10_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF10_KEY, strlen(SHIFT_ALT_CTRL_PF10_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF10_KEY, strlen(ALT_CTRL_PF10_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF10_KEY, strlen(SHIFT_ALT_PF10_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF10_KEY, strlen(SHIFT_CTRL_PF10_KEY));
+			break;
+		case VK_F11:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF11_KEY, strlen(PF11_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF11_KEY, strlen(SHIFT_PF11_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF11_KEY, strlen(CTRL_PF11_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF11_KEY, strlen(ALT_PF11_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF11_KEY, strlen(SHIFT_ALT_CTRL_PF11_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF11_KEY, strlen(ALT_CTRL_PF11_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF11_KEY, strlen(SHIFT_ALT_PF11_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF11_KEY, strlen(SHIFT_CTRL_PF11_KEY));
+			break;
+		case VK_F12:
+			if (dwControlKeyState == 0)
+				WriteToBuffer((char *)PF12_KEY, strlen(PF12_KEY));
+
+			else if (dwControlKeyState == SHIFT_PRESSED)
+				WriteToBuffer((char *)SHIFT_PF12_KEY, strlen(SHIFT_PF12_KEY));
+
+			else if (dwControlKeyState == LEFT_CTRL_PRESSED || dwControlKeyState == RIGHT_CTRL_PRESSED)
+				WriteToBuffer((char *)CTRL_PF12_KEY, strlen(CTRL_PF12_KEY));
+
+			else if (dwControlKeyState == LEFT_ALT_PRESSED || dwControlKeyState == RIGHT_ALT_PRESSED)
+				WriteToBuffer((char *)ALT_PF12_KEY, strlen(ALT_PF12_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_CTRL_PF12_KEY, strlen(SHIFT_ALT_CTRL_PF12_KEY));
+
+			else if ((dwControlKeyState & RIGHT_ALT_PRESSED) || (dwControlKeyState & LEFT_ALT_PRESSED) &&
+				((dwControlKeyState & LEFT_CTRL_PRESSED) || (dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)ALT_CTRL_PF12_KEY, strlen(ALT_CTRL_PF12_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & RIGHT_ALT_PRESSED) ||
+				(dwControlKeyState & LEFT_ALT_PRESSED)))
+				WriteToBuffer((char *)SHIFT_ALT_PF12_KEY, strlen(SHIFT_ALT_PF12_KEY));
+
+			else if ((dwControlKeyState & SHIFT_PRESSED) && ((dwControlKeyState & LEFT_CTRL_PRESSED) ||
+				(dwControlKeyState & RIGHT_CTRL_PRESSED)))
+				WriteToBuffer((char *)SHIFT_CTRL_PF12_KEY, strlen(SHIFT_CTRL_PF12_KEY));
+			break;
+		default:
+			if (inputRecord.Event.KeyEvent.uChar.UnicodeChar != L'\0') {
+				if ((dwControlKeyState & LEFT_ALT_PRESSED) || (dwControlKeyState & RIGHT_ALT_PRESSED)) {
+					memset(tmp_buf, 0, sizeof(tmp_buf));
+					tmp_buf[0] = '\x1b';
+					memcpy(tmp_buf + 1, (char *)octets, n);
+					WriteToBuffer(tmp_buf, n + 1);
+				}
+				else
+					WriteToBuffer((char *)octets, n);
+				break;
+			}
+		}
+	}
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/tncon.h b/contrib/win32/win32compat/tncon.h
new file mode 100644
index 000000000..1f4bcdc1b
--- /dev/null
+++ b/contrib/win32/win32compat/tncon.h
@@ -0,0 +1,226 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* tncon.h
+ * 
+ * Contains terminal emulation console related key definition
+ *
+ */ 
+#ifndef __TNCON_H
+#define __TNCON_H
+
+#include "console.h"
+
+#define UP_ARROW                    "\x1b[A"
+#define DOWN_ARROW                  "\x1b[B"
+#define RIGHT_ARROW                 "\x1b[C"
+#define LEFT_ARROW                  "\x1b[D"
+
+#define APP_UP_ARROW                "\x1bOA"
+#define APP_DOWN_ARROW              "\x1bOB"
+#define APP_RIGHT_ARROW             "\x1bOC"
+#define APP_LEFT_ARROW              "\x1bOD"
+
+#define FIND_KEY                    "\x1b[1~"
+#define INSERT_KEY                  "\x1b[2~"
+#define REMOVE_KEY                  "\x1b[3~"
+#define SELECT_KEY                  "\x1b[4~"
+#define PREV_KEY                    "\x1b[5~"
+#define NEXT_KEY                    "\x1b[6~"
+#define SHIFT_TAB_KEY               "\x1b[~"
+#define SHIFT_ALT_Q                 "\x1b?"
+#define ESCAPE_KEY		    "\x1b"
+#define BACKSPACE_KEY               "\x7f"
+
+// VT100 Function Key's
+#define VT100_PF1_KEY               "\x1bO2"
+#define VT100_PF2_KEY               "\x1bO3"
+#define VT100_PF3_KEY               "\x1bO4"
+#define VT100_PF4_KEY               "\x1bO5"
+#define VT100_PF5_KEY               "\x1bO6"
+#define VT100_PF6_KEY               "\x1bO7"
+#define VT100_PF7_KEY               "\x1bO8"
+#define VT100_PF8_KEY               "\x1bO9"
+#define VT100_PF9_KEY               "\x1bO:"
+#define VT100_PF10_KEY              "\x1bO;"
+
+// VT420 Key's
+#define PF1_KEY                     "\x1b[11~"
+#define PF2_KEY                     "\x1b[12~"
+#define PF3_KEY                     "\x1b[13~"
+#define PF4_KEY                     "\x1b[14~"
+#define PF5_KEY                     "\x1b[15~"
+#define PF6_KEY                     "\x1b[17~"
+#define PF7_KEY                     "\x1b[18~"
+#define PF8_KEY                     "\x1b[19~"
+#define PF9_KEY                     "\x1b[20~"
+#define PF10_KEY                    "\x1b[21~"
+#define PF11_KEY                    "\x1b[23~"
+#define PF12_KEY                    "\x1b[24~"
+
+#define SHIFT_PF1_KEY               "\x1b[11;2~"
+#define SHIFT_PF2_KEY               "\x1b[12;2~"
+#define SHIFT_PF3_KEY               "\x1b[13;2~"
+#define SHIFT_PF4_KEY               "\x1b[14;2~"
+#define SHIFT_PF5_KEY               "\x1b[15;2~"
+#define SHIFT_PF6_KEY               "\x1b[17;2~"
+#define SHIFT_PF7_KEY               "\x1b[18;2~"
+#define SHIFT_PF8_KEY               "\x1b[19;2~"
+#define SHIFT_PF9_KEY               "\x1b[20;2~"
+#define SHIFT_PF10_KEY              "\x1b[21;2~"
+#define SHIFT_PF11_KEY              "\x1b[23;2~"
+#define SHIFT_PF12_KEY              "\x1b[24;2~"
+
+#define ALT_PF1_KEY                 "\x1b[11;3~"
+#define ALT_PF2_KEY                 "\x1b[12;3~"
+#define ALT_PF3_KEY                 "\x1b[13;3~"
+#define ALT_PF4_KEY                 "\x1b[14;3~"
+#define ALT_PF5_KEY                 "\x1b[15;3~"
+#define ALT_PF6_KEY                 "\x1b[17;3~"
+#define ALT_PF7_KEY                 "\x1b[18;3~"
+#define ALT_PF8_KEY                 "\x1b[19;3~"
+#define ALT_PF9_KEY                 "\x1b[20;3~"
+#define ALT_PF10_KEY                "\x1b[21;3~"
+#define ALT_PF11_KEY                "\x1b[23;3~"
+#define ALT_PF12_KEY                "\x1b[24;3~"
+
+#define CTRL_PF1_KEY                "\x1b[11;5~"
+#define CTRL_PF2_KEY                "\x1b[12;5~"
+#define CTRL_PF3_KEY                "\x1b[13;5~"
+#define CTRL_PF4_KEY                "\x1b[14;5~"
+#define CTRL_PF5_KEY                "\x1b[15;5~"
+#define CTRL_PF6_KEY                "\x1b[17;5~"
+#define CTRL_PF7_KEY                "\x1b[18;5~"
+#define CTRL_PF8_KEY                "\x1b[19;5~"
+#define CTRL_PF9_KEY                "\x1b[20;5~"
+#define CTRL_PF10_KEY               "\x1b[21;5~"
+#define CTRL_PF11_KEY               "\x1b[23;5~"
+#define CTRL_PF12_KEY               "\x1b[24;5~"
+
+#define SHIFT_CTRL_PF1_KEY          "\x1b[11;6~"
+#define SHIFT_CTRL_PF2_KEY          "\x1b[12;6~"
+#define SHIFT_CTRL_PF3_KEY          "\x1b[13;6~"
+#define SHIFT_CTRL_PF4_KEY          "\x1b[14;6~"
+#define SHIFT_CTRL_PF5_KEY          "\x1b[15;6~"
+#define SHIFT_CTRL_PF6_KEY          "\x1b[17;6~"
+#define SHIFT_CTRL_PF7_KEY          "\x1b[18;6~"
+#define SHIFT_CTRL_PF8_KEY          "\x1b[19;6~"
+#define SHIFT_CTRL_PF9_KEY          "\x1b[20;6~"
+#define SHIFT_CTRL_PF10_KEY         "\x1b[21;6~"
+#define SHIFT_CTRL_PF11_KEY         "\x1b[23;6~"
+#define SHIFT_CTRL_PF12_KEY         "\x1b[24;6~"
+
+#define SHIFT_ALT_PF1_KEY           "\x1b[11;4~"
+#define SHIFT_ALT_PF2_KEY           "\x1b[12;4~"
+#define SHIFT_ALT_PF3_KEY           "\x1b[13;4~"
+#define SHIFT_ALT_PF4_KEY           "\x1b[14;4~"
+#define SHIFT_ALT_PF5_KEY           "\x1b[15;4~"
+#define SHIFT_ALT_PF6_KEY           "\x1b[17;4~"
+#define SHIFT_ALT_PF7_KEY           "\x1b[18;4~"
+#define SHIFT_ALT_PF8_KEY           "\x1b[19;4~"
+#define SHIFT_ALT_PF9_KEY           "\x1b[20;4~"
+#define SHIFT_ALT_PF10_KEY          "\x1b[21;4~"
+#define SHIFT_ALT_PF11_KEY          "\x1b[23;4~"
+#define SHIFT_ALT_PF12_KEY          "\x1b[24;4~"
+
+#define ALT_CTRL_PF1_KEY            "\x1b[11;7~"
+#define ALT_CTRL_PF2_KEY            "\x1b[12;7~"
+#define ALT_CTRL_PF3_KEY            "\x1b[13;7~"
+#define ALT_CTRL_PF4_KEY            "\x1b[14;7~"
+#define ALT_CTRL_PF5_KEY            "\x1b[15;7~"
+#define ALT_CTRL_PF6_KEY            "\x1b[17;7~"
+#define ALT_CTRL_PF7_KEY            "\x1b[18;7~"
+#define ALT_CTRL_PF8_KEY            "\x1b[19;7~"
+#define ALT_CTRL_PF9_KEY            "\x1b[20;7~"
+#define ALT_CTRL_PF10_KEY           "\x1b[21;7~"
+#define ALT_CTRL_PF11_KEY           "\x1b[23;7~"
+#define ALT_CTRL_PF12_KEY           "\x1b[24;7~"
+
+#define SHIFT_ALT_CTRL_PF1_KEY      "\x1b[11;8~"
+#define SHIFT_ALT_CTRL_PF2_KEY      "\x1b[12;8~"
+#define SHIFT_ALT_CTRL_PF3_KEY      "\x1b[13;8~"
+#define SHIFT_ALT_CTRL_PF4_KEY      "\x1b[14;8~"
+#define SHIFT_ALT_CTRL_PF5_KEY      "\x1b[15;8~"
+#define SHIFT_ALT_CTRL_PF6_KEY      "\x1b[17;8~"
+#define SHIFT_ALT_CTRL_PF7_KEY      "\x1b[18;8~"
+#define SHIFT_ALT_CTRL_PF8_KEY      "\x1b[19;8~"
+#define SHIFT_ALT_CTRL_PF9_KEY      "\x1b[20;8~"
+#define SHIFT_ALT_CTRL_PF10_KEY     "\x1b[21;8~"
+#define SHIFT_ALT_CTRL_PF11_KEY     "\x1b[23;8~"
+#define SHIFT_ALT_CTRL_PF12_KEY     "\x1b[24;8~"
+
+/* XTERM (https://github.com/mintty/mintty/wiki/Keycodes#function-keys) */
+#define XTERM_PF1_KEY               "\x1bOP"
+#define XTERM_PF2_KEY               "\x1bOQ"
+#define XTERM_PF3_KEY               "\x1bOR"
+#define XTERM_PF4_KEY               "\x1bOS"
+
+#define XTERM_SHIFT_PF1_KEY         "\x1b[1;2P"
+#define XTERM_SHIFT_PF2_KEY         "\x1b[1;2Q"
+#define XTERM_SHIFT_PF3_KEY         "\x1b[1;2R"
+#define XTERM_SHIFT_PF4_KEY         "\x1b[1;2S"
+
+#define XTERM_ALT_PF1_KEY           "\x1b[1;3P"
+#define XTERM_ALT_PF2_KEY           "\x1b[1;3Q"
+#define XTERM_ALT_PF3_KEY           "\x1b[1;3R"
+#define XTERM_ALT_PF4_KEY           "\x1b[1;3S"
+
+#define XTERM_CTRL_PF1_KEY          "\x1b[1;5P"
+#define XTERM_CTRL_PF2_KEY          "\x1b[1;5Q"
+#define XTERM_CTRL_PF3_KEY          "\x1b[1;5R"
+#define XTERM_CTRL_PF4_KEY          "\x1b[1;5S"
+
+#define XTERM_SHIFT_ALT_PF1_KEY     "\x1b[1;4P"
+#define XTERM_SHIFT_ALT_PF2_KEY     "\x1b[1;4Q"
+#define XTERM_SHIFT_ALT_PF3_KEY     "\x1b[1;4R"
+#define XTERM_SHIFT_ALT_PF4_KEY     "\x1b[1;4S"
+
+#define XTERM_SHIFT_CTRL_PF1_KEY    "\x1b[1;6P"
+#define XTERM_SHIFT_CTRL_PF2_KEY    "\x1b[1;6Q"
+#define XTERM_SHIFT_CTRL_PF3_KEY    "\x1b[1;6R"
+#define XTERM_SHIFT_CTRL_PF4_KEY    "\x1b[1;6S"
+
+#define XTERM_ALT_CTRL_PF1_KEY      "\x1b[1;7P"
+#define XTERM_ALT_CTRL_PF2_KEY      "\x1b[1;7Q"
+#define XTERM_ALT_CTRL_PF3_KEY      "\x1b[1;7R"
+#define XTERM_ALT_CTRL_PF4_KEY      "\x1b[1;7S"
+
+#define XTERM_SHIFT_ALT_CTRL_PF1_KEY      "\x1b[1;8P"
+#define XTERM_SHIFT_ALT_CTRL_PF2_KEY      "\x1b[1;8Q"
+#define XTERM_SHIFT_ALT_CTRL_PF3_KEY      "\x1b[1;8R"
+#define XTERM_SHIFT_ALT_CTRL_PF4_KEY      "\x1b[1;8S"
+
+#define TERMINAL_ID                 "\x1b[?1;2c"
+#define STATUS_REPORT               "\x1b[2;5R"
+#define CURSOR_REPORT_FORMAT_STRING "\x1b[%d;%dR"
+#define VT52_TERMINAL_ID            "\x1b/Z"
+
+int ReadConsoleForTermEmul(HANDLE hInput, char *destin, int destinlen);
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/tnnet.c b/contrib/win32/win32compat/tnnet.c
new file mode 100644
index 000000000..cde7e2509
--- /dev/null
+++ b/contrib/win32/win32compat/tnnet.c
@@ -0,0 +1,133 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2017 Microsoft Corp.
+ * All rights reserved
+ *
+ * This file is responsible for terminal emulation related network calls to 
+ * invoke ANSI parsing engine.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+#include <windows.h>
+#include "ansiprsr.h"
+#include "inc\utf.h"
+#include "inc\string.h"
+#include "console.h"
+#include "misc_internal.h"
+
+#define dwBuffer 4096
+
+extern BOOL isAnsiParsingRequired;
+extern BOOL isConsoleVTSeqAvailable;
+extern int track_view_port_no_pty_hack;
+extern bool gbVTAppMode;
+BOOL isFirstPacket = TRUE;
+
+/*
+ * Server will always be returning a sequence of ANSI control characters which the client
+ * protocol can either passthru directly to the console or transform based on an output terminal
+ * type. We're not using termcap so we're only supporting the ANSI (vt100) sequences that
+ * are hardcoded in the server and will be transformed to Windows Console commands.
+ */
+void
+processBuffer(HANDLE handle, char *buf, DWORD len, unsigned char **respbuf, size_t *resplen)
+{
+	unsigned char *pszNewHead = NULL;
+	unsigned char *pszHead = NULL;
+	unsigned char *pszTail = NULL;
+	const char *applicationModeSeq = "\x1b[?1h";
+	const DWORD applicationModeSeqLen = (DWORD)strlen(applicationModeSeq);
+	const char *normalModeSeq = "\x1b[?1l";
+	const DWORD normalModeSeqLen = (DWORD)strlen(normalModeSeq);
+	const char *clsSeq = "\x1b[2J";
+	const char *appModePtr = NULL;
+	const char *normalModePtr = NULL;
+
+	if (len == 0)
+		return;
+
+	if (false == isAnsiParsingRequired) {
+		if(isFirstPacket) {
+			isFirstPacket = FALSE;
+
+			/* Windows server at first sends the "cls" after the connection is established.
+			 * There is a bug in the conhost which causes the visible window data to loose so to
+			 * mitigate that issue we need to first move the visible window so that the cursor is at the top of the visible window.
+			 */
+			if (strstr(buf, clsSeq))
+				ConMoveCursorTopOfVisibleWindow();
+		}
+
+		if (!isConsoleVTSeqAvailable) {
+			if (len >= applicationModeSeqLen && (appModePtr = strrstr(buf, applicationModeSeq)))
+				gbVTAppMode = true;
+
+			if (len >= normalModeSeqLen && (normalModePtr = strrstr(buf, normalModeSeq)))
+			{
+				if (appModePtr && (appModePtr > normalModePtr))
+					gbVTAppMode = true;
+				else
+					gbVTAppMode = false;
+			}
+		}
+
+		/* WriteFile() gets messy when user does scroll up/down so we need to restore the visible window. 
+		 * It's a conhost bug but we need to live with it as they are not going to back port the fix.
+		 */
+		if(track_view_port_no_pty_hack)
+			ConRestoreViewRect_NoPtyHack();
+				
+		/* Console has the capability to parse so pass the raw buffer to console directly */
+		WriteFile(handle, buf, len, 0, 0);
+
+		if (track_view_port_no_pty_hack)
+			ConSaveViewRect_NoPtyHack();
+
+		return;
+	}
+
+	/* Transform a single carriage return into a single linefeed before continuing */
+	if ((len == 1) && (buf[0] == 13))
+		buf[0] = 10;
+
+	pszTail = (unsigned char *)buf;
+	pszHead = (unsigned char *)buf;
+	pszTail += len;
+	pszNewHead = pszHead;
+
+	/*
+	 * Loop through the network buffer transforming characters as necessary.
+	 * The buffer will be empty after the transformation
+	 * process since the buffer will contain only commands that are handled by the console API.
+	 */
+	do {
+		pszHead = pszNewHead;
+		pszNewHead = ParseBuffer(pszHead, pszTail, respbuf, resplen);
+
+	} while ((pszNewHead != pszHead) && (pszNewHead < pszTail) && (resplen == NULL || (resplen != NULL && *resplen == 0)));
+}
diff --git a/contrib/win32/win32compat/tnnet.h b/contrib/win32/win32compat/tnnet.h
new file mode 100644
index 000000000..610236ffd
--- /dev/null
+++ b/contrib/win32/win32compat/tnnet.h
@@ -0,0 +1,40 @@
+/*
+ * Author: Microsoft Corp.
+ *
+ * Copyright (c) 2015 Microsoft Corp.
+ * All rights reserved
+ *
+ * Microsoft openssh win32 port
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/* tnnet.h
+ * 
+ * Contains terminal emulation related network calls to invoke ANSI parsing engine
+ *
+ */
+ 
+#ifndef __TNNET_H
+#define __TNNET_H
+void processBuffer(HANDLE handle, char *buf, DWORD len, unsigned char **respbuf, size_t *resplen);
+
+#endif
\ No newline at end of file
diff --git a/contrib/win32/win32compat/ttymodes_windows.c b/contrib/win32/win32compat/ttymodes_windows.c
new file mode 100644
index 000000000..0dc15ca2c
--- /dev/null
+++ b/contrib/win32/win32compat/ttymodes_windows.c
@@ -0,0 +1,201 @@
+/*
+ * SSH2 tty modes for Windows
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******* TODO - integrate these changes into ttymodes.c ******/
+
+#include "includes.h"
+
+#include <sys/types.h>
+
+#include <errno.h>
+#include <string.h>
+#include <termios.h>
+#include <stdarg.h>
+
+#include "packet.h"
+#include "log.h"
+#include "compat.h"
+#include "sshbuf.h"
+#include "ssherr.h"
+
+#define TTY_OP_END		0
+/*
+ * uint32 (u_int) follows speed in SSH1 and SSH2
+ */
+#define TTY_OP_ISPEED_PROTO1	192
+#define TTY_OP_OSPEED_PROTO1	193
+#define TTY_OP_ISPEED_PROTO2	128
+#define TTY_OP_OSPEED_PROTO2	129
+
+/*
+ * Encodes terminal modes for the terminal referenced by fd
+ * or tiop in a portable manner, and appends the modes to a packet
+ * being constructed.
+ */
+void
+ssh_tty_make_modes(struct ssh *ssh, int fd, struct termios *tiop)
+{
+	struct termios tio;
+	struct sshbuf *buf;
+	int r, baud, tty_op_ospeed, tty_op_ispeed;
+	
+	if ((buf = sshbuf_new()) == NULL)
+		fatal("%s: sshbuf_new failed", __func__);
+
+	tio = *tiop;
+	
+	tty_op_ospeed = TTY_OP_OSPEED_PROTO2;
+	tty_op_ispeed = TTY_OP_ISPEED_PROTO2;
+	/* Store input and output baud rates. */
+	baud = 9600;
+
+	if ((r = sshbuf_put_u8(buf, tty_op_ospeed)) != 0 ||
+	    (r = sshbuf_put_u32(buf, baud)) != 0 ||
+	    (r = sshbuf_put_u8(buf, tty_op_ispeed)) != 0 ||
+	    (r = sshbuf_put_u32(buf, baud)) != 0)
+		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+
+#define TTYCHAR(NAME, OP) \
+	if ((r = sshbuf_put_u8(buf, OP)) != 0 || \
+	    (r = sshbuf_put_u32(buf, \
+	    special_char_encode(tio.c_cc[NAME]))) != 0) \
+		fatal("%s: buffer error: %s", __func__, ssh_err(r)); \
+
+#define SSH_TTYMODE_IUTF8 42  /* for SSH_BUG_UTF8TTYMODE */
+
+#define TTYMODE(NAME, FIELD, OP) \
+	if (OP == SSH_TTYMODE_IUTF8 && (datafellows & SSH_BUG_UTF8TTYMODE)) { \
+		debug3("%s: SSH_BUG_UTF8TTYMODE", __func__); \
+	} else if ((r = sshbuf_put_u8(buf, OP)) != 0 || \
+	    (r = sshbuf_put_u32(buf, ((tio.FIELD & NAME) != 0))) != 0) \
+		fatal("%s: buffer error: %s", __func__, ssh_err(r)); \
+
+#undef TTYCHAR
+#undef TTYMODE
+
+	/* Mark end of mode data. */
+	if ((r = sshbuf_put_u8(buf, TTY_OP_END)) != 0 ||
+		(r = sshpkt_put_stringb(ssh, buf)) != 0)
+		fatal("%s: packet error: %s", __func__, ssh_err(r));
+	sshbuf_free(buf);
+}
+
+/*
+ * Decodes terminal modes for the terminal referenced by fd in a portable
+ * manner from a packet being read.
+ */
+void
+ssh_tty_parse_modes(struct ssh *ssh, int fd)
+{
+	struct sshbuf *buf;
+	const u_char *data;
+	u_char opcode;
+	u_int baud;
+	int r, failure = 0;
+	size_t len;
+
+	if ((r = sshpkt_get_string_direct(ssh, &data, &len)) != 0)
+		fatal("%s: packet error: %s", __func__, ssh_err(r));
+	if (len == 0)
+		return;
+	if ((buf = sshbuf_from(data, len)) == NULL) {
+		error("%s: sshbuf_from failed", __func__);
+		return;
+	}
+
+	while (sshbuf_len(buf) > 0) {
+		if ((r = sshbuf_get_u8(buf, &opcode)) != 0)
+			fatal("%s: packet error: %s", __func__, ssh_err(r));
+		switch (opcode) {
+		case TTY_OP_END:
+			goto set;
+
+		case TTY_OP_ISPEED_PROTO2:
+			if ((r = sshbuf_get_u32(buf, &baud)) != 0)
+				fatal("%s: packet error: %s",
+					__func__, ssh_err(r));
+			break;
+
+		case TTY_OP_OSPEED_PROTO2:
+			if ((r = sshbuf_get_u32(buf, &baud)) != 0)
+				fatal("%s: packet error: %s",
+					__func__, ssh_err(r));
+			break;
+
+#define TTYCHAR(NAME, OP) \
+		case OP: \
+			if ((r = sshbuf_get_u32(buf, &u)) != 0) \
+				fatal("%s: packet error: %s", __func__, \
+				    ssh_err(r)); \
+			tio.c_cc[NAME] = special_char_decode(u); \
+			break;
+#define TTYMODE(NAME, FIELD, OP) \
+		case OP: \
+			if ((r = sshbuf_get_u32(buf, &u)) != 0) \
+				fatal("%s: packet error: %s", __func__, \
+				    ssh_err(r)); \
+			if (u) \
+				tio.FIELD |= NAME; \
+			else \
+				tio.FIELD &= ~NAME; \
+			break;
+
+#undef TTYCHAR
+#undef TTYMODE
+
+		default:
+			debug("Ignoring unsupported tty mode opcode %d (0x%x)",
+				opcode, opcode);
+			/*
+			* SSH2:
+			* Opcodes 1 to 159 are defined to have a uint32
+			* argument.
+			* Opcodes 160 to 255 are undefined and cause parsing
+			* to stop.
+			*/
+			if (opcode > 0 && opcode < 160) {
+				if ((r = sshbuf_get_u32(buf, NULL)) != 0)
+					fatal("%s: packet error: %s", __func__,
+						ssh_err(r));
+				break;
+			}
+			else {
+				logit("%s: unknown opcode %d", __func__,
+					opcode);
+				goto set;
+			}
+		}
+	}
+
+set:
+	len = sshbuf_len(buf);
+	sshbuf_free(buf);
+	if (len > 0) {
+		logit("%s: %zu bytes left", __func__, len);
+		return;		/* Don't process bytes passed */
+	}
+	if (failure == -1)
+		return;		/* Packet parsed ok but tcgetattr() failed */
+
+}
diff --git a/contrib/win32/win32compat/utf.c b/contrib/win32/win32compat/utf.c
new file mode 100644
index 000000000..0aecff79a
--- /dev/null
+++ b/contrib/win32/win32compat/utf.c
@@ -0,0 +1,63 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Copyright(c) 2016 Microsoft Corp.
+* All rights reserved
+*
+* UTF8 <--> UTF16 conversion routines
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met :
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and / or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <Windows.h>
+#include "inc\utf.h"
+#include "Debug.h"
+
+/*on error returns NULL and sets errno*/
+wchar_t *
+utf8_to_utf16(const char *utf8)
+{
+	int needed = 0;
+	wchar_t* utf16 = NULL;
+	if ((needed = MultiByteToWideChar(CP_UTF8, 0, utf8, -1, NULL, 0)) == 0 ||
+	    (utf16 = malloc(needed * sizeof(wchar_t))) == NULL ||
+	    MultiByteToWideChar(CP_UTF8, 0, utf8, -1, utf16, needed) == 0) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	return utf16;
+}
+
+char *
+utf16_to_utf8(const wchar_t* utf16)
+{
+	int needed = 0;
+	char* utf8 = NULL;
+	if ((needed = WideCharToMultiByte(CP_UTF8, 0, utf16, -1, NULL, 0, NULL, NULL)) == 0 ||
+	    (utf8 = malloc(needed)) == NULL ||
+	    WideCharToMultiByte(CP_UTF8, 0, utf16, -1, utf8, needed, NULL, NULL) == 0)
+		return NULL;
+	
+	return utf8;
+}
+
diff --git a/contrib/win32/win32compat/w32-doexec.c b/contrib/win32/win32compat/w32-doexec.c
new file mode 100644
index 000000000..6740c97d2
--- /dev/null
+++ b/contrib/win32/win32compat/w32-doexec.c
@@ -0,0 +1,577 @@
+/*
+* Author: Yanbing Wang <yawang@microsoft.com>
+*
+* Support execution of commands on Win32 based operating systems.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include "includes.h"
+
+#include <unistd.h>
+#include "xmalloc.h"
+#include "packet.h"
+
+#include "channels.h"
+#include "hostfile.h"
+#include "auth.h"
+#include "log.h"
+#include "misc.h"
+#include "servconf.h"
+#include "pal_doexec.h"
+#include "misc_internal.h"
+#include "sshTelemetry.h"
+
+#ifndef SUBSYSTEM_NONE
+#define SUBSYSTEM_NONE				0
+#endif
+#ifndef SUBSYSTEM_EXT
+#define SUBSYSTEM_EXT				1
+#endif
+#ifndef SUBSYSTEM_INT_SFTP
+#define SUBSYSTEM_INT_SFTP			2
+#endif
+#ifndef SUBSYSTEM_INT_SFTP_ERROR
+#define SUBSYSTEM_INT_SFTP_ERROR	3
+#endif
+
+/* import */
+extern ServerOptions options;
+extern struct sshauthopt *auth_opts;
+int get_in_chroot();
+char **
+do_setup_env_proxy(struct ssh *, Session *, const char *);
+
+/*
+* do_exec* on Windows
+* - Read and set user environment variables from registry
+* - Build subsystem cmdline path
+* - Interactive shell/commands are executed using ssh-shellhost.exe
+* - ssh-shellhost.exe implements server-side PTY for Windows
+*/
+#define UTF8_TO_UTF16_WITH_CLEANUP(o, i) do {	\
+	if (o != NULL) free(o);						\
+	if ((o = utf8_to_utf16(i)) == NULL)			\
+		goto cleanup;							\
+} while (0)
+
+#define GOTO_CLEANUP_ON_ERR(exp) do {	\
+	if ((exp) != 0)						\
+		goto cleanup;					\
+} while(0)
+
+
+static char*
+get_registry_operation_error_message(const LONG error_code) 
+{
+	char* message = NULL;
+	wchar_t* wmessage = NULL;
+	DWORD length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, error_code, 0, (wchar_t*)&wmessage, 0, NULL);
+	if (length == 0)
+		return NULL;
+
+	if (wmessage[length - 1] == L'\n')
+		wmessage[length - 1] = L'\0';
+	if (length > 1 && wmessage[length - 2] == L'\r')
+		wmessage[length - 2] = L'\0';
+
+	message = utf16_to_utf8(wmessage);
+	LocalFree(wmessage);
+
+	return message;
+}
+
+/* TODO  - built env var set and pass it along with CreateProcess */
+/* Set environment variables with values from the registry */
+/* Ensure that environment of new connections reflect the current state of the machine */
+static void
+setup_session_user_vars(wchar_t* profile_path)
+{
+	/* retrieve and set env variables. */
+	HKEY reg_key = 0;
+	wchar_t name[256];
+	wchar_t path[PATH_MAX + 1] = { 0, };
+	wchar_t *data = NULL, *data_expanded = NULL, *path_value = NULL, *to_apply;
+	DWORD type, name_chars = 256, data_chars = 0, data_expanded_chars = 0, required, i = 0;
+	LONG ret;
+	char *error_message;
+
+	/*These whitelisted environment variables should not be overwritten with the value from the registry*/
+	wchar_t* whitelist[] = { L"PROCESSOR_ARCHITECTURE", L"USERNAME" };
+
+	SetEnvironmentVariableW(L"USERPROFILE", profile_path);
+
+	if (profile_path[0] && profile_path[1] == L':') {
+		SetEnvironmentVariableW(L"HOMEPATH", profile_path + 2);
+		wchar_t wc = profile_path[2];
+		profile_path[2] = L'\0';
+		SetEnvironmentVariableW(L"HOMEDRIVE", profile_path);
+		profile_path[2] = wc;
+	}
+	else
+		SetEnvironmentVariableW(L"HOMEPATH", profile_path);
+
+	swprintf_s(path, _countof(path), L"%s\\AppData\\Local", profile_path);
+	SetEnvironmentVariableW(L"LOCALAPPDATA", path);
+	swprintf_s(path, _countof(path), L"%s\\AppData\\Roaming", profile_path);
+	SetEnvironmentVariableW(L"APPDATA", path);
+	
+	for (int j = 0; j < 2; j++)
+	{
+		/* First update the environment variables with the value from the System Environment, and then User. */
+		/* User variables overwrite the value of system variables with the same name (Except Path) */
+		if (j == 0)
+			ret = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment", 0, KEY_QUERY_VALUE, &reg_key);
+		else
+			ret = RegOpenKeyExW(HKEY_CURRENT_USER, L"Environment", 0, KEY_QUERY_VALUE, &reg_key);
+
+		if (ret != ERROR_SUCCESS) {
+			error_message = get_registry_operation_error_message(ret);
+			if (error_message)
+			{
+				error("Unable to open Registry Key %s. %s", (j == 0 ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER"), error_message);
+				free(error_message);
+			}
+			else
+				error("Unable to open Registry Key %s. %s", (j == 0 ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER"));
+			continue;
+		}
+		
+		while (1) {
+			to_apply = NULL;
+			required = data_chars * sizeof(wchar_t);
+			name_chars = 256;
+			ret = RegEnumValueW(reg_key, i++, name, &name_chars, 0, &type, (LPBYTE)data, &required);
+			if (ret == ERROR_NO_MORE_ITEMS)
+				break;
+			else if (ret == ERROR_MORE_DATA || required > data_chars * 2) {
+				if (data != NULL)
+					free(data);
+				data = xmalloc(required);
+				data_chars = required / 2;
+				i--;
+				continue;
+			}
+			else if (ret != ERROR_SUCCESS) {
+				error_message = get_registry_operation_error_message(ret);
+				if (error_message)
+				{
+					error("Failed to enumerate the value for registry key %s. %s", (j == 0 ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER"), error_message);
+					free(error_message);
+				}
+				else
+					error("Failed to enumerate the value for registry key %s", (j == 0 ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER"));
+				break;
+			}
+
+			if (type == REG_SZ)
+				to_apply = data;
+			else if (type == REG_EXPAND_SZ) {
+				required = ExpandEnvironmentStringsW(data, data_expanded, data_expanded_chars);
+				if (required > data_expanded_chars) {
+					if (data_expanded)
+						free(data_expanded);
+					data_expanded = xmalloc(required * 2);
+					data_expanded_chars = required;
+					ExpandEnvironmentStringsW(data, data_expanded, data_expanded_chars);
+				}
+				to_apply = data_expanded;
+			}
+
+			/* Ensure that variables in the whitelist are not being overwritten with the value from the registry */
+			for (int k = 0; k < ARRAYSIZE(whitelist); k++) {
+				if (_wcsicmp(name, whitelist[k]) == 0)
+				{
+					to_apply = NULL;
+				}
+			}
+
+			/* Path is a special case. The System Path value is preppended to the User Path value */
+			if (_wcsicmp(name, L"PATH") == 0 && j == 1) {
+				if ((required = GetEnvironmentVariableW(L"PATH", NULL, 0)) != 0) {
+					size_t user_path_size = wcslen(to_apply) + 1;
+					path_value = xmalloc((required + user_path_size) * 2);
+					GetEnvironmentVariableW(L"PATH", path_value, required);
+					path_value[required - 1] = L';';
+					GOTO_CLEANUP_ON_ERR(memcpy_s(path_value + required, user_path_size * 2, to_apply, user_path_size * 2));
+					to_apply = path_value;
+				}
+			}
+
+			if (to_apply)
+				SetEnvironmentVariableW(name, to_apply);
+				
+		}
+	cleanup:
+		if (reg_key)
+			RegCloseKey(reg_key);
+		if (data)
+			free(data);
+		if (data_expanded)
+			free(data_expanded);
+		if (path_value)
+			free(path_value);
+		i = 0;
+		data = NULL; 
+		data_expanded = NULL; 
+		path_value = NULL;
+		name_chars = 256; 
+		data_chars = 0; 
+		data_expanded_chars = 0;
+		reg_key = 0;
+	}
+}
+
+static int
+setup_session_env(struct ssh *ssh, Session* s)
+{
+	int i = 0, ret = -1;
+	char *env_name = NULL, *env_value = NULL, *t = NULL, **env = NULL, *path_env_val = NULL;
+	char buf[1024] = { 0 };
+	wchar_t *env_name_w = NULL, *env_value_w = NULL, *pw_dir_w = NULL, *tmp = NULL, wbuf[1024] = { 0, };
+	char *c;
+
+	UTF8_TO_UTF16_WITH_CLEANUP(pw_dir_w, s->pw->pw_dir);
+	/* skip domain part (if present) while setting USERNAME */
+	c = strchr(s->pw->pw_name, '\\');
+	UTF8_TO_UTF16_WITH_CLEANUP(tmp, c ? c + 1 : s->pw->pw_name);
+	SetEnvironmentVariableW(L"USERNAME", tmp);
+
+	if (!s->is_subsystem) {
+		_snprintf(buf, ARRAYSIZE(buf), "%s@%s", s->pw->pw_name, getenv("COMPUTERNAME"));
+		UTF8_TO_UTF16_WITH_CLEANUP(tmp, buf);
+		/* escape $ characters as $$ to distinguish from special prompt characters */
+		for (size_t i = 0, j = 0; i < wcslen(tmp) && j < ARRAYSIZE(wbuf) - 1; i++) {
+			wbuf[j] = tmp[i];
+			if (wbuf[j++] == L'$')
+				wbuf[j++] = L'$';
+		}
+		wcscat_s(wbuf, ARRAYSIZE(wbuf), L" $P$G");
+		SetEnvironmentVariableW(L"PROMPT", wbuf);
+	}
+
+	setup_session_user_vars(pw_dir_w); /* setup user specific env variables */
+
+	env = do_setup_env_proxy(ssh, s, s->pw->pw_shell);
+	while (env_name = env[i]) {
+		if (t = strstr(env[i++], "=")) {
+			/* SKIP, if not applicable on WINDOWS
+			PATH is already set.
+			MAIL is not applicable.
+			*/
+			if ((0 == strncmp(env_name, "PATH=", strlen("PATH="))) ||
+				(0 == strncmp(env_name, "MAIL=", strlen("MAIL=")))) {
+				continue;
+			}
+
+			env_value = t + 1;
+			*t = '\0';
+			UTF8_TO_UTF16_WITH_CLEANUP(env_name_w, env_name);
+			UTF8_TO_UTF16_WITH_CLEANUP(env_value_w, env_value);
+			SetEnvironmentVariableW(env_name_w, env_value_w);
+		}
+	}
+	ret = 0;
+
+cleanup:
+	if (pw_dir_w)
+		free(pw_dir_w);
+	if (tmp)
+		free(tmp);
+	if (env_name_w)
+		free(env_name_w);
+	if (env_value_w)
+		free(env_value_w);
+	if (env) {
+		i = 0;
+		while (t = env[i++])
+			free(t);
+		free(env);
+	}
+	return ret;
+}
+
+int do_exec_windows(struct ssh *ssh, Session *s, const char *command, int pty) {
+	int pipein[2], pipeout[2], pipeerr[2], ret = -1;
+	char *exec_command = NULL, *posix_cmd_input = NULL, *shell = NULL, *pty_cmd_cp = NULL;;
+	HANDLE job = NULL, process_handle;
+	extern char* shell_command_option;
+	extern char* shell_arguments;
+	extern BOOLEAN arg_escape;
+
+	/* Create three pipes for stdin, stdout and stderr */
+	if (pipe(pipein) == -1 || pipe(pipeout) == -1 || pipe(pipeerr) == -1)
+		goto cleanup;
+
+	set_nonblock(pipein[0]);
+	set_nonblock(pipein[1]);
+	set_nonblock(pipeout[0]);
+	set_nonblock(pipeout[1]);
+	set_nonblock(pipeerr[0]);
+	set_nonblock(pipeerr[1]);
+
+	fcntl(pipein[1], F_SETFD, FD_CLOEXEC);
+	fcntl(pipeout[0], F_SETFD, FD_CLOEXEC);
+	fcntl(pipeerr[0], F_SETFD, FD_CLOEXEC);
+
+	/* setup Environment varibles */
+	do {
+		static int environment_set = 0;
+
+		if (environment_set)
+			break;
+
+		if (setup_session_env(ssh, s) != 0)
+			goto cleanup;
+
+		environment_set = 1;
+	} while (0);
+	int in_chroot = get_in_chroot();
+	if (!in_chroot)
+		chdir(s->pw->pw_dir);
+
+	if (s->is_subsystem >= SUBSYSTEM_INT_SFTP_ERROR) {
+		command = "echo This service allows sftp connections only.";
+		pty = 0;
+	}
+
+	JOBOBJECT_EXTENDED_LIMIT_INFORMATION job_info;
+	HANDLE job_dup;
+	pid_t pid = -1;
+	char* shell_command_option_local = NULL;
+	size_t shell_len = 0;
+	/*account for the quotes and null*/
+	shell_len = strlen(s->pw->pw_shell) + 2 + 1;
+	if ((shell = malloc(shell_len)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	sprintf_s(shell, shell_len, "\"%s\"", s->pw->pw_shell);
+	debug3("shell: %s", shell);
+
+	enum sh_type { SH_OTHER, SH_CMD, SH_PS, SH_BASH, SH_CYGWIN, SH_SHELLHOST } shell_type = SH_OTHER;
+	/* get shell type */
+	if (strstr(s->pw->pw_shell, "system32\\cmd"))
+		shell_type = SH_CMD;
+	else if (strstr(s->pw->pw_shell, "powershell"))
+		shell_type = SH_PS;
+	else if (strstr(s->pw->pw_shell, "ssh-shellhost"))
+		shell_type = SH_SHELLHOST;
+	else if (strstr(s->pw->pw_shell, "\\bash"))
+		shell_type = SH_BASH;
+	else if (strstr(s->pw->pw_shell, "cygwin"))
+		shell_type = SH_CYGWIN;
+
+	if (shell_command_option)
+		shell_command_option_local = shell_command_option;
+	else if (shell_type == SH_CMD)
+		shell_command_option_local = "/c";
+	else
+		shell_command_option_local = "-c";
+	debug3("shell_option: %s", shell_command_option_local);
+	send_shell_telemetry(pty, shell_type);
+
+	if (pty) {
+		fcntl(s->ptyfd, F_SETFD, FD_CLOEXEC);
+		char *pty_cmd = NULL;
+		if (command) {
+			size_t len = strlen(shell) + 1 + strlen(shell_command_option_local) + 1 + strlen(command) + 1;
+			pty_cmd_cp = pty_cmd = calloc(1, len);
+			if (pty_cmd != NULL)
+			{
+				strcpy_s(pty_cmd, len, shell);
+				strcat_s(pty_cmd, len, " ");
+				strcat_s(pty_cmd, len, shell_command_option_local);
+				strcat_s(pty_cmd, len, " ");
+				strcat_s(pty_cmd, len, command);
+			}
+		} else {
+			if (shell_arguments) {
+				size_t len = strlen(shell) + 1 + strlen(shell_arguments) + 1;
+				pty_cmd = calloc(1, len);
+
+				if (pty_cmd != NULL)
+				{
+					strcpy_s(pty_cmd, len, shell);
+					strcat_s(pty_cmd, len, " ");
+					strcat_s(pty_cmd, len, shell_arguments);
+				}
+			}
+			else
+				pty_cmd = shell;
+		}
+
+		if (exec_command_with_pty(&pid, pty_cmd, pipein[0], pipeout[1], pipeerr[1], s->col, s->row, s->ttyfd) == -1)
+			goto cleanup;
+		close(s->ttyfd);
+		s->ttyfd = -1;
+	}
+	else {
+		posix_spawn_file_actions_t actions;
+		char *spawn_argv[4] = { NULL, };
+		exec_command = build_exec_command(command);
+		debug3("exec_command: %s", exec_command);
+
+		if (shell_type == SH_PS || shell_type == SH_BASH ||
+			shell_type == SH_CYGWIN || (shell_type == SH_OTHER) && arg_escape) {
+			spawn_argv[0] = shell;
+
+			if (exec_command) {
+				spawn_argv[1] = shell_command_option_local;
+				spawn_argv[2] = exec_command;
+			}
+		}
+		else {
+			/*
+			 * no escaping needed for cmd and ssh-shellhost, or escaping is disabled
+			 * in registry; pass shell, shell option, and quoted command as cmd path
+			 * of posix_spawn to avoid escaping
+			 */
+			size_t posix_cmd_input_len = strlen(shell) + 1;
+
+			/* account for " around and null */
+			if (exec_command) {
+				posix_cmd_input_len += strlen(shell_command_option_local) + 1;
+				posix_cmd_input_len += strlen(exec_command) + 2 + 1;
+			}
+
+			if ((posix_cmd_input = malloc(posix_cmd_input_len)) == NULL) {
+				errno = ENOMEM;
+				goto cleanup;
+			}
+
+			if (exec_command) {
+				sprintf_s(posix_cmd_input, posix_cmd_input_len, "%s %s \"%s\"",
+					shell, shell_command_option_local, exec_command);
+			} else {
+				sprintf_s(posix_cmd_input, posix_cmd_input_len, "%s",
+					shell); 
+			}
+
+			spawn_argv[0] = posix_cmd_input;
+		}
+		debug3("arg escape option: %s", arg_escape ? "TRUE":"FALSE");
+		debug3("spawn_argv[0]: %s", spawn_argv[0]);
+
+		if (posix_spawn_file_actions_init(&actions) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, pipein[0], STDIN_FILENO) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, pipeout[1], STDOUT_FILENO) != 0 ||
+			posix_spawn_file_actions_adddup2(&actions, pipeerr[1], STDERR_FILENO) != 0) {
+			errno = EOTHER;
+			error("posix_spawn initialization failed");
+			goto cleanup;
+		}
+		
+		//Passing the PRIVSEP_LOG_FD (STDERR_FILENO + 2) to sftp-server for logging
+		if (exec_command) {
+			if (strstr(exec_command, "sftp-server.exe")) {
+				if (posix_spawn_file_actions_adddup2(&actions, STDERR_FILENO + 2, SFTP_SERVER_LOG_FD) != 0) {
+					errno = EOTHER;
+					error("posix_spawn initialization failed");
+					goto cleanup;
+				}
+			}
+		}
+
+		if (posix_spawn(&pid, spawn_argv[0], &actions, NULL, spawn_argv, NULL) != 0) {
+			errno = EOTHER;
+			error("posix_spawn: %s", strerror(errno));
+			goto cleanup;
+		}
+		posix_spawn_file_actions_destroy(&actions);
+	}
+
+	memset(&job_info, 0, sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION));
+	job_info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE | JOB_OBJECT_LIMIT_BREAKAWAY_OK;
+
+	if ((process_handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid)) == NULL) {
+		errno = EOTHER;
+		error("cannot get process handle: %d", GetLastError());
+		goto cleanup;
+	}
+
+	/*
+	* assign job object to control processes spawned
+	* 1. create job object
+	* 2. assign child to job object
+	* 3. duplicate job handle into child so it would be the last to close it
+	*/
+	if ((job = CreateJobObjectW(NULL, NULL)) == NULL ||
+		!SetInformationJobObject(job, JobObjectExtendedLimitInformation, &job_info, sizeof(job_info)) ||
+		!AssignProcessToJobObject(job, process_handle) ||
+		!DuplicateHandle(GetCurrentProcess(), job, process_handle, &job_dup, 0, FALSE, DUPLICATE_SAME_ACCESS)) {
+		errno = EOTHER;
+		error("cannot associate job object: %d", GetLastError());
+		TerminateProcess(process_handle, 255);
+		CloseHandle(process_handle);
+		goto cleanup;
+	}
+	s->pid = pid;
+
+	/* Close the child sides of the socket pairs. */
+	close(pipein[0]);
+	close(pipeout[1]);
+	close(pipeerr[1]);
+
+	/*
+	* Enter the interactive session.  Note: server_loop must be able to
+	* handle the case that fdin and fdout are the same.
+	*/
+	if (pty) {
+		/* Set interactive/non-interactive mode */
+		ssh_packet_set_interactive(ssh, 1, options.ip_qos_interactive,
+			options.ip_qos_bulk);
+		session_set_fds(ssh, s, pipein[1], pipeout[0], -1, 1, 1);
+	}
+	else {
+		/* Set interactive/non-interactive mode */
+		ssh_packet_set_interactive(ssh, s->display != NULL, options.ip_qos_interactive,
+			options.ip_qos_bulk);
+		session_set_fds(ssh, s, pipein[1], pipeout[0], pipeerr[0], s->is_subsystem, 0);
+	}
+
+	ret = 0;
+
+cleanup:
+	if (exec_command)
+		free(exec_command);
+	if (posix_cmd_input)
+		free(posix_cmd_input);
+	if (shell)
+		free(shell);
+	if (job)
+		CloseHandle(job);
+	if (pty_cmd_cp)
+		free(pty_cmd_cp);
+
+	return ret;
+}
+
+int
+do_exec_no_pty(struct ssh *ssh, Session *s, const char *command) {
+	return do_exec_windows(ssh, s, command, 0);
+}
+
+int
+do_exec_pty(struct ssh *ssh, Session *s, const char *command) {
+	return do_exec_windows(ssh, s, command, 1);
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/w32-sshfileperm.c b/contrib/win32/win32compat/w32-sshfileperm.c
new file mode 100644
index 000000000..baa3955a8
--- /dev/null
+++ b/contrib/win32/win32compat/w32-sshfileperm.c
@@ -0,0 +1,261 @@
+/*
+* Author: Yanbing Wang <yawang@microsoft.com>
+
+* Author: Bryan Berns <berns@uwalumni.com>
+*   Updates to account for sidhistory checking
+*
+* Support file permission check on Win32 based operating systems.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <Windows.h>
+#include <Sddl.h>
+#include <Aclapi.h>
+#include <lm.h>
+#include <stdio.h> 
+
+#include "inc\pwd.h"
+#include "sshfileperm.h"
+#include "debug.h"
+#include "misc_internal.h"
+#include "config.h"
+
+/*
+* The function is to check if current user is secure to access to the file. 
+* Check the owner of the file is one of these types: Local Administrators groups, system account, current user account
+* Check the users have access permission to the file don't voilate the following rules:	
+	1. no user other than local administrators group, system account, and pwd user have write permission on the file
+* Returns 0 on success and -1 on failure
+*/
+int
+check_secure_file_permission(const char *input_path, struct passwd * pw, int read_ok)
+{	
+	PSECURITY_DESCRIPTOR pSD = NULL;
+	wchar_t * path_utf16 = NULL;
+	PSID owner_sid = NULL, user_sid = NULL, ti_sid = NULL;
+	PACL dacl = NULL;
+	DWORD error_code = ERROR_SUCCESS; 
+	BOOL is_valid_sid = FALSE, is_valid_acl = FALSE;
+	char *bad_user = NULL;
+	int ret = 0;
+
+	if ((user_sid = get_sid(pw ? pw->pw_name : NULL)) == NULL) {
+		ret = -1;
+		goto cleanup;
+	}
+
+	if ((path_utf16 = resolved_path_utf16(input_path)) == NULL) {
+		ret = -1;
+		goto cleanup;
+	}
+
+	ti_sid = get_sid("NT SERVICE\\TrustedInstaller");
+
+	/*Get the owner sid of the file.*/
+	if ((error_code = GetNamedSecurityInfoW(path_utf16, SE_FILE_OBJECT,
+		OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+		&owner_sid, NULL, &dacl, NULL, &pSD)) != ERROR_SUCCESS) {
+		debug3("failed to retrieve the owner sid and dacl of file %S with error code: %d", path_utf16, error_code);
+		errno = EOTHER;
+		ret = -1;
+		goto cleanup;
+	}
+	if (((is_valid_sid = IsValidSid(owner_sid)) == FALSE) || ((is_valid_acl = IsValidAcl(dacl)) == FALSE)) {
+		debug3("IsValidSid: %d; is_valid_acl: %d", is_valid_sid, is_valid_acl);		
+		ret = -1;
+		goto cleanup;
+	}
+	if (!IsWellKnownSid(owner_sid, WinBuiltinAdministratorsSid) &&
+	    !IsWellKnownSid(owner_sid, WinLocalSystemSid) &&
+	    !EqualSid(owner_sid, user_sid) &&
+	    !(ti_sid && EqualSid(owner_sid, ti_sid))) {
+		debug3("Bad owner on %S", path_utf16);
+		ret = -1;
+		goto cleanup;
+	}
+	/*
+	iterate all aces of the file to find out if there is voilation of the following rules:
+		1. no others than administrators group, system account, and current user account have write permission on the file
+	*/
+	for (DWORD i = 0; i < dacl->AceCount; i++) {
+		PVOID current_ace = NULL;
+		PACE_HEADER current_aceHeader = NULL;
+		PSID current_trustee_sid = NULL;
+		ACCESS_MASK current_access_mask = 0;		
+
+		if (!GetAce(dacl, i, &current_ace)) {
+			debug3("GetAce() failed");
+			errno = EOTHER;
+			ret = -1;
+			goto cleanup;
+		}
+
+		current_aceHeader = (PACE_HEADER)current_ace;
+		/* only interested in Allow ACE */
+		if(current_aceHeader->AceType != ACCESS_ALLOWED_ACE_TYPE)
+			continue;
+		
+		PACCESS_ALLOWED_ACE pAllowedAce = (PACCESS_ALLOWED_ACE)current_ace;
+		current_trustee_sid = &(pAllowedAce->SidStart);
+		current_access_mask = pAllowedAce->Mask;	
+		
+		/*no need to check administrators group, pwd user account, and system account*/
+		if (IsWellKnownSid(current_trustee_sid, WinBuiltinAdministratorsSid) ||
+		    IsWellKnownSid(current_trustee_sid, WinLocalSystemSid) ||
+		    EqualSid(current_trustee_sid, user_sid) ||
+		    (ti_sid && EqualSid(current_trustee_sid, ti_sid))) {
+			continue;
+		} else if (read_ok && (current_access_mask & (FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA)) == 0 ) {
+			/* if read is allowed, allow ACES that do not give write access*/
+			continue;
+		} else {
+
+			/* do reverse lookups on the sids to verify the sids are not actually for 
+			 * for the same user as could be the case of a sidhistory entry in the ace */
+			wchar_t resolved_user[DNLEN + 1 + UNLEN + 1] = L"UNKNOWN", resolved_trustee[DNLEN + 1 + UNLEN + 1] = L"UNKNOWN";
+			DWORD resolved_user_len = _countof(resolved_user), resolved_trustee_len = _countof(resolved_trustee);
+			wchar_t resolved_user_domain[DNLEN + 1] = L"UNKNOWN", resolved_trustee_domain[DNLEN + 1] = L"UNKNOWN";
+			DWORD resolved_user_domain_len = _countof(resolved_user_domain), resolved_trustee_domain_len = _countof(resolved_trustee_domain);
+			SID_NAME_USE resolved_user_type, resolved_trustee_type;
+			
+			if (LookupAccountSidW(NULL, user_sid, resolved_user, &resolved_user_len,
+				resolved_user_domain, &resolved_user_domain_len, &resolved_user_type) != 0 &&
+				LookupAccountSidW(NULL, current_trustee_sid, resolved_trustee, &resolved_trustee_len,
+					resolved_trustee_domain, &resolved_trustee_domain_len, &resolved_trustee_type) != 0 &&
+				wcsicmp(resolved_user, resolved_trustee) == 0 && 
+				wcsicmp(resolved_user_domain, resolved_trustee_domain) == 0 &&
+				resolved_user_type == resolved_trustee_type) {
+				/* same user */
+				continue;
+			}
+
+			ret = -1;
+			if (ConvertSidToStringSid(current_trustee_sid, &bad_user) == FALSE) {
+				debug3("ConvertSidToSidString failed with %d. ", GetLastError());
+				break;
+			}
+			logit("Bad permissions. Try removing permissions for user: %S\\%S (%s) on file %S.",
+				resolved_trustee_domain, resolved_trustee, bad_user, path_utf16);
+			break;
+		}
+	}	
+cleanup:
+	if(bad_user)
+		LocalFree(bad_user);
+	if (pSD)
+		LocalFree(pSD);
+	if (user_sid)
+		free(user_sid);
+	if (ti_sid)
+		free(ti_sid);
+	if(path_utf16)
+		free(path_utf16);
+	return ret;
+}
+
+/*
+* The function is similar to check_secure_file_permission.
+* Check the owner of the file is one of these types: Local Administrators groups or system account
+* Check the users have access permission to the file don't violate the following rules:
+	1. no user other than local administrators group and system account have write permission on the folder
+* Returns 0 on success and -1 on failure
+*/
+int
+check_secure_folder_permission(const wchar_t* path_utf16, int read_ok)
+{
+	PSECURITY_DESCRIPTOR pSD = NULL;
+	PSID owner_sid = NULL, ti_sid = NULL;
+	PACL dacl = NULL;
+	DWORD error_code = ERROR_SUCCESS;
+	BOOL is_valid_sid = FALSE, is_valid_acl = FALSE;
+	wchar_t* bad_user = NULL;
+	int ret = 0;
+
+	/*Get the owner sid of the file.*/
+	if ((error_code = GetNamedSecurityInfoW(path_utf16, SE_FILE_OBJECT,
+		OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+		&owner_sid, NULL, &dacl, NULL, &pSD)) != ERROR_SUCCESS) {
+		printf("failed to retrieve the owner sid and dacl of file %S with error code: %d", path_utf16, error_code);
+		errno = EOTHER;
+		ret = -1;
+		goto cleanup;
+	}
+	if (((is_valid_sid = IsValidSid(owner_sid)) == FALSE) || ((is_valid_acl = IsValidAcl(dacl)) == FALSE)) {
+		printf("IsValidSid: %d; is_valid_acl: %d", is_valid_sid, is_valid_acl);
+		ret = -1;
+		goto cleanup;
+	}
+	if (!IsWellKnownSid(owner_sid, WinBuiltinAdministratorsSid) &&
+		!IsWellKnownSid(owner_sid, WinLocalSystemSid)) {
+		printf("Bad owner on %S", path_utf16);
+		ret = -1;
+		goto cleanup;
+	}
+	/*
+	iterate all aces of the file to find out if there is violation of the following rules:
+		1. no others than administrators group and system account have write permission on the file
+	*/
+	for (DWORD i = 0; i < dacl->AceCount; i++) {
+		PVOID current_ace = NULL;
+		PACE_HEADER current_aceHeader = NULL;
+		PSID current_trustee_sid = NULL;
+		ACCESS_MASK current_access_mask = 0;
+
+		if (!GetAce(dacl, i, &current_ace)) {
+			printf("GetAce() failed");
+			errno = EOTHER;
+			ret = -1;
+			goto cleanup;
+		}
+
+		current_aceHeader = (PACE_HEADER)current_ace;
+		/* only interested in Allow ACE */
+		if (current_aceHeader->AceType != ACCESS_ALLOWED_ACE_TYPE)
+			continue;
+
+		PACCESS_ALLOWED_ACE pAllowedAce = (PACCESS_ALLOWED_ACE)current_ace;
+		current_trustee_sid = &(pAllowedAce->SidStart);
+		current_access_mask = pAllowedAce->Mask;
+
+		/*no need to check administrators group and system account*/
+		if (IsWellKnownSid(current_trustee_sid, WinBuiltinAdministratorsSid) ||
+			IsWellKnownSid(current_trustee_sid, WinLocalSystemSid)) {
+			continue;
+		}
+		else if (read_ok && (current_access_mask & (FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA)) == 0) {
+			/* if read is allowed, allow ACES that do not give write access*/
+			continue;
+		}
+		else {
+			ret = -1;
+		}
+	}
+cleanup:
+	if (bad_user)
+		LocalFree(bad_user);
+	if (pSD)
+		LocalFree(pSD);
+	if (ti_sid)
+		free(ti_sid);
+	return ret;
+}
diff --git a/contrib/win32/win32compat/w32api_proxies.c b/contrib/win32/win32compat/w32api_proxies.c
new file mode 100644
index 000000000..813cf7649
--- /dev/null
+++ b/contrib/win32/win32compat/w32api_proxies.c
@@ -0,0 +1,278 @@
+/*
+* Author: Yanbing Wang <yawang@microsoft.com>
+*	Support logon user call on Win32 based operating systems.
+*
+* Author: Manoj Ampalam <manojamp@microsoft.com>
+*	Added generalized wrappers for run time dll loading
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "w32api_proxies.h"
+#include "debug.h"
+#include "misc_internal.h"
+
+static wchar_t* 
+system32_dir()
+{
+	static wchar_t* s_system32_dir = NULL;
+	static wchar_t s_system32_path[PATH_MAX + 1] = { 0, };
+
+	if (s_system32_dir)
+		return s_system32_dir;
+
+	if (!GetSystemDirectoryW(s_system32_path, _countof(s_system32_path))) {
+		debug3("GetSystemDirectory failed with error %d", GetLastError());
+		return NULL;
+	}
+	s_system32_dir = s_system32_path;
+
+	return s_system32_dir;
+}
+
+static HMODULE 
+load_module(wchar_t* name)
+{	
+	HMODULE hm = NULL;
+
+	/*system uses a standard search strategy to find the module */
+	if ((hm = LoadLibraryW(name)) == NULL)
+		debug3("unable to load module %ls at run time, error: %d", name, GetLastError());
+
+	return hm;
+}
+
+static HMODULE
+load_sspicli()
+{
+	static HMODULE s_hm_sspicli = NULL;
+
+	if (!s_hm_sspicli)
+		s_hm_sspicli = load_module(L"sspicli.dll");
+
+	return s_hm_sspicli;
+}
+
+static HMODULE
+load_advapi32()
+{
+	static HMODULE s_hm_advapi32 = NULL;
+
+	if (!s_hm_advapi32)
+		s_hm_advapi32 = load_module(L"advapi32.dll");
+
+	return s_hm_advapi32;
+}
+
+static HMODULE
+load_api_security_lsapolicy()
+{
+	static HMODULE s_hm_api_security_lsapolicy = NULL;
+
+	if (!s_hm_api_security_lsapolicy)
+		s_hm_api_security_lsapolicy = load_module(L"api-ms-win-security-lsapolicy-l1-1-0.dll");
+
+	return s_hm_api_security_lsapolicy;
+}
+
+static HMODULE
+load_secur32()
+{
+	static HMODULE s_hm_secur32 = NULL;
+
+	if (!s_hm_secur32)
+		s_hm_secur32 = load_module(L"secur32.dll");
+
+	return s_hm_secur32;
+}
+
+static HMODULE
+load_ntdll()
+{
+	static HMODULE s_hm_ntdll = NULL;
+
+	if (!s_hm_ntdll)
+		s_hm_ntdll = load_module(L"ntdll.dll");
+
+	return s_hm_ntdll;
+}
+
+FARPROC get_proc_address(HMODULE hm, char* fn)
+{
+	if (hm == NULL) {
+		debug3("GetProcAddress of %s failed with error %d.", fn, GetLastError());
+	}
+	FARPROC ret = GetProcAddress(hm, fn);
+	if (!ret)
+		debug3("GetProcAddress of %s failed with error %d.", fn, GetLastError());
+
+	return ret;
+}
+
+BOOL
+pLogonUserExExW(wchar_t *user_name, wchar_t *domain, wchar_t *password, DWORD logon_type,
+	DWORD logon_provider, PTOKEN_GROUPS token_groups, PHANDLE token, PSID *logon_sid, 
+	PVOID *profile_buffer, LPDWORD profile_length, PQUOTA_LIMITS quota_limits)
+{
+	HMODULE hm = NULL;
+
+	typedef BOOL(WINAPI *LogonUserExExWType)(wchar_t*, wchar_t*, wchar_t*, DWORD, DWORD, PTOKEN_GROUPS, PHANDLE, PSID, PVOID, LPDWORD, PQUOTA_LIMITS);
+	static LogonUserExExWType s_pLogonUserExExW = NULL;
+
+	if (!s_pLogonUserExExW) {
+		/* this API is typically found in sspicli, but this dll doesn't exist on some downlevel machines - we fallback to advapi32 then */
+		if ((hm = load_sspicli()) == NULL &&
+		    (hm = load_advapi32()) == NULL)
+			return FALSE;
+
+		if ((s_pLogonUserExExW = (LogonUserExExWType)get_proc_address(hm, "LogonUserExExW")) == NULL)
+			return FALSE;
+	}
+	
+	return s_pLogonUserExExW(user_name, domain, password, logon_type, logon_provider,
+			token_groups, token, logon_sid, profile_buffer, profile_length, quota_limits);	
+}
+
+
+BOOLEAN pTranslateNameW(LPCWSTR name,
+	EXTENDED_NAME_FORMAT account_format,
+	EXTENDED_NAME_FORMAT desired_name_format,
+	LPWSTR translated_name,
+	PULONG psize)
+{
+	HMODULE hm = NULL;
+	typedef BOOLEAN(SEC_ENTRY *TranslateNameWType)(LPCWSTR, EXTENDED_NAME_FORMAT, EXTENDED_NAME_FORMAT, LPWSTR, PULONG);
+	static TranslateNameWType s_pTranslateNameW = NULL;
+
+	if (!s_pTranslateNameW) {
+		if ((hm = load_secur32()) == NULL)
+			return FALSE;
+
+		if ((s_pTranslateNameW = (TranslateNameWType)get_proc_address(hm, "TranslateNameW")) == NULL)
+			return FALSE;
+	}	
+	return s_pTranslateNameW(name, account_format, desired_name_format, translated_name, psize);
+}
+
+NTSTATUS pLsaOpenPolicy(PLSA_UNICODE_STRING system_name,
+	PLSA_OBJECT_ATTRIBUTES attrib,
+	ACCESS_MASK access,
+	PLSA_HANDLE handle)
+{
+	HMODULE hm = NULL;
+	typedef NTSTATUS(NTAPI *LsaOpenPolicyType)(PLSA_UNICODE_STRING, PLSA_OBJECT_ATTRIBUTES, ACCESS_MASK, PLSA_HANDLE);
+	static LsaOpenPolicyType s_pLsaOpenPolicy = NULL;
+	if (!s_pLsaOpenPolicy) {
+		if ((hm = load_api_security_lsapolicy()) == NULL &&
+			((hm = load_advapi32()) == NULL))
+			return STATUS_ASSERTION_FAILURE;
+		if ((s_pLsaOpenPolicy = (LsaOpenPolicyType)get_proc_address(hm, "LsaOpenPolicy")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}
+	return s_pLsaOpenPolicy(system_name, attrib, access, handle);
+}
+NTSTATUS pLsaFreeMemory(PVOID buffer)
+{
+	HMODULE hm = NULL;
+	typedef NTSTATUS(NTAPI *LsaFreeMemoryType)(PVOID);
+	static LsaFreeMemoryType s_pLsaFreeMemory = NULL;
+	if (!s_pLsaFreeMemory) {
+		if ((hm = load_api_security_lsapolicy()) == NULL &&
+			((hm = load_advapi32()) == NULL))
+			return STATUS_ASSERTION_FAILURE;
+		if ((s_pLsaFreeMemory = (LsaFreeMemoryType)get_proc_address(hm, "LsaFreeMemory")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}
+	return s_pLsaFreeMemory(buffer);
+}
+NTSTATUS pLsaAddAccountRights(LSA_HANDLE lsa_h,
+	PSID psid,
+	PLSA_UNICODE_STRING rights,
+	ULONG num_rights)
+{
+	HMODULE hm = NULL;
+	typedef NTSTATUS(NTAPI *LsaAddAccountRightsType)(LSA_HANDLE, PSID, PLSA_UNICODE_STRING, ULONG);
+	static LsaAddAccountRightsType s_pLsaAddAccountRights = NULL;
+	if (!s_pLsaAddAccountRights) {
+		if ((hm = load_api_security_lsapolicy()) == NULL &&
+			((hm = load_advapi32()) == NULL))
+			return STATUS_ASSERTION_FAILURE;
+		if ((s_pLsaAddAccountRights = (LsaAddAccountRightsType)get_proc_address(hm, "LsaAddAccountRights")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}
+
+	return s_pLsaAddAccountRights(lsa_h, psid, rights, num_rights);
+}
+
+NTSTATUS pLsaRemoveAccountRights(LSA_HANDLE lsa_h,
+	PSID psid,
+	BOOLEAN all_rights,
+	PLSA_UNICODE_STRING rights,
+	ULONG num_rights)
+{
+	HMODULE hm = NULL;
+	typedef NTSTATUS(NTAPI *LsaRemoveAccountRightsType)(LSA_HANDLE, PSID, BOOLEAN, PLSA_UNICODE_STRING, ULONG);
+	static LsaRemoveAccountRightsType s_pLsaRemoveAccountRights = NULL;
+	if (!s_pLsaRemoveAccountRights) {
+		if ((hm = load_api_security_lsapolicy()) == NULL &&
+			((hm = load_advapi32()) == NULL))
+			return STATUS_ASSERTION_FAILURE;
+		if ((s_pLsaRemoveAccountRights = (LsaRemoveAccountRightsType)get_proc_address(hm, "LsaRemoveAccountRights")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}
+
+	return s_pLsaRemoveAccountRights(lsa_h, psid, all_rights, rights, num_rights);
+}
+
+ULONG pRtlNtStatusToDosError(NTSTATUS status)
+{	
+	HMODULE hm = NULL;
+	typedef ULONG(NTAPI *RtlNtStatusToDosErrorType)(NTSTATUS);
+	static RtlNtStatusToDosErrorType s_pRtlNtStatusToDosError = NULL;
+
+	if (!s_pRtlNtStatusToDosError) {
+		if ((hm = load_ntdll()) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+
+		if ((s_pRtlNtStatusToDosError = (RtlNtStatusToDosErrorType)get_proc_address(hm, "RtlNtStatusToDosError")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}	
+	return pRtlNtStatusToDosError(status);
+}
+
+NTSTATUS pLsaClose(LSA_HANDLE lsa_h)
+{
+	HMODULE hm = NULL;
+	typedef NTSTATUS(NTAPI *LsaCloseType)(LSA_HANDLE);
+	static LsaCloseType s_pLsaClose = NULL;
+
+	if (!s_pLsaClose) {
+		if ((hm = load_api_security_lsapolicy()) == NULL &&
+			((hm = load_advapi32()) == NULL))
+			return STATUS_ASSERTION_FAILURE;
+
+		if ((s_pLsaClose = (LsaCloseType)get_proc_address(hm, "LsaClose")) == NULL)
+			return STATUS_ASSERTION_FAILURE;
+	}
+	
+	return s_pLsaClose(lsa_h);
+}
diff --git a/contrib/win32/win32compat/w32api_proxies.h b/contrib/win32/win32compat/w32api_proxies.h
new file mode 100644
index 000000000..431aa68cd
--- /dev/null
+++ b/contrib/win32/win32compat/w32api_proxies.h
@@ -0,0 +1,24 @@
+/*
+* Author: Yanbing Wang <yawang@microsoft.com>
+*
+* Support logon user call on Win32 based operating systems.
+*
+*/
+
+#pragma once
+
+#include <Windows.h>
+#define SECURITY_WIN32
+#include <security.h>
+#include <Ntsecapi.h>
+
+BOOL pLogonUserExExW(wchar_t *, wchar_t *, wchar_t *, DWORD, DWORD, PTOKEN_GROUPS, PHANDLE, PSID *, PVOID *, LPDWORD, PQUOTA_LIMITS);
+BOOLEAN pTranslateNameW(LPCWSTR, EXTENDED_NAME_FORMAT, EXTENDED_NAME_FORMAT, LPWSTR, PULONG);
+NTSTATUS pLsaOpenPolicy(PLSA_UNICODE_STRING, PLSA_OBJECT_ATTRIBUTES, ACCESS_MASK, PLSA_HANDLE);
+NTSTATUS pLsaFreeMemory(PVOID);
+NTSTATUS pLsaAddAccountRights(LSA_HANDLE, PSID,	PLSA_UNICODE_STRING, ULONG);
+ULONG pRtlNtStatusToDosError(NTSTATUS);
+NTSTATUS pLsaClose(LSA_HANDLE);
+NTSTATUS pLsaRemoveAccountRights(LSA_HANDLE, PSID, BOOLEAN, PLSA_UNICODE_STRING, ULONG);
+
+
diff --git a/contrib/win32/win32compat/w32fd.c b/contrib/win32/win32compat/w32fd.c
new file mode 100644
index 000000000..080714242
--- /dev/null
+++ b/contrib/win32/win32compat/w32fd.c
@@ -0,0 +1,1333 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Implementation of POSIX APIs
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#include "inc\sys\socket.h"
+#include "inc\sys\select.h"
+#include "inc\sys\uio.h"
+#include "inc\sys\types.h"
+#include "inc\sys\stat.h"
+#include "inc\unistd.h"
+#include "inc\fcntl.h"
+#include "inc\sys\un.h"
+#include "inc\utf.h"
+#include "inc\stdio.h"
+
+#include "w32fd.h"
+#include "signal_internal.h"
+#include <stdarg.h>
+#include <errno.h>
+#include <time.h>
+#include <assert.h>
+#include <direct.h>
+#include <winioctl.h>
+#include "Shlwapi.h"
+#include <sys\utime.h>
+#include "misc_internal.h"
+#include "debug.h"
+
+/* internal table that stores the fd to w32_io mapping*/
+struct w32fd_table {
+	w32_fd_set occupied;		/*bit map for tracking occipied table entries*/
+	struct w32_io* w32_ios[MAX_FDS];/*array of references to mapped w32_io objects*/
+};
+
+/* mapping table*/
+static struct w32fd_table fd_table;
+
+/* main thread handle*/
+HANDLE main_thread;
+
+void fd_table_set(struct w32_io* pio, int index);
+
+void fd_decode_state(char*);
+#define POSIX_FD_STATE "c28fc6f98a2c44abbbd89d6a3037d0d9_POSIX_FD_STATE"
+#define POSIX_CHROOTW L"c28fc6f98a2c44abbbd89d6a3037d0d9_POSIX_CHROOT"
+
+/* __progname */
+char* __progname = "";
+
+/* __progdir */
+char* __progdir = "";
+wchar_t* __wprogdir = L"";
+
+/* __progdata */
+char* __progdata = "";
+wchar_t* __wprogdata = L"";
+
+/* initializes mapping table*/
+static int
+fd_table_initialize()
+{
+	struct w32_io *pio;
+	HANDLE wh;
+	/* table entries representing std in, out and error*/
+	DWORD wh_index[] = { STD_INPUT_HANDLE , STD_OUTPUT_HANDLE , STD_ERROR_HANDLE };
+	int fd_num = 0;
+
+	memset(&fd_table, 0, sizeof(fd_table));
+
+	/* prepare std io fds */
+	for (fd_num = STDIN_FILENO; fd_num <= STDERR_FILENO; fd_num++) {
+		wh  = GetStdHandle(wh_index[fd_num]);
+		if (wh != NULL && wh != INVALID_HANDLE_VALUE) {
+			pio = malloc(sizeof(struct w32_io));
+			if (!pio) {
+				errno = ENOMEM;
+				return -1;
+			}
+			memset(pio, 0, sizeof(struct w32_io));
+			pio->type = NONSOCK_SYNC_FD;
+			pio->handle = wh;
+			fd_table_set(pio, fd_num);
+		}
+	}
+
+
+	/* decode fd state if any */
+	{
+		char *posix_fd_state;
+
+		/*TODO - validate parent process - to accomodate these scenarios -
+		* A posix parent process launches a regular process that inturn launches a posix child process
+		* In this case the posix child process may misinterpret POSIX_FD_STATE set by grand parent
+		*/
+
+		if ((_dupenv_s(&posix_fd_state, NULL, POSIX_FD_STATE) == 0) && (NULL != posix_fd_state)) {
+			fd_decode_state(posix_fd_state);
+			free(posix_fd_state);
+			_putenv_s(POSIX_FD_STATE, "");
+		}
+	}
+
+	/* decode chroot if any */
+	{
+		_wdupenv_s(&chroot_pathw, NULL, POSIX_CHROOTW);
+		if (chroot_pathw != NULL) {
+			if ((chroot_path = utf16_to_utf8(chroot_pathw)) == NULL)
+				return -1;
+			chroot_path_len = (int) strlen(chroot_path);
+		}
+	}
+
+	return 0;
+}
+
+/* get a free slot in mapping table with least index*/
+static int
+fd_table_get_min_index()
+{
+	int min_index = 0;
+	unsigned char* bitmap = fd_table.occupied.bitmap;
+	unsigned char tmp;
+
+	while (*bitmap == 0xff) {
+		bitmap++;
+		min_index += 8;
+		if (min_index >= MAX_FDS) {
+			errno = EMFILE;
+			debug3("ERROR: MAX_FDS limit reached");
+			return -1;
+		}
+	}
+
+	tmp = *bitmap;
+	while (tmp & 0x80) {
+		tmp <<= 1;
+		min_index++;
+	}
+
+	return min_index;
+}
+
+/* maps pio to fd (specified by index)*/
+static void
+fd_table_set(struct w32_io* pio, int index)
+{
+	fd_table.w32_ios[index] = pio;
+	pio->table_index = index;
+	assert(pio->type != UNKNOWN_FD);
+	FD_SET(index, &(fd_table.occupied));
+}
+
+/* removes entry at index from mapping table*/
+static void
+fd_table_clear(int index)
+{
+	fd_table.w32_ios[index] = NULL;
+	FD_CLR(index, &(fd_table.occupied));
+}
+
+void 
+init_prog_paths()
+{
+	wchar_t* wpgmptr;
+	static int processed = 0;
+
+	if (processed)
+		return;
+
+	if (_get_wpgmptr(&wpgmptr) != 0)
+		fatal("unable to retrieve wpgmptr");
+
+	if ((__wprogdir = _wcsdup(wpgmptr)) == NULL ||
+	    (__progdir = utf16_to_utf8(__wprogdir)) == NULL)
+		fatal("%s out of memory", __func__);
+
+	__progname = strrchr(__progdir, '\\') + 1;
+	/* TODO: retain trailing \ at the end of progdir* variants ? */
+	*(strrchr(__progdir, '\\')) = '\0';
+	*(wcsrchr(__wprogdir, L'\\')) = L'\0';
+
+	/* strip .exe off __progname */
+	*(__progname + strlen(__progname) - 4) = '\0';
+
+	/* get %programdata% value */
+	size_t len = 0;
+	_dupenv_s(&__progdata, &len, "ProgramData");
+
+	if (!__progdata)
+		fatal("couldn't find ProgramData environment variable");
+
+	if(!(__wprogdata = utf8_to_utf16(__progdata)))
+		fatal("%s out of memory", __func__, __LINE__);
+
+	processed = 1;
+}
+
+void
+w32posix_initialize()
+{
+	init_prog_paths();
+	if ((fd_table_initialize() != 0) || (socketio_initialize() != 0))
+		debug_assert_internal();
+	main_thread = OpenThread(THREAD_SET_CONTEXT | SYNCHRONIZE, FALSE, GetCurrentThreadId());
+	if (main_thread == NULL || 
+	    sw_initialize() != 0 ) {
+		debug_assert_internal();
+		fatal("failed to initialize w32posix wrapper");
+	}
+}
+
+void
+w32posix_done()
+{
+	socketio_done();
+}
+
+/* Check if the corresponding fd is set blocking */
+BOOL
+w32_io_is_blocking(struct w32_io* pio)
+{
+	return (pio->fd_status_flags & O_NONBLOCK) ? FALSE : TRUE;
+}
+
+/*
+* Check if io is ready/available. This function is primarily used by select()
+* as it decides on what fds can be set.
+*/
+BOOL
+w32_io_is_io_available(struct w32_io* pio, BOOL rd)
+{
+	if (pio->type == SOCK_FD)
+		return socketio_is_io_available(pio, rd);
+	else
+		return fileio_is_io_available(pio, rd);
+}
+
+void
+w32_io_on_select(struct w32_io* pio, BOOL rd)
+{
+	if ((pio->type == SOCK_FD))
+		socketio_on_select(pio, rd);
+	else
+		fileio_on_select(pio, rd);
+}
+
+#define CHECK_FD(fd) do {							\
+	errno = 0;                                                              \
+	if ((fd < 0) || (fd > MAX_FDS - 1) || fd_table.w32_ios[fd] == NULL) {   \
+		errno = EBADF;                                                  \
+		debug3("%s ERROR: bad fd: %d", __FUNCTION__, fd);                \
+		return -1;                                                      \
+	}                                                                       \
+} while (0)
+
+#define CHECK_SOCK_IO(pio) do {                                             \
+	errno = 0;                                                          \
+	if (pio->type != SOCK_FD) {                                         \
+		errno = ENOTSOCK;                                           \
+		debug3("%s ERROR: not sock :%d", __FUNCTION__, pio->type);   \
+		return -1;                                                  \
+	}                                                                   \
+} while (0)
+
+int
+w32_socket(int domain, int type, int protocol)
+{
+	int min_index = fd_table_get_min_index();
+	struct w32_io* pio = NULL;
+
+	errno = 0;
+	if (min_index == -1)
+		return -1;
+	
+	if (domain == AF_UNIX && type == SOCK_STREAM) {
+		pio = fileio_afunix_socket();		
+		if (pio == NULL)
+			return -1;
+		pio->type = NONSOCK_FD;
+	} else {
+		pio = socketio_socket(domain, type, protocol);
+		if (pio == NULL)
+			return -1;
+		pio->type = SOCK_FD;
+	}	
+
+	fd_table_set(pio, min_index);
+	debug4("socket:%d, socktype:%d, io:%p, fd:%d ", pio->sock, type, pio, min_index);
+	return min_index;
+}
+
+int
+w32_accept(int fd, struct sockaddr* addr, int* addrlen)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	int min_index = fd_table_get_min_index();
+	struct w32_io* pio = NULL;
+
+	if (min_index == -1)
+		return -1;
+
+	if (fd_table.w32_ios[fd]->type == NONSOCK_FD) {
+		errno = ENOTSUP;
+		verbose("Unix domain server sockets are not supported");
+		return -1;
+	}
+
+	pio = socketio_accept(fd_table.w32_ios[fd], addr, addrlen);
+	if (!pio)
+		return -1;
+
+	pio->type = SOCK_FD;
+	fd_table_set(pio, min_index);
+	debug4("socket:%d, io:%p, fd:%d ", pio->sock, pio, min_index);
+	return min_index;
+}
+
+int
+w32_setsockopt(int fd, int level, int optname, const void* optval, int optlen)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_setsockopt(fd_table.w32_ios[fd], level, optname, (const char*)optval, optlen);
+}
+
+int
+w32_getsockopt(int fd, int level, int optname, void* optval, int* optlen)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_getsockopt(fd_table.w32_ios[fd], level, optname, (char*)optval, optlen);
+}
+
+int
+w32_getsockname(int fd, struct sockaddr* name, int* namelen)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_getsockname(fd_table.w32_ios[fd], name, namelen);
+}
+
+int
+w32_getpeername(int fd, struct sockaddr* name, int* namelen)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_getpeername(fd_table.w32_ios[fd], name, namelen);
+}
+
+int
+w32_listen(int fd, int backlog)
+{
+	CHECK_FD(fd);
+	if (fd_table.w32_ios[fd]->type == NONSOCK_FD) {
+		errno = ENOTSUP;
+		verbose("Unix domain server sockets are not supported");
+		return -1;
+	}
+
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_listen(fd_table.w32_ios[fd], backlog);
+}
+
+int
+w32_bind(int fd, const struct sockaddr *name, int namelen)
+{
+	CHECK_FD(fd);
+	if (fd_table.w32_ios[fd]->type == NONSOCK_FD) {
+		errno = ENOTSUP;
+		verbose("Unix domain server sockets are not supported");
+		return -1;
+	}
+
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_bind(fd_table.w32_ios[fd], name, namelen);
+}
+
+int
+w32_connect(int fd, const struct sockaddr* name, int namelen)
+{
+	CHECK_FD(fd);
+
+	if (fd_table.w32_ios[fd]->type == NONSOCK_FD) {
+		struct sockaddr_un* addr = (struct sockaddr_un*)name;
+		return fileio_connect(fd_table.w32_ios[fd], addr->sun_path);
+	}
+
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_connect(fd_table.w32_ios[fd], name, namelen);
+}
+
+int
+w32_recv(int fd, void *buf, size_t len, int flags)
+{
+	CHECK_FD(fd);
+
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_recv(fd_table.w32_ios[fd], buf, len, flags);
+}
+
+int
+w32_send(int fd, const void *buf, size_t len, int flags)
+{
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_send(fd_table.w32_ios[fd], buf, len, flags);
+}
+
+
+int
+w32_shutdown(int fd, int how)
+{
+	debug4("shutdown - fd:%d how:%d", fd, how);
+	CHECK_FD(fd);
+	CHECK_SOCK_IO(fd_table.w32_ios[fd]);
+	return socketio_shutdown(fd_table.w32_ios[fd], how);
+}
+
+int
+w32_socketpair(int domain, int type, int protocol, int sv[2])
+{
+	int p0, p1;
+	struct w32_io* pio[2];
+
+	errno = 0;
+	p0 = fd_table_get_min_index();
+	if (p0 == -1)
+		return -1;
+
+	/*temporarily set occupied bit*/
+	FD_SET(p0, &fd_table.occupied);
+	p1 = fd_table_get_min_index();
+	FD_CLR(p0, &fd_table.occupied);
+	if (p1 == -1)
+		return -1;
+
+	if (-1 == fileio_pipe(pio, 1))
+		return -1;
+
+	pio[0]->type = NONSOCK_FD;
+	pio[1]->type = NONSOCK_FD;
+	fd_table_set(pio[0], p0);
+	fd_table_set(pio[1], p1);
+	sv[0] = p0;
+	sv[1] = p1;
+	debug4("socketpair - r-h:%d,io:%p,fd:%d  w-h:%d,io:%p,fd:%d",
+		pio[0]->handle, pio[0], p0, pio[1]->handle, pio[1], p1);
+
+	return 0;
+}
+
+
+int
+w32_pipe(int *pfds)
+{
+	int read_index, write_index;
+	struct w32_io* pio[2];
+
+	errno = 0;
+	read_index = fd_table_get_min_index();
+	if (read_index == -1)
+		return -1;
+
+	/*temporarily set occupied bit*/
+	FD_SET(read_index, &fd_table.occupied);
+	write_index = fd_table_get_min_index();
+	FD_CLR(read_index, &fd_table.occupied);
+	if (write_index == -1)
+		return -1;
+
+	if (-1 == fileio_pipe(pio, 0))
+		return -1;
+
+	pio[0]->type = NONSOCK_FD;
+	pio[1]->type = NONSOCK_FD;
+	fd_table_set(pio[0], read_index);
+	fd_table_set(pio[1], write_index);
+	pfds[0] = read_index;
+	pfds[1] = write_index;
+	debug4("pipe - r-h:%d,io:%p,fd:%d  w-h:%d,io:%p,fd:%d",
+		pio[0]->handle, pio[0], read_index, pio[1]->handle, pio[1], write_index);
+	
+	return 0;
+}
+
+int
+w32_open(const char *pathname, int flags, ... /* arg */)
+{
+	int min_index = fd_table_get_min_index();
+	struct w32_io* pio;
+	va_list valist;
+	mode_t mode = 0;
+
+	errno = 0;
+	if (min_index == -1)
+		return -1;
+	if (flags & O_CREAT) {
+		va_start(valist, flags);
+		mode = va_arg(valist, mode_t);
+		va_end(valist);
+	}
+
+	pio = fileio_open(pathname, flags, mode);
+	
+	if (pio == NULL)
+		return -1;
+
+	pio->type = NONSOCK_FD;
+	fd_table_set(pio, min_index);
+	debug4("open - handle:%p, io:%p, fd:%d", pio->handle, pio, min_index);
+	debug5("open - path:%s", pathname);
+	return min_index;
+}
+
+int
+w32_read(int fd, void *dst, size_t max)
+{
+	CHECK_FD(fd);
+	if (fd_table.w32_ios[fd]->type == SOCK_FD)
+		return socketio_recv(fd_table.w32_ios[fd], dst, max, 0);
+
+	return fileio_read(fd_table.w32_ios[fd], dst, max);
+}
+
+int
+w32_write(int fd, const void *buf, size_t max)
+{
+	CHECK_FD(fd);
+
+	if (fd_table.w32_ios[fd]->type == SOCK_FD)
+		return socketio_send(fd_table.w32_ios[fd], buf, max, 0);
+
+	return fileio_write_wrapper(fd_table.w32_ios[fd], buf, max);
+}
+
+int
+w32_writev(int fd, const struct iovec *iov, int iovcnt)
+{
+	int written = 0;
+	int i = 0;
+
+	CHECK_FD(fd);
+	for (i = 0; i < iovcnt; i++) {
+		int ret = w32_write(fd, iov[i].iov_base, iov[i].iov_len);
+		if (ret > 0)
+			written += ret;
+	}
+
+	return written;
+}
+
+int
+w32_fstat(int fd, struct w32_stat *buf)
+{
+	CHECK_FD(fd);
+	return fileio_fstat(fd_table.w32_ios[fd], (struct _stat64*)buf);
+}
+
+long
+w32_lseek(int fd, unsigned __int64 offset, int origin)
+{
+	CHECK_FD(fd);
+	return fileio_lseek(fd_table.w32_ios[fd], offset, origin);
+}
+
+int
+w32_isatty(int fd)
+{
+	struct w32_io* pio;
+	if ((fd < 0) || (fd > MAX_FDS - 1) || fd_table.w32_ios[fd] == NULL) {
+		errno = EBADF;
+		return 0;
+	}
+
+	pio = fd_table.w32_ios[fd];
+	if (FILETYPE(pio) == FILE_TYPE_CHAR)
+		return 1;
+	else {
+		errno = EINVAL;
+		return 0;
+	}
+}
+
+FILE*
+w32_fdopen(int fd, const char *mode)
+{
+	errno = 0;
+	if ((fd < 0) || (fd > MAX_FDS - 1) || fd_table.w32_ios[fd] == NULL) {
+		errno = EBADF;
+		debug3("fdopen - ERROR bad fd: %d", fd);
+		return NULL;
+	}
+	return fileio_fdopen(fd_table.w32_ios[fd], mode);
+}
+
+int
+w32_close(int fd)
+{
+	struct w32_io* pio;
+	int r;
+	if ((fd < 0) || (fd > MAX_FDS - 1) || fd_table.w32_ios[fd] == NULL) {
+		errno = EBADF;
+		return -1;
+	}
+
+	pio = fd_table.w32_ios[fd];
+
+	debug4("close - io:%p, type:%d, fd:%d, table_index:%d", pio, pio->type, fd,
+		pio->table_index);
+	
+	if (pio->type == SOCK_FD)
+		r = socketio_close(pio);
+	else
+		r = fileio_close(pio);		
+
+	fd_table_clear(fd);
+	return r;
+}
+
+static int
+w32_io_process_fd_flags(struct w32_io* pio, int flags)
+{
+	DWORD shi_flags;
+	if (flags & ~FD_CLOEXEC) {
+		debug3("fcntl - ERROR unsupported flags %d, io:%p", flags, pio);
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	shi_flags = (flags & FD_CLOEXEC) ? 0 : HANDLE_FLAG_INHERIT;
+
+	HANDLE h = WINHANDLE(pio);
+	
+	/*
+	* Ignore if handle is not valid yet. It will not be valid for
+	* UF_UNIX sockets that are not connected yet
+	*/
+	if (IS_VALID_HANDLE(h) && (SetHandleInformation(h, HANDLE_FLAG_INHERIT, shi_flags) == FALSE)) {
+		debug3("fcntl - SetHandleInformation failed with error:%d, io:%p",
+			GetLastError(), pio);
+		errno = EOTHER;
+		return -1;
+	}
+
+	pio->fd_flags = flags;
+	return 0;
+}
+
+int
+w32_fcntl(int fd, int cmd, ... /* arg */)
+{
+	va_list valist;
+	va_start(valist, cmd);
+	int ret = 0;
+
+	CHECK_FD(fd);
+
+	switch (cmd) {
+	case F_GETFL:
+		ret = fd_table.w32_ios[fd]->fd_status_flags;
+		break;
+	case F_SETFL:
+		fd_table.w32_ios[fd]->fd_status_flags = va_arg(valist, int);
+		ret = 0;
+		break;
+	case F_GETFD:
+		ret = fd_table.w32_ios[fd]->fd_flags;
+		break;
+	case F_SETFD:
+		ret = w32_io_process_fd_flags(fd_table.w32_ios[fd], va_arg(valist, int));
+		break;
+	case F_DUPFD:
+		ret = dup(fd);
+		break;
+	default:
+		errno = EINVAL;
+		debug3("fcntl - ERROR not supported cmd:%d", cmd);
+		ret = -1;
+		break;
+	}
+
+	va_end(valist);
+	return ret;
+}
+
+#define SELECT_EVENT_LIMIT 512
+int
+w32_select(int fds, w32_fd_set* readfds, w32_fd_set* writefds, w32_fd_set* exceptfds, const struct timeval *timeout)
+{
+	ULONGLONG ticks_start = GetTickCount64(), ticks_spent;
+	w32_fd_set read_ready_fds, write_ready_fds;
+	HANDLE events[SELECT_EVENT_LIMIT];
+	int num_events = 0;
+	int in_set_fds = 0, out_ready_fds = 0, i;
+	unsigned int timeout_ms = 0, time_rem = 0;
+
+	errno = 0;
+	/* TODO - the size of these can be reduced based on fds */
+	memset(&read_ready_fds, 0, sizeof(w32_fd_set));
+	memset(&write_ready_fds, 0, sizeof(w32_fd_set));
+
+	if (timeout)
+		timeout_ms = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
+
+	if (fds > MAX_FDS) {
+		errno = EINVAL;
+		debug3("select - ERROR: invalid fds: %d", fds);
+		return -1;
+	}
+
+	if (!readfds && !writefds) {
+		errno = EINVAL;
+		debug3("select - ERROR: null fd_sets");
+		return -1;
+	}
+
+	/* TODO - see if this needs to be supported */
+	if (exceptfds) {
+		for (i = 0; i < fds; i++)
+			FD_CLR(i, exceptfds);
+	}
+
+	if (readfds) {
+		for (i = 0; i < fds; i++)
+			if (FD_ISSET(i, readfds)) {
+				CHECK_FD(i);
+				in_set_fds++;
+			}
+	}
+
+	if (writefds) {
+		for (i = 0; i < fds; i++)
+			if (FD_ISSET(i, writefds)) {
+				CHECK_FD(i);
+				in_set_fds++;
+			}
+	}
+
+	/* if none of input fds are set return error */
+	if (in_set_fds == 0) {
+		errno = EINVAL;
+		debug3("select - ERROR: empty fd_sets");
+		return -1;
+	}
+
+	debug5("Total in fds:%d", in_set_fds);
+	/*
+	 * start async io on selected fds if needed and pick up any events
+	 * that select needs to listen on
+	 */
+	for (int i = 0; i < fds; i++) {
+		if (readfds && FD_ISSET(i, readfds)) {
+			w32_io_on_select(fd_table.w32_ios[i], TRUE);
+			if ((fd_table.w32_ios[i]->type == SOCK_FD) &&
+			    (fd_table.w32_ios[i]->internal.state == SOCK_LISTENING)) {
+				if (num_events == SELECT_EVENT_LIMIT) {
+					debug3("select - ERROR: max #events breach");
+					errno = ENOMEM;
+					return -1;
+				}
+				events[num_events++] = fd_table.w32_ios[i]->read_overlapped.hEvent;
+			}
+		}
+
+		if (writefds && FD_ISSET(i, writefds)) {
+			w32_io_on_select(fd_table.w32_ios[i], FALSE);
+			if ((fd_table.w32_ios[i]->type == SOCK_FD) &&
+			    (fd_table.w32_ios[i]->internal.state == SOCK_CONNECTING)) {
+				if (num_events == SELECT_EVENT_LIMIT) {
+					debug3("select - ERROR: max #events reached for select");
+					errno = ENOMEM;
+					return -1;
+				}
+				events[num_events++] = fd_table.w32_ios[i]->write_overlapped.hEvent;
+			}
+		}
+	}
+
+	/* excute any scheduled APCs */
+	if (0 != wait_for_any_event(NULL, 0, 0))
+		return -1;
+
+	/* see if any io is ready */
+	for (i = 0; i < fds; i++) {
+		if (readfds && FD_ISSET(i, readfds)) {
+			if (w32_io_is_io_available(fd_table.w32_ios[i], TRUE)) {
+				FD_SET(i, &read_ready_fds);
+				out_ready_fds++;
+			}
+		}
+
+		if (writefds && FD_ISSET(i, writefds)) {
+			if (w32_io_is_io_available(fd_table.w32_ios[i], FALSE)) {
+				FD_SET(i, &write_ready_fds);
+				out_ready_fds++;
+			}
+		}
+	}
+
+	/* timeout specified and both fields are 0 - polling mode*/
+	/* proceed with further wait if not in polling mode*/
+	if ((timeout == NULL) || (timeout_ms != 0))
+		/* wait for io until any is ready */
+		while (out_ready_fds == 0) {
+			ticks_spent = GetTickCount64() - ticks_start;
+			time_rem = 0;
+
+			if (timeout != NULL) {
+				if (timeout_ms < ticks_spent) {
+					debug4("select - timing out");
+					break;
+				}
+				time_rem = timeout_ms - (ticks_spent & 0xffffffff);
+			}
+			else
+				time_rem = INFINITE;
+
+			if (0 != wait_for_any_event(events, num_events, time_rem))
+				return -1;
+
+			/* check on fd status */
+			out_ready_fds = 0;
+			for (int i = 0; i < fds; i++) {
+				if (readfds && FD_ISSET(i, readfds)) {
+					if (w32_io_is_io_available(fd_table.w32_ios[i], TRUE)) {
+						FD_SET(i, &read_ready_fds);
+						out_ready_fds++;
+					}
+				}
+
+				if (writefds && FD_ISSET(i, writefds)) {
+					if (w32_io_is_io_available(fd_table.w32_ios[i], FALSE)) {
+						FD_SET(i, &write_ready_fds);
+						out_ready_fds++;
+					}
+				}
+			}
+
+			if (out_ready_fds == 0)
+				debug5("select - wait ended without any IO completion, looping again");
+		}
+
+	/* clear out fds that are not ready yet */
+	if (readfds)
+		for (i = 0; i < fds; i++)
+			if (FD_ISSET(i, readfds)) {
+				if (FD_ISSET(i, &read_ready_fds)) {
+					/* for connect() initiated sockets finish WSA connect process*/
+					if ((fd_table.w32_ios[i]->type == SOCK_FD) &&
+						((fd_table.w32_ios[i]->internal.state == SOCK_CONNECTING)))
+						if (socketio_finish_connect(fd_table.w32_ios[i]) != 0) {
+							/* async connect failed, error will be picked up by recv or send */
+							errno = 0;
+						}
+				} else
+					FD_CLR(i, readfds);
+			}
+
+	if (writefds)
+		for (i = 0; i < fds; i++)
+			if (FD_ISSET(i, writefds)) {
+				if (FD_ISSET(i, &write_ready_fds)) {
+					/* for connect() initiated sockets finish WSA connect process*/
+					if ((fd_table.w32_ios[i]->type == SOCK_FD) &&
+					    ((fd_table.w32_ios[i]->internal.state == SOCK_CONNECTING)))
+						if (socketio_finish_connect(fd_table.w32_ios[i]) != 0) {
+							/* async connect failed, error will be picked up by recv or send */
+							errno = 0;
+						}
+				} else
+					FD_CLR(i, writefds);
+			}
+
+	debug5("select - returning %d", out_ready_fds);
+	return out_ready_fds;
+}
+
+static HANDLE
+dup_handle(int fd) 
+{
+	HANDLE h = fd_table.w32_ios[fd]->handle;
+	int is_sock = fd_table.w32_ios[fd]->type == SOCK_FD;
+
+	if (is_sock) {
+		SOCKET dup_sock;
+		SOCKET sock = (SOCKET)h;
+		WSAPROTOCOL_INFOW info;
+		if (WSADuplicateSocketW(sock, GetCurrentProcessId(), &info) != 0) {
+			errno = EOTHER;
+			error("WSADuplicateSocket failed, WSALastError: %d", WSAGetLastError());
+			return NULL;
+		} 
+		dup_sock = WSASocketW(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, &info, 0, 0);
+		if (dup_sock == INVALID_SOCKET) {
+			errno = EOTHER;
+			error("WSASocketW failed, WSALastError: %d", WSAGetLastError());
+			return NULL;
+		}
+		return (HANDLE)dup_sock;
+	}
+	else {
+		HANDLE dup_handle;
+		if (!DuplicateHandle(GetCurrentProcess(), h, GetCurrentProcess(), &dup_handle, 0, TRUE, DUPLICATE_SAME_ACCESS)) {
+			errno = EOTHER;
+			error("dup - ERROR: DuplicatedHandle() :%d", GetLastError());
+		}
+		return dup_handle;
+	}
+}
+
+int
+w32_dup2(int oldfd, int newfd)
+{
+	struct w32_io* pio;
+	CHECK_FD(oldfd);
+
+	if (fd_table.w32_ios[newfd])
+		w32_close(newfd);
+
+	pio = malloc(sizeof(struct w32_io));
+	if (pio == NULL) {
+		errno = ENOMEM;
+		return -1;
+	}
+
+	memset(pio, 0, sizeof(struct w32_io));
+	if ((pio->handle = dup_handle(oldfd)) == 0) {
+		free(pio);
+		return -1;
+	}
+
+	pio->type = fd_table.w32_ios[oldfd]->type;
+	if (pio->type == SOCK_FD)
+		pio->internal.state = SOCK_READY;
+
+	fd_table_set(pio, newfd);
+	return 0;
+}
+
+int
+w32_dup(int oldfd)
+{
+	int min_index, r;
+	CHECK_FD(oldfd);
+
+	if ((min_index = fd_table_get_min_index()) == -1)
+		return -1;
+
+	if ((r = w32_dup2(oldfd, min_index)) != 0)
+		return r;
+
+	return min_index;
+}
+
+
+
+HANDLE
+w32_fd_to_handle(int fd)
+{
+	return fd_table.w32_ios[fd]->handle;
+}
+
+int
+w32_ftruncate(int fd, off_t length)
+{
+	LARGE_INTEGER new_postion;
+	CHECK_FD(fd);
+
+	new_postion.QuadPart = length;
+	if (!SetFilePointerEx(w32_fd_to_handle(fd), new_postion, 0, FILE_BEGIN))
+		return -1;
+	if (!SetEndOfFile(w32_fd_to_handle(fd)))
+		return -1;
+
+	return 0;
+}
+
+int w32_fchmod(int fd, mode_t mode)
+{
+	wchar_t *file_path;
+	char *file_path_utf8 = NULL;
+	int ret = -1;
+	CHECK_FD(fd);
+
+	file_path = get_final_path_by_handle(fd_table.w32_ios[fd]->handle);
+	if (!file_path)
+		goto cleanup;
+
+	if ((file_path_utf8 = utf16_to_utf8(file_path)) == NULL)
+		goto cleanup;
+
+	ret = w32_chmod(file_path_utf8, mode);
+cleanup:
+	if (file_path_utf8)
+		free(file_path_utf8);
+
+	return ret;
+}
+
+int
+w32_fsync(int fd)
+{
+	CHECK_FD(fd);
+	return FlushFileBuffers(w32_fd_to_handle(fd));
+}
+
+int fork() 
+{ 
+	verbose("fork is not supported"); 
+	return -1;
+}
+char * build_commandline_string(const char* cmd, char *const argv[], BOOLEAN prepend_module_path);
+
+/*
+* spawn a child process
+* - specified by cmd with agruments argv
+* - with std handles set to in, out, err
+* - flags are passed to CreateProcess call
+* spawned child will run as as_user if its not NULL
+*/
+static int
+spawn_child_internal(const char* cmd, char *const argv[], HANDLE in, HANDLE out, HANDLE err, unsigned long flags, HANDLE as_user, BOOLEAN prepend_module_path)
+{
+	PROCESS_INFORMATION pi;
+	STARTUPINFOW si;
+	BOOL b;
+	char *cmdline;
+	wchar_t * cmdline_utf16 = NULL;
+	int ret = -1;
+	if ((cmdline = build_commandline_string(cmd, argv, prepend_module_path)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+	if ((cmdline_utf16 = utf8_to_utf16(cmdline)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	memset(&si, 0, sizeof(STARTUPINFOW));
+	si.cb = sizeof(STARTUPINFOW);
+	si.hStdInput = in;
+	si.hStdOutput = out;
+	si.hStdError = err;
+	si.dwFlags = STARTF_USESTDHANDLES;
+	
+	if (strstr(cmd, "sshd.exe")) {
+		flags |= DETACHED_PROCESS;
+	}
+
+	char* fidoDebug = NULL;
+	size_t len = 0;
+	_dupenv_s(&fidoDebug, &len, "FIDO_DEBUG");
+
+	if (is_bash_test_env() ||
+		(strstr(cmd, "ssh-pkcs11-helper.exe")) ||
+		((fidoDebug == NULL) && strstr(cmd, "ssh-sk-helper.exe"))) {
+		debug3("Creating process with CREATE_NO_WINDOW");
+		flags |= CREATE_NO_WINDOW;
+	}
+	
+	wchar_t * t = cmdline_utf16;
+	do {
+		if (as_user) {
+			debug3("spawning %ls as user", t);
+			b = CreateProcessAsUserW(as_user, NULL, t, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);
+		}
+		else {
+			debug3("spawning %ls as subprocess", t);
+			b = CreateProcessW(NULL, t, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);
+		}
+		if(b || GetLastError() != ERROR_FILE_NOT_FOUND || (argv != NULL && *argv != NULL) || cmd[0] == '\"')
+			break;
+		t++;
+		*(cmdline_utf16 + wcslen(cmdline_utf16) - 1) = L'\0';
+	} while (t == (cmdline_utf16 + 1));
+
+	if (b) {
+		if (register_child(pi.hProcess, pi.dwProcessId) == -1) {
+			TerminateProcess(pi.hProcess, 0);
+			CloseHandle(pi.hProcess);
+			goto cleanup;
+		}
+		CloseHandle(pi.hThread);
+		ret = pi.dwProcessId;
+	}
+	else {
+		errno = GetLastError();
+		error("%s failed error:%d", (as_user ? "CreateProcessAsUserW" : "CreateProcessW"), GetLastError());
+	}
+
+cleanup:
+	if (cmdline)
+		free(cmdline);
+	if (cmdline_utf16)
+		free(cmdline_utf16);
+
+	return ret;
+}
+
+#include "inc\spawn.h"
+
+/* structures defining binary layout of fd info to be transmitted between parent and child processes*/
+struct std_fd_state {
+	int num_inherited;
+	char in_type;
+	char out_type;
+	char err_type;
+	char padding;
+};
+
+struct inh_fd_state {
+	int handle;
+	short index;
+	char type;
+	char padding;
+};
+
+
+/* encodes the fd info into a base64 encoded binary blob */
+static char*
+fd_encode_state(const posix_spawn_file_actions_t *file_actions, HANDLE aux_h[])
+{
+	char *buf, *encoded;
+	struct std_fd_state *std_fd_state;
+	struct inh_fd_state *c;
+	DWORD len_req = 0;
+	BOOL b;
+	int i;
+	int fd_in = file_actions->stdio_redirect[STDIN_FILENO];
+	int fd_out = file_actions->stdio_redirect[STDOUT_FILENO];
+	int fd_err = file_actions->stdio_redirect[STDERR_FILENO];
+	int num_aux_fds = file_actions->num_aux_fds;
+	const int *parent_aux_fds = file_actions->aux_fds_info.parent_fd;
+	const int *child_aux_fds = file_actions->aux_fds_info.child_fd;
+
+	buf = malloc(8 * (1 + num_aux_fds));
+	if (!buf) {
+		errno = ENOMEM;
+		return NULL;
+	}
+
+	std_fd_state = (struct std_fd_state *)buf;
+	std_fd_state->num_inherited = num_aux_fds;
+	std_fd_state->in_type = fd_table.w32_ios[fd_in]->type;
+	std_fd_state->out_type = fd_table.w32_ios[fd_out]->type;
+	std_fd_state->err_type = fd_table.w32_ios[fd_err]->type;
+
+	c = (struct inh_fd_state*)(buf + 8);
+	for (i = 0; i < num_aux_fds; i++) {
+		c->handle = (int)(intptr_t)aux_h[i];
+		c->index = child_aux_fds[i];
+		c->type = fd_table.w32_ios[parent_aux_fds[i]]->type;
+		c++;
+	}
+
+	b = CryptBinaryToStringA(buf, 8 * (1 + num_aux_fds), CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL, &len_req);
+	encoded = malloc(len_req);
+	if (!encoded) {
+		free(buf);
+		errno = ENOMEM;
+		return NULL;
+	}
+	b = CryptBinaryToStringA(buf, 8 * (1 + num_aux_fds), CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, encoded, &len_req);
+
+	free(buf);
+	return encoded;
+}
+
+/* decodes fd info from an encoded binary blob */
+static void
+fd_decode_state(char* enc_buf)
+{
+	char* buf;
+	DWORD req = 0, skipped, out_flags;
+	struct std_fd_state *std_fd_state;
+	struct inh_fd_state *c;
+	int num_inherited = 0;
+
+	CryptStringToBinary(enc_buf, 0, CRYPT_STRING_BASE64 | CRYPT_STRING_STRICT, NULL, &req, &skipped, &out_flags);
+	buf = malloc(req);
+	if (!buf) 
+		fatal("out of memory");
+
+	CryptStringToBinary(enc_buf, 0, CRYPT_STRING_BASE64 | CRYPT_STRING_STRICT, buf, &req, &skipped, &out_flags);
+
+	std_fd_state = (struct std_fd_state *)buf;
+	fd_table.w32_ios[0]->type = std_fd_state->in_type;
+	if (fd_table.w32_ios[0]->type == SOCK_FD)
+		fd_table.w32_ios[0]->internal.state = SOCK_READY;
+	fd_table.w32_ios[1]->type = std_fd_state->out_type;
+	if (fd_table.w32_ios[1]->type == SOCK_FD)
+		fd_table.w32_ios[1]->internal.state = SOCK_READY;
+	fd_table.w32_ios[2]->type = std_fd_state->err_type;
+	if (fd_table.w32_ios[2]->type == SOCK_FD)
+		fd_table.w32_ios[2]->internal.state = SOCK_READY;
+	num_inherited = std_fd_state->num_inherited;
+
+	c = (struct inh_fd_state*)(buf + 8);
+	while (num_inherited--) {
+		struct w32_io* pio = malloc(sizeof(struct w32_io));
+		if (!pio)
+			fatal("out of memory");
+		ZeroMemory(pio, sizeof(struct w32_io));
+		pio->handle = (void*)(INT_PTR)c->handle;
+		pio->type = c->type;
+		if (pio->type == SOCK_FD)
+			pio->internal.state = SOCK_READY;
+		fd_table_set(pio, c->index);
+		c++;
+	}
+
+	free(buf);
+	return;
+}
+
+int
+posix_spawn_internal(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], HANDLE user_token, BOOLEAN prepend_module_path)
+{
+	int i, ret = -1;
+	int sc_flags = 0;
+	char* fd_info = NULL;
+	HANDLE aux_handles[MAX_INHERITED_FDS];
+	HANDLE stdio_handles[STDERR_FILENO + 1];
+	if (file_actions == NULL || envp) {
+		errno = ENOTSUP;
+		return -1;
+	}
+
+	if (attrp && attrp->flags == POSIX_SPAWN_SETPGROUP)
+		sc_flags = CREATE_NEW_PROCESS_GROUP;
+
+	/* prepare handles */
+	memset(stdio_handles, 0, sizeof(stdio_handles));
+	memset(aux_handles, 0, sizeof(aux_handles));
+	stdio_handles[STDIN_FILENO] = dup_handle(file_actions->stdio_redirect[STDIN_FILENO]);
+	stdio_handles[STDOUT_FILENO] = dup_handle(file_actions->stdio_redirect[STDOUT_FILENO]);
+	stdio_handles[STDERR_FILENO] = dup_handle(file_actions->stdio_redirect[STDERR_FILENO]);
+	if (!stdio_handles[STDIN_FILENO] || !stdio_handles[STDOUT_FILENO] || !stdio_handles[STDERR_FILENO]) 
+		goto cleanup;
+	
+	for (i = 0; i < file_actions->num_aux_fds; i++) {
+		aux_handles[i] = dup_handle(file_actions->aux_fds_info.parent_fd[i]);
+		if (aux_handles[i] == NULL) 
+			goto cleanup;
+	}
+
+	/* set fd info */
+	if ((fd_info = fd_encode_state(file_actions, aux_handles)) == NULL)
+		goto cleanup;
+
+	if (_putenv_s(POSIX_FD_STATE, fd_info) != 0)
+		goto cleanup;
+	i = spawn_child_internal(path, argv + 1, stdio_handles[STDIN_FILENO], stdio_handles[STDOUT_FILENO], stdio_handles[STDERR_FILENO], sc_flags, user_token, prepend_module_path);
+	if (i == -1)
+		goto cleanup;
+	if (pidp)
+		*pidp = i;
+	ret = 0;
+cleanup:
+	_putenv_s(POSIX_FD_STATE, "");
+	for (i = 0; i <= STDERR_FILENO; i++) {
+		if (stdio_handles[i] != NULL) {
+			if (fd_table.w32_ios[file_actions->stdio_redirect[i]]->type == SOCK_FD)
+				closesocket((SOCKET)stdio_handles[i]);
+			else
+				CloseHandle(stdio_handles[i]);
+		}
+	}
+	for (i = 0; i < file_actions->num_aux_fds; i++) {
+		if (aux_handles[i] != NULL) {
+			if (fd_table.w32_ios[file_actions->aux_fds_info.parent_fd[i]]->type == SOCK_FD)
+				closesocket((SOCKET)aux_handles[i]);
+			else
+				CloseHandle(aux_handles[i]);
+		}
+	}
+	if (fd_info)
+		free(fd_info);
+	
+	return ret;
+}
+
+int
+posix_spawn(pid_t *pidp, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[])
+{
+	return posix_spawn_internal(pidp, path, file_actions, attrp, argv, envp, NULL, TRUE);
+}
+
+int
+posix_spawnp(pid_t *pidp, const char *file, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[])
+{
+	return posix_spawn_internal(pidp, file, file_actions, attrp, argv, envp, NULL, FALSE);
+}
+
+int
+posix_spawn_as_user(pid_t *pidp, const char *file, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], HANDLE user_token)
+{
+	return posix_spawn_internal(pidp, file, file_actions, attrp, argv, envp, user_token, TRUE);
+}
+
+int
+posix_spawnp_as_user(pid_t *pidp, const char *file, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[], HANDLE user_token)
+{
+	return posix_spawn_internal(pidp, file, file_actions, attrp, argv, envp, user_token, FALSE);
+}
diff --git a/contrib/win32/win32compat/w32fd.h b/contrib/win32/win32compat/w32fd.h
new file mode 100644
index 000000000..0f1ee3a08
--- /dev/null
+++ b/contrib/win32/win32compat/w32fd.h
@@ -0,0 +1,170 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Definitions for Win32 wrapper functions with POSIX like signatures
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#pragma once
+
+#include <Windows.h>
+#include <stdio.h>
+#include "inc\sys\types.h"
+
+enum w32_io_type {
+	UNKNOWN_FD = 0,
+	SOCK_FD = 1,	/*maps a socket fd*/
+	NONSOCK_FD = 2,	/*maps a file fd, pipe fd or a tty fd*/
+	/*
+	 * maps a NONSOCK_FD that doesnt support async or overlapped io
+	 * these are typically used for stdio on ssh client side
+	 * executables (ssh, sftp and scp). 
+	 * Ex. ssh ... > output.txt
+	 *   In the above case, stdout passed to ssh.exe is a handle to 
+	 *   output.txt that is opened in non-overlapped mode
+	 * Ex. sample.exe | ssh ...
+	 *   In the above case, stdin passed to ssh.exe is a handle to
+	 *   a pipe opened in non-overlapped mode
+         * Ex. in Powershell
+	 * $o = ssh ...
+	 *   In the above case, stdout passed to ssh.exe is a handle to 
+	 *   a pipe opened in non-overlapped mode 
+	 */
+	NONSOCK_SYNC_FD = 3 
+};
+
+enum w32_io_sock_state {
+	SOCK_INITIALIZED = 0,
+	SOCK_LISTENING = 1,	/*listen called on socket*/
+	SOCK_CONNECTING = 2,	/*connect called on socket, connect is in progress*/
+	SOCK_READY = 3		/*recv and send can be done*/
+};
+
+/*
+* This structure encapsulates the I/O state info needed to map a File Descriptor
+* to Win32 Handle
+*/
+struct w32_io {
+	OVERLAPPED read_overlapped;
+	OVERLAPPED write_overlapped;
+	struct {
+		char *buf; /*internal read buffer*/
+		DWORD buf_size;
+		DWORD remaining; /*bytes in internal buffer remaining to be read by application*/
+		DWORD completed; /*bytes in internal buffer already read by application*/
+		BOOL pending;	 /*waiting on a read operation to complete*/
+		DWORD error;	 /*error reported on async read or accept completion*/
+	}read_details;
+	struct {
+		char *buf; /*internal write buffer*/
+		DWORD buf_size;
+		DWORD remaining; /*bytes in internal buffer remaining to be written to network*/
+		DWORD completed; /*bytes in internal buffer already written to network*/
+		BOOL pending;	 /*waiting on a write operation to complete*/
+		DWORD error;	 /*error reported on async write or connect completion*/
+	}write_details;
+
+	/*index at which this object is stored in fd_table*/
+	int table_index;
+	enum w32_io_type type;		/*hanldle type*/
+	DWORD fd_flags;			/*fd flags from POSIX*/
+	DWORD fd_status_flags;		/*fd status flags from POSIX*/
+
+	/*underlying w32 handle*/
+	union {
+		SOCKET sock;
+		HANDLE handle;
+	};
+
+	/*internal state used by synchronous io - terminal handles and external 
+	  handles passed through std io*/
+	struct {
+		DWORD to_transfer;
+		DWORD transferred;
+		DWORD error;
+	}sync_read_status;
+	struct {
+		DWORD to_transfer;
+		DWORD transferred;
+		DWORD error;
+	}sync_write_status;
+
+	/*handle specific internal state context, used by sockets and pipes*/
+	struct {
+		enum w32_io_sock_state state;
+		void* context;
+	}internal;
+};
+
+#define WINHANDLE(pio) ((pio)->handle)
+#define FILETYPE(pio) (GetFileType(WINHANDLE(pio)))
+extern HANDLE main_thread;
+
+BOOL w32_io_is_blocking(struct w32_io*);
+BOOL w32_io_is_io_available(struct w32_io* pio, BOOL rd);
+int wait_for_any_event(HANDLE* events, int num_events, DWORD milli_seconds);
+
+/*POSIX mimic'ing socket API and socket helper API*/
+int socketio_initialize();
+int socketio_done();
+BOOL socketio_is_io_available(struct w32_io* pio, BOOL rd);
+void socketio_on_select(struct w32_io* pio, BOOL rd);
+struct w32_io* socketio_socket(int domain, int type, int protocol);
+struct w32_io* socketio_accept(struct w32_io* pio, struct sockaddr* addr, int* addrlen);
+int socketio_setsockopt(struct w32_io* pio, int level, int optname, const char* optval, int optlen);
+int socketio_getsockopt(struct w32_io* pio, int level, int optname, char* optval, int* optlen);
+int socketio_getsockname(struct w32_io* pio, struct sockaddr* name, int* namelen);
+int socketio_getpeername(struct w32_io* pio, struct sockaddr* name, int* namelen);
+int socketio_listen(struct w32_io* pio, int backlog);
+int socketio_bind(struct w32_io* pio, const struct sockaddr *name, int namelen);
+int socketio_connect(struct w32_io* pio, const struct sockaddr* name, int namelen);
+int socketio_finish_connect(struct w32_io* pio);
+int socketio_recv(struct w32_io* pio, void *buf, size_t len, int flags);
+int socketio_send(struct w32_io* pio, const void *buf, size_t len, int flags);
+int socketio_shutdown(struct w32_io* pio, int how);
+int socketio_close(struct w32_io* pio);
+
+/*POSIX mimic'ing file API and file helper API*/
+BOOL fileio_is_io_available(struct w32_io* pio, BOOL rd);
+void fileio_on_select(struct w32_io* pio, BOOL rd);
+int fileio_close(struct w32_io* pio);
+int fileio_pipe(struct w32_io* pio[2], int);
+struct w32_io* fileio_afunix_socket();
+int fileio_connect(struct w32_io*, char*);
+struct w32_io* fileio_open(const char *pathname, int flags, mode_t mode);
+int fileio_read(struct w32_io* pio, void *dst, size_t max);
+int fileio_write_wrapper(struct w32_io* pio, const void* buf, size_t bytes_to_copy);
+int fileio_write(struct w32_io* pio, const void *buf, size_t max);
+int fileio_fstat(struct w32_io* pio, struct _stat64 *buf);
+int fileio_stat(const char *path, struct _stat64 *buf);
+int fileio_lstat(const char *path, struct _stat64 *buf);
+long fileio_lseek(struct w32_io* pio, unsigned __int64 offset, int origin);
+FILE* fileio_fdopen(struct w32_io* pio, const char *mode);
+ssize_t fileio_readlink(const char *path, char *buf, size_t bufsiz);
+int fileio_symlink(const char *target, const char *linkpath);
+int fileio_link(const char *oldpath, const char *newpath);
\ No newline at end of file
diff --git a/contrib/win32/win32compat/w32log.c b/contrib/win32/win32compat/w32log.c
new file mode 100644
index 000000000..b161066d3
--- /dev/null
+++ b/contrib/win32/win32compat/w32log.c
@@ -0,0 +1,206 @@
+/*
+* Copyright (c) 2016 Microsoft Corp.
+* All rights reserved
+*
+* Implementation of sys log for windows:
+* openlog(), closelog, syslog
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <Windows.h>
+#include <io.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include "inc/sys/stat.h"
+
+#include "inc\syslog.h"
+#include "misc_internal.h"
+#include "inc\utf.h"
+#include "openssh-events.h"
+
+#define MSGBUFSIZ 1024
+static int logfd = -1;
+static int sftp_server_logfd = -1;
+const char* identity = NULL;
+int log_facility = 0;
+
+void openlog_etw()
+{
+	EventRegisterOpenSSH();
+}
+
+void
+syslog_etw(int priority, const char *format, const char *formatBuffer)
+{
+	wchar_t *w_identity = NULL, *w_payload = NULL;
+	w_identity = utf8_to_utf16(identity);
+	w_payload = utf8_to_utf16(formatBuffer);
+
+	if (!w_identity || !w_payload)
+		goto done;
+
+	switch (priority) {
+	case LOG_CRIT:
+		EventWriteCRITICAL_Event(w_identity, w_payload);
+		break;
+	case LOG_ERR:
+		EventWriteERROR_Event(w_identity, w_payload);
+		break;
+	case LOG_WARNING:
+		EventWriteWARNING_Event(w_identity, w_payload);
+		break;
+	case LOG_INFO:
+		EventWriteINFO_Event(w_identity, w_payload);
+		break;
+	case LOG_DEBUG:
+		EventWriteDEBUG_Event(w_identity, w_payload);
+		break;
+	default:
+		break;
+	}
+
+done:
+	if (w_identity)
+		free(w_identity);
+	if (w_payload)
+		free(w_payload);
+}
+
+
+/*
+ * log file location will be - "%programData%\\openssh\\logs\\<module_name>.log"
+ */
+void
+openlog_file()
+{	
+	if (strcmp(identity, "sftp-server") == 0 && sftp_server_logfd != -1)
+		return;
+
+	if (strcmp(identity, "sftp-server") != 0 && logfd != -1)
+		return;
+	
+	wchar_t *logs_dir = L"\\logs\\";
+	wchar_t module_path[PATH_MAX] = { 0 }, log_file[PATH_MAX + 12] = { 0 };
+	wchar_t* tmp_identity = NULL;
+
+	if (GetModuleFileNameW(NULL, module_path, PATH_MAX) == 0)
+		return;
+
+	if (wcsnlen(module_path, PATH_MAX) > PATH_MAX - wcslen(logs_dir))
+		return;
+
+	/* split path root and module */
+	{
+		wchar_t* tail = module_path + wcsnlen(module_path, PATH_MAX);
+		while (tail > module_path && *tail != L'\\' && *tail != L'/')
+			tail--;
+		
+		wchar_t ssh_cfg_path[PATH_MAX] = {0 ,};
+		wcscat_s(ssh_cfg_path, _countof(ssh_cfg_path), __wprogdata); /* "%programData%" */
+		wcscat_s(ssh_cfg_path, _countof(ssh_cfg_path), L"\\ssh"); /* "%programData%\\ssh" */
+		if (strcmp(identity, "sftp-server") == 0) {
+			tmp_identity = utf8_to_utf16(identity);
+			if (!tmp_identity)
+				goto cleanup;
+		}
+		else {
+			tmp_identity = malloc(wcslen(tail) * sizeof(wchar_t)); // CodeQL [SM01952]: false positive enough space for null terminator provided
+			if (!tmp_identity)
+				goto cleanup;
+			if (wcsncpy_s(tmp_identity, wcslen(tail), tail + 1, wcslen(tail) - 5) != 0) {
+				goto cleanup;
+			}		
+		}
+
+		if ((wcsncat_s(log_file, PATH_MAX + 12, ssh_cfg_path, wcslen(ssh_cfg_path)) != 0) ||
+		    (wcsncat_s(log_file, PATH_MAX + 12, logs_dir, 6) != 0) ||
+		    (wcsncat_s(log_file, PATH_MAX + 12, tmp_identity, wcslen(tmp_identity)) != 0) ||
+		    (wcsncat_s(log_file, PATH_MAX + 12, L".log", 4) != 0))
+			goto cleanup;
+	}
+	
+	int* fd_ptr = &logfd;
+	
+	if (strcmp(identity, "sftp-server") == 0)
+		fd_ptr = &sftp_server_logfd;
+
+	errno_t err = _wsopen_s(fd_ptr, log_file, _O_WRONLY | _O_CREAT | _O_APPEND, _SH_DENYNO, S_IREAD | S_IWRITE);
+
+cleanup:
+	if (tmp_identity)
+		free(tmp_identity);
+}
+
+void
+syslog_file(int priority, const char *format, const char *formatBuffer)
+{
+	char msgbufTimestamp[MSGBUFSIZ];
+	SYSTEMTIME st;
+	int r;
+	int msg_fd;
+	
+	if (strcmp(identity, "sftp-server") == 0)
+		msg_fd = sftp_server_logfd;
+	else
+		msg_fd = logfd;
+
+	if (msg_fd == -1)
+		return;
+
+	GetLocalTime(&st);
+	r = _snprintf_s(msgbufTimestamp, sizeof(msgbufTimestamp), _TRUNCATE, "%d %04d-%02d-%02d %02d:%02d:%02d.%03d %s\n",
+		GetCurrentProcessId(), st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond,
+		st.wMilliseconds, formatBuffer);
+	if (r == -1) {
+		_write(msg_fd, "_snprintf_s failed.", 20);
+		return;
+	}
+	msgbufTimestamp[strnlen(msgbufTimestamp, MSGBUFSIZ)] = '\0';
+	_write(msg_fd, msgbufTimestamp, (unsigned int)strnlen(msgbufTimestamp, MSGBUFSIZ));
+}
+
+void
+openlog(const char *ident, unsigned int option, int facility)
+{
+	identity = ident;
+	log_facility = facility;
+	if (log_facility == LOG_LOCAL0)
+		openlog_file();
+	else
+		openlog_etw();
+}
+
+void
+syslog(int priority, const char *format, const char *formatBuffer)
+{
+	if (log_facility == LOG_LOCAL0)
+		syslog_file(priority, format, formatBuffer);
+	else
+		syslog_etw(priority, format, formatBuffer);
+}
+
+void
+closelog(void)
+{
+	/*NOOP*/
+}
diff --git a/contrib/win32/win32compat/win32-utf8.c b/contrib/win32/win32compat/win32-utf8.c
new file mode 100644
index 000000000..30d9bc5d1
--- /dev/null
+++ b/contrib/win32/win32compat/win32-utf8.c
@@ -0,0 +1,121 @@
+/* 
+ * Windows versions of functions implemented in utf8.c
+ */
+#include <stdio.h>
+#include <stdarg.h>
+#include <Windows.h>
+
+#include "console.h"
+
+// previous codepage
+UINT g_previous_codepage = 0;
+
+void
+mrestorelocale(void);
+
+int
+vfmprintf(FILE *stream, const char *fmt, va_list ap)
+{
+	DWORD saved_mode = 0, new_mode = 0;
+	int ret;
+	HANDLE hFile;
+	hFile = get_console_handle(stream, &saved_mode);
+	if(hFile != INVALID_HANDLE_VALUE &&
+		((saved_mode & ENABLE_VIRTUAL_TERMINAL_PROCESSING) == ENABLE_VIRTUAL_TERMINAL_PROCESSING)) {
+			new_mode = saved_mode & (~ENABLE_VIRTUAL_TERMINAL_PROCESSING);
+			SetConsoleMode(hFile, new_mode);
+	}
+	
+	ret = vfprintf(stream, fmt, ap);
+	if (saved_mode != 0 && new_mode != saved_mode)
+		SetConsoleMode(hFile, saved_mode);
+	return ret;
+}
+
+int
+mprintf(const char *fmt, ...)
+{
+	int ret = 0;
+	va_list ap;
+	va_start(ap, fmt);
+	ret = vfmprintf(stdout, fmt, ap);
+	va_end(ap);
+	return ret;
+}
+
+int
+fmprintf(FILE *stream, const char *fmt, ...)
+{
+	int ret = 0;
+	va_list ap;
+	va_start(ap, fmt);
+	ret = vfmprintf(stream, fmt, ap);
+	va_end(ap);
+	return ret;
+}
+
+int
+snmprintf(char *buf, size_t len, int *written, const char *fmt, ...)
+{
+	int ret;
+	va_list valist;
+	va_start(valist, fmt);
+	ret = vsnprintf_s(buf, len, _TRUNCATE, fmt, valist);		
+	va_end(valist);
+	if (written != NULL && ret != -1)
+		*written = ret;
+	return ret;
+}
+
+/* TODO - Make windows implementation insync with Unix */
+int
+vasnmprintf(char **str, size_t maxsz, int *wp, const char *fmt, va_list ap)
+{
+	int ret;
+	size_t sz;
+
+	if((sz = vsnprintf(NULL, 0, fmt, ap)) < 0)
+		return -1;
+
+	*str = (char *) malloc(sizeof(char) * (sz + 1));
+	ret = vsnprintf_s(*str, sz + 1, _TRUNCATE, fmt, ap);		
+	if (wp != NULL && ret != -1)
+		*wp = ret;
+
+	return ret;
+}
+
+int
+asmprintf(char **outp, size_t sz, int *written, const char *fmt, ...)
+{
+	int ret;
+	va_list valist;
+	va_start(valist, fmt);
+	ret = vasnmprintf(outp, sz, written, fmt, valist);
+	va_end(valist);
+
+	return ret;
+}
+
+void
+msetlocale(void)
+{
+	// save previous codepage
+	g_previous_codepage = GetConsoleOutputCP();
+
+	// allow console output of unicode characters
+	SetConsoleOutputCP(CP_UTF8);
+
+	// register a restore function at exit
+	atexit(mrestorelocale);
+}
+
+void
+mrestorelocale(void)
+{
+	if( 0 != g_previous_codepage )
+	{
+		// restore console output codepage to previous one
+		SetConsoleOutputCP(g_previous_codepage);
+	}
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/win32_dirent.c b/contrib/win32/win32compat/win32_dirent.c
new file mode 100644
index 000000000..8b63d0811
--- /dev/null
+++ b/contrib/win32/win32compat/win32_dirent.c
@@ -0,0 +1,296 @@
+/*
+* Copyright (c) 2016 Microsoft Corp.
+* All rights reserved
+*
+* directory entry functions in Windows platform like Ubix/Linux
+* opendir(), readdir(), closedir().
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <windows.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <string.h>
+
+#include "inc\utf.h"
+#include "inc\dirent.h"
+#include "inc\libgen.h"
+#include "misc_internal.h"
+
+struct DIR_ {
+	intptr_t hFile;
+	struct _wfinddata_t c_file;
+	int first;
+	wchar_t * nextdisk;
+};
+
+#define ATTR_ROOTDIR  UINT_MAX
+
+/* Enumerate all devices which have drive name.
+Return a DIR stream on the root directory, or NULL if it could not be enumerated. */
+DIR *
+openrootdir()
+{
+	int hr = 0;
+	DWORD dw;
+	DIR * pdir;
+	struct _wfinddata_t c_file = {0};
+	wchar_t * p;
+
+	dw = GetLogicalDriveStringsW(_countof(c_file.name) - 2, c_file.name);
+	if (!dw) {
+		errno = ENODEV;
+		return NULL;
+	}
+	c_file.attrib = ATTR_ROOTDIR;
+	c_file.size = 0;
+	p = c_file.name;
+	while (*p) {
+		size_t len = wcslen(p);
+		if (len == 0)
+			break;
+		p += len + 1;
+		c_file.size++;
+	}
+	if (c_file.size == 0) {
+		errno = ENODEV;
+		return NULL;
+	}
+	pdir = malloc(sizeof(DIR));
+	if (!pdir) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	memset(pdir, 0, sizeof(DIR));
+	pdir->hFile = 0;
+	if (memcpy_s(&pdir->c_file, sizeof(c_file), &c_file, sizeof(c_file))) {
+		return NULL;
+	}
+	pdir->first = 1;
+
+	return pdir;
+}
+
+/* Open a directory stream on NAME.
+   Return a DIR stream on the directory, or NULL if it could not be opened.  */
+DIR *
+opendir(const char *name)
+{
+	struct _wfinddata_t c_file;
+	intptr_t hFile;
+	DIR *pdir;
+	wchar_t searchstr[PATH_MAX];
+	wchar_t* wname = NULL;
+	size_t len;
+
+	if ((wname = resolved_path_utf16(name)) == NULL) 
+		return NULL;
+
+	/* Detect root dir */
+	if (wcscmp(wname, L"/") == 0)
+		return openrootdir();
+
+	convertToBackslashW(wname);
+	len = wcslen(wname);
+	if (len && wname[len-1] == L'\\') {
+		len--;
+		wname[len] = 0;
+	}
+	if (len >= PATH_MAX) {
+		free(wname);
+		errno = ENAMETOOLONG;
+		return NULL;
+	}
+
+	/* add *.* for Windows _findfirst() search pattern */
+	swprintf_s(searchstr, _countof(searchstr) - 1, L"%s\\*.*", wname);
+	free(wname);
+
+	if ((hFile = _wfindfirst(searchstr, &c_file)) == -1L)
+		return NULL; /* errno is set by _wfindfirst */
+	else {
+		if ((pdir = malloc(sizeof(DIR))) == NULL) {
+			_findclose(hFile);
+			errno = ENOMEM;
+			return NULL;
+		}
+
+		memset(pdir, 0, sizeof(DIR));
+		pdir->hFile = hFile;
+		if (memcpy_s(&pdir->c_file, sizeof(c_file), &c_file, sizeof(c_file))) {
+			_findclose(hFile);
+			return NULL;
+		}
+		pdir->first = 1;
+
+		return pdir;
+	}
+}
+
+/* Close the directory stream DIRP.
+   Return 0 if successful, -1 if not.  */
+int 
+closedir(DIR *dirp)
+{
+	if(!dirp) return -1;
+
+	if (dirp && (dirp->hFile)) {
+		_findclose(dirp->hFile);
+	}
+	free(dirp);
+
+	return 0;
+}
+
+/* Read a root directory entry from DIRP.
+   Return a pointer to a `struct dirent' describing the entry,
+   or NULL for EOF or error.  The storage returned may be overwritten
+   by a later readdir call on the same DIR stream.  */
+struct dirent *
+readrootdir(DIR * dirp)
+{
+	wchar_t * p;
+	size_t len = 0;
+	struct dirent *pdirentry;
+	UINT dt;
+	ULARGE_INTEGER totalNumberOfBytes;
+	BOOL x;
+
+	if (dirp->c_file.size <= 0) {
+		errno = ENODATA;
+		return NULL;
+	}
+	if (dirp->first) {
+		dirp->first = 0;
+		dirp->nextdisk = dirp->c_file.name;
+	}
+
+	p = dirp->nextdisk;
+
+	for ( ; ; p += len + 1) {
+		len = wcslen(p);
+		if (len == 0) {
+			dirp->nextdisk = p;
+			errno = ENODATA;
+			return NULL;     /* end of multi-string */
+		}
+
+		dt = GetDriveTypeW(p);
+		if (dt == DRIVE_UNKNOWN || dt == DRIVE_NO_ROOT_DIR || dt == DRIVE_RAMDISK)
+			continue;
+
+		x = GetDiskFreeSpaceExW(p, NULL, &totalNumberOfBytes, NULL);
+		if (!x || totalNumberOfBytes.QuadPart == 0)
+			continue;
+
+		break;   // process filtered disk
+	}
+	dirp->nextdisk = p + len + 1;
+
+	if ((pdirentry = malloc(sizeof(struct dirent))) == NULL) {
+		errno = ENOMEM;
+		return NULL;
+	}
+	pdirentry->d_name[0] = (char)p[0];
+	pdirentry->d_name[1] = ':';
+	pdirentry->d_name[2] = 0;
+
+	pdirentry->d_ino = 1; // a fictious one like UNIX to say it is nonzero
+	return pdirentry;
+}
+
+/* Read a directory entry from DIRP.
+   Return a pointer to a `struct dirent' describing the entry,
+   or NULL for EOF or error.  The storage returned may be overwritten
+   by a later readdir call on the same DIR stream.  */
+struct dirent *
+readdir(void *avp)
+{
+	if(!avp) return NULL;
+
+	static struct dirent pdirentry;
+	struct _wfinddata_t c_file;
+	DIR *dirp = (DIR *)avp;
+	char *tmp = NULL;
+
+	if (dirp->hFile == 0 && dirp->c_file.attrib == ATTR_ROOTDIR)
+		return readrootdir(dirp);
+
+	for (;;) {
+		if (dirp->first) {
+			if (memcpy_s(&c_file, sizeof(c_file), &dirp->c_file, sizeof(c_file))) {
+				return NULL;
+			}
+			dirp->first = 0;
+		} else if (_wfindnext(dirp->hFile, &c_file) != 0)
+			return NULL;
+
+		if (wcscmp(c_file.name, L".") == 0 || wcscmp(c_file.name, L"..") == 0)
+			continue;
+
+		if ((tmp = utf16_to_utf8(c_file.name)) == NULL) {
+			errno = ENOMEM;
+			return NULL;
+		}
+
+		if (strncpy_s(pdirentry.d_name, PATH_MAX, tmp, strlen(tmp) + 1)) {
+			return NULL;
+		}
+		free(tmp);
+
+		pdirentry.d_ino = 1; /* a fictious one like UNIX to say it is nonzero */
+		return &pdirentry;
+	}
+}
+
+/* return last part of a path. The last path being a filename */
+char *
+basename(char *path)
+{
+	char *pdest;
+	const char *endp;
+	static char bname[PATH_MAX];
+
+	/* Find any trailing slashes */
+	endp = path + strlen(path) - 1;
+	while (endp > path && (*endp == '/' || *endp == '\\'))
+		endp--;
+
+	int path_len = endp - path + 1;
+	if (strncpy_s(bname, PATH_MAX, path, path_len + 1)) {
+		return NULL;
+	}
+	bname[path_len] = '\0';
+
+	if (!path)
+		return ".";
+	pdest = strrchr(bname, '/');
+	if (pdest)
+		return (pdest + 1);
+	pdest = strrchr(bname, '\\');
+	if (pdest)
+		return (pdest + 1);
+
+	return path; /* path does not have a slash */
+}
diff --git a/contrib/win32/win32compat/win32_groupaccess.c b/contrib/win32/win32compat/win32_groupaccess.c
new file mode 100644
index 000000000..a8beecdd0
--- /dev/null
+++ b/contrib/win32/win32compat/win32_groupaccess.c
@@ -0,0 +1,332 @@
+/*
+ *
+ * Author: Manoj Ampalam <manoj.ampalam@microsoft.com> 
+ *   groupaccess interface implementation for Windows
+ *
+ * Author: Bryan Berns <berns@uwalumni.com>
+ *   Added support for running configuration rules against nested groups 
+ *   spawning multiple domains/forests.
+ *   Core logic implemented in get_user_groups()
+ *
+ * Copyright (c) 2018 Microsoft Corp.
+ * All rights reserved
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define UMDF_USING_NTSTATUS 
+#define SECURITY_WIN32
+#include <Windows.h>
+#include <LM.h>
+#include <Sddl.h>
+#include <Aclapi.h>
+#include <Ntsecapi.h>
+#include <security.h>
+#include <ntstatus.h>
+#include <stdio.h>
+
+#define __attribute__(a)
+#include "inc/sys/types.h"
+#include "..\..\..\xmalloc.h"
+#include "..\..\..\groupaccess.h"
+#include "..\..\..\match.h"
+#include "..\..\..\log.h"
+
+#include "misc_internal.h"
+
+static int ngroups;
+static char **groups_byname;
+static char *user_name;
+static HANDLE user_token;
+
+/*
+* This method will fetch all the groups (listed below) even if the user is indirectly a member.
+* - Local machine groups
+* - Domain groups
+* - global group
+* - universal groups
+*/
+static int
+get_user_groups()
+{
+	/* early declarations and initializations to support cleanup */
+	HANDLE logon_token = user_token;
+	PTOKEN_GROUPS group_buf = NULL;
+	int ret = -1, num_groups = 0;
+	static int processed = 0;
+
+	if (processed)
+		return 0;
+
+	/* initialize return values */
+	errno = 0;
+	char ** user_groups = NULL;
+
+	debug2("%s: extracting all groups of user %s", __func__, user_name);
+
+	/* fetch the computer name so we can determine if the specified user is local or not */
+	wchar_t computer_name[CNLEN + 1];
+	DWORD computer_name_size = ARRAYSIZE(computer_name);
+	if (GetComputerNameW(computer_name, &computer_name_size) == 0)  {
+		debug3("%s: GetComputerNameW() failed: %d", __FUNCTION__, GetLastError());
+		errno = EOTHER;
+		goto cleanup;
+	}
+
+	/* allocate area for group information */
+	DWORD group_size = 0;
+	if (GetTokenInformation(logon_token, TokenGroups, NULL, 0, &group_size) == 0
+		&& GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
+		(group_buf = (PTOKEN_GROUPS)malloc(group_size)) == NULL) { // CodeQL [SM02320]: GetTokenInformation will initialize group_buf
+		debug3("%s: GetTokenInformation() failed: %d", __FUNCTION__, GetLastError());
+		errno = EOTHER;
+		goto cleanup;
+	}
+
+	/* read group sids from logon token -- this will return a list of groups
+	* similar to the data returned when you do a whoami /groups command */
+	if (GetTokenInformation(logon_token, TokenGroups, group_buf, group_size, &group_size) == 0) {
+		debug3("%s: GetTokenInformation() failed with error %d", __FUNCTION__, GetLastError());
+		errno = EOTHER;
+		goto cleanup;
+	}
+
+	/* allocate memory to hold points to all group names */
+	if ((user_groups = (char**)malloc(sizeof(char*) * group_buf->GroupCount)) == NULL) {
+		errno = ENOMEM;
+		goto cleanup;
+	}
+
+	for (DWORD i = 0; i < group_buf->GroupCount; i++) {
+		/* only bother with group thats are 'enabled' from a security perspective */
+		if ((group_buf->Groups[i].Attributes & SE_GROUP_ENABLED) == 0 ||
+			!IsValidSid(group_buf->Groups[i].Sid))
+			continue;
+
+		/* only bother with groups that are builtin or classic domain/local groups */
+		SID * sid = group_buf->Groups[i].Sid;
+		DWORD sub = sid->SubAuthority[0];
+		SID_IDENTIFIER_AUTHORITY nt_authority = SECURITY_NT_AUTHORITY;
+		if (memcmp(&nt_authority, GetSidIdentifierAuthority(sid), sizeof(SID_IDENTIFIER_AUTHORITY)) == 0 && (
+			sub == SECURITY_NT_NON_UNIQUE || sub == SECURITY_BUILTIN_DOMAIN_RID)) {
+
+			/* lookup the account name for this sid */
+			wchar_t name[GNLEN + 1];
+			DWORD name_len = ARRAYSIZE(name);
+			wchar_t domain[DNLEN + 1];
+			DWORD domain_len = ARRAYSIZE(domain);
+			SID_NAME_USE name_use = 0;
+			if (LookupAccountSidW(NULL, sid, name, &name_len, domain, &domain_len, &name_use) == 0) {
+				errno = ENOENT;
+				debug("%s: LookupAccountSid() failed: %d.", __FUNCTION__, GetLastError());
+				goto cleanup;
+			}
+
+			int current_group = num_groups++;
+			wchar_t formatted_group[DNLEN + 1 + GNLEN + 1];
+			/* for local accounts trim the domain qualifier */
+			if (sub == SECURITY_BUILTIN_DOMAIN_RID || _wcsicmp(computer_name, domain) == 0)
+				swprintf_s(formatted_group, ARRAYSIZE(formatted_group), L"%s", name);
+			else /* add group name in netbios\\name format */
+				swprintf_s(formatted_group, ARRAYSIZE(formatted_group), L"%s\\%s", domain, name);
+			
+			_wcslwr_s(formatted_group, ARRAYSIZE(formatted_group));
+			debug3("Added group '%ls' for user %s", formatted_group, user_name);
+			user_groups[current_group] = utf16_to_utf8(formatted_group);
+			if (user_groups[current_group] == NULL) {
+				errno = ENOMEM;
+				goto cleanup;
+			}
+		}
+	}
+
+
+	ngroups = num_groups;
+	/* downsize the array to the actual size */
+	groups_byname = (char**)realloc(user_groups, sizeof(char*) * num_groups);;
+	user_groups = NULL;
+	ret = 0;
+
+cleanup:
+	if (group_buf)
+		free(group_buf);
+
+	if (user_groups && num_groups) {
+		for (int group = 0; group < num_groups; group++)
+			if (user_groups[group]) free(user_groups[group]);
+		free(user_groups);
+	}
+
+	debug2("%s: done extracting all groups of user %s", __func__, user_name);
+	processed = 1;
+	return ret;
+}
+
+/* 
+ *
+ * checks if user_token has "group" membership, fatal exits on error 
+ * returns 1 if true, 0 otherwise
+ */
+static int
+check_group_membership(const char* group)
+{
+	PSID sid = NULL;
+	BOOL is_member = 0;
+	
+	if ((sid = get_sid(group)) == NULL) {
+		error("unable to resolve group %s", group);
+		goto cleanup;
+	}
+	
+	if (!CheckTokenMembership(user_token, sid, &is_member))
+		fatal("%s CheckTokenMembership for user %s failed with %d for group %s", __func__, user_name, GetLastError(), group);
+
+cleanup:
+	if (sid)
+		free(sid);
+	return is_member? 1: 0;
+}
+
+
+/*
+ * Initialize group access list for user with primary (base) and
+ * supplementary groups.  Return the number of groups in the list.
+ */
+int
+ga_init(const char *user, gid_t base)
+{
+	ngroups = 0;
+	groups_byname = NULL;
+	user_token = NULL;
+
+	user_name = xstrdup(user);
+
+	if ((user_token = get_user_token(user_name, 0)) == NULL) {
+		/*
+		 * TODO - We need to fatal() all the times when we fail to generate the user token.
+		 */
+		if (get_custom_lsa_package()) {
+			error("%s, unable to resolve user %s", __func__, user_name);
+			return 0;
+		} else {
+			fatal("%s, unable to resolve user %s", __func__, user_name);
+		}
+	}
+		
+	/* 
+	 * supposed to retun number of groups associated with user 
+	 * since we do lazy group evaluation, returning 1 here
+	 */
+
+	return 1;
+}
+
+/*
+ * Return 1 if one of user's groups is contained in groups.
+ * Return 0 otherwise.  Use match_pattern() for string comparison.
+ */
+int
+ga_match(char * const *groups, int n)
+{
+	int i, j;
+
+	/* group retrieval is expensive, optmizing the common case scenario with no wild cards */
+	for (j = 0; j < n; j++)
+		if (strchr(groups[j], '?') || strchr(groups[j], '*'))
+			goto fetch_all;
+
+	for (j = 0; j < n; j++)
+		if (check_group_membership(groups[j]))
+			return 1;
+
+	return 0;
+
+fetch_all:
+	if (get_user_groups() == -1)
+		fatal("unable to retrieve group info for user %s", user_name);
+
+	for (i = 0; i < ngroups; i++)
+		for (j = 0; j < n; j++)
+			if (match_pattern(groups_byname[i], groups[j]))
+				return 1;
+	return 0;
+}
+
+/*
+ * Return 1 if one of user's groups matches group_pattern list.
+ * Return 0 on negated or no match.
+ */
+int
+ga_match_pattern_list(const char *group_pattern)
+{
+	int i, found = 0;
+	char *tmp = NULL;
+
+	/* group retrieval is expensive, optmizing the common case scenario - only one group with no wild cards and no negation */
+	if (!strchr(group_pattern, ',') && !strchr(group_pattern, '?') && 
+	    !strchr(group_pattern, '*') && !strchr(group_pattern, '!'))
+		return check_group_membership(group_pattern);
+
+	if (get_user_groups() == -1)
+		fatal("unable to retrieve group info for user %s", user_name);
+
+	/* For domain groups we need special handling.
+	 * We support both "domain\group_name" and "domain/group_name" formats.
+	 */
+	if (tmp = strstr(group_pattern, "/"))
+		*tmp = '\\';
+
+	for (i = 0; i < ngroups; i++) {
+		/* Group names are case insensitive */
+		switch (match_pattern_list(groups_byname[i], group_pattern, 1)) {
+		case -1:
+			return 0;	/* Negated match wins */
+		case 0:
+			continue;
+		case 1:
+			found = 1;
+		}
+	}
+	return found;
+}
+
+/*
+ * Free memory allocated for group access list.
+ */
+void
+ga_free(void)
+{
+	int i;
+
+	if (ngroups > 0) {
+		for (i = 0; i < ngroups; i++)
+			free(groups_byname[i]);
+		ngroups = 0;
+		free(groups_byname);
+	}
+	groups_byname = NULL;
+
+	if (user_name)
+		free(user_name);
+	user_name = NULL;
+	CloseHandle(user_token);
+	user_token = NULL;
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/win32_pty.c b/contrib/win32/win32compat/win32_pty.c
new file mode 100644
index 000000000..7994f25be
--- /dev/null
+++ b/contrib/win32/win32compat/win32_pty.c
@@ -0,0 +1,149 @@
+/*
+* Author: Balu G <bagajjal@microsoft.com>
+*
+* This file contains the conpty related functions.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <Windows.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "Debug.h"
+#include "inc\fcntl.h"
+#include "inc\utf.h"
+#include "misc_internal.h"
+#include "signal_internal.h"
+
+int
+is_conpty_supported()
+{
+	wchar_t *kernel32_dll_path = L"kernel32.dll";
+	HMODULE hm_kernel32 = NULL;
+	static int isConpty = -1;
+
+	if (isConpty != -1)
+		return isConpty;
+
+	isConpty = 0;
+	if ((hm_kernel32 = LoadLibraryExW(kernel32_dll_path, NULL, LOAD_LIBRARY_SEARCH_SYSTEM32)) == NULL) {
+		error("failed to load %S dll", kernel32_dll_path);
+		goto done;
+	}
+
+	if (GetProcAddress(hm_kernel32, "CreatePseudoConsole") == NULL) {
+		debug3("couldn't find CreatePseudoConsole() in %S dll", kernel32_dll_path);
+		goto done;
+	}
+
+	isConpty = 1;
+	debug3("This windows OS supports conpty");
+done:
+	if (!isConpty)
+		debug3("This windows OS doesn't support conpty");
+
+	return isConpty;
+}
+
+int exec_command_with_pty(int * pid, char* cmd, int in, int out, int err, unsigned int col, unsigned int row, int ttyfd)
+{
+	PROCESS_INFORMATION pi;
+	STARTUPINFOW si;
+	wchar_t pty_cmdline[MAX_CMD_LEN] = { 0, };
+	int ret = -1;
+	HANDLE ttyh = (HANDLE)w32_fd_to_handle(ttyfd);
+	wchar_t * cmd_w = NULL;
+	unsigned long flags = 0;
+
+	if ((cmd_w = utf8_to_utf16(cmd)) == NULL) {
+		errno = ENOMEM;
+		return ret;
+	}
+
+	memset(&si, 0, sizeof(STARTUPINFO));
+	si.cb = sizeof(STARTUPINFO);
+	si.dwFlags = STARTF_USESTDHANDLES | STARTF_USESIZE | STARTF_USECOUNTCHARS;
+	si.hStdInput = (HANDLE)w32_fd_to_handle(in);
+	si.hStdOutput = (HANDLE)w32_fd_to_handle(out);
+	si.lpDesktop = NULL;
+
+	if (is_conpty_supported()) {
+		wchar_t system32_path[PATH_MAX] = { 0, };
+		SetHandleInformation(ttyh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
+		wchar_t *cmd_fmt = L"%ls\\conhost.exe --headless --width %d --height %d --signal 0x%x -- %ls";
+
+		if (!GetSystemDirectoryW(system32_path, PATH_MAX))
+			fatal("unable to retrieve system32 path");
+
+		_snwprintf_s(pty_cmdline,
+			MAX_CMD_LEN,
+			MAX_CMD_LEN,
+			cmd_fmt,
+			system32_path,
+			col,
+			row,
+			ttyh,
+			cmd_w);
+
+		si.hStdError = si.hStdOutput;
+		/* process CTRL+C input. Child processes will inherit this behavior. */
+		SetConsoleCtrlHandler(NULL, FALSE);
+	}
+	else {
+		/* launch via  "ssh-shellhost" -p command*/
+		_snwprintf_s(pty_cmdline, MAX_CMD_LEN, MAX_CMD_LEN, L"\"%ls\\ssh-shellhost.exe\" ---pty %ls", __wprogdir, cmd_w);
+		si.dwXCountChars = col;
+		si.dwYCountChars = row;
+
+		/*
+		 * In PTY mode, ssh-shellhost takes stderr as control channel
+		 * TODO - fix this and pass control channel pipe as a command line parameter
+		 */
+		si.hStdError = ttyh;
+	}
+
+	flags = CREATE_NO_WINDOW;
+	debug3("pty commandline: %ls", pty_cmdline);
+	if (CreateProcessW(NULL, pty_cmdline, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi)) {
+		if (register_child(pi.hProcess, pi.dwProcessId) == -1) {
+			TerminateProcess(pi.hProcess, 0);
+			CloseHandle(pi.hProcess);
+			goto done;
+		}
+		CloseHandle(pi.hThread);
+	}
+	else {
+		debug("%s - failed to execute %ls, error:%d", __func__, pty_cmdline, GetLastError());
+		errno = EOTHER;
+		goto done;
+	}
+	*pid = pi.dwProcessId;
+	ret = 0;
+
+done:
+	/* disable Ctrl+C hander in this process*/
+	SetConsoleCtrlHandler(NULL, TRUE);
+	if (cmd_w)
+		free(cmd_w);
+	return ret;
+}
\ No newline at end of file
diff --git a/contrib/win32/win32compat/win32_sshpty.c b/contrib/win32/win32compat/win32_sshpty.c
new file mode 100644
index 000000000..2edde1a94
--- /dev/null
+++ b/contrib/win32/win32compat/win32_sshpty.c
@@ -0,0 +1,73 @@
+/* 
+ * Windows version of sshpty* routines in sshpty.c
+ */
+
+
+
+#include <Windows.h>
+#include "..\..\..\sshpty.h"
+#include "inc\unistd.h"
+#include "misc_internal.h"
+
+/* 
+ * Windows versions of pty_*. Some of them are NO-OPs and should go 
+ * away when pty logic is refactored and abstracted out 
+ * 
+ */
+
+ /*
+ * allocates a control channel for Windows PTY
+ * ptyfd can be used to deliver Window size change events
+ */
+int
+pty_allocate(int *ptyfd, int *ttyfd, char *namebuf, size_t namebuflen)
+{
+	int p[2];
+	*ttyfd = 0;
+	*ptyfd = 0;
+	if (w32_pipe(p) < 0)
+		return 0;
+
+	/* enable blocking mode io*/
+	unset_nonblock(p[0]);
+	unset_nonblock(p[1]);
+	*ttyfd = p[0];
+	*ptyfd = p[1];
+	strcpy_s(namebuf, namebuflen, "windows-pty");
+	return 1;
+}
+
+void
+pty_release(const char *tty) {
+	/* NO-OP */
+}
+
+void
+pty_make_controlling_tty(int *ttyfd, const char *tty) {
+	/* NO-OP */
+}
+
+void
+pty_change_window_size(int ptyfd, u_int row, u_int col,
+    u_int xpixel, u_int ypixel) 
+{
+	unsigned short signalPacket[3];
+	signalPacket[0] = PTY_SIGNAL_RESIZE_WINDOW;
+	signalPacket[1] = col;
+	signalPacket[2] = row;
+	// TODO - xpixel, ypixel
+
+	w32_write(ptyfd, signalPacket, sizeof(signalPacket));
+}
+
+
+void
+pty_setowner(struct passwd *pw, const char *tty) {
+	/* NO-OP */
+}
+
+void
+disconnect_controlling_tty(void) {
+	/* NO-OP */
+}
+
diff --git a/contrib/win32/win32compat/win32_sshtty.c b/contrib/win32/win32compat/win32_sshtty.c
new file mode 100644
index 000000000..ab5f2f8b8
--- /dev/null
+++ b/contrib/win32/win32compat/win32_sshtty.c
@@ -0,0 +1,30 @@
+/* 
+ * Windows version of sshtty* routines implemented in sshtty.c 
+ */
+
+#include <Windows.h>
+#include "..\..\..\sshpty.h"
+static struct termios _saved_tio;
+static int _in_raw_mode = 0;
+
+/* 
+ * TTY raw mode routines for Windows 
+ */
+
+struct termios term_settings;
+
+struct termios *
+get_saved_tio(void) {
+        memset(&term_settings, 0, sizeof(term_settings));
+        return &term_settings;
+}
+
+void
+leave_raw_mode(int quiet) {
+        ConExitRawMode();
+}
+
+void
+enter_raw_mode(int quiet) {
+        ConEnterRawMode();
+}
diff --git a/contrib/win32/win32compat/win32_usertoken_utils.c b/contrib/win32/win32compat/win32_usertoken_utils.c
new file mode 100644
index 000000000..2b8ede0d4
--- /dev/null
+++ b/contrib/win32/win32compat/win32_usertoken_utils.c
@@ -0,0 +1,849 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*   Utilities to generate user tokens
+*
+* Author: Bryan Berns <berns@uwalumni.com>
+*   Updated s4u, logon, and profile loading routines to use 
+*   normalized login names.
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#define SECURITY_WIN32
+#define UMDF_USING_NTSTATUS 
+#include <Windows.h>
+#include <UserEnv.h>
+#include <Ntsecapi.h>
+#include <ntstatus.h>
+#include <Shlobj.h>
+#include <LM.h>
+#include <security.h>
+
+#include "inc\utf.h"
+#include "w32api_proxies.h"
+#include <Ntsecapi.h>
+#include <Strsafe.h>
+#include <sddl.h>
+#include <ntstatus.h>
+#include "misc_internal.h"
+#include "lsa_missingdefs.h"
+#include "Debug.h"
+#include "inc\pwd.h"
+
+#pragma warning(push, 3)
+HANDLE password_auth_token = NULL;
+
+static void
+InitLsaString(LSA_STRING *lsa_string, const char *str)
+{
+	if (!str)
+		memset(lsa_string, 0, sizeof(LSA_STRING));
+	else {
+		lsa_string->Buffer = (char *)str;
+		lsa_string->Length = (USHORT)strlen(str);
+		lsa_string->MaximumLength = lsa_string->Length + 1;
+	}
+}
+
+static void
+EnablePrivilege(const char *privName, int enabled)
+{
+	TOKEN_PRIVILEGES tp;
+	HANDLE hProcToken = NULL;
+	LUID luid;
+
+	int exitCode = 1;
+
+	if (LookupPrivilegeValueA(NULL, privName, &luid) == FALSE ||
+		OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hProcToken) == FALSE)
+		goto done;
+
+	tp.PrivilegeCount = 1;
+	tp.Privileges[0].Luid = luid;
+	tp.Privileges[0].Attributes = enabled ? SE_PRIVILEGE_ENABLED : 0;
+
+	AdjustTokenPrivileges(hProcToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL);
+
+done:
+	if (hProcToken)
+		CloseHandle(hProcToken);
+
+	return;
+}
+
+HANDLE
+generate_s4u_user_token(wchar_t* user_cpn, int impersonation) {
+	HANDLE lsa_handle = NULL, token = NULL;
+	ULONG auth_package_id;
+	NTSTATUS ret, subStatus;
+	void * logon_info = NULL;
+	size_t logon_info_size;
+	LSA_STRING logon_process_name, auth_package_name, origin_name;
+	TOKEN_SOURCE source_context;
+	PKERB_INTERACTIVE_PROFILE profile = NULL;
+	LUID logon_id = { 0, 0 };
+	QUOTA_LIMITS quotas;
+	DWORD profile_size;
+
+	/* the format for the user will be constrained to the output of get_passwd()
+	 * so only the only two formats are a NetBiosDomain\SamAccountName which is
+	 * a domain account or just SamAccountName in which is a local account */
+	BOOL domain_user = wcschr(user_cpn, L'\\') != NULL;
+	
+	/* initialize connection to local security provider */
+	if (impersonation) {
+
+		/* trusted mode - used for impersonation */
+		LSA_OPERATIONAL_MODE mode;
+		InitLsaString(&logon_process_name, __progname);
+		if ((ret = LsaRegisterLogonProcess(&logon_process_name, &lsa_handle, &mode)) != STATUS_SUCCESS) {
+			ULONG winError = LsaNtStatusToWinError(ret);
+			error_f("LsaRegisterLogonProcess failed with error:%d", winError);
+
+			goto done;
+		}
+	}
+	else {
+		/* untrusted mode - used for information lookup */
+		if (LsaConnectUntrusted(&lsa_handle) != STATUS_SUCCESS)
+			goto done;
+	}
+
+	InitLsaString(&auth_package_name, (domain_user) ? MICROSOFT_KERBEROS_NAME_A : MSV1_0_PACKAGE_NAME);
+	if (ret = LsaLookupAuthenticationPackage(lsa_handle, &auth_package_name, &auth_package_id) != STATUS_SUCCESS)
+		goto done;
+
+	if (domain_user) {
+
+		/* lookup the user principal name for the account */
+		WCHAR domain_upn[MAX_UPN_LEN + 1];
+
+		if (lookup_principal_name(user_cpn, domain_upn) != 0) {
+			/* failure - fallback to NetBiosDomain\SamAccountName */
+			wcscpy_s(domain_upn, ARRAYSIZE(domain_upn), user_cpn);
+		}
+		
+		KERB_S4U_LOGON *s4u_logon;
+		logon_info_size = sizeof(KERB_S4U_LOGON);
+
+		/* additional buffer is necessary at end to hold user name */
+		logon_info_size += (wcslen(domain_upn) * sizeof(wchar_t));
+		logon_info = calloc(1, logon_info_size);
+		if (logon_info == NULL)
+			goto done;
+		s4u_logon = (KERB_S4U_LOGON*)logon_info;
+		s4u_logon->MessageType = KerbS4ULogon;
+		s4u_logon->Flags = (impersonation) ? 0x0 : 0x8;
+
+		/* copy the user name into the memory immediately after the structure */
+		s4u_logon->ClientUpn.Length = (USHORT)wcslen(domain_upn) * sizeof(wchar_t);
+		s4u_logon->ClientUpn.MaximumLength = s4u_logon->ClientUpn.Length;
+		s4u_logon->ClientUpn.Buffer = (PWSTR)(s4u_logon + 1);
+		if (memcpy_s(s4u_logon->ClientUpn.Buffer, s4u_logon->ClientUpn.Length,
+			domain_upn, s4u_logon->ClientUpn.Length))
+			goto done;
+	}
+	else {
+
+		MSV1_0_S4U_LOGON *s4u_logon;
+		logon_info_size = sizeof(MSV1_0_S4U_LOGON);
+
+		/* additional buffer is necessary at end to hold user and computer name */
+		logon_info_size += (wcslen(user_cpn) + wcslen(L".")) * sizeof(wchar_t);
+		logon_info = calloc(1, logon_info_size);
+		if (logon_info == NULL)
+			goto done;
+		s4u_logon = (MSV1_0_S4U_LOGON*)logon_info;
+		s4u_logon->MessageType = MsV1_0S4ULogon;
+		s4u_logon->Flags = 0x0;
+
+		/* copy the user name into the memory immediately after the structure */
+		s4u_logon->UserPrincipalName.Length = (USHORT)wcslen(user_cpn) * sizeof(wchar_t);
+		s4u_logon->UserPrincipalName.MaximumLength = s4u_logon->UserPrincipalName.Length;
+		s4u_logon->UserPrincipalName.Buffer = (WCHAR*)(s4u_logon + 1);
+		if (memcpy_s(s4u_logon->UserPrincipalName.Buffer, s4u_logon->UserPrincipalName.Length,
+			user_cpn, s4u_logon->UserPrincipalName.Length))
+			goto done;
+
+		/* copy the computer name immediately after the user name */
+		s4u_logon->DomainName.Length = (USHORT)wcslen(L".") * sizeof(wchar_t);
+		s4u_logon->DomainName.MaximumLength = s4u_logon->DomainName.Length;
+		s4u_logon->DomainName.Buffer = (PWSTR)(((PBYTE)s4u_logon->UserPrincipalName.Buffer)
+			+ s4u_logon->UserPrincipalName.Length);
+		if (memcpy_s(s4u_logon->DomainName.Buffer, s4u_logon->DomainName.Length,
+			L".", s4u_logon->DomainName.Length))
+			goto done;
+	}
+
+	if (strcpy_s(source_context.SourceName, TOKEN_SOURCE_LENGTH, "sshd") != 0 ||
+		AllocateLocallyUniqueId(&source_context.SourceIdentifier) != TRUE)
+		goto done;
+
+	InitLsaString(&origin_name, "sshd");
+	if ((ret = LsaLogonUser(lsa_handle, &origin_name, Network, auth_package_id,
+		logon_info, (ULONG)logon_info_size, NULL, &source_context,
+		(PVOID*)&profile, &profile_size, &logon_id, &token, &quotas, &subStatus)) != STATUS_SUCCESS) {
+		debug("%s: LsaLogonUser() failed. User '%ls' Status: 0x%08X SubStatus %d.", 
+			__FUNCTION__, user_cpn, ret, subStatus);
+		goto done;
+	}
+
+	debug3("LsaLogonUser Succeeded (Impersonation: %d)", impersonation);
+
+done:
+	if (lsa_handle)
+		LsaDeregisterLogonProcess(lsa_handle);
+	if (logon_info)
+		free(logon_info);
+	if (profile)
+		LsaFreeReturnBuffer(profile);
+
+	return token;
+}
+
+HANDLE
+process_custom_lsa_auth(const char* user, const char* pwd, const char* lsa_pkg)
+{
+	HANDLE token = NULL, lsa_handle = NULL;
+	LSA_OPERATIONAL_MODE mode;
+	ULONG auth_package_id;
+	NTSTATUS ret, subStatus;
+	LSA_STRING logon_process_name, lsa_auth_package_name, origin_name;
+	TOKEN_SOURCE source_context;
+	PVOID profile = NULL;
+	LUID logon_id = { 0, 0 };
+	QUOTA_LIMITS quotas;
+	DWORD profile_size;
+	int retVal = -1;
+	wchar_t *user_utf16 = NULL, *pwd_utf16 = NULL, *seperator = NULL;
+	wchar_t logon_info[UNLEN + 1 + PWLEN + 1 + DNLEN + 1];
+	ULONG logon_info_size = ARRAYSIZE(logon_info);
+
+	debug3("LSA auth request, user:%s lsa_pkg:%s ", user, lsa_pkg);
+
+	if ((user_utf16 = utf8_to_utf16(user)) == NULL ||
+		(pwd_utf16 = utf8_to_utf16(pwd)) == NULL)
+		goto done;
+	
+	/* the format for the user will be constrained to the output of get_passwd()
+	* so only the only two formats are NetBiosDomain\SamAccountName which is
+	* a domain account or just SamAccountName in which is a local account */
+
+	seperator = wcschr(user_utf16, L'\\');
+	if (seperator != NULL) {
+		/* domain user: generate login info string user;password;domain */
+		swprintf_s(logon_info, ARRAYSIZE(logon_info), L"%s;%s;%.*s",
+			seperator + 1, pwd_utf16, (int) (seperator - user_utf16), user_utf16);
+	} else {
+		/* local user: generate login info string user;password */
+		swprintf_s(logon_info, ARRAYSIZE(logon_info), L"%s;%s",
+			user_utf16, pwd_utf16);
+	}
+
+	InitLsaString(&logon_process_name, "sshd");
+	InitLsaString(&lsa_auth_package_name, lsa_pkg);
+	InitLsaString(&origin_name, "sshd");
+
+	if ((ret = LsaRegisterLogonProcess(&logon_process_name, &lsa_handle, &mode)) != STATUS_SUCCESS) {
+		error("LsaRegisterLogonProcess failed, error:%x", ret);
+		goto done;
+	}
+
+	if ((ret = LsaLookupAuthenticationPackage(lsa_handle, &lsa_auth_package_name, &auth_package_id)) != STATUS_SUCCESS) {
+		error("LsaLookupAuthenticationPackage failed, lsa auth pkg:%ls error:%x", lsa_pkg, ret);
+		goto done;
+	}
+
+	strcpy_s(source_context.SourceName, sizeof(source_context.SourceName), "sshd");
+
+	if (!AllocateLocallyUniqueId(&source_context.SourceIdentifier)) {
+		error("AllocateLocallyUniqueId failed, error:%d", GetLastError());
+		goto done;
+	}
+
+	if ((ret = LsaLogonUser(lsa_handle, &origin_name, Network, auth_package_id,
+		logon_info, (ULONG)logon_info_size, NULL, &source_context,
+		(PVOID*)&profile, &profile_size, &logon_id, &token, &quotas, &subStatus)) != STATUS_SUCCESS) {
+		debug("%s: LsaLogonUser() failed: User '%s' Status: %08X SubStatus %d.", 
+			__FUNCTION__, user, ret, subStatus);
+		goto done;
+	}
+
+	debug3("LSA auth request is successful for user:%s ", user);
+	retVal = 0;
+done:
+	if (lsa_handle)
+		LsaDeregisterLogonProcess(lsa_handle);
+	if (profile)
+		LsaFreeReturnBuffer(profile);
+	if (user_utf16)
+		free(user_utf16);
+	if (pwd_utf16) {
+		SecureZeroMemory(pwd_utf16, wcslen(pwd_utf16) * sizeof(WCHAR));
+		free(pwd_utf16);
+	}
+	SecureZeroMemory(logon_info, sizeof(logon_info));
+
+	return token;
+}
+
+HANDLE generate_sshd_virtual_token();
+HANDLE generate_sshd_token_as_nonsystem();
+
+HANDLE
+get_user_token(const char* user, int impersonation) {
+	HANDLE token = NULL;
+	wchar_t *user_utf16 = NULL;
+	PSID user_sid = NULL, process_sid = NULL;
+	
+	if ((user_utf16 = utf8_to_utf16(user)) == NULL) {
+		debug("out of memory");
+		goto done;
+	}
+
+	if (wcscmp(user_utf16, L"sshd") == 0) {
+		/* not running as system, try generating sshd token as admin */
+		if (!am_system() && (token = generate_sshd_token_as_nonsystem()) != 0)
+			goto done;
+			
+		if ((token = generate_sshd_virtual_token()) == 0)
+  		    error("%s - unable to generate sshd virtual token, ensure sshd service has TCB privileges", __func__);
+
+		goto done;
+	}
+
+	if (!am_system()) {
+		process_sid = get_sid(NULL);
+		user_sid = get_sid(user);
+		HANDLE t1;
+
+		if (user_sid == NULL && get_custom_lsa_package())
+			debug3("%s - i am running as %s, returning process token since custom lsa is configured", __func__, user);
+		else if (EqualSid(process_sid, user_sid))
+			debug3("%s - i am running as %s, returning process token", __func__, user);
+		else {
+			debug("%s - unable to generate user token for %s as i am not running as system", __func__, user);
+			goto done;
+		}
+
+		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS_P, &t1)) {
+			error("%s - OpenProcessToken failed with %d", __func__, GetLastError());
+			goto done;
+		}
+
+		if (impersonation) {
+			token = t1;
+			goto done;
+		} else if (!DuplicateToken(t1, SecurityIdentification, &token))
+			error("%s - DuplicateToken failed with %d", __func__, GetLastError());
+				
+		CloseHandle(t1);
+		goto done;
+	}
+
+	/* is this is a virtual user to be authenticated via custom lsa provider ? */
+	if ((user_sid = get_sid(user)) == NULL && get_custom_lsa_package() && !impersonation) {
+		if ((token = process_custom_lsa_auth(user, "", get_custom_lsa_package())) == NULL)
+			error("%s - unable to generate identity token for %s from custom lsa provider: %s", 
+				__func__, user, get_custom_lsa_package());
+		goto done;
+	}
+
+	if ((token = generate_s4u_user_token(user_utf16, impersonation)) == 0) {
+		debug3("%s - unable to generate token for user %ls", __func__, user_utf16);
+		/* work around for https://github.com/PowerShell/Win32-OpenSSH/issues/727 by doing a fake login */
+		pLogonUserExExW(L"FakeUser", L"FakeDomain", L"FakePasswd",
+			LOGON32_LOGON_NETWORK_CLEARTEXT, LOGON32_PROVIDER_DEFAULT, NULL, &token, NULL, NULL, NULL, NULL);
+		if ((token = generate_s4u_user_token(user_utf16, impersonation)) == 0)
+			error("%s - unable to generate token on 2nd attempt for user %ls", __func__, user_utf16);
+		goto done;
+	}
+
+done:
+	if (user_utf16)
+		free(user_utf16);
+
+	if (user_sid)
+		free(user_sid);
+
+	if (process_sid)
+		free(process_sid);
+
+	return token;
+}
+
+int 
+load_user_profile(HANDLE user_token, char* user)
+{
+	wchar_t * user_utf16 = NULL;
+
+	if (!am_system()) {
+	    debug("Not running as SYSTEM: skipping loading user profile");
+	    return 0;
+	}
+
+	if ((user_utf16 = utf8_to_utf16(user)) == NULL) {
+		fatal("out of memory");
+		return -1;
+	}
+
+	/* note: user string will normalized form output of get_passwd() */
+	wchar_t * user_name = user_utf16;
+	wchar_t * domain_name = NULL;
+	wchar_t * seperator = wcschr(user_name, L'\\');
+	if (seperator != NULL) {
+		domain_name = user_name;
+		*seperator = L'\0';
+		user_name = seperator + 1;
+	}
+
+	PROFILEINFOW profileInfo = { 0 };
+	profileInfo.dwSize = sizeof(profileInfo);
+	profileInfo.dwFlags = PI_NOUI;
+	profileInfo.lpProfilePath = NULL;
+	profileInfo.lpUserName = user_name;
+	profileInfo.lpDefaultPath = NULL;
+	profileInfo.lpServerName = domain_name;
+	profileInfo.lpPolicyPath = NULL;
+	profileInfo.hProfile = NULL;
+	EnablePrivilege("SeBackupPrivilege", 1);
+	EnablePrivilege("SeRestorePrivilege", 1);
+	if (LoadUserProfileW(user_token, &profileInfo) == FALSE) {
+		debug3("%s: LoadUserProfileW() failed for user %S with error %d.", __FUNCTION__, GetLastError());
+	}
+	EnablePrivilege("SeBackupPrivilege", 0);
+	EnablePrivilege("SeRestorePrivilege", 0);
+
+	if (user_utf16)
+		free(user_utf16);
+
+	return 0;
+}
+
+
+/* *** virtual account token generation logic ***/
+
+char* LSAMappingErrorDetails[] = {
+	"LsaSidNameMappingOperation_Success",
+	"LsaSidNameMappingOperation_NonMappingError",
+	"LsaSidNameMappingOperation_NameCollision",
+	"LsaSidNameMappingOperation_SidCollision",
+	"LsaSidNameMappingOperation_DomainNotFound",
+	"LsaSidNameMappingOperation_DomainSidPrefixMismatch",
+	"LsaSidNameMappingOperation_MappingNotFound"
+};
+
+#define VIRTUALUSER_DOMAIN L"VIRTUAL USERS"
+#define VIRTUALUSER_GROUP_NAME L"ALL VIRTUAL USERS"
+
+/* returns 0 on success -1 on failure */
+int
+add_sid_mapping_to_lsa(PUNICODE_STRING domain_name,
+	 PUNICODE_STRING account_name,
+	 PSID sid)
+{
+	LSA_SID_NAME_MAPPING_OPERATION_INPUT   input = { 0 };
+	PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT p_output = NULL;
+	LSA_SID_NAME_MAPPING_OPERATION_ERROR op_result =
+		LsaSidNameMappingOperation_NonMappingError;
+	NTSTATUS status = STATUS_SUCCESS;
+	int ret = 0;
+
+	input.AddInput.DomainName = *domain_name;
+	if (account_name)
+		input.AddInput.AccountName = *account_name;
+	input.AddInput.Sid = sid;
+
+	status = LsaManageSidNameMapping(LsaSidNameMappingOperation_Add,
+		&input,
+		&p_output);
+	if (status != STATUS_SUCCESS) {
+		ret = -1;
+		if (p_output) {
+			op_result = p_output->AddOutput.ErrorCode;
+			if (op_result == LsaSidNameMappingOperation_NameCollision || op_result == LsaSidNameMappingOperation_SidCollision)
+				ret = 0; /* OK as it failed due to collision */
+			else
+				error("LsaManageSidNameMapping failed with : %s", LSAMappingErrorDetails[op_result]);
+		}
+		else
+			error("LsaManageSidNameMapping failed with ntstatus: %d", status);
+	}
+
+	if (p_output) {
+		status = pLsaFreeMemory(p_output);
+		if (status != STATUS_SUCCESS)
+			debug3("LsaFreeMemory failed with ntstatus: %d", status);
+	}
+
+	return ret;
+}
+
+
+int remove_virtual_account_lsa_mapping(PUNICODE_STRING domain_name,
+	PUNICODE_STRING account_name)
+{
+	int ret = 0;
+
+	LSA_SID_NAME_MAPPING_OPERATION_INPUT         input = { 0 };
+	PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT       p_output = NULL;
+	PLSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT remove_input = &input.RemoveInput;
+
+	remove_input->DomainName = *domain_name;
+	if (account_name)
+		remove_input->AccountName = *account_name;
+	
+	NTSTATUS status = LsaManageSidNameMapping(LsaSidNameMappingOperation_Remove,
+		&input,
+		&p_output);
+	if (status != STATUS_SUCCESS)
+		ret = -1;
+		
+	if (p_output) {
+		status = pLsaFreeMemory(p_output);
+		if (status != STATUS_SUCCESS)
+			debug3("LsaFreeMemory failed with ntstatus: %d", status);
+	}
+	return ret;
+}
+
+void 
+init_unicode_string(PUNICODE_STRING dest, PWSTR source)
+{
+	dest->Buffer = source;
+	dest->Length = (USHORT)(wcslen(source) * sizeof(wchar_t));
+	dest->MaximumLength = dest->Length + 2;
+}
+
+HANDLE generate_sshd_token_as_nonsystem()
+{
+	/*
+	 * This logic tries to reset sshd account password and generate sshd token via logon user
+	 * however this token cannot be used to spawn child processes in typical interactive 
+	 * scenarios, without modifying ACLs on desktop station. 
+	 * Since sshd is run in interactive mode primarily for debugging/testing purposes, we are
+	 * simply returing the process token (to be used for spawning unprivileged worker)
+	 {
+	    UUID uuid;
+	    RPC_CWSTR rpc_str;
+	    USER_INFO_1003 info;
+	    HANDLE token = 0;
+	    UuidCreate(&uuid);
+	    UuidToStringW(&uuid, (RPC_WSTR*)&rpc_str);
+
+	    info.usri1003_password = (LPWSTR)rpc_str;
+	    NetUserSetInfo(NULL, L"sshd", 1003, (LPBYTE)&info, NULL);
+
+	    LogonUserW(L"sshd", NULL, (LPCWSTR)rpc_str, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &token);
+	}
+	*/
+	HANDLE token = 0;
+	OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS_P , &token);
+	return token;
+}
+
+HANDLE generate_sshd_virtual_token()
+{
+	SID_IDENTIFIER_AUTHORITY nt_authority = SECURITY_NT_AUTHORITY;
+	UNICODE_STRING domain, group, account, svcLogonRight;
+	WCHAR va_name[16]; /* enough to accommodate sshd_ + log10(MAXDWORD) */
+	LSA_OBJECT_ATTRIBUTES ObjectAttributes;
+	LSA_HANDLE lsa_policy = NULL;
+	NTSTATUS lsa_ret = 0, lsa_add_ret = (NTSTATUS)-1;
+
+	PSID sid_domain = NULL, sid_group = NULL, sid_user = NULL;
+	HANDLE va_token = 0, va_token_restricted = 0;
+
+	StringCchPrintfW(va_name, 32, L"%s_%d", L"sshd", GetCurrentProcessId());
+
+	init_unicode_string(&svcLogonRight, L"SeServiceLogonRight");
+	init_unicode_string(&domain, VIRTUALUSER_DOMAIN);
+	init_unicode_string(&group, VIRTUALUSER_GROUP_NAME);
+	init_unicode_string(&account, va_name);
+
+	/* Initialize SIDs */
+	/* domain SID - S-1-5-111 */
+	if (!(AllocateAndInitializeSid(&nt_authority, 1, 111, 0, 0, 0, 0, 0, 0, 0, &sid_domain))) {
+		debug3("AllocateAndInitializeSid failed with domain SID");
+		goto cleanup;
+	}
+
+	/* group SID - S-1-5-111-0 */
+	if (!(AllocateAndInitializeSid(&nt_authority, 2, 111, 0, 0, 0, 0, 0, 0, 0, &sid_group))) {
+		debug3("AllocateAndInitializeSid failed with group SID");
+		goto cleanup;
+	}
+
+	/*
+	* account SID
+	* this is derived from higher RIDs in sshd service account SID to ensure there are no conflicts
+	* S-1-5-80-3847866527-469524349-687026318-516638107-1125189541 (Well Known group: NT SERVICE\sshd)
+	* Ex account SID - S-1-5-111-3847866527-469524349-687026318-516638107-1125189541-123
+	*/
+	if (!(AllocateAndInitializeSid(&nt_authority, 7, 111, 3847866527, 469524349,
+		687026318, 516638107, 1125189541, GetCurrentProcessId(), 0, &sid_user))) {
+		debug3("AllocateAndInitializeSid failed with account SID");
+		goto cleanup;
+	}
+
+	/* Map the domain SID */
+	if (add_sid_mapping_to_lsa(&domain, NULL, sid_domain) != 0) {
+		debug3("add_sid_mapping_to_lsa failed to map the domain Sid");
+		goto cleanup;
+	}
+
+	/* Map the group SID */
+	if (add_sid_mapping_to_lsa(&domain, &group, sid_group) != 0) {
+		debug3("add_sid_mapping_to_lsa failed to map the group Sid");
+		goto cleanup;
+	}
+
+	/* Map the user SID */
+	if (add_sid_mapping_to_lsa(&domain, &account, sid_user) != 0) {
+		debug3("add_sid_mapping_to_lsa failed to map the user Sid");
+		goto cleanup;
+	}
+
+	/* assign service logon privilege to virtual account */
+	ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
+	if ((lsa_ret = pLsaOpenPolicy(NULL, &ObjectAttributes,
+		POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
+		&lsa_policy)) != STATUS_SUCCESS) {
+		error("%s: unable to open policy handle, error: %d",
+			__FUNCTION__, (ULONG)pRtlNtStatusToDosError(lsa_ret));
+		goto cleanup;
+	}
+
+	/* alter security to allow policy to account to logon as a service */
+	if ((lsa_add_ret = pLsaAddAccountRights(lsa_policy, sid_user, &svcLogonRight, 1)) != STATUS_SUCCESS) {
+		error("%s: unable to assign SE_SERVICE_LOGON_NAME privilege, error: %d",
+			__FUNCTION__, (ULONG)pRtlNtStatusToDosError(lsa_add_ret));
+		goto cleanup;
+	}
+
+	/* Logon virtual and create token */
+	if (!pLogonUserExExW(va_name, VIRTUALUSER_DOMAIN, L"", LOGON32_LOGON_SERVICE,
+		LOGON32_PROVIDER_VIRTUAL, NULL, &va_token, NULL, NULL, NULL, NULL)) {
+		debug3("LogonUserExExW failed with %d", GetLastError());
+		goto cleanup;
+	}
+
+	/* remove all privileges */
+	if (!CreateRestrictedToken(va_token, DISABLE_MAX_PRIVILEGE, 0, NULL, 0, NULL, 0, NULL, &va_token_restricted))
+		debug3("CreateRestrictedToken failed with %d", GetLastError());
+
+	CloseHandle(va_token);
+
+cleanup:
+	remove_virtual_account_lsa_mapping(&domain, &account);
+
+	/* attempt to remove virtual account permissions if previous add succeeded */
+	if (lsa_add_ret == STATUS_SUCCESS)
+		if ((lsa_ret = pLsaRemoveAccountRights(lsa_policy, sid_user, FALSE, &svcLogonRight, 1)) != STATUS_SUCCESS)
+			debug("%s: unable to remove SE_SERVICE_LOGON_NAME privilege, error: %d", __FUNCTION__, pRtlNtStatusToDosError(lsa_ret));
+
+	if (sid_domain)
+		FreeSid(sid_domain);
+	if (sid_user)
+		FreeSid(sid_user);
+	if (sid_group)
+		FreeSid(sid_group);
+	if (lsa_policy)
+		pLsaClose(lsa_policy);
+
+	return va_token_restricted;
+}
+
+
+/* returns NULL if not configured, fatal exists on error */
+char *
+get_custom_lsa_package()
+{
+	static char *s_lsa_auth_pkg = NULL;
+	static int s_processed = 0;
+	wchar_t *lsa_auth_pkg_w = NULL;
+	int lsa_auth_pkg_len = 0;
+	HKEY reg_key = 0;
+	REGSAM mask = STANDARD_RIGHTS_READ | KEY_QUERY_VALUE | KEY_WOW64_64KEY;
+
+	if (s_processed)
+		return s_lsa_auth_pkg;
+
+	if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE, SSH_REGISTRY_ROOT, 0, mask, &reg_key) == ERROR_SUCCESS) &&
+	    (RegQueryValueExW(reg_key, L"LSAAuthenticationPackage", 0, NULL, NULL, &lsa_auth_pkg_len) == ERROR_SUCCESS)) {
+		lsa_auth_pkg_w = (wchar_t *)malloc(lsa_auth_pkg_len); // lsa_auth_pkg_len includes the null terminating character.
+		if (!lsa_auth_pkg_w)
+			fatal("%s: out of memory", __func__);
+
+		memset(lsa_auth_pkg_w, 0, lsa_auth_pkg_len);
+		if (RegQueryValueExW(reg_key, L"LSAAuthenticationPackage", 0, NULL, (LPBYTE)lsa_auth_pkg_w, &lsa_auth_pkg_len) == ERROR_SUCCESS) {
+			s_lsa_auth_pkg = utf16_to_utf8(lsa_auth_pkg_w);
+			if (!s_lsa_auth_pkg)
+				fatal("utf16_to_utf8 failed to convert lsa_auth_pkg_w:%ls", lsa_auth_pkg_w);
+		}
+	}
+
+	if (lsa_auth_pkg_w)
+		free(lsa_auth_pkg_w);
+	if (reg_key)
+		RegCloseKey(reg_key);
+
+	s_processed = 1;
+	return s_lsa_auth_pkg;
+}
+
+/*
+ * Not thread safe 
+ * returned value is pointer from static buffer
+ * dont free()
+ */
+wchar_t* get_final_path_by_handle(HANDLE h)
+{
+	static wchar_t path_buf[PATH_MAX];
+
+	if (GetFinalPathNameByHandleW(h, path_buf, PATH_MAX, 0) == 0) {
+		errno = EOTHER;
+		debug3("failed to get final path of file with handle:%d error:%d", h, GetLastError());
+		return NULL;
+	}
+
+	return (path_buf + 4);
+}
+
+/* using the netbiosname\samaccountname as an input, lookup the upn for the user.
+ * if no explicit upn is defined, implicit upn is returned (samaccountname@fqdn) */
+int lookup_principal_name(const wchar_t * sam_account_name, wchar_t * user_principal_name)
+{
+	wchar_t * seperator = wcschr(sam_account_name, L'\\');
+	wchar_t domain_upn[MAX_UPN_LEN + 1];
+	DWORD domain_upn_len = ARRAYSIZE(domain_upn);
+	DWORD lookup_error = 0;
+
+	/* sanity check */
+	if (seperator == NULL)
+		return -1;
+
+	/* try explicit lookup */
+	if (pTranslateNameW(sam_account_name, NameSamCompatible, NameUserPrincipal, domain_upn, &domain_upn_len) != 0) {
+		wcscpy_s(user_principal_name, MAX_UPN_LEN + 1, domain_upn);
+		debug3("%s: Successfully discovered explicit principal name: '%ls'=>'%ls'",
+			__FUNCTION__, sam_account_name, user_principal_name);
+		return 0;
+	}
+
+	/* try implicit lookup */
+	lookup_error = GetLastError();
+	domain_upn_len = ARRAYSIZE(domain_upn);
+	if (pTranslateNameW(sam_account_name, NameSamCompatible, NameCanonical, domain_upn, &domain_upn_len) != 0) {
+		/* construct an implicit upn using the samaccountname from the passed parameter 
+		 * and the fully qualified domain portion of the canonical name */
+		wcscpy_s(user_principal_name, MAX_UPN_LEN + 1, seperator + 1);
+		wcscat_s(user_principal_name, MAX_UPN_LEN + 1, L"@");
+		wcsncat_s(user_principal_name, MAX_UPN_LEN + 1, domain_upn, wcschr(domain_upn, L'/') - domain_upn);
+		debug3("%s: Successfully discovered implicit principal name: '%ls'=>'%ls'",
+			__FUNCTION__, sam_account_name, user_principal_name);
+		return 0;
+	}
+
+	/* report error */
+	error("%s: User principal name lookup failed for user '%ls' (explicit: %d, implicit: %d)",
+		__FUNCTION__, sam_account_name, lookup_error, GetLastError());
+	return -1;
+}
+
+int 
+windows_password_auth(const char *username, const char* password)
+{
+	wchar_t *user_utf16 = NULL, *pwd_utf16 = NULL, *unam_utf16 = NULL, *udom_utf16 = L".";
+	HANDLE token = NULL;
+	WCHAR domain_upn[MAX_UPN_LEN + 1];
+	ULONG domain_upn_len = ARRAYSIZE(domain_upn);
+
+	user_utf16 = utf8_to_utf16(username);
+	pwd_utf16 = utf8_to_utf16(password);
+	if (user_utf16 == NULL || pwd_utf16 == NULL) {
+		debug("out of memory");
+		goto done;
+	}
+
+	/* the format for the user will be constrained to the output of get_passwd()
+	* so only the only two formats are NetBiosDomain\SamAccountName which is
+	* a domain account or just SamAccountName in which is a local account */
+
+	/* default assumption - local user */
+	unam_utf16 = user_utf16;
+
+	/* translate to domain user if format contains a backslash */
+	wchar_t * backslash = wcschr(user_utf16, L'\\');
+	if (backslash != NULL) {
+
+		/* attempt to format into upn format as this is preferred for login */
+		if (lookup_principal_name(user_utf16, domain_upn) == 0) {
+			unam_utf16 = domain_upn;
+			udom_utf16 = NULL;
+		}
+
+		/* could not discover upn so just use netbios for the domain parameter and
+		* the sam account name for the user name */
+		else {
+			*backslash = '\0';
+			unam_utf16 = backslash + 1;
+			udom_utf16 = user_utf16;
+		}
+	}
+
+	if (pLogonUserExExW(unam_utf16, udom_utf16, pwd_utf16, LOGON32_LOGON_NETWORK_CLEARTEXT,
+		LOGON32_PROVIDER_DEFAULT, NULL, &token, NULL, NULL, NULL, NULL) == TRUE)
+		password_auth_token = token;
+	else {
+		if (GetLastError() == ERROR_PASSWORD_MUST_CHANGE)
+			/*
+			* TODO - need to add support to force password change
+			* by sending back SSH_MSG_USERAUTH_PASSWD_CHANGEREQ
+			*/
+			error("password for user %s has expired", username);
+		else {
+			debug("Windows authentication failed for user: %ls domain: %ls error: %d",
+				unam_utf16, udom_utf16, GetLastError());
+
+			/* If LSA authentication package is configured then it will return the auth_token */
+			if (get_custom_lsa_package())
+				password_auth_token = process_custom_lsa_auth(username, password, get_custom_lsa_package());
+		}
+	}
+
+done:
+
+	if (user_utf16)
+		free(user_utf16);
+	if (pwd_utf16)
+		SecureZeroMemory(pwd_utf16, sizeof(wchar_t) * wcslen(pwd_utf16));
+
+	return (password_auth_token) ? 1 : 0;
+
+}
+
+#pragma warning(pop)
\ No newline at end of file
diff --git a/contrib/win32/win32compat/win32compat.vcproj b/contrib/win32/win32compat/win32compat.vcproj
new file mode 100644
index 000000000..1de0f2545
--- /dev/null
+++ b/contrib/win32/win32compat/win32compat.vcproj
@@ -0,0 +1,311 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8.00"
+	Name="win32compat"
+	ProjectGUID="{8660C2FE-9874-432D-B047-E042BB41DBE0}"
+	RootNamespace="win32compat"
+	Keyword="Win32Proj"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="..;..\..\..;.\includes;..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
+			IntermediateDirectory="$(ConfigurationName)"
+			ConfigurationType="4"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				AdditionalIncludeDirectories="..;..\..\..;.\includes;..\..\..\..\openssl-0.9.8e\build\include"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB"
+				RuntimeLibrary="2"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="false"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath=".\daemon.c"
+				>
+			</File>
+			<File
+				RelativePath=".\gettimeofday.c"
+				>
+			</File>
+			<File
+				RelativePath=".\isatty.c"
+				>
+			</File>
+			<File
+				RelativePath=".\pwd.c"
+				>
+			</File>
+			<File
+				RelativePath=".\startupneeds.c"
+				>
+			</File>
+			<File
+				RelativePath=".\strcasecmp.c"
+				>
+			</File>
+			<File
+				RelativePath=".\syslog.c"
+				>
+			</File>
+			<File
+				RelativePath=".\winsockhelp.c"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath=".\includes\grp.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\in.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\in_systm.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\arpa\inet.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\ioctl.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\ip.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\arpa\nameser.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netdb.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\param.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\pwd.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\resolv.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\resource.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\select.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\socket.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\syslog.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\netinet\tcp.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\termios.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\time.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\types.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\uio.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\un.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\unistd.h"
+				>
+			</File>
+			<File
+				RelativePath=".\includes\sys\wait.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+		</Filter>
+		<File
+			RelativePath=".\Makefile.in"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				ExcludedFromBuild="true"
+				>
+				<Tool
+					Name="VCCustomBuildTool"
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff --git a/contrib/win32/win32compat/wmain_common.c b/contrib/win32/win32compat/wmain_common.c
new file mode 100644
index 000000000..9f96ca7ce
--- /dev/null
+++ b/contrib/win32/win32compat/wmain_common.c
@@ -0,0 +1,65 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Converts UTF-16 arguments to UTF-8
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <Windows.h>
+#include "inc\utf.h"
+#include "misc_internal.h"
+#include "Debug.h"
+
+int
+main(int, char **);
+
+int
+wmain(int argc, wchar_t **wargv) {
+	char** argv = NULL;
+	int i, r;
+	_set_invalid_parameter_handler(invalid_parameter_handler);
+	if (argc) {
+		if ((argv = malloc(argc * sizeof(char*))) == NULL)
+			fatal("out of memory");
+		for (i = 0; i < argc; i++)
+			if ((argv[i] = utf16_to_utf8(wargv[i])) == NULL)
+				fatal("out of memory");
+        }
+
+	if (getenv("SSH_AUTH_SOCK") == NULL)
+		_putenv("SSH_AUTH_SOCK=\\\\.\\pipe\\openssh-ssh-agent");
+
+	if (getenv("TERM") == NULL)
+		_putenv("TERM=xterm-256color");
+
+	w32posix_initialize();
+	
+	r = main(argc, argv);
+	w32posix_done();	
+	return r;
+}
diff --git a/contrib/win32/win32compat/wmain_sshd.c b/contrib/win32/win32compat/wmain_sshd.c
new file mode 100644
index 000000000..1b4bc78c6
--- /dev/null
+++ b/contrib/win32/win32compat/wmain_sshd.c
@@ -0,0 +1,286 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* wmain entry for sshd. 
+*
+* Copyright (c) 2015 Microsoft Corp.
+* All rights reserved
+*
+* Microsoft openssh win32 port
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+*
+* 1. Redistributions of source code must retain the above copyright
+* notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+* notice, this list of conditions and the following disclaimer in the
+* documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* disable inclusion of compatability defitnitions in CRT headers */
+#define __STDC__ 1
+#include <Windows.h>
+#include <wchar.h>
+#include <Lm.h>
+#include <sddl.h>
+#include <stdio.h>
+
+#include "inc\utf.h"
+#include "misc_internal.h"
+#include "Debug.h"
+
+int main(int, char **);
+extern HANDLE main_thread;
+
+int scm_start_service(DWORD, LPWSTR*);
+
+SERVICE_TABLE_ENTRYW dispatch_table[] =
+{
+	{ L"sshd", (LPSERVICE_MAIN_FUNCTIONW)scm_start_service },
+	{ NULL, NULL }
+};
+static SERVICE_STATUS_HANDLE service_status_handle;
+static SERVICE_STATUS service_status;
+
+
+static VOID ReportSvcStatus(DWORD dwCurrentState, DWORD dwWin32ExitCode, DWORD dwWaitHint)
+{
+	service_status.dwCurrentState = dwCurrentState;
+	service_status.dwWin32ExitCode = dwWin32ExitCode;
+	service_status.dwWaitHint = dwWaitHint;
+
+	if (dwCurrentState == SERVICE_START_PENDING)
+		service_status.dwControlsAccepted = 0;
+	else
+		service_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
+
+	if ((dwCurrentState == SERVICE_RUNNING) || (dwCurrentState == SERVICE_STOPPED))
+		service_status.dwCheckPoint = 0;
+	else
+		service_status.dwCheckPoint = 1;
+
+	SetServiceStatus(service_status_handle, &service_status);
+}
+
+BOOL WINAPI native_sig_handler(DWORD);
+static VOID WINAPI service_handler(DWORD dwControl)
+{
+	switch (dwControl)
+	{
+	case SERVICE_CONTROL_STOP: {
+		ReportSvcStatus(SERVICE_STOP_PENDING, NO_ERROR, 500);
+		ReportSvcStatus(SERVICE_STOPPED, NO_ERROR, 0);
+		/* TODO - GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0); doesn't seem to be invoking
+		 * signal handler (native_sig_handler) when sshd runs as service
+		 * So calling the signal handler directly to interrupt the deamon's main thread
+		 * This is being called after reporting SERVICE_STOPPED because main thread does a exit()
+		 * as part of handling Crtl+c
+		 */
+		native_sig_handler(CTRL_C_EVENT);
+		return;
+	}
+	case SERVICE_CONTROL_INTERROGATE:
+		break;
+	default:
+		break;
+	}
+
+	ReportSvcStatus(service_status.dwCurrentState, NO_ERROR, 0);
+}
+
+#define SSH_HOSTKEY_GEN_CMDLINE L"ssh-keygen -A"
+static void
+generate_host_keys()
+{
+	STARTUPINFOW si;
+	PROCESS_INFORMATION pi;
+	wchar_t cmdline[PATH_MAX];
+
+	if (am_system()) {
+		/* create host keys if they dont already exist */
+		ZeroMemory(&si, sizeof(si));
+		si.cb = sizeof(STARTUPINFOW);
+		ZeroMemory(&pi, sizeof(pi));
+		memcpy(cmdline, SSH_HOSTKEY_GEN_CMDLINE, wcslen(SSH_HOSTKEY_GEN_CMDLINE) * 2 + 2);
+		if (CreateProcessW(NULL, cmdline, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi)) {
+			WaitForSingleObject(pi.hProcess, INFINITE);
+			CloseHandle(pi.hThread);
+			CloseHandle(pi.hProcess);
+		}
+	}
+}
+
+/*
+* 1) Create %programdata%\ssh - Administrator group(F), system(F), authorized users(RX).
+* 2) Create %programdata%\ssh\logs - Administrator group(F), system(F)
+* 3) copy <binary_location>\sshd_config_default to %programdata%\ssh\sshd_config
+*/
+static void
+create_prgdata_ssh_folder()
+{
+	/* create ssh cfg folder */
+	wchar_t ssh_cfg_dir[PATH_MAX] = { 0, };
+	wcscpy_s(ssh_cfg_dir, _countof(ssh_cfg_dir), __wprogdata);
+	wcscat_s(ssh_cfg_dir, _countof(ssh_cfg_dir), L"\\ssh");
+	if (create_directory_withsddl(ssh_cfg_dir, L"O:BAD:PAI(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)(A;OICI;0x1200a9;;;AU)") < 0) {
+		printf("failed to create %S", ssh_cfg_dir);
+		exit(255);
+	}
+
+	/* create logs folder */
+	wchar_t logs_dir[PATH_MAX] = { 0, };
+	wcscat_s(logs_dir, _countof(logs_dir), ssh_cfg_dir);
+	wcscat_s(logs_dir, _countof(logs_dir), L"\\logs");
+	if (create_directory_withsddl(logs_dir, L"O:BAD:PAI(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)") < 0) {
+		printf("failed to create %S", logs_dir);
+		exit(255);
+	}
+
+	/* copy sshd_config_default to %programData%\ssh\sshd_config */
+	wchar_t sshd_config_path[PATH_MAX] = { 0, };
+	wcscat_s(sshd_config_path, _countof(sshd_config_path), ssh_cfg_dir);
+	wcscat_s(sshd_config_path, _countof(sshd_config_path), L"\\sshd_config");
+	if (GetFileAttributesW(sshd_config_path) == INVALID_FILE_ATTRIBUTES) {
+		wchar_t sshd_config_default_path[PATH_MAX] = { 0, };
+		swprintf_s(sshd_config_default_path, PATH_MAX, L"%S\\%s", __progdir, L"sshd_config_default");
+
+		if (CopyFileW(sshd_config_default_path, sshd_config_path, TRUE) == 0) {
+			printf("Failed to copy %S to %S, error:%d", sshd_config_default_path, sshd_config_path, GetLastError());
+			exit(255);
+		}
+	}
+}
+
+/* Create HKLM\Software\OpenSSH windows registry key */
+static void
+create_openssh_registry_key()
+{
+	HKEY ssh_registry_root = NULL;
+	wchar_t* sddl_str;
+	SECURITY_ATTRIBUTES sa;
+	int r;
+
+	memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
+	sa.nLength = sizeof(sa);
+
+	// SDDL - FullAcess to System and Builtin/Admins and read only access to Authenticated users
+	sddl_str = L"D:PAI(A;OICI;KA;;;SY)(A;OICI;KA;;;BA)(A;OICI;KR;;;AU)";
+	if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl_str, SDDL_REVISION_1, &sa.lpSecurityDescriptor, &sa.nLength)) {
+		printf("cannot convert sddl ERROR:%d", GetLastError());
+		return;
+	}
+
+	if ((r = RegCreateKeyExW(HKEY_LOCAL_MACHINE, SSH_REGISTRY_ROOT, 0, 0, 0, KEY_WRITE, &sa, &ssh_registry_root, 0)) == ERROR_SUCCESS)
+		RegCloseKey(ssh_registry_root);
+	else
+		printf("cannot create ssh root reg key, ERROR:%d", r);
+}
+
+static void
+prereq_setup()
+{
+	create_prgdata_ssh_folder();
+	generate_host_keys();
+	create_openssh_registry_key();
+}
+
+int sshd_main(int argc, wchar_t **wargv) {
+	char** argv = NULL;
+	int i, r;
+	_set_invalid_parameter_handler(invalid_parameter_handler);
+
+	if (argc) {
+		if ((argv = malloc(argc * sizeof(char*))) == NULL) {
+			printf("out of memory");
+			exit(255);
+		}
+
+		for (i = 0; i < argc; i++)
+			argv[i] = utf16_to_utf8(wargv[i]);
+	}
+
+	w32posix_initialize();
+
+	r = main(argc, argv);
+	w32posix_done();
+	return r;
+}
+
+int argc_original = 0;
+wchar_t **wargv_original = NULL;
+
+int wmain(int argc, wchar_t **wargv) {
+	wchar_t *path_value = NULL, *path_new_value;
+	errno_t result = 0;
+	size_t path_new_len = 0, len;
+	argc_original = argc;
+	wargv_original = wargv;
+
+	init_prog_paths();
+	/* change current directory to sshd.exe root */
+	_wchdir(__wprogdir);
+
+	/*
+	* we want to launch scp and sftp executables from the binary directory
+	* that sshd is hosted in. This will facilitate hosting and evaluating
+	* multiple versions of OpenSSH at the same time.
+	* it does not work well for powershell, cygwin, etc if program path is
+	* prepended to executable directory. 
+	* To achive above, PATH is set to process environment
+	*/
+	_wdupenv_s(&path_value, &len, L"PATH");
+	if (!path_value || (wcsstr(path_value, __wprogdir)) == NULL) {
+		path_new_len = wcslen(__wprogdir) + wcslen(path_value) + 2;
+		if ((path_new_value = (wchar_t *) malloc(path_new_len * sizeof(wchar_t))) == NULL) {
+			errno = ENOMEM;
+			error("failed to allocation memory");
+			return -1;
+		}
+		swprintf_s(path_new_value, path_new_len, L"%s%s%s", __wprogdir, path_value ? L";" : L"",  path_value);
+		if (result = _wputenv_s(L"PATH", path_new_value)) {
+			error("failed to set PATH environment variable: to value:%s, error:%d", path_new_value, result);
+			errno = result;
+			if (path_new_value)
+				free(path_new_value);
+			if(path_value)
+				free(path_value);
+			return -1;
+		}
+		if (path_new_value)
+			free(path_new_value);
+		if(path_value)
+			free(path_value);
+	}
+
+	if (!StartServiceCtrlDispatcherW(dispatch_table)) {
+		if (GetLastError() == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)
+			return sshd_main(argc, wargv); /* sshd running NOT as service*/
+		else
+			return -1;
+	}
+
+	return 0;
+}
+
+int scm_start_service(DWORD num, LPWSTR* args) {
+	service_status_handle = RegisterServiceCtrlHandlerW(L"sshd", service_handler);
+	ZeroMemory(&service_status, sizeof(service_status));
+	service_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+	ReportSvcStatus(SERVICE_START_PENDING, NO_ERROR, 300);
+	prereq_setup();
+	ReportSvcStatus(SERVICE_RUNNING, NO_ERROR, 0);
+	return sshd_main(argc_original, wargv_original);
+}
diff --git a/pal_doexec.h b/pal_doexec.h
new file mode 100644
index 000000000..b4a798b8a
--- /dev/null
+++ b/pal_doexec.h
@@ -0,0 +1,8 @@
+#ifndef _PAL_DOEXEC_H
+#define _PAL_DOEXEC_H
+
+#include "session.h"
+
+int	do_exec_pty(struct ssh *, Session *, const char *);
+int	do_exec_no_pty(struct ssh *, Session *, const char *);
+#endif /* _PAL_DOEXEC_H */
\ No newline at end of file
diff --git a/regress/.gitattributes b/regress/.gitattributes
new file mode 100644
index 000000000..434a50934
--- /dev/null
+++ b/regress/.gitattributes
@@ -0,0 +1,5 @@
+# Set the default behavior, in case people don't have core.autocrlf set.
+* text=auto
+
+# Declare files that will always have LF line endings on checkout.
+*.sh text eol=lf
\ No newline at end of file
diff --git a/regress/pesterTests/AuthorizedKeysCommand.Tests.ps1 b/regress/pesterTests/AuthorizedKeysCommand.Tests.ps1
new file mode 100644
index 000000000..c3c1c4b07
--- /dev/null
+++ b/regress/pesterTests/AuthorizedKeysCommand.Tests.ps1
@@ -0,0 +1,75 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "authorizedKeysCommand"
+        
+Describe "E2E scenarios for AuthorizedKeysCommand" -Tags "CI" {
+    BeforeAll {        
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = 47004
+        $opensshbinpath = $OpenSSHTestInfo['OpenSSHBinPath']
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        $sshdconfig = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config
+        $sshdDelay = $OpenSSHTestInfo["DelayTime"]
+
+        $testDir = Join-Path $OpenSSHTestInfo["TestDataPath"] $suite
+        if(-not (Test-Path $testDir))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+    }
+
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+
+    AfterEach {$tI++;}
+
+    Context "$tC - basic test cases" {
+        
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - keys command with %k argument" {
+            #override authorizedkeysfile location to an unknown location, so AuthorizedKeysCommand gets executed
+            $kcOutFile = Join-Path $testDir "$tC.$tI.kcout.txt"
+            Remove-Item -Force $kcOutFile -ErrorAction SilentlyContinue
+            $sshdArgs = "-ddd -f $sshdconfig  -E $logFile -o `"AuthorizedKeysFile .fake/authorized_keys`""
+            $sshdArgs += " -o `"AuthorizedKeysCommand=$env:windir\system32\cmd.exe /c echo ssh-ed25519 %k & whoami > $kcOutFile`""
+            $sshdArgs += " -o `"AuthorizedKeysCommandUser=$ssouser`""
+            $sshdArgs += " -o PasswordAuthentication=no"
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments $sshdArgs -Port $port
+            $o = ssh -p $port test_target echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"
+            #check the command is run as AuthorizedKeysCommandUser
+            (gc $kcOutFile).Contains($ssouser) | Should Be $true
+        }
+
+        It "$tC.$tI - keys command with %k argument AuthorizedKeysCommandUser as SYSTEM" {
+            #override authorizedkeysfile location to an unknown location, so AuthorizedKeysCommand gets executed
+            $kcOutFile = Join-Path $testDir "$tC.$tI.kcout.txt"
+            Remove-Item -Force $kcOutFile -ErrorAction SilentlyContinue
+            $sshdArgs = "-ddd -f $sshdconfig  -E $logFile -o `"AuthorizedKeysFile .fake/authorized_keys`""
+            $sshdArgs += " -o `"AuthorizedKeysCommand=$env:windir\system32\cmd.exe /c echo ssh-ed25519 %k & whoami > $kcOutFile`""
+            $sshdArgs += " -o `"AuthorizedKeysCommandUser=system`""
+            $sshdArgs += " -o PasswordAuthentication=no"
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments $sshdArgs -Port $port
+            $o = ssh -p $port test_target echo 12345
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "12345"
+            #check the command is run as AuthorizedKeysCommandUser
+            (gc $kcOutFile).Contains("nt authority\system") | Should Be $true
+        }
+    }
+}
diff --git a/regress/pesterTests/Authorized_keys_fileperm.Tests.ps1 b/regress/pesterTests/Authorized_keys_fileperm.Tests.ps1
new file mode 100644
index 000000000..098957bf0
--- /dev/null
+++ b/regress/pesterTests/Authorized_keys_fileperm.Tests.ps1
@@ -0,0 +1,210 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+Import-Module OpenSSHUtils -Force
+$tC = 1
+$tI = 0
+$suite = "authorized_keys_fileperm"
+Describe "Tests for authorized_keys file permission" -Tags "CI" {
+    BeforeAll {    
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+
+        $sshLogName = "test.txt"
+        $sshdLogName = "sshdlog.txt"
+        $server = $OpenSSHTestInfo["Target"]
+        $port = 47003
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        $PwdUser = $OpenSSHTestInfo["PasswdUser"]
+        $ssouserProfile = $OpenSSHTestInfo["SSOUserProfile"]
+        $opensshbinpath = $OpenSSHTestInfo['OpenSSHBinPath']
+        $sshdconfig = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config
+        $sshdDelay = $OpenSSHTestInfo["DelayTime"]
+        Remove-Item -Path (Join-Path $testDir "*$sshLogName") -Force -ErrorAction SilentlyContinue        
+        
+        #skip when the task schedular (*-ScheduledTask) cmdlets does not exist
+        $ts = (get-command get-ScheduledTask -ErrorAction SilentlyContinue)
+        $skip = $ts -eq $null
+        if($IsWindows -and ([Environment]::OSVersion.Version.Major -le 6))
+        {
+            #suppress the firewall blocking dialogue on win7
+            netsh advfirewall firewall add rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any action=allow dir=in
+        }        
+    }
+
+    AfterEach { $tI++ }
+    
+    AfterAll {
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {            
+            netsh advfirewall firewall delete rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any dir=in
+        }    
+    }
+
+    Context "Authorized key file permission" {
+        BeforeAll {
+            $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+            $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+            $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+            $objUserSid = Get-UserSID -User $ssouser
+
+            $ssouserSSHProfilePath = Join-Path $ssouserProfile .testssh
+            if(-not (Test-Path $ssouserSSHProfilePath -PathType Container)) {
+                New-Item $ssouserSSHProfilePath -ItemType directory -Force -ErrorAction Stop | Out-Null
+            }
+            $authorizedkeyPath = Join-Path $ssouserProfile .testssh\authorized_keys
+            $Source = Join-Path $ssouserProfile .ssh\authorized_keys
+            Copy-Item $Source $ssouserSSHProfilePath -Force -ErrorAction Stop            
+            Repair-AuthorizedKeyPermission -Filepath $authorizedkeyPath -confirm:$false
+            if(-not $skip)
+            {
+                Stop-SSHDTestDaemon -Port $port
+            }
+                        
+            #add wrong password so ssh does not prompt password if failed with authorized keys
+            Add-PasswordSetting -Pass "WrongPass"
+            $tI=1
+        }
+
+        AfterAll {
+            Repair-AuthorizedKeyPermission -Filepath $authorizedkeyPath -confirm:$false
+            if(Test-Path $authorizedkeyPath) {
+                Repair-AuthorizedKeyPermission -Filepath $authorizedkeyPath -confirm:$false
+                Remove-Item $authorizedkeyPath -Force -ErrorAction SilentlyContinue
+            }
+            if(Test-Path $ssouserSSHProfilePath) {            
+                Remove-Item $ssouserSSHProfilePath -Force -ErrorAction SilentlyContinue -Recurse
+            }
+            Remove-PasswordSetting
+            $tC++
+        }
+
+        BeforeEach {
+            $sshlog = Join-Path $testDir "$tC.$tI.$sshLogName"
+            $sshdlog = Join-Path $testDir "$tC.$tI.$sshdLogName"
+            if(-not $skip)
+            {
+                Stop-SSHDTestDaemon -Port $port
+            }
+        }       
+
+        It "$tC.$tI-authorized_keys-positive(pwd user is the owner and running process can access to the file)" -skip:$skip {
+            #setup to have ssouser as owner and grant ssouser read and write, admins group, and local system full control            
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owners $objUserSid -FullAccessNeeded  $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            $o = ssh -p $port $ssouser@$server echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-authorized_keys-positive(authorized_keys is owned by local system)"  -skip:$skip {
+            #setup to have system as owner and grant it full control            
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $systemSid -FullAccessNeeded  $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            
+            $o = ssh -p $port $ssouser@$server  echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-authorized_keys-positive(authorized_keys is owned by admins group and pwd does not have explict ACE)"  -skip:$skip {
+            #setup to have admin group as owner and grant it full control            
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            $o = ssh -p $port $ssouser@$server  echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-authorized_keys-positive(authorized_keys is owned by admins group and pwd have explict ACE)"  -skip:$skip {
+            #setup to have admin group as owner and grant it full control
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $adminsSid -FullAccessNeeded $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            $o = ssh -p $port $ssouser@$server  echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"          
+        }
+
+        It "$tC.$tI-authorized_keys-positive(other account can read authorized_keys file)"  -skip:$skip {
+            #setup to have current user as owner and grant it full control
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $objUserSid -FullAccessNeeded $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #add $PwdUser to access the file authorized_keys
+            $objPwdUserSid = Get-UserSid -User $PwdUser
+            Set-FilePermission -FilePath $authorizedkeyPath -User $objPwdUserSid -Perm "Read"
+
+            #Run
+            Start-SSHDTestDaemon -workDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            $o = ssh -p $port -E $sshlog $ssouser@$server echo 1234
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-authorized_keys-negative(authorized_keys is owned by other admin user)"  -skip:$skip {
+            #setup to have current user (admin user) as owner and grant it full control
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $currentUserSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            ssh -p $port -E $sshlog $ssouser@$server echo 1234
+            $LASTEXITCODE | Should Not Be 0
+            Stop-SSHDTestDaemon -Port $port                  
+            sleep $sshdDelay                  
+            $sshlog | Should Contain "Permission denied"
+            $sshdlog | Should Contain "Authentication refused."            
+        }
+
+        It "$tC.$tI-authorized_keys-negative(other account has modify permissions to authorized_keys file)"  -skip:$skip {
+            #setup to have current user as owner and grant it full control            
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $objUserSid -FullAccessNeeded $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #add $PwdUser to access the file authorized_keys
+            $objPwdUserSid = Get-UserSid -User $PwdUser
+            Set-FilePermission -FilePath $authorizedkeyPath -User $objPwdUserSid -Perm "Modify"
+
+            #Run
+            Start-SSHDTestDaemon -workDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            ssh -p $port -E $sshlog $ssouser@$server echo 1234
+            $LASTEXITCODE | Should Not Be 0            
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $sshlog | Should Contain "Permission denied"
+            $sshdlog | Should Contain "Authentication refused."
+        }
+
+        It "$tC.$tI-authorized_keys-negative(authorized_keys is owned by other non-admin user)"  -skip:$skip {
+            #setup to have PwdUser as owner and grant it full control            
+            $objPwdUserSid = Get-UserSid -User $PwdUser
+            Repair-FilePermission -Filepath $authorizedkeyPath -Owner $objPwdUserSid -FullAccessNeeded $adminsSid,$systemSid,$objPwdUser -confirm:$false
+
+            #Run
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdconfig -o `"AuthorizedKeysFile .testssh/authorized_keys`" -E $sshdlog" -Port $port
+            ssh -p $port -E $sshlog $ssouser@$server echo 1234
+            $LASTEXITCODE | Should Not Be 0
+            Stop-SSHDTestDaemon -Port $port
+            sleep $sshdDelay
+            $sshlog | Should Contain "Permission denied"
+            $sshdlog | Should Contain "Authentication refused."            
+        }
+    }
+}
diff --git a/regress/pesterTests/CertAuth.Tests.ps1 b/regress/pesterTests/CertAuth.Tests.ps1
new file mode 100644
index 000000000..2e6a8e216
--- /dev/null
+++ b/regress/pesterTests/CertAuth.Tests.ps1
@@ -0,0 +1,93 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "certauth"
+        
+Describe "E2E scenarios for certificate authentication" -Tags "CI" {
+    BeforeAll {        
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = $OpenSSHTestInfo["Port"]
+        $pkuser = $OpenSSHTestInfo["PubKeyUser"]
+        $cakey = $OpenSSHTestInfo["CA_Private_Key"]
+        $opensshbinpath = $OpenSSHTestInfo['OpenSSHBinPath']
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        $sshdconfig = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config
+        $sshdDelay = $OpenSSHTestInfo["DelayTime"]
+        
+        $testDir = Join-Path $OpenSSHTestInfo["TestDataPath"] $suite
+        if(-not (Test-Path $testDir))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        $user_key = Join-Path $testDir "cert_auth_user_key"
+        $keypassphrase = "testpassword"        
+    }
+
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+
+    AfterEach {$tI++;}
+
+    Context "$tC - generate certificates" {
+        
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - sign user keys" {
+            Remove-Item "$($user_key)*"
+            ssh-keygen -t ed25519 -f $user_key  -P $keypassphrase
+            $user_key | Should Exist
+            $nullFile = join-path $testDir ("$tC.$tI.nullfile")
+            $null > $nullFile
+            $user_key_pub = ($user_key + ".pub")
+            iex "cmd /c `"ssh-keygen -s $cakey -I $pkuser -V -1w:+54w5d  -n $pkuser $user_key_pub < $nullFile 2> nul `""
+        }
+
+    }
+
+    Context "$tC - ssh with certificate" {
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - authenticate using certificate" {
+            #set up SSH_ASKPASS for key passphrase
+            Add-PasswordSetting -Pass $keypassphrase
+            $o = ssh -i $user_key -p $port $pkuser@$server echo 1234
+            $o | Should Be "1234"
+            Remove-PasswordSetting            
+        }
+
+        It "$tC.$tI - authenticate using certificate via AuthorizedPrincipalsCommand" {
+            $pcOutFile = Join-Path $testDir "$tC.$tI.pcout.txt"
+            $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+            Remove-Item -Force $pcOutFile -ErrorAction SilentlyContinue
+            $sshdArgs = "-d -f $sshdconfig  -E $logFile -o `"AuthorizedKeysFile .fake/authorized_keys`""
+            $sshdArgs += " -o `"AuthorizedPrincipalsCommand=$env:windir\system32\cmd.exe /c echo otheruser& echo $pkuser& whoami > $pcOutFile`""
+            $sshdArgs += " -o `"AuthorizedPrincipalsCommandUser=$ssouser`""
+            $sshdArgs += " -o PasswordAuthentication=no"
+
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments $sshdArgs -Port 47004
+            
+            #set up SSH_ASKPASS for key passphrase
+            Add-PasswordSetting -Pass $keypassphrase
+            $o = ssh -i $user_key -p 47004 $pkuser@$server echo 2345
+            Remove-PasswordSetting   
+            
+            Stop-SSHDTestDaemon -Port 47004
+            sleep $sshdDelay
+            $o | Should Be "2345"
+            #check the command is run as AuthorizedPrincipalsCommandUser
+            (gc $pcOutFile).Contains($ssouser) | Should Be $true          
+        }
+    }
+
+}
diff --git a/regress/pesterTests/Cfginclude.Tests.ps1 b/regress/pesterTests/Cfginclude.Tests.ps1
new file mode 100644
index 000000000..315a3bb34
--- /dev/null
+++ b/regress/pesterTests/Cfginclude.Tests.ps1
@@ -0,0 +1,138 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "Cfginclude"
+Describe "Tests for ssh config" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        if(-not (Test-Path $OpenSSHTestInfo["TestDataPath"]))
+        {
+            $null = New-Item $OpenSSHTestInfo["TestDataPath"] -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        $logName = "testlog.txt"
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = $OpenSSHTestInfo["Port"]
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+
+        # for the first time, delete the existing log files.
+        if ($OpenSSHTestInfo['DebugMode'])
+        {         
+            Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+            Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue         
+            Remove-Item -Path (Join-Path $testDir "*log*.log") -Force -ErrorAction SilentlyContinue
+        }
+        
+        Remove-Item -Path (Join-Path $testDir "*logName") -Force -ErrorAction SilentlyContinue
+    }
+
+    AfterEach {        
+        if( $OpenSSHTestInfo["DebugMode"])
+        {
+            Copy-Item "$env:ProgramData\ssh\logs\ssh-agent.log" "$testDir\agentlog$tC.$tI.log" -Force -ErrorAction SilentlyContinue
+            Copy-Item "$env:ProgramData\ssh\logs\sshd.log" "$testDir\sshdlog$tC.$tI.log" -Force -ErrorAction SilentlyContinue
+                    
+            #Clear the ssh-agent, sshd logs so that next testcase will get fresh logs.
+            Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+            Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue
+        }
+        $tI++
+    }
+
+    Context "$tC-User SSHConfig--ReadConfig" {
+        BeforeAll {
+            $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+            $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+            $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+            $objUserSid = Get-UserSID -User $ssouser
+
+            $userConfigFile = Join-Path $home ".ssh\config"
+            if( -not (Test-path $userConfigFile) ) {
+                #prep sample config
+                Add-Content "PubkeyAcceptedKeyTypes ssh-ed25519*" $userConfigFile 
+            }
+            Enable-Privilege SeRestorePrivilege | out-null
+            $oldACL = Get-ACL $userConfigFile
+            $tI=1
+        }
+
+        BeforeEach {
+            $logPath = Join-Path $testDir "$tC.$tI.$logName"
+        }
+
+        AfterEach {            
+            Set-Acl -Path $userConfigFile -AclObject $oldACL -confirm:$false
+        }
+
+        AfterAll {
+            $tC++
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig positive (current logon user is the owner)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $currentUserSid -FullAccessNeeded $adminsSid,$systemSid,$currentUserSid -confirm:$false
+
+            #Run
+            $o = ssh test_target echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig positive (local system is the owner)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $systemSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+            $o = ssh test_target echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig positive (admin is the owner and current user has no explict ACE)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+            Set-FilePermission -Filepath $userConfigFile -UserSid $currentUserSid -Action Delete
+
+            #Run
+            $o = ssh test_target echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig positive (admin is the owner and current user has explict ACE)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid,$currentUserSid -confirm:$false
+            
+            #Run
+            $o = ssh test_target echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig negative (wrong owner)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $objUserSid -FullAccessNeeded $adminsSid,$systemSid,$objUserSid -confirm:$false
+
+            #Run
+            cmd /c "ssh test_target echo 1234 2> $logPath"
+            $LASTEXITCODE | Should Not Be 0
+            Get-Content $logPath | Should Match "^Bad owner or permissions on [a-fA-F]:[/\\]{1,}Users[/\\]{1,}\w+[/\\]{1,}.ssh[/\\]{1,}config$"
+        }
+
+        It "$tC.$tI-User SSHConfig-ReadConfig negative (others has permission)" {
+            #setup
+            Repair-FilePermission -Filepath $userConfigFile -Owners $currentUserSid -FullAccessNeeded $adminsSid,$systemSid,$currentUserSid,$objUserSid -confirm:$false
+
+            #Run
+            cmd /c "ssh test_target echo 1234 2> $logPath"
+            $LASTEXITCODE | Should Not Be 0
+            $logPath | Should Contain "^Bad owner or permissions on [a-fA-F]:[/\\]{1,}Users[/\\]{1,}\w+[/\\]{1,}.ssh[/\\]{1,}config$"
+        }
+    }
+}
diff --git a/regress/pesterTests/CommonUtils.psm1 b/regress/pesterTests/CommonUtils.psm1
new file mode 100644
index 000000000..109dc5543
--- /dev/null
+++ b/regress/pesterTests/CommonUtils.psm1
@@ -0,0 +1,145 @@
+﻿Import-Module OpenSSHUtils -Force
+
+Add-Type -TypeDefinition @"
+   public enum PlatformType
+   {
+      Windows,
+      Linux,
+      OSX
+   }
+"@
+
+function Set-FilePermission
+{    
+    param(
+        [parameter(Mandatory=$true)]
+        [string]$FilePath,
+        [parameter(Mandatory=$true)]
+        [System.Security.Principal.SecurityIdentifier] $UserSid,
+        [System.Security.AccessControl.FileSystemRights[]]$Perms,
+        [System.Security.AccessControl.AccessControlType] $AccessType = "Allow",
+        [ValidateSet("Add", "Delete")]
+        [string]$Action = "Add"
+    )    
+
+    $myACL = Get-ACL $FilePath
+    $account = Get-UserAccount -UserSid $UserSid
+    if($Action -ieq "Delete")
+    {
+        $myACL.SetAccessRuleProtection($True, $True)
+        Enable-Privilege SeRestorePrivilege | out-null
+        Set-Acl -Path $FilePath -AclObject $myACL
+        $myACL = Get-ACL $FilePath
+        
+        if($myACL.Access) 
+        {        
+            $myACL.Access | % {
+                if($_.IdentityReference.Equals($account))
+                {
+                    if($_.IsInherited)
+                    {
+                        $myACL.SetAccessRuleProtection($True, $True)
+                        Enable-Privilege SeRestorePrivilege | out-null
+                        Set-Acl -Path $FilePath -AclObject $myACL
+                        $myACL = Get-ACL $FilePath
+                    }
+                    
+                    if(-not ($myACL.RemoveAccessRule($_)))
+                    {
+                        throw "failed to remove access of $($_.IdentityReference) rule in setup "
+                    }
+                }
+            }
+        } 
+    }
+    elseif($Perms)
+    {
+        $Perms | % { 
+            $userACE = New-Object System.Security.AccessControl.FileSystemAccessRule `
+                ($UserSid, $_, "None", "None", $AccessType)
+            $myACL.AddAccessRule($userACE)
+        }
+    }
+    Enable-Privilege SeRestorePrivilege | out-null
+    Set-Acl -Path $FilePath -AclObject $myACL -confirm:$false
+}
+
+function Add-PasswordSetting 
+{
+    param([string] $pass)
+    if ($IsWindows) {
+        if (-not($env:DISPLAY)) {$env:DISPLAY = 1}
+        $askpass_util = Join-Path $PSScriptRoot "utilities\askpass_util\askpass_util.exe"
+        $env:SSH_ASKPASS=$askpass_util
+        $env:ASKPASS_PASSWORD=$pass
+        $env:SSH_ASKPASS_REQUIRE="prefer"
+    }
+}
+
+function Remove-PasswordSetting
+{
+    if ($env:DISPLAY -eq 1) { Remove-Item env:\DISPLAY -ErrorAction SilentlyContinue }
+    Remove-item "env:SSH_ASKPASS" -ErrorAction SilentlyContinue
+    Remove-item "env:ASKPASS_PASSWORD" -ErrorAction SilentlyContinue
+    Remove-item "env:SSH_ASKPASS_REQUIRE" -ErrorAction SilentlyContinue
+}
+
+$Taskfolder = "\OpenSSHTestTasks\"
+$Taskname = "StartTestDaemon"
+        
+function Start-SSHDTestDaemon
+{
+    param(
+    [string] $Arguments,
+    [string] $Workdir,
+    [string] $Port)    
+
+    $Arguments += " -p $Port"
+    $ac = New-ScheduledTaskAction -Execute (join-path $workdir "sshd") -WorkingDirectory $workdir -Argument $Arguments
+    $task = Register-ScheduledTask -TaskName $Taskname -User system -Action $ac -TaskPath $Taskfolder -Force    
+    Start-ScheduledTask -TaskPath $Taskfolder -TaskName $Taskname
+    #sleep for 1 seconds for process to ready to listener
+    $num = 0
+    while ((netstat -anop TCP | select-string -Pattern "0.0.0.0:$Port") -eq $null)
+    {
+        start-sleep 1
+        $num++
+        if($num -gt 30) { break }
+    }
+}
+
+function Stop-SSHDTestDaemon
+{
+    param(
+    [string] $Port) 
+
+    $task = Get-ScheduledTask -TaskPath $Taskfolder -TaskName $Taskname -ErrorAction SilentlyContinue
+    if($task)
+    {
+        if($task.State -eq "Running")
+        {
+            Stop-ScheduledTask -TaskPath $Taskfolder -TaskName $Taskname
+        }        
+        Unregister-ScheduledTask -TaskPath $Taskfolder -TaskName $Taskname -Confirm:$false
+    }
+
+    #kill process listening on $Port
+    $p = netstat -anop TCP | select-string -Pattern "0.0.0.0:$Port"
+    if (-not($p -eq $null)) 
+    {
+        foreach ($ps in $p) {
+            $pss =$ps.ToString() -split "\s+"; 
+            $processid = $pss[$pss.length -1] 
+            Stop-Process -Id $processid -Force -ErrorAction SilentlyContinue
+        }
+        #if still running, wait a little while for task to complete
+        $num = 0
+        while (-not((netstat -anop TCP | select-string -Pattern "0.0.0.0:$Port") -eq $null))
+        {
+            start-sleep 1
+            $num++
+            if($num -gt 30) { break }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/regress/pesterTests/FileBasedLogging.tests.ps1 b/regress/pesterTests/FileBasedLogging.tests.ps1
new file mode 100644
index 000000000..a78254a58
--- /dev/null
+++ b/regress/pesterTests/FileBasedLogging.tests.ps1
@@ -0,0 +1,225 @@
+If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+Import-Module OpenSSHUtils -Force
+$tC = 1
+$tI = 0
+$suite = "FileBasedLogging"
+Describe "Tests for admin and non-admin file based logs" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }        
+
+        $sshLogName = "test.txt"
+        $sshdLogName = "sshdlog.txt"
+        $server = $OpenSSHTestInfo["Target"]
+        $opensshbinpath = $OpenSSHTestInfo['OpenSSHBinPath']
+        $nonadminusername = $OpenSSHTestInfo['NonAdminUser']
+        $adminusername = $OpenSSHTestInfo['AdminUser']
+        $password = $OpenSSHTestInfo['TestAccountPW']
+        $port = 47003  
+        $sshdDelay = $OpenSSHTestInfo["DelayTime"]		
+        Remove-Item -Path (Join-Path $testDir "*$sshLogName") -Force -ErrorAction SilentlyContinue
+
+        <# Setup sshd_config file#>
+        
+        $sshdconfig_ori = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config
+        $sshdconfig_custom = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config_custom
+        if (Test-Path $sshdconfig_custom) {
+            Remove-Item $sshdconfig_custom -Force
+        }
+        Copy-Item $sshdconfig_ori $sshdconfig_custom
+        get-acl $sshdconfig_ori | set-acl $sshdconfig_custom
+        $content = Get-Content -Path $sshdconfig_custom
+        $newContent = $content -replace "Subsystem	sftp	sftp-server.exe -l DEBUG3", "Subsystem	sftp	sftp-server.exe -l DEBUG3 -f LOCAL0"
+        $newContent | Set-Content -Path $sshdconfig_custom
+
+        #skip when the task schedular (*-ScheduledTask) cmdlets does not exist
+        $ts = (get-command get-ScheduledTask -ErrorAction SilentlyContinue)
+        $skip = $ts -eq $null
+        if(-not $skip)
+        {
+            Stop-SSHDTestDaemon   -Port $port
+        }
+        if($IsWindows -and ([Environment]::OSVersion.Version.Major -le 6))
+        {
+            #suppress the firewall blocking dialogue on win7
+            netsh advfirewall firewall add rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any action=allow dir=in
+        }
+    }
+
+    AfterEach { $tI++ }
+    
+    AfterAll {        
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {            
+            netsh advfirewall firewall delete rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any dir=in
+        }    
+    }
+
+
+    Context "Tests Logs for SSH connections" {
+        BeforeAll {            
+            $sshdConfigPath = $sshdconfig_custom
+            Add-PasswordSetting -Pass $password
+            $tI=1
+        }
+        
+        BeforeEach {
+            $sshlog = Join-Path $testDir "$tC.$tI.$sshLogName"            
+            $sshdlog = Join-Path $testDir "$tC.$tI.$sshdLogName"
+
+            if (Test-Path $sshdlog -PathType Leaf) {
+                Clear-Content $sshdlog
+            }
+
+            if(-not $skip)
+            {
+                Stop-SSHDTestDaemon   -Port $port
+            }
+        }
+
+        AfterAll {            
+            Remove-PasswordSetting
+            $tC++
+        }
+
+        It "$tC.$tI-Nonadmin SSH Connection"  -skip:$skip {
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-ddd -f $sshdConfigPath -E $sshdlog" -Port $port
+            $o = ssh -vvv -p $port -E $sshlog $nonadminusername@$server echo 1234
+            $o | Should Be 1234
+            Stop-SSHDTestDaemon   -Port $port
+            sleep $sshdDelay
+            $sshdlog | Should Contain "KEX done \[preauth\]"
+            $sshdlog | Should Contain "exec_command: echo 1234"
+        }
+
+        It "$tC.$tI-Admin SSH Connection"  -skip:$skip {
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-ddd -f $sshdConfigPath -E $sshdlog" -Port $port
+            $o = ssh -vvv -p $port -E $sshlog $adminusername@$server echo 1234
+            $o | Should Be 1234
+            Stop-SSHDTestDaemon   -Port $port
+            sleep $sshdDelay
+            $sshdlog | Should Contain "KEX done \[preauth\]"
+            $sshdlog | Should Contain "exec_command: echo 1234"
+        }
+    }
+
+    Context "Tests Logs for SFTP connections" {
+
+        BeforeAll {
+            $sshdConfigPath = $sshdconfig_custom
+
+            function Setup-KeyBasedAuth
+            {
+                param([string] $Username, [string] $KeyFilePath, [string] $UserProfile)
+
+                $userSSHProfilePath = Join-Path $UserProfile .ssh
+
+                if (-not (Test-Path $userSSHProfilePath -PathType Container)) {
+                    New-Item $userSSHProfilePath -ItemType directory -Force -ErrorAction Stop | Out-Null
+                }
+
+                $authorizedkeyPath = Join-Path $userSSHProfilePath authorized_keys
+
+                if($OpenSSHTestInfo["NoLibreSSL"])
+                {
+                    ssh-keygen.exe -t ed25519 -f $KeyFilePath -Z -P "" aes128-ctr
+                }
+                else
+                {
+                    ssh-keygen.exe -t ed25519 -f $KeyFilePath -P ""
+                }
+                Copy-Item "$keyFilePath.pub" $authorizedkeyPath -Force -ErrorAction SilentlyContinue
+                Repair-AuthorizedKeyPermission -Filepath $authorizedkeyPath -confirm:$false
+            }
+
+            $AdminUserProfile = $OpenSSHTestInfo['AdminUserProfile']
+            $NonAdminUserProfile = $OpenSSHTestInfo['NonAdminUserProfile']
+
+            $KeyFileName = $nonadminusername + "_sshtest_fileBasedLog_ed25519"
+            $NonadminKeyFilePath = Join-Path $testDir $keyFileName
+            Remove-Item -path "$NonadminKeyFilePath*" -Force -ErrorAction SilentlyContinue
+            Setup-KeyBasedAuth -Username $nonadminusername -KeyFilePath $NonadminKeyFilePath -UserProfile $NonAdminUserProfile
+
+            $KeyFileName = $adminusername + "_sshtest_fileBasedLog_ed25519"
+            $AdminKeyFilePath = Join-Path $testDir $keyFileName
+            Remove-Item -path "$AdminKeyFilePath*" -Force -ErrorAction SilentlyContinue
+            Setup-KeyBasedAuth -Username $adminusername -KeyFilePath $AdminKeyFilePath -UserProfile $AdminUserProfile
+
+            #create batch file
+            $commands = 
+"ls
+exit"
+            $batchFilePath = Join-Path $testDir "$tC.$tI.commands.txt"
+            Set-Content $batchFilePath -Encoding UTF8 -value $commands
+
+            $tI = 1
+        }
+
+        BeforeEach {
+            Clear-Content "$env:ProgramData\ssh\logs\sftp-server.log" -Force -ErrorAction SilentlyContinue
+            $sshlog = Join-Path $testDir "$tC.$tI.$sshLogName"            
+            $sshdlog = Join-Path $testDir "$tC.$tI.$sshdLogName"
+            if (Test-Path $sshdlog -PathType Leaf) {
+                Clear-Content $sshdlog
+            }
+            if(-not $skip)
+            {
+                Stop-SSHDTestDaemon   -Port $port
+            }
+        }
+
+        AfterAll {
+            Remove-Item -path "$NonadminKeyFilePath*" -Force -ErrorAction SilentlyContinue
+            Remove-Item -path "$AdminKeyFilePath*" -Force -ErrorAction SilentlyContinue
+
+            $authorized_key = Join-Path .ssh authorized_keys
+            $AdminAuthKeysPath = Join-Path $AdminUserProfile $authorized_key
+            $NonAdminAuthKeysPath = Join-Path $NonAdminUserProfile $authorized_key
+            Remove-Item -path "$AdminAuthKeysPath*" -Force -ErrorAction SilentlyContinue
+            Remove-Item -path "$NonAdminAuthKeysPath*" -Force -ErrorAction SilentlyContinue
+
+            $tC++
+        }
+
+        It "$tC.$tI-Nonadmin SFTP Connection"  -skip:$skip {
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-ddd -f $sshdConfigPath -E $sshdlog" -Port $port
+            sftp -P $port -i $NonadminKeyFilePath -b $batchFilePath $nonadminusername@$server
+            Stop-SSHDTestDaemon   -Port $port
+            sleep $sshdDelay
+            $sftplog = Join-Path $testDir "$tC.$tI.sftp-server.log"
+            Copy-Item "$env:ProgramData\ssh\logs\sftp-server.log" $sftplog -Force -ErrorAction SilentlyContinue
+
+            $sshdlog | Should Contain "Accepted publickey for $nonadminusername"
+            $sshdlog | Should Contain "KEX done \[preauth\]"
+            $sshdlog | Should Contain "debug2: subsystem request for sftp by user $nonadminusername"
+            $sftplog | Should Contain "session opened for local user $nonadminusername"
+            $sftplog | Should Contain "debug3: request 3: opendir"
+            $sftplog | Should Contain "session closed for local user $nonadminusername"
+        }
+
+        It "$tC.$tI-Admin SFTP Connection"  -skip:$skip {	
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-ddd -f $sshdConfigPath -E $sshdlog" -Port $port
+            sftp -P $port -i $AdminKeyFilePath -b $batchFilePath $adminusername@$server
+            Stop-SSHDTestDaemon   -Port $port
+            sleep $sshdDelay
+            $sftplog = Join-Path $testDir "$tC.$tI.sftp-server.log"
+            Copy-Item "$env:ProgramData\ssh\logs\sftp-server.log" $sftplog -Force -ErrorAction SilentlyContinue
+  
+            $sshdlog | Should Contain "Accepted publickey for $adminusername"
+            $sshdlog | Should Contain "KEX done \[preauth\]"
+            $sshdlog | Should Contain "debug2: subsystem request for sftp by user $adminusername"
+            $sftplog | Should Contain "session opened for local user $adminusername"
+            $sftplog | Should Contain "debug3: request 3: opendir"
+            $sftplog | Should Contain "session closed for local user $adminusername"
+        }
+    }
+}
diff --git a/regress/pesterTests/Hostkey_fileperm.Tests.ps1 b/regress/pesterTests/Hostkey_fileperm.Tests.ps1
new file mode 100644
index 000000000..a6408829e
--- /dev/null
+++ b/regress/pesterTests/Hostkey_fileperm.Tests.ps1
@@ -0,0 +1,152 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "hostkey_fileperm"
+Describe "Tests for host keys file permission" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        
+        $logName = "sshdlog.txt"
+        $port = 47003
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        $script:logNum = 0
+        Remove-Item -Path (Join-Path $testDir "*$logName") -Force -ErrorAction SilentlyContinue        
+        $skip = $IsWindows -and ([Environment]::OSVersion.Version.Major -le 6) -and ([Environment]::OSVersion.Version.Minor -lt 2)
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {
+            #suppress the firewall blocking dialogue on win7
+            netsh advfirewall firewall add rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any action=allow dir=in
+        }
+    }
+
+    AfterEach { $tI++ }
+    AfterAll {
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {            
+            netsh advfirewall firewall delete rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any dir=in
+        }    
+    }
+
+    Context "$tC - Host key files permission" {
+        BeforeAll {
+            $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+            $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)
+            $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+            $objUserSid = Get-UserSID -User $ssouser
+            $everyoneSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::WorldSid)
+            
+            $hostKeyFilePath = join-path $testDir hostkeyFilePermTest_ed25519_key
+            if(Test-path $hostKeyFilePath -PathType Leaf) {
+                Repair-SshdHostKeyPermission -filepath $hostKeyFilePath -confirm:$false
+            }
+            Remove-Item -path "$hostKeyFilePath*" -Force -ErrorAction SilentlyContinue
+            ssh-keygen.exe -t ed25519 -f $hostKeyFilePath -P `"`"
+            Get-Process -Name sshd  -ErrorAction SilentlyContinue | Where-Object {$_.SessionID -ne 0} | Stop-process -force -ErrorAction SilentlyContinue
+            $tI=1
+            
+            function WaitForValidation
+            {
+                param([string]$logPath, [int]$length)
+                $num = 0
+                while((-not (Test-Path $logPath -PathType leaf)) -or ((Get-item $logPath).Length -lt $length) -and ($num++ -lt 4))
+                {
+                    Start-Sleep -Milliseconds 1000
+                }
+                Get-Process -Name sshd  -ErrorAction SilentlyContinue | Where-Object {$_.SessionID -ne 0} | Stop-process -force -ErrorAction SilentlyContinue
+                
+                $num = 0
+                while ([string]::IsNullorEmpty($(Get-Content $logPath -ErrorAction SilentlyContinue | Out-String)) -and ($num++ -lt 4))
+                {
+                    Start-Sleep -Milliseconds 1000
+                }
+            }
+        }
+
+        BeforeEach {
+            $logPath = Join-Path $testDir "$tC.$tI.$logName"
+        }
+
+        AfterEach {
+            if(Test-path $hostKeyFilePath -PathType Leaf) {
+                Repair-SshdHostKeyPermission -filepath $hostKeyFilePath -confirm:$false
+            }            
+        }
+        AfterAll { $tC++ }
+
+        It "$tC.$tI-Host keys-positive (both public and private keys are owned by admin groups and running process can access to public key file)" {            
+            Repair-FilePermission -Filepath $hostKeyFilePath -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+            Repair-FilePermission -Filepath "$hostKeyFilePath.pub" -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+        
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-h $hostKeyFilePath", "-E $logPath") -NoNewWindow
+            WaitForValidation -LogPath $logPath -Length 600            
+
+            #validate file content does not contain unprotected info.
+            $logPath | Should Not Contain "UNPROTECTED PRIVATE KEY FILE!"
+            
+        }
+
+        It "$tC.$tI-Host keys-positive (both public and private keys are owned by admin groups and pwd user has explicit ACE)" {            
+            Repair-FilePermission -Filepath $hostKeyFilePath -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -ReadAccessNeeded $currentUserSid -confirm:$false
+            Repair-FilePermission -Filepath "$hostKeyFilePath.pub" -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -ReadAccessNeeded $everyOneSid -confirm:$false
+
+            #Run
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-h $hostKeyFilePath", "-E $logPath") -NoNewWindow
+            WaitForValidation -LogPath $logPath -Length 600         
+
+            #validate file content does not contain unprotected info.
+            $logPath | Should Not Contain "UNPROTECTED PRIVATE KEY FILE!"
+        }
+
+        It "$tC.$tI-Host keys-positive (both public and private keys are owned by system and running process can access to public key file)" -skip:$skip {
+            Repair-FilePermission -Filepath $hostKeyFilePath -Owners $systemSid -FullAccessNeeded $systemSid,$adminsSid -ReadAccessNeeded $currentUserSid -confirm:$false
+            Set-FilePermission -Filepath $hostKeyFilePath -UserSid $adminsSid -Action Delete
+            Repair-FilePermission -Filepath "$hostKeyFilePath.pub" -Owners $systemSid -FullAccessNeeded $systemSid,$adminsSid -ReadAccessNeeded $currentUserSid -confirm:$false
+            Set-FilePermission -Filepath "$hostKeyFilePath.pub" -UserSid $adminsSid -Action Delete
+            
+            #Run
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-h $hostKeyFilePath", "-E $logPath") -NoNewWindow
+            WaitForValidation -LogPath $logPath -Length 600
+
+            #validate file content does not contain unprotected info.
+            $logPath | Should Not Contain "UNPROTECTED PRIVATE KEY FILE!"
+        }
+
+        It "$tC.$tI-Host keys-negative (other account can access private key file)" {
+            Repair-FilePermission -Filepath $hostKeyFilePath -Owners $adminsSid -FullAccessNeeded $systemSid,$adminsSid -ReadAccessNeeded $objUserSid -confirm:$false
+            Repair-FilePermission -Filepath "$hostKeyFilePath.pub" -Owners $adminsSid -FullAccessNeeded $systemSid,$adminsSid -ReadAccessNeeded $everyOneSid -confirm:$false
+            
+            #Run
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-h $hostKeyFilePath", "-E $logPath") -NoNewWindow
+            WaitForValidation -LogPath $logPath -Length 1100
+
+            #validate file content contains unprotected info.
+            $logPath | Should Contain "bad permissions"            
+        }
+
+        It "$tC.$tI-Host keys-negative (the private key has wrong owner)" {
+            #setup to have ssouser as owner and grant it full control
+            Repair-FilePermission -Filepath $hostKeyFilePath -Owners $objUserSid -FullAccessNeeded $systemSid,$adminsSid,$objUserSid -confirm:$false
+            Repair-FilePermission -Filepath "$hostKeyFilePath.pub" -Owners $adminsSid -FullAccessNeeded $systemSid,$adminsSid -ReadAccessNeeded $everyOneSid -confirm:$false
+
+            #Run
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-h $hostKeyFilePath", "-E $logPath") -NoNewWindow
+            WaitForValidation -LogPath $logPath -Length 1100
+
+            #validate file content contains unprotected info.
+            $logPath | Should Contain "bad permissions"
+        }
+
+    }
+}
diff --git a/regress/pesterTests/KeyUtils.Tests.ps1 b/regress/pesterTests/KeyUtils.Tests.ps1
new file mode 100644
index 000000000..94029f8af
--- /dev/null
+++ b/regress/pesterTests/KeyUtils.Tests.ps1
@@ -0,0 +1,471 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "keyutils"
+
+Describe "E2E scenarios for ssh key management" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+
+        $keypassphrase = "testpassword"
+        $NoLibreSSL = $OpenSSHTestInfo["NoLibreSSL"]
+        if($NoLibreSSL)
+        {
+            $keytypes = @("ed25519")                
+        }
+        else
+        {
+            $keytypes = @("rsa","dsa","ecdsa","ed25519")            
+        }
+        
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        
+        $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+        $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+        $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+        $objUserSid = Get-UserSID -User $ssouser
+        $everyoneSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::WorldSid)              
+
+        function ValidateRegistryACL {
+            param([string]$UserSid = $currentUserSid, $count)
+            $agentPath = "Registry::HKEY_Users\$UserSid\Software\OpenSSH\Agent"                       
+            $myACL = Get-ACL $agentPath
+            $OwnerSid = Get-UserSid -User $myACL.Owner
+            $OwnerSid.Equals($adminsSid) | Should Be $true
+            $myACL.Access | Should Not Be $null
+            $FullControlPerm = [System.UInt32] [System.Security.AccessControl.RegistryRights]::FullControl.value__
+            $identities = @($systemSid, $adminsSid)
+
+            foreach ($a in $myACL.Access) {
+                $id = Get-UserSid -User $a.IdentityReference
+                $identities -contains $id | Should Be $true                
+                ([System.UInt32]$a.RegistryRights.value__) | Should Be $FullControlPerm            
+                $a.AccessControlType | Should Be ([System.Security.AccessControl.AccessControlType]::Allow)
+                $a.IsInherited | Should Be $false
+                $a.InheritanceFlags | Should Be ([System.Security.AccessControl.InheritanceFlags]::None)
+                $a.PropagationFlags | Should Be ([System.Security.AccessControl.PropagationFlags]::None)
+            }
+
+            $entries = @(Get-ChildItem $agentPath\keys)
+            $entries.Count | Should Be $count
+            if($count -gt 0)
+            {
+                Test-Path $agentPath\keys | Should be $true                
+                $entries | % {
+                    $keyentryAcl = Get-Acl $_.pspath
+                    $OwnerSid = Get-UserSid -User $keyentryAcl.Owner
+                    $OwnerSid.Equals($adminsSid) | Should Be $true
+                    $keyentryAcl.Access | Should Not Be $
+                    foreach ($a in $keyentryAcl.Access) {
+                        $id = Get-UserSid -User $a.IdentityReference
+                        $identities -contains $id | Should Be $true                
+                        ([System.UInt32]$a.RegistryRights.value__) | Should Be $FullControlPerm            
+                        $a.AccessControlType | Should Be ([System.Security.AccessControl.AccessControlType]::Allow)
+                        $a.IsInherited | Should Be $false
+                        $a.InheritanceFlags | Should Be ([System.Security.AccessControl.InheritanceFlags]::None)
+                        $a.PropagationFlags | Should Be ([System.Security.AccessControl.PropagationFlags]::None)
+                    }
+                }                
+            }
+            else
+            {
+                Test-Path $agentPath\keys | Should be $false
+            }            
+        }
+
+        #only validate owner and ACEs of the file
+        function ValidateKeyFile {
+            param(
+                [string]$FilePath,
+                [bool]$IsHostKey = $true
+            )
+
+            $myACL = Get-ACL $FilePath
+            $currentOwnerSid = Get-UserSid -User $myACL.Owner
+            $currentOwnerSid.Equals($currentUserSid) | Should Be $true
+            $myACL.Access | Should Not Be $null
+            
+            $ReadAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Read.value__) -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+            $ReadWriteAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Read.value__) -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Write.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Modify.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+
+            $FullControlPerm = [System.UInt32] [System.Security.AccessControl.FileSystemRights]::FullControl.value__
+    
+            if($FilePath.EndsWith(".pub")) {
+                if ($IsHostKey) {
+                    $myACL.Access.Count | Should Be 3
+                    $identities = @($systemSid, $adminsSid, $currentUserSid)
+                }
+                else {
+                    $myACL.Access.Count | Should Be 4
+                    $identities = @($systemSid, $adminsSid, $currentUserSid, $everyoneSid)
+                }
+            }
+            else {
+                $myACL.Access.Count | Should Be 3
+                $identities = @($systemSid, $adminsSid, $currentUserSid)
+            }
+
+            foreach ($a in $myACL.Access) {
+                $id = Get-UserSid -User $a.IdentityReference
+                $identities -contains $id | Should Be $true           
+
+                switch ($id)
+                {
+                    {@($systemSid, $adminsSid) -contains $_}
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FullControlPerm
+                        break;
+                    }
+
+                    $currentUserSid
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $ReadWriteAccessPerm
+                        break;
+                    }
+                    $everyoneSid
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $ReadAccessPerm
+                        break;
+                    }
+                }
+            
+                $a.AccessControlType | Should Be ([System.Security.AccessControl.AccessControlType]::Allow)
+                $a.IsInherited | Should Be $false
+                $a.InheritanceFlags | Should Be ([System.Security.AccessControl.InheritanceFlags]::None)
+                $a.PropagationFlags | Should Be ([System.Security.AccessControl.PropagationFlags]::None)
+            }
+        }
+    }
+
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+
+    AfterEach {$tI++;}    
+
+    Context "$tC -ssh-keygen all key types" {
+
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - Keygen -A" {
+            Push-Location $testDir
+            remove-item ssh_host_*_key* -ErrorAction SilentlyContinue
+            ssh-keygen -A
+            Pop-Location
+            
+            Get-ChildItem (join-path $testDir ssh_host_*_key) | % {
+                ValidateKeyFile -FilePath $_.FullName
+            }
+
+            Get-ChildItem (join-path $testDir ssh_host_*_key.pub) | % {
+                ValidateKeyFile -FilePath $_.FullName
+            }            
+        }
+
+        It "$tC.$tI - Keygen -t -f" {
+            foreach($type in $keytypes)
+            {
+                $keyPath = Join-Path $testDir "id_$type"
+                remove-item $keyPath -ErrorAction SilentlyContinue
+                if($OpenSSHTestInfo["NoLibreSSL"])
+                {
+                    ssh-keygen -t $type -P $keypassphrase -f $keyPath -Z aes128-ctr
+                }
+                else
+                {
+                    ssh-keygen -t $type -P $keypassphrase -f $keyPath
+                }                
+                ValidateKeyFile -FilePath $keyPath
+                ValidateKeyFile -FilePath "$keyPath.pub" -IsHostKey $false
+            }
+        }
+    }
+
+    # This uses keys generated in above context
+    Context "$tC -ssh-add test cases" {
+        BeforeAll {
+            $tI=1
+            function WaitForStatus
+            {
+                param([string]$ServiceName, [string]$Status)
+                while((((Get-Service $ServiceName).Status) -ine $Status) -and ($num++ -lt 4))
+                {
+                    Start-Sleep -Milliseconds 1000
+                }
+            }
+        }
+        AfterAll{$tC++}
+
+        # Executing ssh-agent will start agent service
+        # This is to support typical Unix scenarios where 
+        # running ssh-agent will setup the agent for current session
+        It "$tC.$tI - ssh-agent starts agent service" {
+            if ((Get-Service ssh-agent).Status -eq "Running") {
+                Stop-Service ssh-agent -Force
+            }
+
+            (Get-Service ssh-agent).Status | Should Be "Stopped"
+
+            ssh-agent
+            WaitForStatus -ServiceName ssh-agent -Status "Running"
+
+            (Get-Service ssh-agent).Status | Should Be "Running"
+        }
+
+        It "$tC.$tI - ssh-add - add and remove all key types" {
+            #set up SSH_ASKPASS
+            Add-PasswordSetting -Pass $keypassphrase
+
+            $nullFile = join-path $testDir ("$tC.$tI.nullfile")
+            $null > $nullFile
+            
+            foreach($type in $keytypes)
+            {
+                $keyPath = Join-Path $testDir "id_$type"
+                # for ssh-add to consume SSh_ASKPASS, stdin should not be TTY
+                iex "cmd /c `"ssh-add $keyPath < $nullFile 2> nul `""
+                #Check if -Raw presents for Get-Content cmdlet
+                $rawParam = (get-command Get-Content).Parametersets | Select -ExpandProperty Parameters | ? {$_.Name -ieq "Raw"}
+                if($rawParam)
+                {
+                    $keyPathDifferentEnding = Join-Path $testDir "id_$($type)_DifferentEnding"
+                    if((Get-Content -Path $keyPath -raw).Contains("`r`n"))
+                    {
+                        $newcontent = (Get-Content -Path $keyPath -raw).Replace("`r`n", "`n")
+                    }
+                    else
+                    {
+                        $newcontent = (Get-Content -Path $keyPath -raw).Replace("`n", "`r`n")
+                    }
+                    Set-content -Path $keyPathDifferentEnding -value "$newcontent"
+                    Repair-UserKeyPermission $keyPathDifferentEnding -confirm:$false
+                    iex "cmd /c `"ssh-add $keyPathDifferentEnding < $nullFile 2> nul `""
+                }                             
+            }
+
+            #remove SSH_ASKPASS
+            Remove-PasswordSetting
+
+            #ensure added keys are listed
+            $allkeys = ssh-add -L
+            $allkeys | Set-Content (Join-Path $testDir "$tC.$tI.allkeyonAdd.txt")
+            ValidateRegistryACL -count $allkeys.Count
+            
+            foreach($type in $keytypes)
+            {
+                $keyPath = Join-Path $testDir "id_$type"
+                $pubkeyraw = ((Get-Content "$keyPath.pub").Split(' '))[1]
+                @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 1
+            }
+
+            #delete added keys
+            foreach($type in $keytypes)
+            {
+                $keyPath = Join-Path $testDir "id_$type"
+                iex "cmd /c `"ssh-add -d $keyPath 2> nul `""
+            }
+
+            #check keys are deleted
+            $allkeys = ssh-add -L
+            $allkeys | Set-Content (Join-Path $testDir "$tC.$tI.allkeyonDelete.txt")
+
+            foreach($type in $keytypes)
+            {
+                $keyPath = Join-Path $testDir "id_$type"
+                $pubkeyraw = ((Get-Content "$keyPath.pub").Split(' '))[1]
+                @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 0
+            }
+
+            $allkeys = @(ssh-add -L)
+            ValidateRegistryACL -count $allkeys.count
+        }        
+    }
+
+    Context "$tC ssh-keygen known_hosts operations" {
+
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - list and delete host key thumbprints" {
+            $kh = Join-Path $testDir "$tC.$tI.known_hosts"
+            $entry = "[localhost]:47002 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMtJMxwn+iJU0X4+EC7PSj/cfcMbdP6ahhodtXx+6RHv sshtest_hostkey_ed25519"
+            $entry | Set-Content $kh
+            $o = ssh-keygen -F [localhost]:47002 -f $kh
+            $o.Count | Should Be 2
+            $o[1] | Should Be $entry
+
+            $o = ssh-keygen -H -F [localhost]:47002 -f $kh
+            $o[1].StartsWith("|1|")  | Should Be $true
+
+            $o = ssh-keygen -R [localhost]:47002 -f $kh
+            $o.count | Should Be 3
+            $o[0] | Should Be "# Host [localhost]:47002 found: line 1"
+            (dir $kh).Length | Should Be 0
+        }
+
+    }
+
+    Context "$tC-ssh-add key files with different file perms" {
+        BeforeAll {
+            $keyFileName = "sshadd_userPermTestkey_ed25519"
+            $keyFilePath = Join-Path $testDir $keyFileName
+            Remove-Item -path "$keyFilePath*" -Force -ErrorAction SilentlyContinue
+            ssh-keygen.exe -t ed25519 -f $keyFilePath -P $keypassphrase            
+            #set up SSH_ASKPASS
+            Add-PasswordSetting -Pass $keypassphrase
+            $tI=1
+        }
+        BeforeEach {
+            $nullFile = join-path $testDir ("$tC.$tI.nullfile")
+            $null > $nullFile
+        }
+        AfterEach {
+            if(Test-Path $keyFilePath) {
+                Repair-FilePermission -FilePath $keyFilePath -Owner $currentUserSid -FullAccessNeeded $currentUserSid,$systemSid,$adminsSid -confirm:$false
+            }            
+        }
+
+        AfterAll {
+            #remove SSH_ASKPASS
+            Remove-PasswordSetting
+            $tC++
+        }
+
+        It "$tC.$tI-  ssh-add - positive (Secured private key owned by current user)" {
+            #setup to have current user as owner and grant it full control                    
+            Repair-FilePermission -FilePath $keyFilePath -Owner $currentUserSid -FullAccessNeeded $currentUserSid,$systemSid,$adminsSid -confirm:$false
+
+            # for ssh-add to consume SSh_ASKPASS, stdin should not be TTY
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul"
+            $LASTEXITCODE | Should Be 0
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]            
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 1
+            
+            #clean up
+            cmd /c "ssh-add -d $keyFilePath 2> nul "
+        }
+
+        It "$tC.$tI - ssh-add - positive (Secured private key owned by Administrators group and the current user has no explicit ACE)" {
+            #setup to have local admin group as owner and grant it full control            
+            Repair-FilePermission -FilePath $keyFilePath -Owner $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            # for ssh-add to consume SSh_ASKPASS, stdin should not be TTY
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul "
+            $LASTEXITCODE | Should Be 0
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 1
+            
+            #clean up
+            cmd /c "ssh-add -d $keyFilePath 2> nul "
+        }
+
+        It "$tC.$tI - ssh-add - positive (Secured private key owned by Administrators group and the current user has explicit ACE)" {
+            #setup to have local admin group as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $adminsSid -FullAccessNeeded $currentUserSid,$adminsSid,$systemSid -confirm:$false
+
+            # for ssh-add to consume SSh_ASKPASS, stdin should not be TTY
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul "
+            $LASTEXITCODE | Should Be 0
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 1
+            
+            #clean up
+            cmd /c "ssh-add -d $keyFilePath 2> nul "
+        }
+
+        It "$tC.$tI - ssh-add - positive (Secured private key owned by local system group)" {
+            #setup to have local admin group as owner and grant it full control            
+            Repair-FilePermission -FilePath $keyFilePath -Owners $systemSid -FullAccessNeeded $systemSid,$adminsSid -confirm:$false
+
+            # for ssh-add to consume SSh_ASKPASS, stdin should not be TTY
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul "
+            $LASTEXITCODE | Should Be 0
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 1
+            
+            #clean up
+            cmd /c "ssh-add -d $keyFilePath 2> nul "
+        }
+        
+        It "$tC.$tI-  ssh-add - negative (other account can access private key file)" {
+            #setup to have current user as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $currentUserSid -FullAccessNeeded $currentUserSid,$adminsSid, $systemSid -ReadAccessNeeded $objUserSid -confirm:$false
+
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul "
+            $LASTEXITCODE | Should Not Be 0
+
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]            
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 0
+        }
+
+        It "$tC.$tI - ssh-add - negative (the private key has wrong owner)" {
+            #setup to have ssouser as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $objUserSid -FullAccessNeeded $objUserSid,$adminsSid, $systemSid -confirm:$false
+
+            cmd /c "ssh-add $keyFilePath < $nullFile 2> nul "
+            $LASTEXITCODE | Should Not Be 0
+
+            $allkeys = ssh-add -L
+            $pubkeyraw = ((Get-Content "$keyFilePath.pub").Split(' '))[1]            
+            @($allkeys | where { $_.contains($pubkeyraw) }).count | Should Be 0
+        }
+    }
+		
+    Context "$tC - ssh-keyscan test cases" {
+        BeforeAll {            
+            $tI=1
+            $port = $OpenSSHTestInfo["Port"]
+            Remove-item (join-path $testDir "$tC.$tI.out.txt") -force -ErrorAction SilentlyContinue
+        }
+        BeforeEach {
+            $outputFile = join-path $testDir "$tC.$tI.out.txt"
+        }
+        AfterAll{$tC++}
+
+		It "$tC.$tI - ssh-keyscan with default arguments" -Skip:$NoLibreSSL {
+			cmd /c "ssh-keyscan -p $port 127.0.0.1 2>&1 > $outputFile"
+			$outputFile | Should Contain '.*ssh-rsa.*'
+		}
+
+        It "$tC.$tI - ssh-keyscan with -p" -Skip:$NoLibreSSL {
+			cmd /c "ssh-keyscan -p $port 127.0.0.1 2>&1 > $outputFile"
+			$outputFile | Should Contain '.*ssh-rsa.*'
+		}
+
+		It "$tC.$tI - ssh-keyscan with -f" -Skip:$NoLibreSSL {
+			Set-Content -Path tmp.txt -Value "127.0.0.1"
+			cmd /c "ssh-keyscan -p $port -f tmp.txt 2>&1 > $outputFile"
+			$outputFile | Should Contain '.*ssh-rsa.*'
+		}
+
+		It "$tC.$tI - ssh-keyscan with -f -t" -Skip:$NoLibreSSL {
+			Set-Content -Path tmp.txt -Value "127.0.0.1"
+			cmd /c "ssh-keyscan -p $port -f tmp.txt -t rsa,dsa 2>&1 > $outputFile"
+			$outputFile | Should Contain '.*ssh-rsa.*'
+		}
+	}
+}
diff --git a/regress/pesterTests/Log_fileperm.Tests.ps1 b/regress/pesterTests/Log_fileperm.Tests.ps1
new file mode 100644
index 000000000..1c00f200a
--- /dev/null
+++ b/regress/pesterTests/Log_fileperm.Tests.ps1
@@ -0,0 +1,110 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "log_fileperm"
+
+Describe "Tests for log file permission" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Setup-OpenSSHTestEnvironment to setup test environment."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        $port = 47003
+        $logName = "log.txt"        
+        
+        $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+        $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+        $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"        
+
+        Remove-Item (Join-Path $testDir "*$logName") -Force -ErrorAction SilentlyContinue
+        
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {
+            #suppress the firewall blocking dialogue on win7
+            netsh advfirewall firewall add rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any action=allow dir=in
+        }
+
+        #only validate owner and ACEs of the file
+        function ValidateLogFilePerm {
+            param([string]$FilePath)
+            
+            $myACL = Get-ACL $FilePath
+            $currentOwnerSid = Get-UserSid -User $myACL.Owner
+            $currentOwnerSid.Equals($currentUserSid) | Should Be $true
+            $myACL.Access | Should Not Be $null            
+
+            $ReadWriteAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Read.value__) -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Write.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Modify.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+
+            $FullControlPerm = [System.UInt32] [System.Security.AccessControl.FileSystemRights]::FullControl.value__
+            
+            $myACL.Access.Count | Should Be 3
+            $identities = @($systemSid, $adminsSid, $currentUserSid)            
+
+            foreach ($a in $myACL.Access) {
+                $id = Get-UserSid -User $a.IdentityReference
+                $identities -contains $id | Should Be $true           
+
+                switch ($id)
+                {
+                    {@($systemSid, $adminsSid) -contains $_}
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FullControlPerm
+                        break;
+                    }
+                    $currentUserSid
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $ReadWriteAccessPerm
+                        break;
+                    }
+                }
+            
+                $a.AccessControlType | Should Be ([System.Security.AccessControl.AccessControlType]::Allow)
+                $a.IsInherited | Should Be $false
+                $a.InheritanceFlags | Should Be ([System.Security.AccessControl.InheritanceFlags]::None)
+                $a.PropagationFlags | Should Be ([System.Security.AccessControl.PropagationFlags]::None)
+            }
+        }
+    }
+
+    BeforeEach {
+        $logPath = Join-Path $testDir "$tC.$tI.$logName"
+    }
+
+    AfterEach {$tI++;}
+    AfterAll {
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {            
+            netsh advfirewall firewall delete rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any dir=in
+        }    
+    }
+
+    Context "$tC-SSHD -E Log file permission" {
+        BeforeAll {            
+            Get-Process -Name sshd  -ErrorAction SilentlyContinue | Where-Object {$_.SessionID -ne 0} | Stop-process -force -ErrorAction SilentlyContinue
+            $tI=1
+        }
+        
+        AfterAll {
+            $tC++
+        }
+
+        It "$tC.$tI-SSHD -E Log file permission" {
+            #Run
+            Start-Process -FilePath sshd.exe -WorkingDirectory $($OpenSSHTestInfo['OpenSSHBinPath']) -ArgumentList @("-d", "-p $port", "-E $logPath") -NoNewWindow
+            Start-sleep 1; 
+            ValidateLogFilePerm -FilePath $logPath
+            Get-Process -Name sshd  -ErrorAction SilentlyContinue | Where-Object {$_.SessionID -ne 0} | Stop-process -force -ErrorAction SilentlyContinue
+        }
+    }
+}
\ No newline at end of file
diff --git a/regress/pesterTests/PlatformAbstractLayer.psm1 b/regress/pesterTests/PlatformAbstractLayer.psm1
new file mode 100644
index 000000000..9d59bfa15
--- /dev/null
+++ b/regress/pesterTests/PlatformAbstractLayer.psm1
@@ -0,0 +1,448 @@
+﻿#Abstract layer
+Enum MachineRole {
+    Client
+    Server
+}
+
+Enum Protocol
+{
+    WSMAN
+    SSH
+}
+
+Enum PlatformType {
+    Windows
+    Linux
+    OSX
+}
+
+function Set-Platform {
+    # Use the .NET Core APIs to determine the current platform; if a runtime
+    # exception is thrown, we are on FullCLR, not .NET Core.
+    if($IsMacOS) {
+        [PlatformType]::OSX
+    } elseif($IsLinux) {
+        [PlatformType]::Linux
+    } elseif($IsWindows) {        
+        [PlatformType]::Windows    
+    }
+}
+
+function Is-CoreCLR {
+    # Use the .NET Core APIs to determine the current platform; if a runtime
+    # exception is thrown, we are on FullCLR, not .NET Core.
+    try {
+        $Runtime = [System.Runtime.InteropServices.RuntimeInformation]        
+        $IsCoreCLR = $true        
+    } catch {    
+        try {
+            $IsCoreCLR = $false            
+        }
+        catch { }
+    }
+    if($IsCoreCLR)
+    {
+        $true
+    }
+    $false
+}
+
+Class Machine
+{
+    [string] $MachineName = "localhost"
+    [MachineRole] $Role = [MachineRole]::Client
+    [PlatformType] $Platform
+    [boolean] $IsCoreCLR
+
+    #Members on server role
+    [string []] $PublicHostKeyPaths
+    [string []] $PrivateHostKeyPaths
+    [string] $ssouser = "sshtest_ssouser"
+    [string] $passwduser = "sshtest_passwduser"
+    [string] $passwduser_pw = "P@ssw0rd_1"
+    [string] $localAdminAuthorizedKeyPath
+    [string] $sshdConfigFile = (join-path $PSScriptRoot "sshd_config")
+    [string] $backupFileName = (join-path $PSScriptRoot "sshd_backup")
+    [System.Security.SecureString] $password
+    $preLatfpSetting
+    [string] $localUserprofilePath
+
+    #Members on client role
+    [string []] $clientPrivateKeyPaths
+    [string []] $clientPublicKeyPaths
+    [string] $ClientKeyDirectory
+    [string] $knownHostOfCurrentUser    
+    [string] $OpenSSHdir = $PSScriptRoot
+    [string] $ToolsPath = "$env:ProgramData\chocolatey\lib\sysinternals\tools"    
+
+    Machine() {
+        $this.Platform = Set-Platform        
+        $this.IsCoreCLR = Is-CoreCLR
+        #$this.InitializeClient()
+        #$this.InitializeServer()
+    }
+
+    Machine ([MachineRole] $r) {
+        $this.Platform = Set-Platform        
+        $this.IsCoreCLR = Is-CoreCLR
+        $this.Role = $r
+        #if($this.Role -eq [MachineRole]::Client) {
+        #    $this.InitializeClient()
+        #} else {
+        #    $this.InitializeServer()
+        #}        
+    }    
+
+    [void] InitializeClient() {
+        $this.ClientKeyDirectory = join-path $PSScriptRoot "clientkeys"
+        if(-not (Test-path $this.ClientKeyDirectory -PathType Container))
+        {
+            New-Item -Path $this.ClientKeyDirectory -ItemType Directory -Force -ErrorAction silentlycontinue
+        }
+
+        Remove-Item -Path "$($this.ClientKeyDirectory)\*" -Force -ea silentlycontinue        
+
+        $this.knownHostOfCurrentUser = join-path ($env:USERPROFILE) ".ssh/known_hosts"
+
+        if ($this.Platform -eq [PlatformType]::Windows)
+        {
+            $this.ToolsPath = "$env:ProgramData\chocolatey\lib\sysinternals\tools"
+            #download pstools
+            if ( -not (Test-Path (join-path $($this.ToolsPath) "psexec.exe" ))) {
+	            $this.DownloadPStools()
+            }
+        }
+        
+    }
+
+    [void] InitializeServer() {
+        if ($this.Platform -eq [PlatformType]::Windows)
+        {
+            #Start-Service sshd
+            #load the profile to create the profile folder
+            $this.SetLocalAccountTokenFilterPolicy(1)
+        }
+
+        $this.password = ConvertTo-SecureString -String $this.localAdminPassword -AsPlainText -Force
+        $this.AddAdminUser($this.localAdminUserName, $this.password)
+        
+        $this.SetupServerRemoting([Protocol]::WSMAN)
+        $this.localUserprofilePath = $this.GetUserProfileLocation($this)
+        $sshPath = join-path $($this.localUserprofilePath)  ".ssh"
+        if(-not (Test-path $sshPath -PathType Container))
+        {
+            New-Item -Path $sshPath -ItemType Directory -Force -ErrorAction silentlycontinue
+        }
+        $this.localAdminAuthorizedKeyPath = join-path $($this.localUserprofilePath)  ".ssh/authorized_keys"
+        Remove-Item -Path $($this.localAdminAuthorizedKeyPath) -Force -ea silentlycontinue
+    }
+
+    [void] SetupClient([Machine] $server) {
+        #add the host keys known host on client
+        
+        if( -not (Test-Path $($this.knownHostOfCurrentUser ) ) )
+        {
+            $null = New-item -path $($this.knownHostOfCurrentUser) -force
+        }
+        foreach($keypath in $server.PublicHostKeyPaths)
+        {
+            $this.SetKeys($($server.MachineName), $keypath,  $($this.knownHostOfCurrentUser))
+        }
+    }
+
+    [void] SetupSingleSignon([string] $identifyFile) {
+        .\ssh-add.exe $identifyFile
+    }
+
+    [void] CleanupSingleSignon([string] $identifyFile) {
+        .\ssh-add.exe -d $identifyFile
+    }
+
+    [void] AddItemInSSHDConfig([string] $key, [string] $value) {
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+                Get-Content $this.sshdConfigFile | % {
+                    if($_.StartsWith($key)) {
+                        "#$_"
+                    }
+                    else {$_}
+                } | Set-Content $this.sshdConfigFile
+            Add-Content -Path $this.sshdConfigFile -Value "`r`n$key $value"
+
+            Restart-Service sshd
+        } else {               
+        }
+    }
+
+    [void] BackupSSHDConfig() {
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+            if(Test-path $this.backupFileName) {
+                Remove-Item -Path $this.backupFileName -Force
+            }
+
+            Copy-Item $this.sshdConfigFile $this.backupFileName -Force
+        }
+    }
+
+    [void] RestoreSSHDConfig() {
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+            Copy-Item $this.backupFileName $this.sshdConfigFile  -Force
+            Remove-Item -Path $this.backupFileName -Force
+            Restart-Service sshd
+        }
+    }
+
+    [void] SetupServerRemoting([Protocol] $protocol) {
+        if ($this.Platform -eq [PlatformType]::Windows)
+        {
+            switch($protocol )
+            {
+                ([Protocol]::SSH) {
+                    $env:Path = "$env:Path;$PSScriptRoot"
+                    Restart-Service sshd
+                }
+                ([Protocol]::WSMAN) {
+                    if( (Get-ComputerInfo).osproductType -notcontains 'Server' )
+                        {
+                            Enable-PSRemoting -Force
+                        }
+                }
+                default {
+                }
+            }
+        }
+    }    
+
+    [void] SetupServer([Machine] $client) {
+        if( -not (Test-Path $($this.localAdminAuthorizedKeyPath ) ) )
+        {
+            $null = New-item -path $($this.localAdminAuthorizedKeyPath) -force
+        }
+        
+        foreach($publicKeyPath in $client.clientPublicKeyPaths)
+        {
+            $this.SetKeys($null, $publicKeyPath, $($this.localAdminAuthorizedKeyPath))
+        }        
+        # Provide Read Access to NT Service\sshd
+        $acl = get-acl $($this.localAdminAuthorizedKeyPath)
+        $ar = New-Object  System.Security.AccessControl.FileSystemAccessRule("NT Service\sshd", "Read", "Allow")
+        $acl.SetAccessRule($ar)
+        Set-Acl  $($this.localAdminAuthorizedKeyPath) $acl
+    }
+
+    [void] CleanupServer() {
+        $sshPath = split-path $this.localAdminAuthorizedKeyPath -Parent
+        if(Test-Path $sshPath -PathType Container )
+        {
+            Remove-item -path $sshPath -force -Recurse
+        }
+
+        if ( $this.Platform -eq [PlatformType]::Windows )
+        {
+            $this.CleanupLocalAccountTokenFilterPolicy()
+        }
+    }
+
+    [void] CleanupClient() {                
+        Remove-item -path $($this.ClientKeyDirectory) -force -Recurse -ea silentlycontinue
+        $sshPath = split-path $this.knownHostOfCurrentUser -Parent
+        if(Test-Path $sshPath -PathType Container )
+        {
+            Remove-item -path $sshPath -force -Recurse
+        }
+        $this.CleanupPasswordSetting()
+    }
+
+    [void] RunCmd($Str) {        
+        if ($this.Platform -eq [PlatformType]::Windows)
+        {
+            cmd /c $Str
+        }
+    }
+
+    [void] AddLocalUser($UserName, $password) {
+        $a = Get-LocalUser -Name $UserName -ErrorAction Ignore
+        if ($a -eq $null)
+        {
+            $pass = ConvertTo-SecureString -String $this.localAdminPassword -AsPlainText -Force
+            $a = New-LocalUser -Name $UserName -Password $pass -AccountNeverExpires -PasswordNeverExpires -UserMayNotChangePassword                
+        }
+    }
+
+    [void] AddLocalGroup($groupName) {
+        $g = Get-LocalGroup -Name $groupName -ErrorAction Ignore
+        if ($g -eq $null)
+        {                
+            $g = New-LocalGroup -Name $groupName
+        }
+    }
+
+    [void] AddUserToLocalGroup($UserName, $password, $groupName) {        
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+            $this.AddLocalUser($UserName, $password)
+            $this.AddLocalGroup($groupName)
+
+            if((Get-LocalGroupMember -Name $groupName -Member $UserName -ErrorAction Ignore ) -eq $null)
+            {
+                Add-LocalGroupMember -Name $groupName -Member $UserName
+            }
+        } else {    
+            #Todo add local user and add it to a user group on linux
+        }
+    }
+
+    [void] RemoveUserFromLocalGroup($UserName, $groupName) {        
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+            if((Get-LocalGroupMember -Name $groupName -Member $UserName -ErrorAction Ignore ) -eq $null)
+            {
+                Remove-LocalGroupMember -Name $groupName -Member $UserName
+            }
+        } else {    
+            #Todo add local user and add it to a user group on linux
+        }
+    }
+
+    [void] ClenaupLocalGroup($groupName) {
+        $g = Get-LocalGroup -Name $groupName -ErrorAction Ignore
+        if ($g -eq $null)
+        {                
+            $g | Remove-LocalGroup
+        }
+    }
+
+    [void] AddAdminUser($UserName, $password) {        
+        if ( $this.Platform -eq [PlatformType]::Windows ) {
+            $a = Get-LocalUser -Name $UserName -ErrorAction Ignore
+            if ($a -eq $null)
+            {                
+                $a = New-LocalUser -Name $UserName -Password $password -AccountNeverExpires -PasswordNeverExpires -UserMayNotChangePassword                
+            }
+
+            if((Get-LocalGroupMember -SID s-1-5-32-544 -Member $a -ErrorAction Ignore ) -eq $null)
+            {
+                Add-LocalGroupMember -SID s-1-5-32-544 -Member $a
+            }
+        } else {    
+            #Todo add local user and add it to a administrators on linux             
+        }
+    }
+
+    [void] CleanupPasswordSetting() {
+        if ($this.Platform -eq [PlatformType]::Windows -and (Test-Path env:SSH_ASKPASS))
+        {
+            if ($env:DISPLAY -eq 1) {Remove-Item env:\DISPLAY}
+            remove-item "env:SSH_ASKPASS" -ErrorAction SilentlyContinue
+        }
+    }
+
+    #Set LocalAccountTokenFilterPolicy
+    [void] SetLocalAccountTokenFilterPolicy($setting) {        
+        $path = "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\system"
+        #load the profile to create the profile folder
+        $this.preLatfpSetting = get-ItemProperty -Path $path -Name LocalAccountTokenFilterPolicy -ErrorAction Ignore
+        if( $this.preLatfpSetting -eq $null)
+        {
+            New-ItemProperty -Path $path -Name LocalAccountTokenFilterPolicy -Value $setting -PropertyType DWord
+        }
+        else
+        {
+            Set-ItemProperty -Path $path -Name LocalAccountTokenFilterPolicy -Value $setting
+        }    
+    }
+
+    [void] CleanupLocalAccountTokenFilterPolicy() {    
+        if($this.preLatfpSetting -eq $null)
+        {
+            Remove-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\system -Name LocalAccountTokenFilterPolicy -Force -ErrorAction SilentlyContinue
+        }
+        else
+        {
+            Set-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\system -Name LocalAccountTokenFilterPolicy -Value $this.preLatfpSetting.LocalAccountTokenFilterPolicy
+        }
+    }
+
+    [void] SecureHostKeys([string[]] $keys) {
+        if ( $this.Platform -eq [PlatformType]::Windows )
+        {            
+            #TODO: Remove the path to OpenSSHDir from the string link
+            #Secure host-keys with psexec 
+            foreach($key in $keys) {              
+	            & "$($this.ToolsPath)\psexec" -accepteula -nobanner -i -s -w $($this.OpenSSHdir) cmd.exe /c "ssh-add.exe $key"
+            }
+        }
+    }
+
+    [void] CleanupHostKeys() {
+        if ( $this.Platform -eq [PlatformType]::Windows )
+        {
+            & "$($this.ToolsPath)\psexec" -accepteula -nobanner -i -s -w $($this.OpenSSHdir) cmd.exe /c "ssh-add.exe -D"
+        }
+    }
+
+    [string] GetUserProfileLocation([Machine] $remote ) {        
+        #load the profile to create the profile folder        
+        $pscreds = [System.Management.Automation.PSCredential]::new($($remote.MachineName) + "\" + $($remote.localAdminUserName), $($remote.password))
+        $ret = Invoke-Command -Credential $pscreds -ComputerName $($remote.MachineName) -command {$env:userprofile}
+        return $ret
+    }
+
+    [void] UnzipFile($argVar, $targetondisk ) {    
+	    $shell_app=new-object -com shell.application
+	    $zip_file = $shell_app.namespace($argVar)
+	    Write-Host "Uncompressing zip file to $($targetondisk)" -ForegroundColor Cyan
+	    $destination = $shell_app.namespace($targetondisk)
+	    $destination.Copyhere($zip_file.items(), 0x10)
+	    $shell_app = $null
+    }
+
+    #this does not work when "using module"; works fine when import the module
+    [void] DownloadPStools()
+     {
+        $machinePath = [Environment]::GetEnvironmentVariable('Path', 'MACHINE')
+        $newMachineEnvironmentPath = $machinePath
+        # Install chocolatey
+        $chocolateyPath = "$env:AllUsersProfile\chocolatey\bin"
+        if(Get-Command "choco" -ErrorAction SilentlyContinue)
+        {
+            Write-Information -MessageData "Chocolatey is already installed. Skipping installation."
+        }
+        else
+        {
+            Write-Information -MessageData  "Chocolatey not present. Installing chocolatey."
+            Invoke-Expression ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))
+
+            if (-not ($machinePath.ToLower().Contains($chocolateyPath.ToLower())))
+            {
+                Write-Information -MessageData "Adding $chocolateyPath to Path environment variable"
+                $newMachineEnvironmentPath += ";$chocolateyPath"
+                $env:Path += ";$chocolateyPath"
+            }
+            else
+            {
+                Write-Information -MessageData "$chocolateyPath already present in Path environment variable"
+            }
+        }
+
+        if ( -not (Test-Path $($this.ToolsPath) ) ) {
+            Write-Information -MessageData "sysinternals not present. Installing sysinternals."
+            choco install sysinternals -y            
+        }
+        else
+        {
+            Write-Information -MessageData "sysinternals present. Skipping installation."
+        }	    
+    }
+
+    [void] SetKeys($Hostnames, $keyPath, $Path) {
+        if($Hostnames -ne $null)
+        {
+            foreach ($hostname in $Hostnames)
+            {                
+                ($hostname + " " + (Get-Content $keyPath)) | Out-File -Append $Path -Encoding ascii
+            }
+        }
+        else
+        {
+            Get-Content $keyPath | Out-File -Append $Path -Encoding ascii
+        }
+    } 
+}
diff --git a/regress/pesterTests/PortForwarding.Tests.ps1 b/regress/pesterTests/PortForwarding.Tests.ps1
new file mode 100644
index 000000000..0fe4b5269
--- /dev/null
+++ b/regress/pesterTests/PortForwarding.Tests.ps1
@@ -0,0 +1,44 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "portfwd"
+
+Describe "E2E scenarios for port forwarding" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        $testDir = Join-Path $OpenSSHTestInfo["TestDataPath"] $suite
+        if(-not (Test-Path $testDir))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        #skip on ps 2 becase non-interactive cmd require a ENTER before it returns on ps2
+        $skip = $IsWindows -and ($PSVersionTable.PSVersion.Major -le 2)
+    }
+
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+    AfterEach {$tI++;}
+
+    Context "$tC - Basic port forwarding scenarios"  {
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        #TODO - this relies on winrm (that is windows specific)
+        It "$tC.$tI - local port forwarding" -skip:$skip {
+            ssh -L 5432:127.0.0.1:47001 test_target powershell.exe Test-WSMan -computer 127.0.0.1 -port 5432 | Set-Content $stdoutFile
+            $stdoutFile | Should Contain "wsmid"
+        }
+
+        It "$tC.$tI - remote port forwarding" -skip:$skip {
+            ssh -R 5432:127.0.0.1:47001 test_target powershell.exe Test-WSMan -computer 127.0.0.1 -port 5432  | Set-Content $stdoutFile
+            $stdoutFile | Should Contain "wsmid"
+        }
+    }        
+}
diff --git a/regress/pesterTests/PowerShell.SSH.Tests.ps1 b/regress/pesterTests/PowerShell.SSH.Tests.ps1
new file mode 100644
index 000000000..1f8acd70e
--- /dev/null
+++ b/regress/pesterTests/PowerShell.SSH.Tests.ps1
@@ -0,0 +1,81 @@
+﻿Describe "Tests for powershell over ssh" -Tags "Scenario" {
+    BeforeAll {
+        $defaultParamValues = $PSDefaultParameterValues.Clone()
+        #Skip on windows powershell. this feature only supported in powershell core from git
+	#due to known issue, these tests need to be disabled.
+        #if ($psversiontable.GitCommitId -eq $null)
+        if ($true)
+        {
+            $PSDefaultParameterValues["It:Skip"] = $true
+        }
+        
+        [Machine] $client = [Machine]::new([MachineRole]::Client)
+        [Machine] $server = [Machine]::new([MachineRole]::Server)
+        $client.SetupClient($server)
+        $server.SetupServer($client)
+        $server.SetupServerRemoting([Protocol]::SSH)
+    }
+    AfterAll {
+        $global:PSDefaultParameterValues = $defaultParamValues
+        $client.CleanupClient()
+        $server.CleanupServer()
+    }
+
+    Context "Key based authentication with KeyFilePath. Key is Secured in ssh-agenton server" {
+        BeforeAll {
+            $server.SecureHostKeys($server.PrivateHostKeyPaths)
+            $identifyFile = $client.clientPrivateKeyPaths[0]
+        }
+
+        AfterAll {
+            $server.CleanupHostKeys()
+        }        
+        It 'Key is Secured in ssh-agenton server' {
+            $session = New-PSSession -HostName $server.MachineName -UserName $server.localAdminUserName -KeyFilePath $identifyFile
+            #$pscreds = [System.Management.Automation.PSCredential]::new($($server.MachineName) + "\" + $($server.localAdminUserName), $($server.password))
+            #$session = New-PSSession -Credential $pscreds -ComputerName $($server.MachineName)
+            $ret = Invoke-Command $session -command {$env:computername}
+            $ret | Should be $server.MachineName
+        }
+    }
+
+    #this context only run on windows
+    Context "Single signon and host keys are secured in ssh-agent" {
+        BeforeAll {        
+            $server.SecureHostKeys($server.PrivateHostKeyPaths)
+            $identifyFile = $client.clientPrivateKeyPaths[0]
+            #setup single signon
+            .\ssh-add.exe $identifyFile
+        }
+
+        AfterAll {
+            $server.CleanupHostKeys()
+
+            #cleanup single signon
+            .\ssh-add.exe -D
+        }
+        
+        It 'Single signon and host keys are secured in ssh-agent' {
+            #$session = New-PSSession -HostName $server.MachineName -UserName $server.localAdminUserName
+            $pscreds = [System.Management.Automation.PSCredential]::new($($server.MachineName) + "\" + $($server.localAdminUserName), $($server.password))
+            $session = New-PSSession -Credential $pscreds -ComputerName $($server.MachineName)
+            $ret = Invoke-Command $session -command {$env:computername}
+            $ret | Should be $server.MachineName
+        }
+    }    
+   
+   Context "Key based authentication with KeyFilePath. Host keys are not secured on server" {
+        BeforeAll {
+            $identifyFile = $client.clientPrivateKeyPaths[0]
+        }
+        
+        It 'Key based authentication with KeyFilePath. Host keys are not secured on server' {
+            $session = New-PSSession -HostName $server.MachineName -UserName $server.localAdminUserName -KeyFilePath $identifyFile
+            #$pscreds = [System.Management.Automation.PSCredential]::new($($server.MachineName) + "\" + $($server.localAdminUserName), $($server.password))
+            #$session = New-PSSession -Credential $pscreds -ComputerName $($server.MachineName)
+            $ret = Invoke-Command $session -command {$env:computername}
+            $ret | Should be $server.MachineName
+        }
+    }    
+}   
+
diff --git a/regress/pesterTests/README.md b/regress/pesterTests/README.md
new file mode 100644
index 000000000..afd636e76
--- /dev/null
+++ b/regress/pesterTests/README.md
@@ -0,0 +1,66 @@
+﻿Run OpenSSH Pester Tests:
+==================================
+
+#### To setup the test environment before test run:
+
+```powershell
+Import-Module  .\openssh-portable\contrib\win32\openssh\OpenSSHTestHelper.psm1 –Force
+Setup-OpenSSHTestEnvironment
+```
+
+`Set-OpenSSHTestEnvironment` contains below parameters:
+* `-OpenSSHBinPath`: Specify the location where ssh.exe should be picked up. If not specified, the function will prompt to user if he/she want to choose the first ssh.exe found in `$env:path` if exists.
+* `-TestDataPath`: Specify the location where the test binaries deploy to. The default is `$env:SystemDrive\OpenSSHTests` if it not specified.
+* `-Quiet`: If it is set, the function will do all the changes without prompting to user to confirm.
+* `-DebugMode`: If it is set, the subsequent tests will be running in debug mode. User can modify by setting $OpenSSHTestInfo["DebugMode"] .
+
+#### To run the test suites:
+
+```powershell
+Run-OpenSSHE2ETest
+Run-OpenSSHUnitTest
+```
+
+#### To run a particular test, just run the script or the executatlbe directly
+
+```powershell
+C:\git\openssh-portable\regress\pesterTests\SCP.Tests.ps1
+C:\git\openssh-portable\bin\x64\Release\unittest-bitmap\unittest-bitmap.exe
+```
+
+#### To verify / modify (Ex- DebugMode) the Test setup environment 
+
+```powershell
+$OpenSSHTestInfo
+$OpenSSHTestInfo["DebugMode"] = $true
+```
+
+#### To revert what's done in Setup-OpenSSHTestEnvironment:
+
+```powershell
+Cleanup-OpenSSHTestEnvironment
+```
+
+
+#### Guidelines for writing Pester based OpenSSH test cases
+Follow these simple steps for test case indexing
+- Initialize the following variables at start
+```  
+  $tC = 1
+  $tI = 0
+```
+- Place the following blocks in Describe
+```
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+    AfterEach {$tI++;}
+```
+- Place the following blocks in each Context
+```
+  BeforeAll {$tI=1}
+  AfterAll{$tC++}
+```
+- Prefix any test out file with $tC.$tI. You may use pre-created $stderrFile, $stdoutFile, $logFile for this purpose
diff --git a/regress/pesterTests/SCP.Tests.ps1 b/regress/pesterTests/SCP.Tests.ps1
new file mode 100644
index 000000000..1c3580c83
--- /dev/null
+++ b/regress/pesterTests/SCP.Tests.ps1
@@ -0,0 +1,278 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+#covered -i -p -q -r -v -c -S -C
+#todo: -F, -l and -P should be tested over the network
+$tI = 0
+$suite = "SCP"
+Describe "Tests for scp command" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        $fileName1 = "test.txt"
+        $fileName2 = "test2.txt"
+        $fileName3 = "test3.txt"
+        $wildcardFileName1 = "te?t.txt"
+        $wildcardFileName2 = "test*"
+        $SourceDirName = "SourceDir"
+        $SourceDir = Join-Path $testDir $SourceDirName
+        $SourceFilePath = Join-Path $SourceDir $fileName1
+        $SourceFilePath3 = Join-Path $SourceDir $fileName3
+        $SourceFileWildCardFile1 = Join-Path $SourceDir $wildcardFileName1
+        $DestinationDir = Join-Path "$($OpenSSHTestInfo["TestDataPath"])\SCP" "DestDir"
+        $DestinationDirWildcardPath = Join-Path "$($OpenSSHTestInfo["TestDataPath"])\SCP" "DestD?r"
+        $DestinationFilePath = Join-Path $DestinationDir $fileName1        
+        $NestedSourceDir= Join-Path $SourceDir "nested"
+        $NestedSourceFilePath = Join-Path $NestedSourceDir $fileName2
+        $null = New-Item $SourceDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        $null = New-Item $NestedSourceDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        $null = New-item -path $SourceFilePath -ItemType file -force -ErrorAction SilentlyContinue
+        $null = New-item -path $NestedSourceFilePath -ItemType file -force -ErrorAction SilentlyContinue
+        "Test content111" | Set-content -Path $SourceFilePath
+        "Test content333" | Set-content -Path $SourceFilePath3
+        "Test content in nested dir" | Set-content -Path $NestedSourceFilePath
+        $null = New-Item $DestinationDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        $sshcmd = (get-command ssh).Path        
+
+        # for symlink tests
+        $SourceDirSymLinkName = "SourceDirSymLink"
+        $SourceDirSymLink = Join-Path $testDir $SourceDirSymLinkName
+        $tmpDir = Join-Path $testDir "tmpDir"
+        $tmpDirFilePath = Join-Path $tmpDir $fileName1
+        $null = New-Item $SourceDirSymLink -ItemType directory -Force -ErrorAction SilentlyContinue
+        $null = New-Item $tmpDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        $null = New-item -path $tmpDirFilePath -ItemType file -force -ErrorAction SilentlyContinue
+        "Test content in tmp dir for sym link" | Set-content -Path $tmpDirFilePath
+        $SymLinkName = "SymLinkDir"
+        $SymLinkDir = Join-Path $SourceDirSymLink $SymLinkName
+        $null = New-Item -Path $SymLinkDir -ItemType SymbolicLink -Value $tmpDir
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = $OpenSSHTestInfo["Port"]
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+
+        $testData = @(
+            @{
+                Title = 'Simple copy local file to local file'
+                Source = $SourceFilePath                   
+                Destination = $DestinationFilePath
+            },
+            @{
+                Title = 'Simple copy local file to remote file'
+                Source = $SourceFilePath
+                Destination = "test_target:$DestinationFilePath"
+                Options = "-S `"$sshcmd`""
+            },
+            @{
+                Title = 'Simple copy remote file to local file'
+                Source = "test_target:$SourceFilePath"
+                Destination = $DestinationFilePath
+                Options = "-p -c aes128-ctr -C"
+            },            
+            @{
+                Title = 'Simple copy local file to local dir'
+                Source = $SourceFilePath
+                Destination = $DestinationDir
+            },
+            @{
+                Title = 'simple copy local file to remote dir'         
+                Source = $SourceFilePath
+                Destination = "test_target:$DestinationDir"
+                Options = "-C -q"
+            },
+            @{
+                Title = 'simple copy remote file to local dir'
+                Source = "test_target:$SourceFilePath"
+                Destination = $DestinationDir
+            },
+            @{
+                Title = 'Simple copy local file with wild card name to local dir'
+                Source = $SourceFileWildCardFile1
+                Destination = $DestinationDir
+            },
+            @{
+                Title = 'simple copy remote file with wild card name to local dir'
+                Source = "test_target:$SourceFileWildCardFile1"
+                Destination = $DestinationDir
+            },
+            @{
+                Title = 'simple copy local file to remote dir with wild card name'         
+                Source = $SourceFilePath
+                Destination = "test_target:$DestinationFilePath"
+                Options = "-C -q"
+            }
+        )
+
+        $testData1 = @(
+            @{
+                Title = 'copy from local dir to remote dir'
+                Source = $sourceDir
+                Destination = "test_target:$DestinationDir"
+                Options = "-r -p -c aes128-ctr"
+            },
+            @{
+                Title = 'copy from local dir to local dir'
+                Source = $sourceDir
+                Destination = $DestinationDir
+                Options = "-r "
+            },
+            @{
+                Title = 'copy from remote dir to local dir'            
+                Source = "test_target:$sourceDir"
+                Destination = $DestinationDir
+                Options = "-C -r -q"
+            }
+        )
+
+        $testData2 = @(
+            @{
+                Title = 'symlink copy from local dir to remote dir'
+                Source = $SourceDirSymLink
+                Destination = "test_target:$DestinationDir"
+                Options = "-r -p -c aes128-ctr"
+            },
+            @{
+                Title = 'symlink copy from local dir to local dir'
+                Source = $SourceDirSymLink
+                Destination = $DestinationDir
+                Options = "-r "
+            },
+            @{
+                Title = 'symlink copy from remote dir to local dir'            
+                Source = "test_target:$SourceDirSymLink"
+                Destination = $DestinationDir
+                Options = "-C -r -q"
+            }
+        )
+
+        # for the first time, delete the existing log files.
+        if ($OpenSSHTestInfo['DebugMode'])
+        {
+            Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+            Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue
+        }
+
+        function CheckTarget {
+            param([string]$target)
+            if(-not (Test-path $target))
+            {
+                if( $OpenSSHTestInfo["DebugMode"])
+                {
+                    Copy-Item "$env:ProgramData\ssh\logs\ssh-agent.log" "$testDir\failedagent$tI.log" -Force -ErrorAction SilentlyContinue
+                    Copy-Item "$env:ProgramData\ssh\logs\sshd.log" "$testDir\failedsshd$tI.log" -Force -ErrorAction SilentlyContinue
+                    
+                    # clear the ssh-agent, sshd logs so that next testcase will get fresh logs.
+                    Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+                    Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue
+                }
+             
+                return $false
+            }
+            return $true
+        }
+    }
+    AfterAll {
+
+        if($OpenSSHTestInfo -eq $null)
+        {
+            #do nothing
+        }
+        elseif( -not $OpenSSHTestInfo['DebugMode'])
+        {
+            if(-not [string]::IsNullOrEmpty($SourceDir))
+            {
+                Get-Item $SourceDir | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
+            }
+            if(-not [string]::IsNullOrEmpty($SourceDirSymLink))
+            {
+                Get-Item $SourceDirSymLink | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
+            }
+            if(-not [string]::IsNullOrEmpty($DestinationDir))
+            {
+                Get-Item $DestinationDir | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }
+
+    BeforeAll {
+        $null = New-Item $DestinationDir -ItemType directory -Force -ErrorAction SilentlyContinue
+    }
+
+    AfterEach {
+        Get-ChildItem $DestinationDir -Recurse | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue
+        Start-Sleep 1
+        $tI++
+    }       
+    
+
+    It 'File copy: <Title> ' -TestCases:$testData {
+        param([string]$Title, $Source, $Destination, [string]$Options)
+        iex  "scp $Options $Source $Destination"
+        $LASTEXITCODE | Should Be 0
+        #validate file content. DestPath is the path to the file.
+        CheckTarget -target $DestinationFilePath | Should Be $true
+        
+        $equal = @(Compare-Object (Get-ChildItem -path $SourceFilePath) (Get-ChildItem -path $DestinationFilePath) -Property Name, Length ).Length -eq 0
+        $equal | Should Be $true
+
+        if($Options.contains("-p ") -and [environment]::OSVersion.Version.Major -ge 10)
+        {
+            $equal = @(Compare-Object (Get-ChildItem -path $SourceFilePath).LastWriteTime.DateTime (Get-ChildItem -path $DestinationFilePath).LastWriteTime.DateTime ).Length -eq 0
+            $equal | Should Be $true
+        }
+    }
+                
+    It 'Directory recursive copy: <Title> ' -TestCases:$testData1 {
+        param([string]$Title, $Source, $Destination, [string]$Options)                        
+            
+        iex  "scp $Options $Source $Destination"
+        $LASTEXITCODE | Should Be 0
+        CheckTarget -target (join-path $DestinationDir $SourceDirName) | Should Be $true
+
+        $equal = @(Compare-Object (Get-Item -path $SourceDir ) (Get-Item -path (join-path $DestinationDir $SourceDirName) ) -Property Name, Length).Length -eq 0        
+        $equal | Should Be $true
+
+        if($Options.contains("-p "))
+        {
+            $equal = @(Compare-Object (Get-Item -path $SourceDir).LastWriteTime.DateTime (Get-Item -path (join-path $DestinationDir $SourceDirName)).LastWriteTime.DateTime).Length -eq 0            
+            $equal | Should Be $true
+        }
+
+        $equal = @(Compare-Object (Get-ChildItem -Recurse -path $SourceDir) (Get-ChildItem -Recurse -path (join-path $DestinationDir $SourceDirName) ) -Property Name, Length).Length -eq 0
+        $equal | Should Be $true
+
+        if($Options.contains("-p ") -and $IsWindows -and ($PSVersionTable.PSVersion.Major -gt 2))
+        {
+            $equal = @(Compare-Object (Get-ChildItem -Recurse -path $SourceDir).LastWriteTime.DateTime (Get-ChildItem -Recurse -path (join-path $DestinationDir $SourceDirName) ).LastWriteTime.DateTime).Length -eq 0            
+            $equal | Should Be $true
+        }
+    }
+
+    It 'Directory with symlink recursive copy: <Title> ' -TestCases:$testData2 {
+        param([string]$Title, $Source, $Destination, [string]$Options)                        
+            
+        iex  "scp $Options $Source $Destination"
+        $LASTEXITCODE | Should Be 0
+        $expectedFilepath = join-path $DestinationDir $SourceDirSymLinkName $SymLinkName $fileName1
+        CheckTarget -target $expectedFilepath | Should Be $true
+        Get-Content $expectedFilepath | Should Be "Test content in tmp dir for sym link"
+    }
+
+    It 'File copy: path contains wildcards ' {
+        $Source = Join-Path $SourceDir $wildcardFileName2
+        scp -p $Source $DestinationDir
+        $LASTEXITCODE | Should Be 0
+        #validate file content. DestPath is the path to the file.
+        CheckTarget -target $DestinationFilePath | Should Be $true
+        CheckTarget -target (Join-path $DestinationDir $fileName3) | Should Be $true
+
+        $equal = @(Compare-Object (Get-ChildItem -path $Source) (Get-ChildItem -path (join-path $DestinationDir $wildcardFileName2)) -Property Name, Length ).Length -eq 0
+        $equal | Should Be $true
+        
+        $equal = @(Compare-Object (Get-ChildItem -path $Source).LastWriteTime.DateTime (Get-ChildItem -path (join-path $DestinationDir $wildcardFileName3)).LastWriteTime.DateTime ).Length -eq 0
+        $equal | Should Be $true        
+    }
+}   
diff --git a/regress/pesterTests/SFTP.Tests.ps1 b/regress/pesterTests/SFTP.Tests.ps1
new file mode 100644
index 000000000..a0a35f380
--- /dev/null
+++ b/regress/pesterTests/SFTP.Tests.ps1
@@ -0,0 +1,302 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tI = 0
+Describe "SFTP Test Cases" -Tags "CI" {
+    BeforeAll {
+        $serverDirectory = $null
+        $clientDirectory = $null
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        $rootDirectory = "$($OpenSSHTestInfo["TestDataPath"])\SFTP"
+        
+        $outputFileName = "output.txt"
+        $batchFileName = "sftp-batchcmds.txt"
+        $tempFileName = "tempFile.txt"
+        $tempFilePath = Join-Path $rootDirectory $tempFileName
+
+        $tempUnicodeFileName = "tempFile_язык.txt"
+        $tempUnicodeFilePath = Join-Path $rootDirectory $tempUnicodeFileName
+
+        $clientDirectory = Join-Path $rootDirectory 'client_dir'
+        $serverDirectory = Join-Path $rootDirectory 'server_dir'
+
+        $null = New-Item $clientDirectory -ItemType directory -Force
+        $null = New-Item $serverDirectory -ItemType directory -Force
+        $null = New-Item $tempFilePath -ItemType file -Force -value "temp file data"
+        $null = New-Item $tempUnicodeFilePath -ItemType file -Force -value "temp file data"
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = $OpenSSHTestInfo["Port"]
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+
+        Remove-item (Join-Path $rootDirectory "*.$outputFileName") -Force -ErrorAction SilentlyContinue                
+        Remove-item (Join-Path $rootDirectory "*.$batchFileName") -Force -ErrorAction SilentlyContinue
+        Remove-item (Join-Path $rootDirectory "*.log") -Force -ErrorAction SilentlyContinue
+        
+        $skip = $IsWindows -and ($PSVersionTable.PSVersion.Major -le 2)
+
+        $testData1 = @(
+             @{
+                title = "put, ls for non-unicode file names"
+                options = ''
+                commands = "put $tempFilePath $serverDirectory
+                            ls $serverDirectory"
+                expectedoutput = (join-path $serverdirectory $tempFileName)
+             },
+             @{
+                title = "get, ls for non-unicode file names"
+                options = ''
+                commands = "get $tempFilePath $clientDirectory
+                            ls $clientDirectory"
+                expectedoutput = (join-path $clientDirectory $tempFileName)
+             },
+             @{
+                title = "mput, ls for non-unicode file names"
+                options = ''
+                commands = "mput $tempFilePath $serverDirectory
+                            ls $serverDirectory"
+                expectedoutput = (join-path $serverdirectory $tempFileName)
+             },
+             @{
+                title = "mget, ls for non-unicode file names"
+                options = ''
+                commands = "mget $tempFilePath $clientDirectory
+                            ls $clientDirectory"
+                expectedoutput = (join-path $clientDirectory $tempFileName)
+             },
+             @{
+                title = "mkdir, cd, pwd for non-unicode directory names"
+                options = ''
+                commands = "cd $serverdirectory
+                            mkdir server_test_dir
+                            cd server_test_dir
+                            pwd"
+                expectedoutput = (join-path $serverdirectory "server_test_dir")
+             },
+             @{
+                Title = "lmkdir, lcd, lpwd for non-unicode directory names"
+                Options = ''
+                Commands = "lcd $clientDirectory
+                            lmkdir client_test_dir
+                            lcd client_test_dir
+                            lpwd"
+                ExpectedOutput = (Join-Path $clientDirectory "client_test_dir")
+             },
+             @{
+                title = "put, ls for unicode file names"
+                options = ''
+                commands = "put $tempUnicodeFilePath $serverDirectory
+                            ls $serverDirectory"
+                expectedoutput = (join-path $serverdirectory $tempUnicodeFileName)			
+             },
+             @{
+                title = "get, ls for unicode file names"
+                options = ''
+                commands = "get $tempUnicodeFilePath $clientDirectory
+                            ls $clientDirectory"
+                expectedoutput = (join-path $clientDirectory $tempUnicodeFileName)
+             },
+             @{
+                title = "mput, ls for unicode file names"
+                options = ''
+                commands = "mput $tempUnicodeFilePath $serverDirectory
+                            ls $serverDirectory"
+                expectedoutput = (join-path $serverdirectory $tempUnicodeFileName)
+             },
+             @{
+                title = "mget, ls for unicode file names"
+                options = ''
+                commands = "mget $tempUnicodeFilePath $clientDirectory
+                            ls $clientDirectory"
+                expectedoutput = (join-path $clientDirectory $tempUnicodeFileName)
+             },
+             @{
+                title = "mkdir, cd, pwd for unicode directory names"
+                options = ''
+                commands = "cd $serverdirectory
+                            mkdir server_test_dir_язык
+                            cd server_test_dir_язык
+                            pwd"
+                expectedoutput = (join-path $serverdirectory "server_test_dir_язык")
+             },
+             @{
+                Title = "lmkdir, lcd, lpwd for unicode directory names"
+                Options = ''
+                Commands = "lcd $clientDirectory
+                            lmkdir client_test_dir_язык
+                            lcd client_test_dir_язык
+                            lpwd
+                            lls $clientDirectory"
+                ExpectedOutput = (Join-Path $clientDirectory "client_test_dir_язык")
+             }
+        )
+        
+        $testData2 = @(
+            @{
+                title = "rm, rmdir, rename for unicode file, directory"
+                options = '-b $batchFilePath'
+                
+                tmpFileName1 = $tempUnicodeFileName
+                tmpFilePath1 = $tempUnicodeFilePath
+                tmpFileName2 = "tempfile_язык_2.txt"
+                tmpFilePath2 = (join-path $serverDirectory "tempfile_язык_2.txt")
+
+                tmpDirectoryName1 = "test_dir_язык_1"
+                tmpDirectoryPath1 = (join-path $serverDirectory "test_dir_язык_1")
+                tmpDirectoryName2 = "test_dir_язык_2"
+                tmpDirectoryPath2 = (join-path $serverDirectory "test_dir_язык_2")
+            },
+            @{
+                title = "rm, rmdir, rename for non-unicode file, directory"
+                options = '-b $batchFilePath'
+                
+                tmpFileName1 = $tempFileName
+                tmpFilePath1 = $tempFilePath
+                tmpFileName2 = "tempfile_2.txt"
+                tmpFilePath2 = (join-path $serverDirectory "tempfile_2.txt")
+
+                tmpDirectoryName1 = "test_dir_1"
+                tmpDirectoryPath1 = (join-path $serverDirectory "test_dir_1")
+                tmpDirectoryName2 = "test_dir_2"
+                tmpDirectoryPath2 = (join-path $serverDirectory "test_dir_2")
+            }
+        )
+
+        # for the first time, delete the existing log files.
+        if ($OpenSSHTestInfo['DebugMode'])
+        {
+            Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+            Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue
+            Clear-Content "$env:ProgramData\ssh\logs\sftp-server.log" -Force -ErrorAction SilentlyContinue
+        }
+
+        function CopyDebugLogs {
+            if($OpenSSHTestInfo["DebugMode"])
+            {
+                Copy-Item "$env:ProgramData\ssh\logs\ssh-agent.log" "$rootDirectory\ssh-agent_$tI.log" -Force -ErrorAction SilentlyContinue
+                Copy-Item "$env:ProgramData\ssh\logs\sshd.log" "$rootDirectory\sshd_$tI.log" -Force -ErrorAction SilentlyContinue
+                Copy-Item "$env:ProgramData\ssh\logs\sftp-server.log" "$rootDirectory\sftp-server_$tI.log" -Force -ErrorAction SilentlyContinue
+                
+                # clear the ssh-agent, sshd logs so that next testcase will get fresh logs.
+                Clear-Content "$env:ProgramData\ssh\logs\ssh-agent.log" -Force -ErrorAction SilentlyContinue
+                Clear-Content "$env:ProgramData\ssh\logs\sshd.log" -Force -ErrorAction SilentlyContinue
+                Clear-Content "$env:ProgramData\ssh\logs\sftp-server.log" -Force -ErrorAction SilentlyContinue
+            }
+        }
+    }
+
+    AfterAll {
+       if($serverDirectory) { Get-ChildItem $serverDirectory | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
+       if($clientDirectory) { Get-ChildItem $clientDirectory | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
+    }
+
+    BeforeEach {
+       if($serverDirectory) { Get-ChildItem $serverDirectory | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
+       if($clientDirectory) { Get-ChildItem $clientDirectory | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue }
+       $outputFilePath = Join-Path $rootDirectory "$tI.$outputFileName"
+       $batchFilePath = Join-Path $rootDirectory "$tI.$batchFileName"
+    }
+
+    AfterEach {
+        CopyDebugLogs
+        $tI++
+    }    
+
+    It '<Title>' -TestCases:$testData1 {
+       param([string]$Title, $Options, $Commands, $ExpectedOutput)
+
+       Set-Content $batchFilePath -Encoding UTF8 -value $Commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) -b $batchFilePath test_target > $outputFilePath")
+       iex $str
+
+       #validate file content.
+       Test-Path $ExpectedOutput | Should be $true
+    }
+
+    It '<Title>' -TestCases:$testData2 {
+       param([string]$Title, $Options, $tmpFileName1, $tmpFilePath1, $tmpFileName2, $tmpFilePath2, $tmpDirectoryName1, $tmpDirectoryPath1, $tmpDirectoryName2, $tmpDirectoryPath2)
+       if($skip) { return }
+
+       #rm (remove file)
+       $commands = "mkdir $tmpDirectoryPath1
+                    put $tmpFilePath1 $tmpDirectoryPath1
+                    ls $tmpDirectoryPath1"
+       Set-Content $batchFilePath  -Encoding UTF8 -value $commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) test_target > $outputFilePath")
+       iex $str
+       Test-Path (join-path $tmpDirectoryPath1 $tmpFileName1) | Should be $true
+
+       $commands = "rm $tmpDirectoryPath1\*
+                    ls $tmpDirectoryPath1
+                    pwd
+                   "
+       Set-Content $batchFilePath  -Encoding UTF8 -value $commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) test_target > $outputFilePath")
+       iex $str
+       Test-Path (join-path $tmpDirectoryPath1 $tmpFileName1) | Should be $false
+
+       #rename file
+       Remove-Item $outputFilePath
+       Copy-Item $tmpFilePath1 -destination $tmpDirectoryPath1
+       $commands = "rename $tmpDirectoryPath1\$tmpFileName1 $tmpDirectoryPath1\$tmpFileName2
+                    ls $tmpDirectoryPath1
+                    pwd"
+       Set-Content $batchFilePath -Encoding UTF8 -value $commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) test_target > $outputFilePath")
+       iex $str
+       Test-Path (join-path $tmpDirectoryPath1 $tmpFileName2) | Should be $true
+
+       #rename directory
+       Remove-Item $outputFilePath
+       $commands = "rm $tmpDirectoryPath1\*
+                    rename $tmpDirectoryPath1 $tmpDirectoryPath2
+                    ls $serverDirectory"
+       Set-Content $batchFilePath -Encoding UTF8 -value $commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) test_target > $outputFilePath")
+       iex $str
+       Test-Path $tmpDirectoryPath2 | Should be $true
+
+       #rmdir (remove directory)
+       Remove-Item $outputFilePath
+       $commands = "rmdir $tmpDirectoryPath2
+                    ls $serverDirectory"
+       Set-Content $batchFilePath -Encoding UTF8 -value $commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -P $port $($Options) test_target > $outputFilePath")
+       iex $str
+       Test-Path $tmpDirectoryPath2 | Should be $false
+    }
+
+    It "$script:testId-ls lists items the user has no read permission" {
+       $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+       $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+            
+       $permTestHasAccessFile = "permTestHasAccessFile.txt"
+       $permTestHasAccessFilePath = Join-Path $serverDirectory $permTestHasAccessFile
+       Remove-Item $permTestHasAccessFilePath -Force -ErrorAction SilentlyContinue
+       New-Item $permTestHasAccessFilePath -ItemType file -Force -value "perm test has access file data" | Out-Null
+
+       $permTestNoAccessFile = "permTestNoAccessFile.txt"
+       $permTestNoAccessFilePath = Join-Path $serverDirectory $permTestNoAccessFile
+       Remove-Item $permTestNoAccessFilePath -Force -ErrorAction SilentlyContinue
+       New-Item $permTestNoAccessFilePath -ItemType file -Force -value "perm test no access file data" | Out-Null
+       Repair-FilePermission -Filepath $permTestNoAccessFilePath -Owners $currentUserSid -FullAccessNeeded $adminsSid,$currentUserSid -confirm:$false
+
+       $Commands = "ls $serverDirectory"
+       Set-Content $batchFilePath -Encoding UTF8 -value $Commands
+       $str = $ExecutionContext.InvokeCommand.ExpandString("sftp -b $batchFilePath test_target > $outputFilePath")
+       iex $str
+       $content = Get-Content $outputFilePath
+       
+       #cleanup
+       $HasAccessPattern = $permTestHasAccessFilePath.Replace("\", "[/\\]")
+       $matches = @($content | select-string -Pattern "^/$HasAccessPattern\s{0,}$")
+       $matches.count | Should be 1
+
+       $NoAccessPattern = $permTestNoAccessFilePath.Replace("\", "[/\\]")
+       $matches = @($content | select-string -Pattern "^/$NoAccessPattern\s{0,}$")
+       $matches.count | Should be 1
+    }
+}
diff --git a/regress/pesterTests/SSH.Tests.ps1 b/regress/pesterTests/SSH.Tests.ps1
new file mode 100644
index 000000000..015727134
--- /dev/null
+++ b/regress/pesterTests/SSH.Tests.ps1
@@ -0,0 +1,371 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+#todo: -i -q -v -l -c -C
+#todo: -S -F -V -e
+$tC = 1
+$tI = 0
+$suite = "sshclient"
+        
+Describe "E2E scenarios for ssh client" -Tags "CI" {
+    BeforeAll {        
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+
+        $server = $OpenSSHTestInfo["Target"]
+        $port = $OpenSSHTestInfo["Port"]
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+
+        $testDir = Join-Path $OpenSSHTestInfo["TestDataPath"] $suite
+        if(-not (Test-Path $testDir))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }
+        $acl = Get-Acl $testDir
+        $rights = [System.Security.AccessControl.FileSystemRights]"Read, Write"
+        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule($ssouser, $rights, "ContainerInherit,Objectinherit", "None", "Allow")
+        $acl.SetAccessRule($accessRule)
+        Set-Acl -Path $testDir -AclObject $acl
+        #skip on ps 2 becase non-interactive cmd require a ENTER before it returns on ps2
+        $skip = $IsWindows -and ($PSVersionTable.PSVersion.Major -le 2)
+
+        <#$testData = @(
+            @{
+                Title = 'Simple logon no option';                
+                LogonStr = "$($server.localAdminUserName)@$($server.MachineName)"
+                Options = ""
+            },
+            @{
+                Title = 'Simple logon using -C -l option'
+                LogonStr = $server.MachineName
+                Options = "-C -l $($server.localAdminUserName)"
+            }
+        )
+        
+        $testData1 = @(
+            @{
+                Title = "logon using -i -q option"
+                LogonStr = "$($server.localAdminUserName)@$($server.MachineName)"
+                Options = '-i $identifyFile -q'
+            },
+            @{
+                Title = "logon using -i option"
+                LogonStr = "$($server.localAdminUserName)@$($server.MachineName)"
+                Options = '-i $identifyFile'
+            },
+            @{
+                Title = "logon using -i -c  option"
+                LogonStr = "$($server.localAdminUserName)@$($server.MachineName)"
+                Options = '-i $identifyFile -c aes256-ctr'
+            },
+             -V does not redirect to file
+            @{
+                Title = "logon using -i -V option"
+                LogonStr = "$($server.localAdminUserName)@$($server.MachineName)"
+                Options = '-i $identifyFile -V'
+                SkipVerification = $true
+            },
+            @{
+                Title = 'logon using -i -l option'
+                LogonStr = $server.MachineName
+                Options = '-i $identifyFile -l $($server.localAdminUserName)'
+            }
+        )#>
+        $dfltShellRegPath = "HKLM:\Software\OpenSSH"
+        $dfltShellRegKeyName = "DefaultShell"
+        $dfltShellCmdOptionRegKeyName = "DefaultShellCommandOption"
+        Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellRegKeyName -ErrorAction SilentlyContinue
+        Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellCmdOptionRegKeyName -ErrorAction SilentlyContinue
+
+        function ConfigureDefaultShell {
+            param
+            (
+                  [string] $default_shell_path,
+                  [string] $default_shell_cmd_option_val = $null
+            )
+            
+            if (!(Test-Path $dfltShellRegPath)) {
+                New-Item -Path $dfltShellRegPath -Force | Out-Null
+            }
+            New-ItemProperty -Path $dfltShellRegPath -Name $dfltShellRegKeyName -Value $default_shell_path -PropertyType String -Force
+            if ($default_shell_cmd_option_val -ne $null) {
+                New-ItemProperty -Path $dfltShellRegPath -Name $dfltShellCmdOptionRegKeyName -Value $default_shell_cmd_option_val -PropertyType String -Force
+            }
+        }
+    }
+
+    BeforeEach {
+        $stderrFile=Join-Path $testDir "$tC.$tI.stderr.txt"
+        $stdoutFile=Join-Path $testDir "$tC.$tI.stdout.txt"
+        $logFile = Join-Path $testDir "$tC.$tI.log.txt"
+    }        
+
+    AfterEach {$tI++;}
+
+   Context "$tC - Basic Scenarios" {
+        
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - test version" {
+            iex "cmd /c `"ssh -V 2> $stderrFile`""
+            $stderrFile | Should Contain "OpenSSH_for_Windows"
+        }
+
+        It "$tC.$tI - test help" {
+            iex "cmd /c `"ssh -? 2> $stderrFile`""
+            $stderrFile | Should Contain "usage: ssh"
+        }
+        
+        It "$tC.$tI - remote echo command" {
+            iex "$sshDefaultCmd echo 1234" | Should Be "1234"
+        }
+
+    }
+    
+    Context "$tC - exit code (exit-status.sh)" {
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - various exit codes" {
+            foreach ($i in (0,1,4,5,44)) {
+                ssh -p $port $ssouser@$server exit $i
+                $LASTEXITCODE | Should Be $i
+            }            
+        }
+    }
+
+    Context "$tC - Redirection Scenarios" {
+        
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - stdout to file" -skip:$skip {
+            ssh test_target powershell get-process > $stdoutFile
+            $stdoutFile | Should Contain "ProcessName"
+        }
+
+        It "$tC.$tI - stdout to PS object" {
+            $o = ssh test_target echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI - multiple double quotes in cmdline" {
+            # actual command line ssh target "cmd" /c "echo hello"
+            $o = ssh test_target `"cmd`" /c `"echo hello`"
+            $o | Should Be "hello"
+        }
+
+        It "$tC.$tI - stdin from PS object" -skip:$skip {
+            # execute this script that dumps the length of input data, on the remote end
+            $str = "begin {} process { Write-Output `$input.Length} end { }"
+            $EncodedText =[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
+            $h = "hello123"
+            # ignore error stream using 2> $null
+            $o = $h | ssh test_target PowerShell -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -EncodedCommand $EncodedText 2> $null
+            $o | Should Be "8"
+        }
+
+        It "$tC.$tI - stream file in and out" -skip:$skip {
+            # prep a file of size > 10KB (https://github.com/PowerShell/Win32-OpenSSH/issues/908 was caught with such file size)
+            $str = ""
+            (1..100) | foreach {$str += "1234567890"}
+            #strem file from local to remote
+            $testsrc = Join-Path $testDir "$tC.$tI.testsrc"
+            $testdst1 = Join-Path $testDir "$tC.$tI.testdst1"
+            $null | Set-Content $testsrc
+            $null | Set-Content $testdst1
+            (1..105) | foreach {Add-Content -Encoding Ascii -Path $testsrc -Value $str}
+            # execute this script that dumps input stream in target file, on the remote end
+            $str = "begin {} process { Add-Content -Encoding Ascii -path $testdst1 -Value ([string]`$input)} end { }"
+            $EncodedText =[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($str))
+            # ignore error stream using 2> $null
+            get-content $testsrc | ssh test_target PowerShell -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -EncodedCommand $EncodedText 2> $null
+            (dir $testdst1).Length | Should Be (dir $testsrc).Length
+
+            # stream file from remote to local
+            $testdst2 = Join-Path $testDir "$tC.$tI.testdst2"
+            $null | Set-Content $testdst2
+            (ssh test_target powershell get-content $testdst1 -Encoding Ascii) | Set-Content $testdst2 -Encoding ASCII
+            (dir $testdst2).Length | Should Be (dir $testsrc).Length
+
+        }
+    }
+    
+    Context "$tC - configure powershell default shell Scenarios" {
+        BeforeAll {
+            $tI=1
+            $shell_path = (Get-Command powershell.exe -ErrorAction SilentlyContinue).path
+            if($shell_path -ne $null) {
+                ConfigureDefaultShell -default_shell_path $shell_path -default_shell_cmd_option_val "-c"
+            }
+        }
+        AfterAll{
+            $tC++
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellRegKeyName -ErrorAction SilentlyContinue
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellCmdOptionRegKeyName -ErrorAction SilentlyContinue
+        }        
+
+        It "$tC.$tI - basic powershell" -skip:$skip {
+            $o = ssh test_target Write-Output 1234
+            $o | Should Be "1234"
+        }
+        
+        It "$tC.$tI - basic in powershell cmdlet" -skip:$skip {
+            $o = ssh test_target "cd `$env:ProgramFiles;pwd"
+            $LASTEXITCODE | Should Be 0
+            #$o | Should Match "c:\Program Files"
+        }
+        It "$tC.$tI - powershell as default shell and double quotes in cmdline" {
+            # actual command line ssh target echo `"hello`"
+            $o = ssh test_target echo `"hello`"
+            $o | Should Be "hello"
+        }
+        It "$tC.$tI - multiple commands with double quotes in powershell cmdlet" -skip:$skip {
+            # actual command line ssh target cd "$env:programfiles\";pwd
+            $o = ssh test_target "cd `"`$env:programfiles\`";pwd"
+            $LASTEXITCODE | Should Be 0
+            $match = $o -match "Program Files"
+            $match.count | Should be 1
+        }
+        It "$tC.$tI - multiple commands with double quotes in powershell cmdlet" -skip:$skip {
+            # actual command line ssh target dir "$env:programfiles\";cd "$env:programfiles\";pwd
+            $o = ssh test_target "dir `"`$env:programfiles\`";cd `"`$env:programfiles\`";pwd"
+            $LASTEXITCODE | Should Be 0
+            #$o -contains "Program Files" | Should Be $True
+            $match = $o -match "Program Files"
+            $match.count | Should Be 3
+        }
+        It "$tC.$tI - single quotes in powershell cmdlet" -skip:$skip {
+            # actual command line ssh target echo '$env:computername'
+            $o = ssh test_target "echo '`$env:computername'"
+            $LASTEXITCODE | Should Be 0            
+            $o | Should Be `$env:computername
+        }
+    }
+    Context "$tC - configure cmd as default shell" {
+        BeforeAll {
+            $tI=1
+            $shell_path = (Get-Command cmd.exe -ErrorAction SilentlyContinue).path
+            if($shell_path -ne $null) {
+                ConfigureDefaultShell -default_shell_path $shell_path -default_shell_cmd_option_val "/c"
+        }
+        }
+        AfterAll{
+            $tC++
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellRegKeyName -ErrorAction SilentlyContinue
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellCmdOptionRegKeyName -ErrorAction SilentlyContinue
+        }
+        It "$tC.$tI - default shell as cmd" -skip:$skip {            
+            $o = ssh test_target where cmd
+            $o | Should Contain "cmd"            
+        }
+        It "$tC.$tI - cmd as default shell and double quotes in cmdline" {
+            # actual command line ssh target echo "hello"
+            $o = ssh test_target echo "`"hello`""
+            $o | Should Be "`"hello`""
+        }
+        It "$tC.$tI - single quotes in powershell cmdlet" -skip:$skip {
+            # actual command line ssh target echo '$env:computername'
+            $o = ssh test_target "echo 'hello'"
+            $LASTEXITCODE | Should Be 0            
+            $o | Should Be "'hello'"
+        }
+    }
+    Context "$tC - configure ssh-shellhost as default shell" {
+        BeforeAll {
+            $tI=1
+            $shell_path = (Get-Command ssh-shellhost -ErrorAction SilentlyContinue).path
+            ConfigureDefaultShell -default_shell_path $shell_path
+        }
+        AfterAll{
+            $tC++
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellRegKeyName -ErrorAction SilentlyContinue
+            Remove-ItemProperty -Path $dfltShellRegPath -Name $dfltShellCmdOptionRegKeyName -ErrorAction SilentlyContinue
+        }
+        It "$tC.$tI - shellhost as default shell and multiple double quotes in cmdline" {
+            # actual command line ssh target "cmd" /c "echo "hello""
+            $o = ssh test_target `"cmd`" /c `"echo `"hello`"`"
+            $o | Should Be "`"hello`""
+        }
+    }
+    
+    Context "$tC - cmdline parameters" {        
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - verbose to file (-v -E)" {
+            $o = ssh -v -E $logFile test_target echo 1234
+            $o | Should Be "1234"
+            #TODO - checks below are very inefficient (time taking). 
+            $logFile | Should Contain "OpenSSH_"
+            $logFile | Should Contain "Exit Status 0"
+        }
+
+
+        It "$tC.$tI - cipher options (-c)" {
+            #bad cipher
+            iex "cmd /c `"ssh -c bad_cipher test_target echo 1234 2>$stderrFile`""
+            $stderrFile | Should Contain "Unknown cipher type"
+            #good cipher, ensure cipher is used from debug logs
+            $o = ssh -c aes256-ctr  -v -E $logFile test_target echo 1234
+            $o | Should Be "1234"
+            $logFile | Should Contain "kex: server->client cipher: aes256-ctr"
+            $logFile | Should Contain "kex: client->server cipher: aes256-ctr"
+        }
+
+        It "$tC.$tI - ssh_config (-F)" {
+            #ensure -F is working by pointing to a bad configuration
+            $badConfigFile = Join-Path $testDir "$tC.$tI.bad_ssh_config"
+            "bad_config_line" | Set-Content $badConfigFile
+            iex "cmd /c `"ssh -F $badConfigFile test_target echo 1234 2>$stderrFile`""
+            $stderrFile | Should Contain "bad_ssh_config"
+            $stderrFile | Should Contain "bad_config_line"
+            $stderrFile | Should Contain "bad configuration options"
+
+            #try with a proper configuration file. Put it on a unicode path with unicode content
+            #so we can test the Unicode support simultaneously
+            $goodConfigFile = Join-Path $testDir "$tC.$tI.Очень_хорошо_ssh_config"
+            "#this is a Unicode comment because it contains русский язык" | Set-Content $goodConfigFile -Encoding UTF8
+            "Host myhost" | Add-Content $goodConfigFile
+            "    HostName $server" | Add-Content $goodConfigFile
+            "    Port $port" | Add-Content $goodConfigFile
+            "    User $ssouser" | Add-Content $goodConfigFile
+            $o = ssh -F $goodConfigFile myhost echo 1234
+            $o | Should Be "1234"          
+        }
+
+        It "$tC.$tI - IP options - (-4) (-6)" {
+            # TODO - this test assumes target is localhost. 
+            # make it work independent of target
+            #-4
+            $o = ssh -4 -v -E $logFile test_target echo 1234
+            $o | Should Be "1234"
+            $logFile | Should Contain "[127.0.0.1]"
+            #-4
+            $o = ssh -6 -v -E $logFile test_target echo 1234
+            $o | Should Be "1234"
+            $logFile | Should Contain "[::1]"            
+        }
+
+        It "$tC.$tI - auto populate known hosts" {
+            
+            $kh = Join-Path $testDir "$tC.$tI.known_hosts"
+            $nul | Set-Content $kh
+            # doing via cmd to intercept and drain stderr output
+            iex "cmd /c `"ssh -o UserKnownHostsFile=`"$kh`" -o StrictHostKeyChecking=no test_target hostname 2>&1`""
+            @(Get-Content $kh).Count | Should Be 1
+        }
+
+        It "$tC.$tI - ProxyCommand with file name only" {
+            iex "cmd /c `"ssh -o ProxyCommand=`"`"cmd.exe /c echo test string for invalid proxy 1>&2`"`" abc 2>$stderrFile`""
+            $stderrFile | Should Contain "test string for invalid proxy"
+        }
+
+        It "$tC.$tI - ProxyCommand with absolute path to the file" {
+            iex "cmd /c `"ssh -o ProxyCommand=`"`"$($env:ComSpec) /c echo test string for invalid proxy 1>&2`"`" abc 2>$stderrFile`""
+            $stderrFile | Should Contain "test string for invalid proxy"
+        }
+    }
+}
diff --git a/regress/pesterTests/SSHDConfig.tests.ps1 b/regress/pesterTests/SSHDConfig.tests.ps1
new file mode 100644
index 000000000..47a825959
--- /dev/null
+++ b/regress/pesterTests/SSHDConfig.tests.ps1
@@ -0,0 +1,368 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$tC = 1
+$tI = 0
+$suite = "sshdConfig"
+Describe "Tests of sshd_config" -Tags "CI" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }
+        
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }        
+
+        $sshLogName = "test.txt"
+        $sshdLogName = "sshdlog.txt"
+        $server = $OpenSSHTestInfo["Target"]
+        $opensshbinpath = $OpenSSHTestInfo['OpenSSHBinPath']
+        $port = 47003
+        $sshdDelay = $OpenSSHTestInfo["DelayTime"]        
+        Remove-Item -Path (Join-Path $testDir "*$sshLogName") -Force -ErrorAction SilentlyContinue
+
+        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
+        $ContextName = $env:COMPUTERNAME
+        $ContextType = [System.DirectoryServices.AccountManagement.ContextType]::Machine
+        $PrincipalContext = new-object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList @($ContextType, $ContextName)
+        $IdentityType = [System.DirectoryServices.AccountManagement.IdentityType]::SamAccountName     
+        
+        #prepare custom sshd_config
+        $sshdconfig_ori = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config
+        $sshdconfig_custom = Join-Path $Global:OpenSSHTestInfo["ServiceConfigDir"] sshd_config_custom
+        if (Test-Path $sshdconfig_custom) {
+            Remove-Item $sshdconfig_custom -Force
+        }
+        Copy-Item $sshdconfig_ori $sshdconfig_custom
+        get-acl $sshdconfig_ori | set-acl $sshdconfig_custom
+        
+        Add-Content $sshdconfig_custom @"
+
+DenyUsers denyuser1 deny*2 denyuse?3, 
+AllowUsers allowuser1 allowu*r2 allow?se?3 allowuser4 localuser1 localu*r2 loc?lu?er3 localadmin matchuser
+DenyGroups denygroup1 denygr*p2 deny?rou?3
+AllowGroups allowgroup1 allowg*2 allowg?ou?3 Adm*
+
+Match User matchuser
+	ForceCommand cmd.exe /c "whoami & set SSH_ORIGINAL_COMMAND"
+
+"@
+
+        function Add-LocalUser
+        {
+            param([string] $UserName, [string] $Password)
+            $user = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $UserName)
+            if($user -eq $null)
+            {
+                try {
+                    $user = new-object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList @($PrincipalContext,$UserName,$Password, $true)
+                    $user.Save()
+                }
+                finally {
+                    $user.Dispose()
+                }
+            }
+        }
+
+        function Add-LocalGroup
+        {
+            param([string] $groupName)
+            $group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $GroupName)
+            if($group -eq $null)
+            {
+                try {
+                    $group = new-object -TypeName System.DirectoryServices.AccountManagement.GroupPrincipal -ArgumentList @($PrincipalContext,$groupName)
+                    $group.Save()
+                }
+                finally {
+                    $group.Dispose()
+                }
+            }
+        }
+
+        function Add-UserToLocalGroup
+        {
+            param([string]$UserName, [string]$Password, [string]$GroupName)
+            Add-LocalGroup -groupName $GroupName
+            Add-LocalUser -UserName $UserName -Password $Password
+            $group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $GroupName)    
+            $user = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $UserName)
+    
+            if(-not $group.Members.Contains($user))
+            {
+                try {
+                    $group.Members.Add($user)
+                    $group.save()
+                }
+                finally {
+                    $group.Dispose()
+                }
+            }
+        }
+
+        function Remove-UserFromLocalGroup
+        {        
+            param([string]$UserName, [string]$GroupName)
+            $group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $GroupName)
+            $user = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $UserName)
+            if($group.Members.Contains($user))
+            {
+                try {
+                    $group.Members.Remove($user)
+                    $group.save()
+                }
+                finally {
+                    $group.Dispose()
+                }
+            }
+        }
+
+        function Clenaup-LocalGroup
+        {
+            param([string]$GroupName)
+            $group = [System.DirectoryServices.AccountManagement.GroupPrincipal]::FindByIdentity($PrincipalContext, $IdentityType, $GroupName)
+            if($group -ne $null)
+            {
+                try {
+                    $group.Delete()
+                }
+                finally {
+                    $group.Dispose()
+                }
+            }
+        }
+        
+        #skip when the task schedular (*-ScheduledTask) cmdlets does not exist
+        $ts = (get-command get-ScheduledTask -ErrorAction SilentlyContinue)
+        $skip = $ts -eq $null
+        if(-not $skip)
+        {
+            Stop-SSHDTestDaemon   -Port $port
+        }
+        if($IsWindows -and ([Environment]::OSVersion.Version.Major -le 6))
+        {
+            #suppress the firewall blocking dialogue on win7
+            netsh advfirewall firewall add rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any action=allow dir=in
+        }
+    }
+
+    AfterEach { $tI++ }
+    
+    AfterAll {        
+        $PrincipalContext.Dispose()
+        if($IsWindows -and ($psversiontable.BuildVersion.Major -le 6))
+        {            
+            netsh advfirewall firewall delete rule name="sshd" program="$($OpenSSHTestInfo['OpenSSHBinPath'])\sshd.exe" protocol=any dir=in
+        }    
+    }
+
+<#
+    Settings in the sshd_config:
+
+    DenyUsers denyuser1 denyu*2 denyuse?3, 
+    AllowUsers allowuser1 allowu*r2 allow?se?3 allowuser4 localuser1 localu*r2 loc?lu?er3 localadmin
+    DenyGroups denygroup1 denygr*p2 deny?rou?3
+    AllowGroups allowgroup1 allowg*2 allowg?ou?3 Adm*
+#>
+     Context "Tests of AllowGroups, AllowUsers, DenyUsers, DenyGroups" {
+        BeforeAll {            
+            $password = "Bull_dog123456"
+
+            $allowUser1 = "allowuser1"
+            $allowUser2 = "allowuser2"
+            $allowUser3 = "allowuser3"
+            $allowUser4 = "allowuser4"
+
+            $denyUser1 = "denyuser1"
+            $denyUser2 = "denyuser2"
+            $denyUser3 = "denyuser3"
+
+            $localuser1 = "localuser1"
+            $localuser2 = "localuser2"
+            $localuser3 = "localuser3"
+
+            $allowGroup1 = "allowgroup1"
+            $allowGroup2 = "allowgroup2"
+            $allowGroup3 = "allowgroup3"
+
+            $denyGroup1 = "denygroup1"
+            $denyGroup2 = "denygroup2"
+            $denyGroup3 = "denygroup3"
+            $sshdConfigPath = $sshdconfig_custom
+            #add wrong password so ssh does not prompt password if failed with authorized keys
+            Add-PasswordSetting -Pass $password            
+            $tI=1
+        }
+        
+        BeforeEach {
+            $sshlog = Join-Path $testDir "$tC.$tI.$sshLogName"            
+            $sshdlog = Join-Path $testDir "$tC.$tI.$sshdLogName"
+            if(-not $skip)
+            {
+                Stop-SSHDTestDaemon   -Port $port
+            }
+        }
+
+        AfterAll {            
+            Remove-PasswordSetting
+            $tC++
+        }
+
+        It "$tC.$tI-User with full name in the list of AllowUsers"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port
+
+           Add-UserToLocalGroup -UserName $allowUser1 -Password $password -GroupName $allowGroup1
+
+           $o = ssh  -p $port $allowUser1@$server echo 1234
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $o | Should Be "1234"
+           Remove-UserFromLocalGroup -UserName $allowUser1 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User with * wildcard"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $allowUser2 -Password $password -GroupName $allowGroup1
+           
+           $o = ssh  -p $port $allowUser2@$server echo 1234
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $o | Should Be "1234"
+           Remove-UserFromLocalGroup -UserName $allowUser2 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User with ? wildcard"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+           Add-UserToLocalGroup -UserName $allowUser3 -Password $password -GroupName $allowGroup1
+           
+           $o = ssh  -p $port $allowUser3@$server echo 1234
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $o | Should Be "1234"
+           Remove-UserFromLocalGroup -UserName $allowUser3 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User with full name in the list of DenyUsers"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $denyUser1 -Password $password -GroupName $allowGroup1
+
+           ssh -p $port -E $sshlog $denyUser1@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because listed in DenyUsers"
+
+           Remove-UserFromLocalGroup -UserName $denyUser1 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User with * wildcard in the list of DenyUsers"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $denyUser2 -Password $password -GroupName $allowGroup1
+
+           ssh -p $port -E $sshlog $denyUser2@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because listed in DenyUsers"
+
+           Remove-UserFromLocalGroup -UserName $denyUser2 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User with ? wildcard in the list of DenyUsers"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $denyUser3 -Password $password -GroupName $allowGroup1
+
+           ssh -p $port -E $sshlog $denyUser3@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because not listed in AllowUsers"
+           
+           Remove-UserFromLocalGroup -UserName $denyUser3 -GroupName $allowGroup1
+
+        }
+
+        It "$tC.$tI-User is listed in the list of AllowUsers but also in a full name DenyGroups and AllowGroups"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $localuser1 -Password $password -GroupName $allowGroup1
+           Add-UserToLocalGroup -UserName $localuser1 -Password $password -GroupName $denyGroup1
+           
+           ssh -p $port -E $sshlog $localuser1@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because a group is listed in DenyGroups"
+
+           Remove-UserFromLocalGroup -UserName $localuser1 -GroupName $allowGroup1
+           Remove-UserFromLocalGroup -UserName $localuser1 -GroupName $denyGroup1
+
+        }
+
+        It "$tC.$tI-User is listed in the list of AllowUsers but also in a wildcard * DenyGroups"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $localuser2 -Password $password -GroupName $denyGroup2
+           
+           ssh -p $port -E $sshlog $localuser2@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because a group is listed in DenyGroups"
+           
+           Remove-UserFromLocalGroup -UserName $localuser2 -GroupName $denyGroup2
+
+        }
+
+        It "$tC.$tI-User is listed in the list of AllowUsers but also in a wildcard ? DenyGroups"  -skip:$skip {
+           #Run
+           Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+
+           Add-UserToLocalGroup -UserName $localuser3 -Password $password -GroupName $denyGroup3
+           
+           ssh -p $port -E $sshlog $localuser3@$server echo 1234
+           $LASTEXITCODE | Should Not Be 0
+           Stop-SSHDTestDaemon   -Port $port
+           sleep $sshdDelay
+           $sshdlog | Should Contain "not allowed because a group is listed in DenyGroups"
+           
+           Remove-UserFromLocalGroup -UserName $localuser3 -GroupName $denyGroup3
+
+        }
+
+        It "$tC.$tI - Match User block with ForceCommand" -skip:$skip  {
+            Start-SSHDTestDaemon -WorkDir $opensshbinpath -Arguments "-d -f $sshdConfigPath -E $sshdlog" -Port $port 
+            $matchuser = "matchuser"
+            Add-UserToLocalGroup -UserName $matchuser -Password $password -GroupName $allowGroup1
+
+            $o = ssh  -p $port -T $matchuser@$server randomcommand
+            # Match block's ForceCommand returns output of "whoami & set SSH_ORIGINAL_COMMAND"
+            $o[0].Contains($matchuser) | Should Be $true
+            $o[1].Contains("randomcommand") | Should Be $true
+            
+            Stop-SSHDTestDaemon   -Port $port
+            sleep $sshdDelay
+            Remove-UserFromLocalGroup -UserName $matchuser -GroupName $allowGroup1
+        }
+    }
+}
diff --git a/regress/pesterTests/Setup.Tests.ps1 b/regress/pesterTests/Setup.Tests.ps1
new file mode 100644
index 000000000..96074759c
--- /dev/null
+++ b/regress/pesterTests/Setup.Tests.ps1
@@ -0,0 +1,524 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$suite = "Setup"
+$tC = 1
+$tI = 0
+Describe "Setup Tests" -Tags "Setup" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }     
+        
+        $windowsInBox = $OpenSSHTestInfo["WindowsInBox"]
+        $binPath = $OpenSSHTestInfo["OpenSSHBinPath"]
+        $dataPath = Join-path $env:ProgramData ssh        
+        
+        $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+        $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)
+        $usersSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinUsersSid)
+        $authenticatedUserSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::AuthenticatedUserSid)
+        $trustedInstallerSid = Get-UserSID -User "NT SERVICE\TrustedInstaller"
+        $allApplicationPackagesSid = Get-UserSID -User "ALL APPLICATION PACKAGES"
+        $allRestrictedApplicationPackagesSid = Get-UserSID -User "ALL RESTRICTED APPLICATION PACKAGES"
+
+        $FSReadAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                    ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+        $FSReadWriteAccessPerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Write.value__)  -bor `
+                ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Modify.value__)  -bor `
+                ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+
+        $FSFullControlPerm = [System.UInt32] [System.Security.AccessControl.FileSystemRights]::FullControl.value__
+        $FSReadAndExecutePerm = ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::ReadAndExecute.value__)  -bor `
+                ([System.UInt32] [System.Security.AccessControl.FileSystemRights]::Synchronize.value__)
+
+        $RegReadKeyPerm = ([System.UInt32] [System.Security.AccessControl.RegistryRights]::ReadKey.value__)
+        $RegFullControlPerm = [System.UInt32] [System.Security.AccessControl.RegistryRights]::FullControl.value__        
+
+        #only validate owner and ACEs of the registry
+        function ValidateRegistryACL {
+            param([string]$RegPath, $Ownersid = $adminsSid, $IdAcls)
+            Test-Path -Path $RegPath | Should Be $true                      
+            $myACL = Get-ACL $RegPath
+            $OwnerSid = Get-UserSid -User $myACL.Owner
+            $OwnerSid.Equals($Ownersid) | Should Be $true
+            $myACL.Access | Should Not Be $null
+            $CAPABILITY_SID = "S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681"            
+            $nonPropagate = $myACL.Access | ? {($_.PropagationFlags -eq ([System.Security.AccessControl.PropagationFlags]::None)) -and ($_.IdentityReference -ine $CAPABILITY_SID)}
+
+            foreach ($a in $nonPropagate) {
+                $findItem = $IdAcls | ? {
+                    ($a.IdentityReference -eq (Get-UserAccount -UserSid ($_.Identity))) -and `
+                    ($a.IsInherited -eq $_.IsInherited) -and `
+                    ($a.AccessControlType -eq ([System.Security.AccessControl.AccessControlType]::Allow)) -and  `                    
+                    (([System.Int32]$a.RegistryRights.value__) -eq ($_.RegistryRights))
+                }
+                $findItem | Should Not Be $null
+            }
+
+            foreach ($expected in $IdAcls) {
+                $findItem = $nonPropagate | ? {
+                    ((Get-UserAccount -UserSid ($expected.Identity)) -eq $_.IdentityReference) -and `
+                    ($expected.IsInherited -eq $_.IsInherited) -and `                    
+                    ($expected.RegistryRights -eq ([System.Int32]$_.RegistryRights.value__))
+                }
+                $findItem | Should Not Be $null
+            }            
+        }
+
+        #only validate owner and ACEs of the file
+        function ValidateFileSystem {
+            param(
+                [string]$FilePath,
+                [bool]$IsDirectory = $false,
+                [switch]$IsDataFile,
+                $OwnerSid = $trustedInstallerSid)
+
+            if($IsDirectory)
+            {
+                Test-Path -Path $FilePath -PathType Container | Should Be $true
+            }
+            else
+            {
+                Test-Path -Path $FilePath -PathType Leaf | Should Be $true
+            }
+
+            $myACL = Get-ACL $FilePath
+            $currentOwnerSid = Get-UserSid -User $myACL.Owner
+            if(-not $windowsInBox) {return}            
+            $currentOwnerSid.Equals($OwnerSid) | Should Be $true            
+            $myACL.Access | Should Not Be $null
+            if($IsDirectory)
+            {
+                $identities = @($systemSid, $adminsSid)
+            }
+            elseif($IsDataFile)
+            {
+                $identities = @($systemSid, $adminsSid, $authenticatedUserSid)
+            }
+            else
+            {
+                $identities = @($systemSid, $adminsSid, $trustedInstallerSid, $allApplicationPackagesSid, $allRestrictedApplicationPackagesSid, $usersSid)
+            }
+
+            $identities | % {
+                $myACL.Access.IdentityReference -contains (Get-UserAccount -UserSid $_) | Should Be $true
+            }
+
+            foreach ($a in $myACL.Access) {
+                $id = Get-UserSid -User $a.IdentityReference
+                if($id -eq $null)
+                {
+                    $idRefShortValue = ($a.IdentityReference.Value).split('\')[-1]
+                    $id = Get-UserSID -User $idRefShortValue                                      
+                }
+
+                $identities -contains $id | Should be $true
+
+                switch ($id)
+                {
+                    {@($systemSid, $adminsSid) -contains $_}
+                    {
+                        if($IsDataFile)
+                        {
+                            ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FSFullControlPerm
+                        }
+                        else
+                        {
+                            ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FSReadAndExecutePerm
+                        }                        
+                        break;
+                    }
+                    {@($usersSid, $allApplicationPackagesSid, $allRestrictedApplicationPackagesSid, $authenticatedUserSid) -contains $_}
+                    {                        
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FSReadAndExecutePerm                     
+                        break;
+                    }
+                    $trustedInstallerSid
+                    {
+                        ([System.UInt32]$a.FileSystemRights.value__) | Should Be $FSFullControlPerm
+                        break;
+                    }
+                }
+            
+                $a.AccessControlType | Should Be ([System.Security.AccessControl.AccessControlType]::Allow)
+                if($IsDirectory)
+                {
+                    $a.InheritanceFlags | Should Be (([System.Security.AccessControl.InheritanceFlags]::ContainerInherit.value__ -bor `
+                         [System.Security.AccessControl.InheritanceFlags]::ObjectInherit.value__))
+                }
+                else
+                {
+                    $a.InheritanceFlags | Should Be ([System.Security.AccessControl.InheritanceFlags]::None)
+                }
+                $a.PropagationFlags | Should Be ([System.Security.AccessControl.PropagationFlags]::None)
+            }
+        }        
+    }    
+
+    Context "$tC - Validate Openssh binary files" {
+
+        BeforeAll {
+            $tI=1
+            $binaries =  @(
+                @{
+                    Name = 'sshd.exe'
+                },
+                @{
+                    Name = 'ssh.exe'
+                },
+                @{
+                    Name = 'ssh-agent.exe'
+                },
+                @{
+                    Name = 'ssh-add.exe'
+                },
+                @{
+                    Name = 'sftp.exe'
+                },
+                @{
+                    Name = 'sftp-server.exe'
+                },
+                @{
+                    Name = 'scp.exe'
+                },
+                @{
+                    Name = 'ssh-shellhost.exe'
+                },
+                @{
+                    Name = 'ssh-agent.exe'
+                },
+                @{
+                    Name = 'ssh-keyscan.exe'
+                }
+            )
+            $dataFile =  @(
+                @{
+                    Name = 'sshd_config_default'
+                },
+                @{
+                    Name = 'install-sshd.ps1'
+                },
+                @{
+                    Name = 'uninstall-sshd.ps1'
+                },
+                @{
+                    Name = 'FixHostFilePermissions.ps1'
+                },
+                @{
+                    Name = 'FixUserFilePermissions.ps1'
+                },
+                @{
+                    Name = 'OpenSSHUtils.psm1'
+                },
+                @{
+                    Name = 'OpenSSHUtils.psd1'
+                },
+                @{
+                    Name = 'openssh-events.man'
+                }
+            )
+
+            $dataFile1 = @(
+                @{
+                    Name = "sshd_config"
+                }
+                @{
+                    Name = "logs"
+                    IsDirectory = $true
+                }
+            )
+        }
+        AfterAll{$tC++}        
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate Openssh binary files--<Name>" -TestCases:$binaries{
+            param([string]$Name, [boolean]$IsDirectory = $false)
+            ValidateFileSystem -FilePath (join-path $binPath $Name)
+        }
+        It "$tC.$tI - Validate Openssh script files--<Name>" -TestCases:$dataFile {
+            param([string]$Name, [boolean]$IsDirectory = $false)            
+            if(-not $WindowsInbox) { ValidateFileSystem -FilePath (join-path $binPath $Name) }
+        }
+
+        It "$tC.$tI - Validate data files--<Name>" -TestCases:$dataFile1 {
+            param([string]$Name, [boolean]$IsDirectory = $false)
+            if(-not (Test-Path $dataPath -PathType Container))
+            {
+                Start-Service sshd
+            }
+            
+            ValidateFileSystem -FilePath (join-path $dataPath $Name) -IsDirectory $IsDirectory -OwnerSid $adminsSid -IsDataFile
+        }
+    } 
+    
+    Context "$tC - Validate Openssh registry entries" {
+        BeforeAll {
+            $tI=1
+            $servicePath = "HKLM:\SYSTEM\ControlSet001\Services"
+            $opensshRegPath = "HKLM:\SOFTWARE\OpenSSH"
+            
+            $opensshACLs = @(
+                @{
+                    Identity=$systemSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                },
+                @{
+                    Identity=$adminsSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                },                
+                @{
+                    Identity=$authenticatedUserSid
+                    IsInherited = $false
+                    RegistryRights = $RegReadKeyPerm
+                    PropagationFlags = "None"
+                }
+            )
+
+            $opensshAgentACLs = @(
+                @{
+                    Identity=$systemSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                },
+                @{
+                    Identity=$adminsSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                }
+            )
+        }        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }               
+
+        It "$tC.$tI - Validate Registry key ssh-agent\Description" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "Description"
+            $p | Should Not Be $null
+        }
+
+        It "$tC.$tI - Validate Registry key ssh-agent\ErrorControl" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "ErrorControl"
+            $p | Should Be 1
+        }
+
+        It "$tC.$tI - Validate Registry key ssh-agent\ImagePath" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "ImagePath"
+            $imagePath = (Join-Path $binPath "ssh-agent.exe").ToLower()
+            $p | Should Match "[`"]?$($imagePath.Replace("\", "\\"))[`"]?"
+        }
+
+        It "$tC.$tI - Validate Registry key ssh-agent\ObjectName" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "ObjectName"
+            $p | Should Be "LocalSystem"
+        }        
+
+        It "$tC.$tI - Validate Registry key ssh-agent\Start" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "Start"  
+            if($windowsInBox) {
+                $p | Should Be 4
+            }
+            else {
+                $p | Should Be 3
+            }
+        }
+
+        It "$tC.$tI - Validate Registry key ssh-agent\Type" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent") -Name "Type"
+            $p | Should Be 16
+        }        
+
+        It "$tC.$tI - Validate Registry key to ssh-agent\Security\Security" { 
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "ssh-agent\Security") -Name Security
+            $p.Gettype() | Should Be byte[]
+        }        
+
+        It "$tC.$tI - Validate Registry key sshd\Description" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "Description"
+            $p | Should not Be $null
+        }
+
+        It "$tC.$tI - Validate Registry key sshd\ErrorControl" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "ErrorControl"
+            $p | Should Be 1
+        }
+
+        It "$tC.$tI - Validate Registry key sshd\ImagePath" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "ImagePath"
+            $imagePath = (Join-Path $binPath "sshd.exe").ToLower()
+            $p | Should Match "[`"]?$($imagePath.Replace("\", "\\"))[`"]?"
+        }
+
+        It "$tC.$tI - Validate Registry key sshd\ObjectName" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "ObjectName"            
+            $p | Should Be "LocalSystem"
+        }        
+
+        It "$tC.$tI - Validate Registry key sshd\Start" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "Start"            
+            $p | Should Be 3
+        }
+
+        It "$tC.$tI - Validate Registry key sshd\Type" {
+            $p = Get-ItemPropertyValue (Join-Path $servicePath "sshd") -Name "Type"            
+            $p | Should Be 16
+        }
+
+        It "$tC.$tI - Validate Registry openssh entry" {
+            ValidateRegistryACL -RegPath $opensshRegPath -IdAcls $opensshACLs
+        }
+        It "$tC.$tI - Validate Registry openssh\agent entry" {
+            $agentPath = Join-Path $opensshRegPath "Agent"
+            if(Test-Path $agentPath -PathType Container)
+            {
+                ValidateRegistryACL -RegPath $agentPath -IdAcls $opensshAgentACLs
+            }
+            elseif((-not $windowsInBox) -or ((Get-Service ssh-agent).StartType -ne ([System.ServiceProcess.ServiceStartMode]::Disabled)))
+            {
+                Start-Service ssh-agent
+                ValidateRegistryACL -RegPath $agentPath -IdAcls $opensshAgentACLs
+            }                            
+        }
+    }
+
+    Context "$tC - Validate service settings" {
+        BeforeAll {            
+            $tI=1
+        }        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate properties of ssh-agent service" {            
+            $sshdSvc = Get-service ssh-agent
+            if($windowsInBox) {
+                $sshdSvc.StartType | Should Be ([System.ServiceProcess.ServiceStartMode]::Disabled)
+            }
+            else {
+                $sshdSvc.StartType | Should Be ([System.ServiceProcess.ServiceStartMode]::Manual)
+            }
+            $sshdSvc.ServiceType | Should Be ([System.ServiceProcess.ServiceType]::Win32OwnProcess)
+            $sshdSvc.ServiceName | Should Be "ssh-agent"
+            $sshdSvc.DisplayName | Should BeLike "OpenSSH*"
+            $sshdSvc.Name | Should Be "ssh-agent"
+            ($sshdSvc.DependentServices).Count | Should Be 0
+            ($sshdSvc.ServicesDependedOn).Count | Should Be 0
+            ($sshdSvc.RequiredServices).Count | Should Be 0
+        }
+
+        It "$tC.$tI - Validate properties of sshd service" {            
+            $sshdSvc = Get-service sshd
+            $sshdSvc.StartType | Should Be ([System.ServiceProcess.ServiceStartMode]::Manual)
+            $sshdSvc.ServiceType | Should Be ([System.ServiceProcess.ServiceType]::Win32OwnProcess)
+            $sshdSvc.ServiceName | Should Be "sshd"
+            $sshdSvc.DisplayName | Should BeLike "OpenSSH*"
+            $sshdSvc.Name | Should Be "sshd"
+            ($sshdSvc.DependentServices).Count | Should Be 0
+            ($sshdSvc.ServicesDependedOn).Count | Should Be 0
+            ($sshdSvc.RequiredServices).Count | Should Be 0
+        }
+        
+        It "$tC.$tI - Validate RequiredPrivileges of ssh-agent" {
+            $expected = @("SeAssignPrimaryTokenPrivilege", "SeTcbPrivilege", "SeBackupPrivilege", "SeRestorePrivilege", "SeImpersonatePrivilege")
+            $a = sc.exe qprivs ssh-agent 256
+            $p = @($a | % { if($_ -match "Se[\w]+Privilege" ) {$start = $_.IndexOf("Se");$_.Substring($start, $_.length-$start)}})
+            $expected | % {
+                $p -contains $_ | Should be $true
+            }
+
+            $p | % {
+                $expected -contains $_ | Should be $true
+            }
+        }
+
+        It "$tC.$tI - Validate RequiredPrivileges of sshd" {
+            $expected = @("SeAssignPrimaryTokenPrivilege", "SeTcbPrivilege", "SeBackupPrivilege", "SeRestorePrivilege", "SeImpersonatePrivilege")
+            $a = sc.exe qprivs sshd 256
+            $p = $a | % { if($_ -match "Se[\w]+Privilege" ) {$start = $_.IndexOf("Se");$_.Substring($start, $_.length-$start)}}
+            $expected | % {
+                $p -contains $_ | Should be $true
+            }
+
+            $p | % {
+                $expected -contains $_ | Should be $true
+            }
+        }
+
+        It "$tC.$tI - Validate security access to ssh-agent service" {            
+            $a = @(sc.exe sdshow ssh-agent)
+            $b = $a[-1] -split "[D|S]:"
+
+            $expected_dacl_aces = @("(A;;CCLCSWRPWPDTLOCRRC;;;SY)", "(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)", "(A;;CCLCSWLOCRRC;;;IU)", "(A;;CCLCSWLOCRRC;;;SU)", "(A;;RP;;;AU)")
+            $c = @($b | ? { -not [string]::IsNullOrWhiteSpace($_) })
+            $dacl = $c[0]
+            $dacl_aces = $dacl -split "(\([;|\w]+\))"
+            $actual_dacl_aces = $dacl_aces | ? { -not [string]::IsNullOrWhiteSpace($_) }
+
+            $expected_dacl_aces | % {
+                $actual_dacl_aces -contains $_ | Should be $true 
+            }
+            $actual_dacl_aces | % {
+                $expected_dacl_aces -contains $_ | Should be $true
+            }
+
+            <# ignore sacl for now
+            if($c.Count -gt 1) {                
+                $c[1] | Should Be "(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"            
+            }#>
+        }
+
+        It "$tC.$tI - Validate security access to sshd service" {            
+            $a = @(sc.exe sdshow sshd)
+            $b = $a[-1] -split "[D|S]:"
+
+            $expected_dacl_aces = @("(A;;CCLCSWRPWPDTLOCRRC;;;SY)", "(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)", "(A;;CCLCSWLOCRRC;;;IU)", "(A;;CCLCSWLOCRRC;;;SU)")
+            $c = @($b | ? { -not [string]::IsNullOrWhiteSpace($_) })
+            $dacl = $c[0]
+            $dacl_aces = $dacl -split "(\([;|\w]+\))"
+            $actual_dacl_aces = $dacl_aces | ? { -not [string]::IsNullOrWhiteSpace($_) }
+
+            $expected_dacl_aces | % {
+                $actual_dacl_aces -contains $_ | Should be $true
+            }
+            $actual_dacl_aces | % {
+                $expected_dacl_aces -contains $_ | Should be $true
+            }
+
+            <# ignore sacl for now
+            if($c.Count -gt 1) {                
+                $c[1] | Should Be "(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)"            
+            }#>
+        }
+    }
+
+    Context "$tC - Validate Firewall settings" {
+        BeforeAll {
+            $firwallRuleName = "OpenSSH-Server-In-TCP"
+            $tI=1
+        }
+        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate Firewall settings" -skip:(!$windowsInBox) {
+            $rule = Get-NetFirewallRule -Name $firwallRuleName            
+            $rule.Group | Should BeLike "OpenSSH*"
+            $rule.Description | Should BeLike "*OpenSSH*"
+            $rule.DisplayName | Should BeLike "OpenSSH*"
+            $rule.Enabled | Should Be $true
+            $rule.Profile.ToString() | Should Be 'Any'
+            $rule.Direction.ToString() | Should Be 'Inbound'
+            $rule.Action.ToString() | Should Be 'Allow'
+            $rule.StatusCode | Should Be 65536
+            $fwportFilter = $rule | Get-NetFirewallPortFilter
+            $fwportFilter.Protocol | Should Be 'TCP'
+            $fwportFilter.LocalPort | Should Be 22
+            $fwportFilter.RemotePort | Should Be 'Any'
+        }        
+    }
+}
diff --git a/regress/pesterTests/ShellHost.Tests.ps1 b/regress/pesterTests/ShellHost.Tests.ps1
new file mode 100644
index 000000000..8a68cacbc
--- /dev/null
+++ b/regress/pesterTests/ShellHost.Tests.ps1
@@ -0,0 +1,42 @@
+﻿$tC = 1
+$tI = 0
+$suite = "shellhost"
+
+Describe "E2E scenarios for ssh-shellhost" -Tags "CI" {
+    BeforeAll {
+    }
+
+    BeforeEach {
+    }        
+
+    AfterEach {$tI++;}
+
+    Context "$tC - shellhost commandline scenarios"  {
+        BeforeAll {$tI=1}
+        AfterAll{$tC++}
+
+        It "$tC.$tI - exit code tests" -skip:$skip {
+            foreach ($i in (0,1,4,5,44)) {
+                ssh-shellhost -c cmd /c exit $i
+                $LASTEXITCODE | Should Be $i
+            }
+        }
+
+        It "$tC.$tI - various quote tests" -skip:$skip {
+            $o = ssh-shellhost -c cmd /c echo hello
+            $o | Should Be "hello"
+            $o = ssh-shellhost -c "cmd /c echo hello"
+            $o | Should Be "hello"
+            $o = ssh-shellhost -c cmd /c echo "hello"
+            $o | Should Be "hello"
+            $o = ssh-shellhost -c "cmd /c echo `"hello`""
+            $o | Should Be "`\`"hello`\`""
+            $o = ssh-shellhost -c "cmd /c echo `"hello"
+            $o | Should Be "`\`"hello"
+            $o = ssh-shellhost -c "cmd" /c echo "hello"
+            $o | Should Be "hello"
+                
+        }
+
+    }        
+}
diff --git a/regress/pesterTests/Uninstall.Tests.ps1 b/regress/pesterTests/Uninstall.Tests.ps1
new file mode 100644
index 000000000..74268bd2d
--- /dev/null
+++ b/regress/pesterTests/Uninstall.Tests.ps1
@@ -0,0 +1,196 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+$suite = "Uninstall"
+$tC = 1
+$tI = 0
+Describe "Uninstall Tests" -Tags "Uninstall" {
+    BeforeAll {
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to set test environments."
+        }      
+        
+        $windowsInBox = $OpenSSHTestInfo["WindowsInBox"]
+        $binPath = $OpenSSHTestInfo["OpenSSHBinPath"]
+        $dataPath = Join-path $env:ProgramData ssh        
+
+        Stop-Service sshd -ErrorAction SilentlyContinue
+        Stop-Service ssh-agent -ErrorAction SilentlyContinue
+        if(Get-Service sshd -ErrorAction SilentlyContinue)
+        {        
+            if($windowsInBox) {
+                Remove-WindowsCapability -online -name OpenSSH.Server~~~~0.0.1.0
+            }
+            else {
+                & (Join-Path $binPath "uninstall-sshd.ps1")
+            }
+        }
+        if(Get-Service ssh-agent -ErrorAction SilentlyContinue)
+        {
+            if($windowsInBox) {
+                Remove-WindowsCapability -online -name OpenSSH.Client~~~~0.0.1.0
+            }
+            else
+            {
+                & (Join-Path $binPath "uninstall-sshd.ps1")
+            }
+        }
+        
+        
+        $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+        $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)        
+        $authenticatedUserSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::AuthenticatedUserSid)        
+
+        $RegReadKeyPerm = ([System.UInt32] [System.Security.AccessControl.RegistryRights]::ReadKey.value__)
+        $RegFullControlPerm = [System.UInt32] [System.Security.AccessControl.RegistryRights]::FullControl.value__        
+
+        #only validate owner and ACEs of the registry
+        function ValidateRegistryACL {
+            param([string]$RegPath, $Ownersid = $adminsSid, $IdAcls)
+            Test-Path -Path $RegPath | Should Be $true                      
+            $myACL = Get-ACL $RegPath
+            $OwnerSid = Get-UserSid -User $myACL.Owner
+            $OwnerSid.Equals($Ownersid) | Should Be $true
+            $myACL.Access | Should Not Be $null
+            $CAPABILITY_SID = "S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479-3232135806-4053264122-3456934681"            
+            $nonPropagate = $myACL.Access | ? {($_.PropagationFlags -eq ([System.Security.AccessControl.PropagationFlags]::None)) -and ($_.IdentityReference -ine $CAPABILITY_SID)}
+
+            foreach ($a in $nonPropagate) {
+                $findItem = $IdAcls | ? {
+                    ($a.IdentityReference -eq (Get-UserAccount -UserSid ($_.Identity))) -and `
+                    ($a.IsInherited -eq $_.IsInherited) -and `
+                    ($a.AccessControlType -eq ([System.Security.AccessControl.AccessControlType]::Allow)) -and  `
+                    ($a.PropagationFlags -eq ([System.Security.AccessControl.PropagationFlags]::None) -and  `
+                    (([System.Int32]$a.RegistryRights.value__) -eq ($_.RegistryRights))) 
+                }
+                $findItem | Should Not Be $null
+            }         
+        }    
+    }    
+
+    Context "$tC - Validate Openssh binary files" {
+        BeforeAll {
+            if(-not $Windowsbox)
+            {
+                $binaries =  $null                
+                return
+            }
+            $tI=1
+            $binaries =  @(
+                @{
+                    Name = 'sshd.exe'
+                },
+                @{
+                    Name = 'ssh.exe'
+                },
+                @{
+                    Name = 'ssh-agent.exe'
+                },
+                @{
+                    Name = 'ssh-add.exe'
+                },
+                @{
+                    Name = 'sftp.exe'
+                },
+                @{
+                    Name = 'sftp-server.exe'
+                },
+                @{
+                    Name = 'scp.exe'
+                },
+                @{
+                    Name = 'ssh-shellhost.exe'
+                },
+                @{
+                    Name = 'ssh-agent.exe'
+                },
+                @{
+                    Name = 'ssh-keyscan.exe'
+                }
+            )
+        }
+        AfterAll{$tC++}        
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate Openssh binary files--<Name> is removed" -TestCases:$binaries{
+            param([string]$Name, [boolean]$IsDirectory = $false)
+            if(-not [string]::IsNullOrWhiteSpace($Name)) {
+                (join-path $binPath $Name) | Should Not Exist
+            }
+        }        
+    } 
+    
+    Context "$tC - Validate Openssh registry entries" {
+        BeforeAll {
+            $tI=1
+            $servicePath = "HKLM:\SYSTEM\ControlSet001\Services"
+            $opensshRegPath = "HKLM:\SOFTWARE\OpenSSH"
+            
+            $opensshACLs = @(
+                @{
+                    Identity=$systemSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                },
+                @{
+                    Identity=$adminsSid
+                    IsInherited = $false
+                    RegistryRights = $RegFullControlPerm
+                    PropagationFlags = "None"
+                },                
+                @{
+                    Identity=$authenticatedUserSid
+                    IsInherited = $false
+                    RegistryRights = $RegReadKeyPerm
+                    PropagationFlags = "None"
+                }
+            )
+        }        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }               
+
+        It "$tC.$tI - Validate Registry key ssh-agent is removed" {
+            (Join-Path $servicePath "ssh-agent") | Should Not Exist
+        }
+
+        It "$tC.$tI - Validate Registry key sshd is removed" {
+            (Join-Path $servicePath "sshd") | Should Not Exist
+        }
+
+        It "$tC.$tI - Validate Registry openssh entry" {
+            ValidateRegistryACL -RegPath $opensshRegPath -IdAcls $opensshACLs
+        }       
+    }
+
+    Context "$tC - Validate service is removed" {
+        BeforeAll {            
+            $tI=1
+        }
+        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate ssh-agent is removed" {
+            Get-Service ssh-agent -ErrorAction SilentlyContinue | Should Be $null
+        }
+
+        It "$tC.$tI - Validate sshd is removed" {
+            Get-Service sshd -ErrorAction SilentlyContinue | Should Be $null
+        }
+    }
+
+    Context "$tC - Validate Firewall settings" {
+        BeforeAll {
+            $firwallRuleName = "OpenSSH-Server-In-TCP"
+            $tI=1
+        }
+        
+        AfterAll{$tC++}
+        AfterEach { $tI++ }
+
+        It "$tC.$tI - Validate Firewall settings" -skip:(!$windowsInBox) {
+            Get-NetFirewallRule -Name $firwallRuleName -ErrorAction SilentlyContinue | Should Be $null
+        }        
+    }    
+}
diff --git a/regress/pesterTests/Userkey_fileperm.Tests.ps1 b/regress/pesterTests/Userkey_fileperm.Tests.ps1
new file mode 100644
index 000000000..1b2379689
--- /dev/null
+++ b/regress/pesterTests/Userkey_fileperm.Tests.ps1
@@ -0,0 +1,138 @@
+﻿If ($PSVersiontable.PSVersion.Major -le 2) {$PSScriptRoot = Split-Path -Parent $MyInvocation.MyCommand.Path}
+Import-Module $PSScriptRoot\CommonUtils.psm1 -Force
+
+$tC = 1
+$tI = 0
+$suite = "userkey_fileperm"
+
+Describe "Tests for user Key file permission" -Tags "CI" {
+    BeforeAll {    
+        if($OpenSSHTestInfo -eq $null)
+        {
+            Throw "`$OpenSSHTestInfo is null. Please run Set-OpenSSHTestEnvironment to setup test environment."
+        }
+        $testDir = "$($OpenSSHTestInfo["TestDataPath"])\$suite"
+        if( -not (Test-path $testDir -PathType Container))
+        {
+            $null = New-Item $testDir -ItemType directory -Force -ErrorAction SilentlyContinue
+        }        
+
+        $logName = "log.txt"
+        $port = $OpenSSHTestInfo["Port"]
+        $ssouser = $OpenSSHTestInfo["SSOUser"]
+        $pubKeyUser = $OpenSSHTestInfo["PubKeyUser"]
+        $pubKeyUserProfile = $OpenSSHTestInfo["PubKeyUserProfile"]
+        $server = $OpenSSHTestInfo["Target"]
+        $userName = "$env:USERNAME@$env:USERDOMAIN"
+        $keypassphrase = "testpassword"
+        
+        $systemSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::LocalSystemSid)
+        $adminsSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::BuiltinAdministratorsSid)                        
+        $currentUserSid = Get-UserSID -User "$($env:USERDOMAIN)\$($env:USERNAME)"
+        $objUserSid = Get-UserSID -User $ssouser
+        $everyoneSid = Get-UserSID -WellKnownSidType ([System.Security.Principal.WellKnownSidType]::WorldSid)        
+        $pubKeyUserAccountSid = Get-UserSID -User $pubKeyUser        
+                
+        Add-PasswordSetting -Pass $keypassphrase
+    }
+
+    AfterAll {
+        Remove-PasswordSetting
+    }
+    BeforeEach {
+        $logPath = Join-Path $testDir "$tC.$tI.$logName"
+    }
+
+    AfterEach {$tI++;}    
+
+    Context "$tC-ssh with private key file" {
+        BeforeAll {            
+            $keyFileName = "sshtest_userPermTestkey_ed25519"
+            $keyFilePath = Join-Path $testDir $keyFileName
+            Remove-Item -path "$keyFilePath*" -Force -ErrorAction SilentlyContinue
+            if($OpenSSHTestInfo["NoLibreSSL"])
+            {
+                    ssh-keygen.exe -t ed25519 -f $keyFilePath -P $keypassphrase -Z aes128-ctr
+            }
+            else
+            {
+                ssh-keygen.exe -t ed25519 -f $keyFilePath -P $keypassphrase 
+            }
+
+            $pubKeyUserProfilePath = Join-Path $pubKeyUserProfile .ssh
+            if(-not (Test-Path $pubKeyUserProfilePath -PathType Container)) {
+                New-Item $pubKeyUserProfilePath -ItemType Directory -Force -ErrorAction Stop | Out-Null
+            }
+            
+            $testAuthorizedKeyPath = Join-Path $pubKeyUserProfilePath authorized_keys
+            Copy-Item "$keyFilePath.pub" $testAuthorizedKeyPath -Force -ErrorAction SilentlyContinue
+            Repair-AuthorizedKeyPermission -FilePath $testAuthorizedKeyPath -confirm:$false
+            $tI=1
+        }
+        AfterAll {
+            if(Test-Path $testAuthorizedKeyPath) {                
+                Remove-Item $testAuthorizedKeyPath -Force -ErrorAction SilentlyContinue
+            }
+            if(Test-Path $pubKeyUserProfilePath) {            
+                Remove-Item $pubKeyUserProfilePath -Recurse -Force -ErrorAction SilentlyContinue
+            }
+            $tC++
+        }        
+
+        It "$tC.$tI-ssh with private key file -- positive (Secured private key owned by current user)" {
+            Repair-FilePermission -FilePath $keyFilePath -Owners $currentUserSid -FullAccessNeeded $adminsSid,$systemSid,$currentUserSid -confirm:$false
+            
+            #Run
+            $o = ssh -p $port -i $keyFilePath $pubKeyUser@$server echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-ssh with private key file -- positive(Secured private key owned by Administrators group and current user has no explicit ACE)" {
+            #setup to have local admin group as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+            $o = ssh -p $port -i $keyFilePath $pubKeyUser@$server echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-ssh with private key file -- positive(Secured private key owned by Administrators group and current user has explicit ACE)" {
+            #setup to have local admin group as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $adminsSid -FullAccessNeeded $adminsSid,$systemSid -ReadAccessNeeded $currentUserSid -confirm:$false
+
+            #Run
+            $o = ssh -p $port -i $keyFilePath $pubKeyUser@$server echo 1234
+            $o | Should Be "1234"
+        }
+
+        It "$tC.$tI-ssh with private key file -- positive (Secured private key owned by local system)" {
+            #setup to have local system as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $systemSid -FullAccessNeeded $adminsSid,$systemSid -confirm:$false
+
+            #Run
+            $o = ssh -p $port -i $keyFilePath $pubKeyUser@$server echo 1234
+            $o | Should Be "1234"
+        }
+        
+        It "$tC.$tI-ssh with private key file -- negative(other account can access private key file)" {
+            #setup to have current user as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $currentUserSid -FullAccessNeeded $currentUser,$adminsSid,$systemSid -ReadAccessNeeded $objUserSid -confirm:$false
+
+            #Run
+            $o = ssh -p $port -i $keyFilePath -E $logPath $pubKeyUser@$server echo 1234
+            $LASTEXITCODE | Should Not Be 0
+
+            $logPath | Should Contain "UNPROTECTED PRIVATE KEY FILE!"
+        }
+
+        It "$tC.$tI-ssh with private key file -- negative(the private key has wrong owner)" {
+            #setup to have ssouser as owner and grant it full control
+            Repair-FilePermission -FilePath $keyFilePath -Owners $objUserSid -FullAccessNeeded $objUserSid,$adminsSid,$systemSid -ReadAccessNeeded $objUserSid -confirm:$false
+
+            $o = ssh -p $port -i $keyFilePath -E $logPath $pubKeyUser@$server echo 1234
+            $LASTEXITCODE | Should Not Be 0
+
+            $logPath | Should Contain "UNPROTECTED PRIVATE KEY FILE!"
+        }
+    }
+}
diff --git a/regress/pesterTests/data/SSHD_Config b/regress/pesterTests/data/SSHD_Config
new file mode 100644
index 000000000..101202fab
--- /dev/null
+++ b/regress/pesterTests/data/SSHD_Config
@@ -0,0 +1,129 @@
+#	$OpenBSD: sshd_config,v 1.84 2011/05/23 03:30:07 djm Exp $
+
+# This is the sshd server system-wide configuration file.  See
+# sshd_config(5) for more information.
+
+# This sshd was compiled with PATH=/usr/bin:/bin:/usr/sbin:/sbin
+
+# The strategy used for options in the default sshd_config shipped with
+# OpenSSH is to specify options with their default value where
+# possible, but leave them commented.  Uncommented options override the
+# default value.
+
+Port 47002
+#AddressFamily any
+#ListenAddress 0.0.0.0
+#ListenAddress ::
+
+# The default requires explicit activation of protocol 1
+#Protocol 2
+
+# HostKey for protocol version 1
+#HostKey /etc/ssh/ssh_host_key
+# HostKeys for protocol version 2
+HostKey ___TEST_SERVICE_CONFIG_DIR___\sshtest_hostkey_rsa
+HostKey ___TEST_SERVICE_CONFIG_DIR___\sshtest_hostkey_dsa
+HostKey ___TEST_SERVICE_CONFIG_DIR___\sshtest_hostkey_ecdsa
+HostKey ___TEST_SERVICE_CONFIG_DIR___\sshtest_hostkey_ed25519
+
+# Lifetime and size of ephemeral version 1 server key
+#KeyRegenerationInterval 1h
+#ServerKeyBits 1024
+
+# Logging
+# obsoletes QuietMode and FascistLogging
+#SyslogFacility AUTH
+LogLevel DEBUG3
+
+# Authentication:
+
+#LoginGraceTime 2m
+#PermitRootLogin yes
+#StrictModes yes
+#MaxAuthTries 6
+#MaxSessions 10
+
+#RSAAuthentication yes
+#PubkeyAuthentication yes
+
+# The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2
+# but this is overridden so installations will only check .ssh/authorized_keys
+AuthorizedKeysFile	.ssh/authorized_keys
+
+# For this to work you will also need host keys in /etc/ssh/ssh_known_hosts
+#RhostsRSAAuthentication no
+# similar for protocol version 2
+#HostbasedAuthentication no
+# Change to yes if you don't trust ~/.ssh/known_hosts for
+# RhostsRSAAuthentication and HostbasedAuthentication
+#IgnoreUserKnownHosts no
+# Don't read the user's ~/.rhosts and ~/.shosts files
+#IgnoreRhosts yes
+
+# To disable tunneled clear text passwords, change to no here!
+#PasswordAuthentication yes
+#PermitEmptyPasswords no
+
+# Change to no to disable s/key passwords
+#ChallengeResponseAuthentication yes
+
+# Kerberos options
+#KerberosAuthentication no
+#KerberosOrLocalPasswd yes
+#KerberosTicketCleanup yes
+#KerberosGetAFSToken no
+
+# GSSAPI options
+#GSSAPIAuthentication no
+#GSSAPICleanupCredentials yes
+
+# Set this to 'yes' to enable PAM authentication, account processing, 
+# and session processing. If this is enabled, PAM authentication will 
+# be allowed through the ChallengeResponseAuthentication and
+# PasswordAuthentication.  Depending on your PAM configuration,
+# PAM authentication via ChallengeResponseAuthentication may bypass
+# the setting of "PermitRootLogin without-password".
+# If you just want the PAM account and session checks to run without
+# PAM authentication, then enable this but set PasswordAuthentication
+# and ChallengeResponseAuthentication to 'no'.
+#UsePAM no
+
+#AllowAgentForwarding yes
+#AllowTcpForwarding yes
+#GatewayPorts no
+#X11Forwarding no
+#X11DisplayOffset 10
+#X11UseLocalhost yes
+#PrintMotd yes
+#PrintLastLog yes
+#TCPKeepAlive yes
+#UseLogin no
+#UsePrivilegeSeparation yes
+#PermitUserEnvironment no
+#Compression delayed
+#ClientAliveInterval 0
+#ClientAliveCountMax 3
+#UseDNS yes
+#PidFile /var/run/sshd.pid
+#MaxStartups 10
+#PermitTunnel no
+#ChrootDirectory none
+
+# no default banner path
+#Banner none
+
+# override default of no subsystems
+Subsystem	sftp	sftp-server.exe -l DEBUG3
+
+# Example of overriding settings on a per-user basis
+#Match User anoncvs
+#	X11Forwarding no
+#	AllowTcpForwarding no
+#	ForceCommand cvs server
+PubkeyAcceptedKeyTypes ssh-ed25519*
+
+#DenyUsers denyuser1 deny*2 denyuse?3, 
+#AllowUsers allowuser1 allowu*r2 allow?se?3 allowuser4 localuser1 localu*r2 loc?lu?er3 localadmin
+#DenyGroups denygroup1 denygr*p2 deny?rou?3
+#AllowGroups allowgroup1 allowg*2 allowg?ou?3 Adm*
+TrustedUserCAKeys ___TEST_SERVICE_CONFIG_DIR___\sshtest_ca_userkeys.pub
diff --git a/regress/pesterTests/data/known_hosts b/regress/pesterTests/data/known_hosts
new file mode 100644
index 000000000..f8b759a69
--- /dev/null
+++ b/regress/pesterTests/data/known_hosts
@@ -0,0 +1,10 @@
+
+###OpenSSHE2ETests
+[localhost]:47002 ssh-dss AAAAB3NzaC1kc3MAAACBAIyVGPwSzaCedtroufmFrwXGVPzYUMHPePvlduORG2+1VmLkP2Yw+U6MHRnaDyDriCulhnmwIueGxhH+t0HKbGK0j7XpGnwgmFOBIg5gJwQTDJ+gX+qC2ju55WB0Gkkwl+xktnAFSqmj8ttSzUBhh1ksh5A6oW+NKjwEVH8tQExFAAAAFQC0YldxCDQbTuDO04EVgA0OMpDIvwAAAIBXWRzpoyQWNoB18DGbY9zupGhfwuKGmnlj2mY0aYxY3qu1+9ciQOBrwYJlf4dEJbirwp2XmKzHZ6LFrkLQptVcD1wDkG/a/wMRvh+tbxlq45S3Eh0oNj1cobhUlFm9m5PM2HW1LccbOAEBUG/L4Vcj1Ag4n639H0fwDRL+rwOpjgAAAIBh/fSBidBGsQITgg45wwDszk7AAhngNm+jbiea8dbgYP6wpT6dJdg3pYwKT0V/PdXTSDi16kkoMkbUsMZyxyFJf/TtmCtBnon55yL9+H5dtcOBF8BXR7KzQX1E1n0eIL9jZ0Q4BspkB4LKQXhxRnrNJlv/oopxXua/GCMW17xxuA== sshtest_hostkey_dsa
+[localhost]:47002 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHF2eWwgnaUSLNNN0ilxiT916uMa6lusMB31AxfkDGArh4xCWL0e3F/gRifRephM0cD2dSh8Ji6VnjkhvZptjEw= sshtest_hostkey_ecdsa
+[localhost]:47002 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMtJMxwn+iJU0X4+EC7PSj/cfcMbdP6ahhodtXx+6RHv sshtest_hostkey_ed25519
+[localhost]:47002 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDU+NcQ5NuRutQJoZVjDmP/vE6IYZOaE59FTUjaoZkuPl4prdOPgqAnCwSy9XtnfzPm/oe62SyYIHgj8wRzhqjMU8g8aGqfv9ryF+hpNXZrFYXIdkdxnubzfb4e70RRRoTH8P5vuY8sAn0FIRlV/3EDkSKBFy2W3InMTO6l8gbkzzkgbn1GLvH06QJVdb2PcHksSn7dJBVHWASYi3TJWWu4muI+ZNfothujxAHqjKTJuJ9apDZIc0tnkPmlifRmolSUS4OAH2KWZ+5Gwaj7gsB8bk4QuA+QCT60OCcuzCcy4FBuXvvXkM9MBe/P2KZjVLAn86SriRtoE4RI+9R9S7DV sshtest_hostkey_rsa
+[localhost]:47003 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMtJMxwn+iJU0X4+EC7PSj/cfcMbdP6ahhodtXx+6RHv sshtest_hostkey_ed25519
+[localhost]:47004 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMtJMxwn+iJU0X4+EC7PSj/cfcMbdP6ahhodtXx+6RHv sshtest_hostkey_ed25519
+###OpenSSHE2ETests
+
diff --git a/regress/pesterTests/data/ssh_config b/regress/pesterTests/data/ssh_config
new file mode 100644
index 000000000..c95dcbfb8
--- /dev/null
+++ b/regress/pesterTests/data/ssh_config
@@ -0,0 +1,9 @@
+﻿
+###OpenSSHE2ETests
+Host test_target
+    HostName localhost
+    Port 47002
+    User sshtest_ssouser
+###OpenSSHE2ETests
+
+
diff --git a/regress/pesterTests/data/sshtest_ca_userkeys b/regress/pesterTests/data/sshtest_ca_userkeys
new file mode 100644
index 000000000..7c602426e
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_ca_userkeys
@@ -0,0 +1,7 @@
+-----BEGIN OPENSSH PRIVATE KEY-----
+b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
+QyNTUxOQAAACCbSeGZ+6Me6gaSAwK41/QILL6KnNUlem4XUu/Xm7RqYQAAAKCOV5jPjleY
+zwAAAAtzc2gtZWQyNTUxOQAAACCbSeGZ+6Me6gaSAwK41/QILL6KnNUlem4XUu/Xm7RqYQ
+AAAEBPPuXnlqwvhMYZNKaoMQS0GmtlJwFcctT3aZg1Ib4JaJtJ4Zn7ox7qBpIDArjX9Ags
+voqc1SV6bhdS79ebtGphAAAAG21hbm9qYW1wQHJlZG1vbmRAbWFub2otZGV2MwEC
+-----END OPENSSH PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_ca_userkeys.pub b/regress/pesterTests/data/sshtest_ca_userkeys.pub
new file mode 100644
index 000000000..0fccad783
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_ca_userkeys.pub
@@ -0,0 +1 @@
+ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJtJ4Zn7ox7qBpIDArjX9Agsvoqc1SV6bhdS79ebtGph sshtest_ca_userkeys
diff --git a/regress/pesterTests/data/sshtest_hostkey_dsa b/regress/pesterTests/data/sshtest_hostkey_dsa
new file mode 100644
index 000000000..ec1ff7306
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_dsa
@@ -0,0 +1,12 @@
+-----BEGIN DSA PRIVATE KEY-----
+MIIBuwIBAAKBgQCMlRj8Es2gnnba6Ln5ha8FxlT82FDBz3j75XbjkRtvtVZi5D9m
+MPlOjB0Z2g8g64grpYZ5sCLnhsYR/rdBymxitI+16Rp8IJhTgSIOYCcEEwyfoF/q
+gto7ueVgdBpJMJfsZLZwBUqpo/LbUs1AYYdZLIeQOqFvjSo8BFR/LUBMRQIVALRi
+V3EINBtO4M7TgRWADQ4ykMi/AoGAV1kc6aMkFjaAdfAxm2Pc7qRoX8Lihpp5Y9pm
+NGmMWN6rtfvXIkDga8GCZX+HRCW4q8Kdl5isx2eixa5C0KbVXA9cA5Bv2v8DEb4f
+rW8ZauOUtxIdKDY9XKG4VJRZvZuTzNh1tS3HGzgBAVBvy+FXI9QIOJ+t/R9H8A0S
+/q8DqY4CgYBh/fSBidBGsQITgg45wwDszk7AAhngNm+jbiea8dbgYP6wpT6dJdg3
+pYwKT0V/PdXTSDi16kkoMkbUsMZyxyFJf/TtmCtBnon55yL9+H5dtcOBF8BXR7Kz
+QX1E1n0eIL9jZ0Q4BspkB4LKQXhxRnrNJlv/oopxXua/GCMW17xxuAIVAIy08ce7
+877PESiaI4iDWj36uuWV
+-----END DSA PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_hostkey_dsa.pub b/regress/pesterTests/data/sshtest_hostkey_dsa.pub
new file mode 100644
index 000000000..ce5b1a33e
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_dsa.pub
@@ -0,0 +1 @@
+ssh-dss AAAAB3NzaC1kc3MAAACBAIyVGPwSzaCedtroufmFrwXGVPzYUMHPePvlduORG2+1VmLkP2Yw+U6MHRnaDyDriCulhnmwIueGxhH+t0HKbGK0j7XpGnwgmFOBIg5gJwQTDJ+gX+qC2ju55WB0Gkkwl+xktnAFSqmj8ttSzUBhh1ksh5A6oW+NKjwEVH8tQExFAAAAFQC0YldxCDQbTuDO04EVgA0OMpDIvwAAAIBXWRzpoyQWNoB18DGbY9zupGhfwuKGmnlj2mY0aYxY3qu1+9ciQOBrwYJlf4dEJbirwp2XmKzHZ6LFrkLQptVcD1wDkG/a/wMRvh+tbxlq45S3Eh0oNj1cobhUlFm9m5PM2HW1LccbOAEBUG/L4Vcj1Ag4n639H0fwDRL+rwOpjgAAAIBh/fSBidBGsQITgg45wwDszk7AAhngNm+jbiea8dbgYP6wpT6dJdg3pYwKT0V/PdXTSDi16kkoMkbUsMZyxyFJf/TtmCtBnon55yL9+H5dtcOBF8BXR7KzQX1E1n0eIL9jZ0Q4BspkB4LKQXhxRnrNJlv/oopxXua/GCMW17xxuA== sshtest_hostkey_dsa
diff --git a/regress/pesterTests/data/sshtest_hostkey_ecdsa b/regress/pesterTests/data/sshtest_hostkey_ecdsa
new file mode 100644
index 000000000..04fa8fdb9
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_ecdsa
@@ -0,0 +1,5 @@
+-----BEGIN EC PRIVATE KEY-----
+MHcCAQEEICAT5BC1AJpeOsRQaettNtqw6rzKlHDgtGvqnYZuU8YOoAoGCCqGSM49
+AwEHoUQDQgAEcXZ5bCCdpRIs003SKXGJP3Xq4xrqW6wwHfUDF+QMYCuHjEJYvR7c
+X+BGJ9F6mEzRwPZ1KHwmLpWeOSG9mm2MTA==
+-----END EC PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_hostkey_ecdsa.pub b/regress/pesterTests/data/sshtest_hostkey_ecdsa.pub
new file mode 100644
index 000000000..f0fc02dfd
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_ecdsa.pub
@@ -0,0 +1 @@
+ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBHF2eWwgnaUSLNNN0ilxiT916uMa6lusMB31AxfkDGArh4xCWL0e3F/gRifRephM0cD2dSh8Ji6VnjkhvZptjEw= sshtest_hostkey_ecdsa
diff --git a/regress/pesterTests/data/sshtest_hostkey_ed25519 b/regress/pesterTests/data/sshtest_hostkey_ed25519
new file mode 100644
index 000000000..e3635f420
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_ed25519
@@ -0,0 +1,7 @@
+-----BEGIN OPENSSH PRIVATE KEY-----
+b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
+QyNTUxOQAAACDLSTMcJ/oiVNF+PhAuz0o/3H3DG3T+moYaHbV8fukR7wAAAKACW4cWAluH
+FgAAAAtzc2gtZWQyNTUxOQAAACDLSTMcJ/oiVNF+PhAuz0o/3H3DG3T+moYaHbV8fukR7w
+AAAEDIU6PKvxw+6hgpQmTOOFeUasWnsYU3gricJCNrEHu2FstJMxwn+iJU0X4+EC7PSj/c
+fcMbdP6ahhodtXx+6RHvAAAAF3NzaHRlc3RfaG9zdGtleV9lZDI1NTE5AQIDBAUG
+-----END OPENSSH PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_hostkey_ed25519.pub b/regress/pesterTests/data/sshtest_hostkey_ed25519.pub
new file mode 100644
index 000000000..6e7e56300
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_ed25519.pub
@@ -0,0 +1 @@
+ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMtJMxwn+iJU0X4+EC7PSj/cfcMbdP6ahhodtXx+6RHv sshtest_hostkey_ed25519
diff --git a/regress/pesterTests/data/sshtest_hostkey_rsa b/regress/pesterTests/data/sshtest_hostkey_rsa
new file mode 100644
index 000000000..cfb42de9a
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_rsa
@@ -0,0 +1,27 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIEogIBAAKCAQEA1PjXEOTbkbrUCaGVYw5j/7xOiGGTmhOfRU1I2qGZLj5eKa3T
+j4KgJwsEsvV7Z38z5v6HutksmCB4I/MEc4aozFPIPGhqn7/a8hfoaTV2axWFyHZH
+cZ7m832+Hu9EUUaEx/D+b7mPLAJ9BSEZVf9xA5EigRctltyJzEzupfIG5M85IG59
+Ri7x9OkCVXW9j3B5LEp+3SQVR1gEmIt0yVlruJriPmTX6LYbo8QB6oykybifWqQ2
+SHNLZ5D5pYn0ZqJUlEuDgB9ilmfuRsGo+4LAfG5OELgPkAk+tDgnLswnMuBQbl77
+15DPTAXvz9imY1SwJ/Okq4kbaBOESPvUfUuw1QIDAQABAoIBAGdEafRVJGqbbulk
+om0vsyl0A5h5x/pz/Uy7VtI8fWxA7aPEF8uEiWelHhgwlC/xLBeb3/CoEcmKJPc5
+hTUHXJ4HGhbAgsMHYoD1OsqZE9yEySQUxju/0zjKBgA2AKhwSz4wCw/dqCCs7DYq
+gICEpiYWn+Z8eKyoL2ETBL0OiG01c4oZ8Qd1WrNPNAOA8uX2avCIawiGqfI5hRR2
+UIpmTNsh8SbA7hMqI47JlLvmfAdKOvug09f36Yhx63RuXWy0AHqz3HcTe4K4tzlP
+M+DnKDgHQkx8R5j/Q9Dv6ZlKn85FatIWftjd9e4Zsjx2lCKXBFIyn3EM1aiCaRAS
+iIFJh4ECgYEA6nBShG3z6bLbBNEWPq2xqmq6uJDD7dg6glK5alDDKwCmurfQYxyY
+HD/1YcIlf+kC4qUCrREgYlheH3xRbzT0yomtci015iC8R8ZZgGNqZO52HxhQVWdN
+i08vsJmUnrq0WFyXS0OysnPCEPLbHBoFVbJWEDTgKxLOwbYMEyp7IHECgYEA6I8Z
+tRE3AMbdYvN8+hjq5fcrsRZvkbddYa3DLYImii09s84p82MEskFd+dcTs6ViX2Qn
+wFgdASCi0FBblKca6ZxgwMHoEEiWgx6zndayeU2wDGWCbHlVXkpnCPb7O+YoMKhy
+XtDDfVZ0n0Cu+W6dlbVxWyP0uQ8RrE25Po/QSKUCgYAGCrkFsrO7jSF54U2ade2D
+P9bqFMkH4y+21hzzMXumKxEg9MXJGB6Pc9KGH3PJ9R5e6vPDtBJKlo5ub0zF+e5p
+Hd07eRDPin5vtxvtZCKE0WR37q97U/s6oOLQwVSENrmZIWHAzdDYKoWQ3EFrWvxS
+NhNjvYkdcxGjCmcLQ2gC8QKBgD4IFZpXmi1J3jmLqxVm2hk3Id9dlarvlyf72mjk
+I3WN9bxlTIlQKyuFBhUjSm0Luz6oj3XdyvbHBsa7+IGhRSt0+9XOoyDcy9DzuoNq
+hjaXA1N7LBvVDXFWNT+N6Zujm6rG86LY2pwvGHJ2JXYBDGWnfTILWDaYj2U/Yh8O
+60bFAoGAVnm3EVlak5mbDpSpyzqnglVKgZ+mz+4ODcF+qK4415QtAua8Je8Frcje
+3dYJtP5c5Xm+wE5Lmr+yZUAxup5oC5NAmtvLwK8DLPjfZIBtF7qBf08am8e8HnZw
+PzFks7iwv86eqgvTwBdE6QmaBzvEPLSmSI93uRz3q/S+16j50Pk=
+-----END RSA PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_hostkey_rsa.pub b/regress/pesterTests/data/sshtest_hostkey_rsa.pub
new file mode 100644
index 000000000..2c56f329b
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_hostkey_rsa.pub
@@ -0,0 +1 @@
+ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDU+NcQ5NuRutQJoZVjDmP/vE6IYZOaE59FTUjaoZkuPl4prdOPgqAnCwSy9XtnfzPm/oe62SyYIHgj8wRzhqjMU8g8aGqfv9ryF+hpNXZrFYXIdkdxnubzfb4e70RRRoTH8P5vuY8sAn0FIRlV/3EDkSKBFy2W3InMTO6l8gbkzzkgbn1GLvH06QJVdb2PcHksSn7dJBVHWASYi3TJWWu4muI+ZNfothujxAHqjKTJuJ9apDZIc0tnkPmlifRmolSUS4OAH2KWZ+5Gwaj7gsB8bk4QuA+QCT60OCcuzCcy4FBuXvvXkM9MBe/P2KZjVLAn86SriRtoE4RI+9R9S7DV sshtest_hostkey_rsa
diff --git a/regress/pesterTests/data/sshtest_userssokey_ed25519 b/regress/pesterTests/data/sshtest_userssokey_ed25519
new file mode 100644
index 000000000..086588e20
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_userssokey_ed25519
@@ -0,0 +1,7 @@
+-----BEGIN OPENSSH PRIVATE KEY-----
+b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
+QyNTUxOQAAACArxdmtP2DtTFvNp+4N4vlEP2tBmG7QtG4qfNUKlYmxRQAAAKAX+9lZF/vZ
+WQAAAAtzc2gtZWQyNTUxOQAAACArxdmtP2DtTFvNp+4N4vlEP2tBmG7QtG4qfNUKlYmxRQ
+AAAEBkZYPXRU9wu7OCcBia+eKvWOtDKpZRibjGQMTdBlCn5CvF2a0/YO1MW82n7g3i+UQ/
+a0GYbtC0bip81QqVibFFAAAAGnNzaHRlc3RfdXNlcnNzb2tleV9lZDI1NTE5AQID
+-----END OPENSSH PRIVATE KEY-----
diff --git a/regress/pesterTests/data/sshtest_userssokey_ed25519.pub b/regress/pesterTests/data/sshtest_userssokey_ed25519.pub
new file mode 100644
index 000000000..1456a8759
--- /dev/null
+++ b/regress/pesterTests/data/sshtest_userssokey_ed25519.pub
@@ -0,0 +1 @@
+ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICvF2a0/YO1MW82n7g3i+UQ/a0GYbtC0bip81QqVibFF sshtest_userssokey_ed25519
diff --git a/regress/pesterTests/utilities/askpass_util/README.txt b/regress/pesterTests/utilities/askpass_util/README.txt
new file mode 100644
index 000000000..cca267b46
--- /dev/null
+++ b/regress/pesterTests/utilities/askpass_util/README.txt
@@ -0,0 +1,3 @@
+askpass_util is a test utility to be used in conjunction with SSH_ASKPASS in ssh. 
+
+It simply spits out environment variable stored in ASKPASS_PASSWORD.
\ No newline at end of file
diff --git a/regress/pesterTests/utilities/askpass_util/askpass_util.cpp b/regress/pesterTests/utilities/askpass_util/askpass_util.cpp
new file mode 100644
index 000000000..b9b5b7b2c
--- /dev/null
+++ b/regress/pesterTests/utilities/askpass_util/askpass_util.cpp
@@ -0,0 +1,13 @@
+// askpass_util.cpp : Defines the entry point for the console application.
+//
+
+#include <Windows.h>
+#include <stdio.h>
+
+int main()
+{
+	//read from environment variable, spit it out on stdout
+	printf("%s", getenv("ASKPASS_PASSWORD"));
+	return 0;
+}
+
diff --git a/regress/pesterTests/utilities/askpass_util/askpass_util.exe b/regress/pesterTests/utilities/askpass_util/askpass_util.exe
new file mode 100644
index 0000000000000000000000000000000000000000..a7376719f63a64b6aef348c91ef87dfaddbfb2c8
GIT binary patch
literal 9728
zcmeHNe{@vUoxhXJga8Q%NFXT6giad#k&xsiAz>1n2qTFS8AwQo0>hBJWM-I|WM|%k
z;KDiJkS)_^DtoG}>roFB?b@m<wzwOW>fmHa@I<AnOQYm;W7q1l$@ZkkO6mq?Ki~Ui
z(g{?1_MHB)+x2q3-|xMj@Av-t-tWEd&JA_<9%jjmF+C_6WvmyHl7;g>!E}txS@Oyp
zc4FpRIla1dZ{;*NT>)dKzoXsn@EThjK3|7q+#wqMvd`%98P}|@H+nl-#e($oS*BRi
zzxKSe=4kr)g>iaDu37jz%8%85u;2$=4lOvs<u4cfl*@lx@Eqjc3z-X#K^{&2VBtfM
zW%d8U?Sy*MLb5Nbf1j5(x>}sn_Lt4XW@T)hE`>FH^w(SCHX|%aH(NIclLN9qLm!(5
znF%sd*`no>7)zldQe3i56v&xK$;@(q8&W;0%;l6Ikm++7J3$#6V<YhAHEBCzYk(Vb
z7;pL-eGE7Zy(Lj;WUMc-d{w?c61yZ|i_*YoTr}6%xRK+@$k_G*f2%`sF!tmuKmZuo
zlP?mI1zi_tX6z6JQy~bxVK;#il7+EwL3^94HSh;Fayw&!5wfte6!-)F7Ua24;2UnY
z6fz-MxSi<ffFb#aZ3j`m@!&$1l7+E5c;;(%jR$(W1PhA{PNhxCSfe7Rx^>a4UZaHt
z`}93^X&c<E(Wd@9iqxr(7Dls9a8>rUtr2Hxj)g_DEC6iI#mK9#z$)06CWIsAbbX<P
zU67M5L@s=4PhzamtyAaDW=!3L?P60aDccUFjH_?WV9c!xrKlezGxVCa?O<5)od1<t
zo649odlB087+{^vE546lY;Nuj%Xg`B0jOKSy2H|JXLB|TUm~rVO9~^gFQ}py?c3Df
za@9@f63rXb@1v;JLxaJ(XQ&0R9#lVrIm+q-z|}Hd?PpXi;-2puFj<(o2t&d|k}%Nb
zgJF3FYF<R0;`4{Lei9TXnfg;q^^kS=XbD^^oT)aSl7=zX+E6+H&JnoE`5u^h3pI;r
zNOSwGlULxjUL3&e)5~Davt%_uR##?{Rlk8MCqXr8`1bqgDJl=E@6!;}o#<Q{7orub
zr0W}1vo<U#qsg7rq?9Rdt6MOK=sEQ+ZU&?48r20cqts}b`X05fo&;AW)E7vMs|O)$
z(G}1x#<;K?z{oq8Zc3xt1?|D}vO(=Z#!bHPQhUv@StzGRtCYGiMW?Wkb!3B0&4yWX
zb3_qU^-~N2jig595p@ON{rf&)Xy`6v<F&0L>Sc5lQ4gchPrrr!5tDAj7=t&WsG4;f
z`DUh`g`-(|WNp!`REVt+*c})%p_Y50T7nkgS%W*N`K_CeWfxgkD1AQhtW4rJrV%eq
zC0?ZmZ+kGSkc)H^7dJ9443mi9wg+=3xX8Z<@%TfAWzZ>Bc5E@1`eR1O9&75c+o;?<
zJQ<Dl8=NrJ;onhG9y6iTZ^#CxarYY*b1f!qSQg8<^_zEwS^xgqP)@=!Yh{IRq0l<R
z1j?sIn3B$*r?QjfAUHmRdz4@EsVmmhMx~}Qc_8DTs^|A?$WA_sOv=vjWyu%J=cGkS
zU7Go>H2*B+j@0Bk(#!+?wBQ@d%;)6a2w`kv<&DwbtD6xh2-M`_aHREUHpbBSS~-GF
zvFS(k=Ce|!5LVtC&v<bTY{rYj+akwx+sNm^eW^^IaoW%TTb;TGE3BSGOIT)oad>M)
zeL*YCax?WQWSd7nJ+9*;4vwYKS=0TwWC&i-$$QmbVBN83w{(9lf74ls=G6660T5am
zZF1HSR0-(PQ1kWSE8)>KN9ly=kuNp{N0z)!HQdJLTL*#z(RT*~1L;E6iy`Yo$U6D-
z(@(!n^)&!hfF0KXwQnN_x((`bxP8!_>QqhWr3BwX+RVLm_cGR2fk|1Iy!B`$!~xuq
z5Or3@<aIC4#&@T!;!rlJS78ZWCf%*4Y#US;mWJ={ykM7!?ahhB_i^3m62&^E;AA*Z
zj%LFd51&#_(dLL56o=Kzh+*=qdKw0pea3!r@k}B7GOfqAH1F-NB8M|6W&gf3CeOpp
zP_6JE$tuX^=9rhcixjwn+!Oq82@KvH2u?)h8R}&;KRR3U^eFPp@aqlXOJ~1fP2~$j
zZP9VA!9z8%Rhu6aFTyz!j5pob^!hy?TV8z)T}RFRQhN7kY38M~$0$xm+j^`Qu|2bm
zv|lC!T8qhO)?yTkC}Y$zJ=QT8naHSayvI5z)Qt&slfr=c9eKvf>(TaTX7}52nsO?A
z?pnr9jbzRq2=RS!>E|K7AG9SD!j?!cgG(aL&6sL5Yd%_xIO!e+ro&04&ch^enjwI7
zbl_JZ#s?$4+hHA1FHB%7)#!t%`cREt{RGqIr6iOhLb$?^h6!an9FFuJB=g?=#HUW2
z`bL~NVZ;obIZ9pXTQ>`z_wbXzIhcfvWDAu#Q9;#FSoNiax*xn8jfQ#-5r5<$@hA2Z
ze`zoApLKz^J^08|T=YE3#S;=2-JM)K?cw5iC&c3qbw3WFSoNXqhmq-_%n@Yz`3UF~
zQY@2hTd4am*FJ-fc^5(q6)={5>oZvh+J5VEbcG68Peija;kd@0&CyHed#ul3`)D({
z{ybLiN<=$|d#n>!GdhXk%=C<Zj9ePJA)I5NNp8E3HWYnQu?A_dPzJis@KYtWnRN1J
zN_A!OsRQMF6MY=pL^av+`CykcXV<?5dsPgDWjqp&IG@8OUF(v(jUA@21LZ9N?}(fm
z?8;1*mnfF`RYt>i7fCl%<&c<PwUk796|?-EPD&BNTi?(#^(M@Bu)guNli1v^5;K1m
z$Zk?rbw{O{$~$T~x{LlIcv^4%%>Ntvw)-M5?ITlS(@oQ_HjU=?VUn>Ml=E5KRa&E^
zG=61`DKq3TW%ht>9jR|@;`;@WFZ{DDB&tz)La|Q9c0GC7I^KGW>RpInAG9L0k(%uo
z4g9&`0!=?E&yUKPQ8^7e)43%RpFuj~)EBXG!M<#5d**tu1}r$XtX??3dghIpFmTUO
zO-U4+83(;&DvslZ6HF&nl5nQ6DRd*%>Df0_pYa3bv-?6bLc8^$^{JtzG{rik)P01(
z9r&HgC)O&~ky4)|dS(wO)?v4<bgk%<XAf+4v*v4R%BxW~cl`EfMpZaP$E0smZBI#J
z(&DO45?NKYlw>B&0SGYzU^0{EDpj2rNAMk8h-XGqV!*zM8HyF7P|-hPFk~IuTkM{(
zSvaHh+Ou^ilpG4^LwBc!>M`WuA2G}}WF3clrJ2EZlC<XR+kQkpbtJDgbA7*oW(`XQ
zoTW;eNMuU)2xl^MXX!Js3F~uFshbFnqzGq%6DhKQI9`5~+!h>2)v6<`*yq-9<1s>|
zdBFjrhU1`N923H^?NDKu4-<;%Xl@AtCYoE$`F75`IN!|q5zZgy{87#y=KL_{4|0Bp
z^OKxE#rZ+b_jA6Nb0_CE&TBY7&iON(w{q^`ypwZ@^JU=2brFpJ>-3lJfx|a5_79*p
zKznat%n8~EDhDkErGYL$cMc?hDDC|wV}App^vjrBwoEI}i^*AeT3Lm@71&28?}z*j
z=t<BQz&`+X7W4+_NznH|hd_Hl_kzknH-S!oYEXw#Ib<K|{si<x;FOXUTDV*^SCdrm
zW?I<XgfchyBaE)(bXBjezuQ(_UvDSYw0`3nGR+NW72<D0Nhsb4x|jpHZn}=1MdpJl
zmx3sR6t71Ixf7Lb(Aloi(X&fp+LBoKALi*>FrGs{JK!UuWqNG_k)B<I^{ro1-);K+
z+TR`6RQ=jL7Zw+PSNC6}UcGXQBzilyI08F69f5#dmRz1K8%2-k2#C|bg3i_*yfwy*
zkVKT0fYz>VSV!+k^sdC;m`q+DR~ohVr~(%~6q)$<u@4yTL#&{%u%)e?v4MDb^~MI%
z=GE0uvB9e_0?$sza6xD6y=ho2uRC-VM&R&O*lJ)S(=p!ON7FDHZ%>_$al5f;SOd2k
z2S!h71$-V2+>YfiHcnXVJ#8FiK6hR=1-fGIXB1m~h!xGwbpQSLx9)&zSg$E=FSVFz
zt9d^sr(yT<e!_`ZgJ#z^4b$uffK}3Xc*mwLWcgd<5yG@JDkkiyTrI9+m_S%Bus+Bb
zRzet^2}|`;SQ%mT4oE*E<8Oo6D0kw6S+FCZ?JSEHJKCF|X%AJQchKz+{Qb{VSVYiv
zVEc7b7#|nmi3vZp=<$RN#w3-S=2_TI5T&?&C_yi0S=b@a80HgCM=*~PBlas~JpCAF
z&T(K933hJ+vjEFZup0-q9av@pHV<d!W?-oaSTQggFqVKd0ILB;zKy5DID45fUYaid
z63*=!<`umGQDUr=*~P9Fu~V`;9llnN=r6Iiba=fTKGwK;<EDEWYU`{;C4~j89uIlJ
zZg;f!CA+I*hrLbqwcz)i-5!uyT^+GX_FZkAewR;b!!B$WCDFHw9)Rru(P?jUc_h(~
z&P29`5XtW7?6gaJIz?7Mt%#Bw5dB_<<P`mWoMH@3`r2IWvR}0O9DaYtZo9+Zj`lEO
zm(L}+93I#GQ!4c2@^|>Wq7QSrh1t=0+$vr>(WG2!0|WB1ia+G-BHPTwE*IL!CBGok
zppCVS{(8cg0VD0S!wdfQ7W&J>R0-o+h!Jab7a*tAzMa|qV!JCqGnbrx(a~zho4Lb7
zZm>J>hX9vkN71vx(Xtbf8lSUf$}L6w8H9VwC+@cMLFlwz`6|(v%BK0F!^azy96LPF
ztxD)WrlEC{Tv*>F=nZSBje_0C`<DD2p0-Xq&ImUn=eT@OGe@T@-y6u^?egWLMm}Hg
zd{0q+QN9)!SLqWR{S{XD%ar8uieF(tv5=^~dK{X6zRJQWIy$H6A24k4X>s0a<xvku
z+{ptI-(W+%D1E7VX3|<wS}ptih%lSKqea9)>M%6KeH4e7H@P+tD|Gnp6de-c*X9=k
z6qxz?4YKIpV-x*t9f)*ai@3T2UJ(6k*0rtIwz4@1XakQPfb1Nh^?MLg-Uc|ZI)Dj?
zlw)@%*G_GW`gMr98U!3`$B5R5JLL9u(H|d4JGD{Q(JFhy8ouqD7`xlL@gD0sp*X(R
zr=NOXm;T%ycyZC|Yv}n7pT#IXu`Eu1?tZ>*?|-KUW?@+L`y>-&1<}QfE_C#JhIC)2
z|4$y!@%uXN?E9zBnx2sPb^aP0f6ihx(9s=z9~oVhDsS)ddW^e7e*ho3s=T6t!aSqs
zYw2ip`P!@UHZ|OtU!G?SNI3o-9^4J8^7e><yxUi$&#J^PP|>@?v&V=Ae1WPw+3#B!
zXmN^OM<CzpYVmgjI@+XsTtHSj0^WjMMR`Vi%v^0^Kx$0v4NV!1m6Bf$NVUGUj#z6;
z|3quTQeF==17eHpcS(C<Wgvd>uVnNhw%YuzUHIy?i-9R+qT1Sps&vU&C+-qGMi23-
zJV&6`x2t2P=+86CuId*0gjeOYIXnR|&$xW5oyz53-b>~3X=AEfJ~cU1uUsDY8wyvg
z#UCwV;~TMVy22X@%L=Ot*A~_lZYzAc@a@8aqAf+<B7f2DqDPCKDEe{Hv&AQhUoSpg
z{BiME@rB}v;w!~^VYV<&SR@#QJfT1+6{-ZQP$x7CJA`(@E9@2y2!AUa6<!ox5tfwP
zUGiAT^CjVu!II&U|0ubxbXn>0($dnkr5j3LC_P#F@1>)q`m$AJ&1GVlRJO0|+hs48
zohmz5He9A(amxx}Ma2sDimdXI@>S*Q%eR*wE&u!S@$&yHzoEidVXfFu;j4JHB3$uq
z#fKG>6*E>owDQrFM^=8a^7ECKR|@7zbFI0-yw&V6?=tT-KVUv&{*L)!^JC^C<{z4$
zGylZgYktk#XMWRs)_l%9Z2py5HUHLp(foy(Ri;#?RnDtqM(w|o^c4;k4iyd;vLb!a
WVA0v4p`ziEk&?+0{1Es*o&Fo=2!O``

literal 0
HcmV?d00001

diff --git a/regress/unittests/win32compat/dir_tests.c b/regress/unittests/win32compat/dir_tests.c
new file mode 100644
index 000000000..94fbed5e5
--- /dev/null
+++ b/regress/unittests/win32compat/dir_tests.c
@@ -0,0 +1,172 @@
+#include "includes.h"
+#include <sys/stat.h>
+#include <unistd.h>
+#include <inc/dirent.h>
+#include <sys/statvfs.h>
+#include <sys/time.h>
+
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+int retValue;
+
+void
+dir_tests_1()
+{
+	TEST_START("directory testcases");
+
+	char *test_dirname_1 = "test_dir_1";
+	char *tes_dirname_2 = "test_dir_2";
+	char cwd[PATH_MAX];
+	char *p_ret;
+	struct stat st;
+	char *tmpfile = "tmp.txt";
+	char mode[12];
+	struct timeval tv[2];
+	DIR *dirp = NULL;
+	struct dirent *dp = NULL;
+	char dir_fullpath[PATH_MAX];
+	int f = -1;
+
+	p_ret = getcwd(NULL, PATH_MAX);
+	ASSERT_PTR_EQ(p_ret, NULL);
+
+	p_ret = getcwd(cwd, PATH_MAX);
+	ASSERT_PTR_NE(p_ret, NULL);
+
+	// delete test_dirname_1, if exits.	
+	strcpy(dir_fullpath, cwd);
+	strcat(dir_fullpath, "\\");
+	strcat(dir_fullpath, test_dirname_1);
+	delete_dir_recursive(dir_fullpath);
+
+	// delete test_dirname_2, if exists
+	strcpy(dir_fullpath, cwd);
+	strcat(dir_fullpath, "\\");
+	strcat(dir_fullpath, tes_dirname_2);
+	delete_dir_recursive(dir_fullpath);
+
+	retValue = mkdir(NULL, 0);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = mkdir(test_dirname_1, S_IRUSR | S_IWUSR | S_IXUSR);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = stat(NULL, &st);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = stat(test_dirname_1, &st);
+	ASSERT_INT_EQ(retValue, 0);
+	ASSERT_INT_EQ(st.st_size, 0);
+	strmode(st.st_mode, mode);
+	ASSERT_CHAR_EQ(mode[0], 'd');
+
+	retValue = chdir(NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = chdir(test_dirname_1);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	p_ret = getcwd(cwd, PATH_MAX);
+	ASSERT_PTR_NE(p_ret, NULL);
+	p_ret = NULL;
+	p_ret = strstr(cwd, test_dirname_1);
+	ASSERT_PTR_NE(p_ret, NULL);
+
+	retValue = chdir("..");
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = rename(NULL, tes_dirname_2);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = rename(test_dirname_1, NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = rename(NULL, NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = rename(test_dirname_1, tes_dirname_2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = stat(tes_dirname_2, &st);
+	ASSERT_INT_EQ(retValue, 0);
+
+	dirp = opendir(NULL);
+	ASSERT_PTR_EQ(dirp, NULL);
+
+	dirp = opendir(tes_dirname_2);
+	ASSERT_PTR_NE(dirp, NULL);
+
+	dp = readdir(NULL);
+	ASSERT_PTR_EQ(dp, NULL);
+
+	dp = readdir(dirp);
+	ASSERT_PTR_EQ(dp, NULL);
+	
+	tv[0].tv_sec = st.st_atime + 1000;
+	tv[1].tv_sec = st.st_mtime + 1000;
+	tv[0].tv_usec = tv[1].tv_usec = 0;
+	retValue = utimes(tes_dirname_2, tv);
+	ASSERT_INT_EQ(retValue, -1);
+	ASSERT_INT_EQ(errno, ERROR_SHARING_VIOLATION);
+
+	retValue = closedir(NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = closedir(dirp);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = utimes(tes_dirname_2, tv);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = chdir(tes_dirname_2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	f = open(tmpfile, O_RDWR | O_CREAT | O_TRUNC, 0600);
+	ASSERT_INT_NE(f, -1);
+	close(f);
+
+	retValue = chdir("..");
+	ASSERT_INT_EQ(retValue, 0);
+
+	dirp = opendir(tes_dirname_2);
+	ASSERT_PTR_NE(dirp, NULL);
+
+	dp = readdir(dirp);
+	ASSERT_PTR_NE(dp, NULL);
+	
+	retValue = closedir(dirp);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = rmdir(NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = rmdir(tes_dirname_2);
+	ASSERT_INT_NE(retValue, 0);
+	
+	retValue = chdir(tes_dirname_2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = unlink(NULL);
+	ASSERT_INT_EQ(retValue, -1);
+
+	retValue = unlink(tmpfile);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = chdir("..");
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = rmdir(tes_dirname_2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	dirp = opendir(tes_dirname_2);
+	ASSERT_PTR_EQ(dirp, NULL);
+
+	TEST_DONE();
+}
+
+void
+dir_tests()
+{
+	dir_tests_1();
+}
diff --git a/regress/unittests/win32compat/file_tests.c b/regress/unittests/win32compat/file_tests.c
new file mode 100644
index 000000000..c2f2894ec
--- /dev/null
+++ b/regress/unittests/win32compat/file_tests.c
@@ -0,0 +1,702 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*
+* Author: Bryan Berns <berns@uwalumni.com>
+*   Added tests for symlink(), readlink(), lstat()
+*/
+
+#include "includes.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/select.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/time.h>
+
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+#define SMALL_RECV_BUF_SIZE 128
+
+#pragma warning(disable:4267)
+
+fd_set read_set, write_set, except_set;
+struct timeval time_val;
+char *send_buf, *recv_buf;
+int retValue, r_pipe, w_pipe;
+char *tmp_filename = "tmp.txt";
+
+int unset_nonblock(int fd);
+int set_nonblock(int fd);
+void prep_input_buffer(char* buf, int size, int seed);
+
+void 
+file_blocking_io_tests()
+{
+	char* small_send_buf = "sample payload";
+	char small_recv_buf[SMALL_RECV_BUF_SIZE];
+	int pipeio[2];
+
+	{
+		TEST_START("Basic pipe()");		
+		
+		retValue = pipe(pipeio);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("pipe read and write");
+		
+		r_pipe = pipeio[0];
+		w_pipe = pipeio[1];
+		retValue = write(r_pipe, small_send_buf, strlen(small_send_buf));
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EACCES);
+		retValue = read(w_pipe, small_recv_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EACCES);
+		retValue = write(w_pipe, small_send_buf, strlen(small_send_buf));
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		retValue = read(r_pipe, small_recv_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		small_recv_buf[retValue] = '\0';
+		ASSERT_STRING_EQ(small_send_buf, small_recv_buf);
+		memset(small_recv_buf, 0, sizeof(small_recv_buf));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("close pipe fds");
+		
+		retValue = close(w_pipe);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = read(r_pipe, small_recv_buf, SMALL_RECV_BUF_SIZE); /* send on other side is closed*/
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = close(r_pipe);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+}
+
+void file_simple_fileio()
+{
+	TEST_START("file io and fstat");
+
+	char* small_write_buf = "sample payload";
+	char small_read_buf[SMALL_RECV_BUF_SIZE];
+	int f;
+	struct stat st;
+	{
+		//f = open(tmp_filename, O_WRONLY | O_CREAT | O_TRUNC);
+		//ASSERT_INT_EQ(f, -1);
+	}
+	{
+		f = open(tmp_filename, O_WRONLY | O_CREAT | O_TRUNC, 0600);
+		ASSERT_INT_NE(f, -1);
+		close(f);
+	}
+
+	{
+		f = open(tmp_filename, O_RDONLY);
+		ASSERT_INT_NE(f, -1);		
+		retValue = fstat(f, &st);
+		ASSERT_INT_EQ(retValue, 0);
+		ASSERT_INT_EQ(st.st_size, 0);
+		ASSERT_INT_EQ(st.st_mode & 0777, 0666);
+		retValue = read(f, small_read_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, 0);		
+		close(f);
+	}
+	
+	{
+		f = open(tmp_filename, O_WRONLY | O_TRUNC);
+		ASSERT_INT_NE(f, -1);
+		retValue = write(f, small_write_buf, strlen(small_write_buf));
+		ASSERT_INT_EQ(retValue, strlen(small_write_buf));		
+		close(f);
+	}
+	
+	{
+		f = open(tmp_filename, O_RDONLY);
+		ASSERT_INT_NE(f, -1);		
+		retValue = stat(tmp_filename, &st);
+		ASSERT_INT_EQ(retValue, 0);
+		ASSERT_INT_EQ(st.st_size, strlen(small_write_buf));
+		ASSERT_INT_EQ(st.st_mode & 0777, 0600);
+		char mode[12];
+		strmode(st.st_mode, mode);
+		ASSERT_CHAR_EQ(mode[0], '-');
+		
+		struct timeval tv[2];
+		tv[0].tv_sec = st.st_atime + 1000;
+		tv[1].tv_sec = st.st_mtime + 1000;
+		tv[0].tv_usec = tv[1].tv_usec = 0;
+		retValue = utimes(tmp_filename, tv);
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, ERROR_SHARING_VIOLATION);
+
+		retValue = read(f, small_read_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, strlen(small_write_buf));
+		small_read_buf[retValue] = '\0';
+		ASSERT_STRING_EQ(small_write_buf, small_read_buf);
+		
+		retValue = read(f, small_read_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, 0);
+
+		close(f);
+		
+		retValue = utimes(tmp_filename, tv);
+		ASSERT_INT_EQ(retValue, 0);
+	}
+
+	{
+		/* test fopen, fgets, fclose*/
+		FILE *fp = fopen(tmp_filename, "r");
+		ASSERT_PTR_NE(fp, NULL);
+
+		char line[1024];
+		char *retp = fgets(line, sizeof(line), fp);
+		ASSERT_PTR_NE(retp, NULL);
+
+		retValue = strncmp(line, small_read_buf, strlen(line));
+		ASSERT_INT_EQ(retValue, 0);
+		fclose(fp);
+	}
+
+	{
+		/* test writev, ftruncate, isatty, lseek, fdopen */
+		f = open(tmp_filename, O_RDWR | O_TRUNC);
+		ASSERT_INT_NE(f, -1);
+		struct iovec iov;
+		iov.iov_base = small_write_buf;
+		iov.iov_len = strlen(small_write_buf);
+		retValue = writev(f, &iov, 1);
+		ASSERT_INT_EQ(retValue, strlen(small_write_buf));
+
+		int truncate_len = 10;
+		int ret1 = ftruncate(f, truncate_len);
+		ASSERT_INT_EQ(ret1, 0);
+
+		explicit_bzero(small_read_buf, SMALL_RECV_BUF_SIZE);
+		retValue = read(f, small_read_buf, SMALL_RECV_BUF_SIZE);
+		ASSERT_INT_EQ(retValue, truncate_len);
+
+		retValue = isatty(f);
+		ASSERT_INT_EQ(retValue, 0);
+		ASSERT_INT_EQ(errno, EINVAL);
+
+		int offset = 3;
+		retValue = lseek(f, offset, SEEK_SET);
+		ASSERT_INT_EQ(retValue, 0);
+		char *tmp = dup_str(small_read_buf);
+		ASSERT_PTR_NE(tmp, NULL); // CodeQL [SM02311] false positive: ASSERT_PTR_NE is checking if tmp is NULL.
+
+		retValue = read(f, small_read_buf, SMALL_RECV_BUF_SIZE);
+		small_read_buf[retValue] = '\0';
+		retValue = strcmp(tmp+offset, small_read_buf);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		FILE *f2 = fdopen(f, "r");
+		ASSERT_PTR_NE(f2, NULL);
+		fclose(f2);		
+
+		retValue = unlink(tmp_filename);
+		ASSERT_INT_EQ(retValue, 0);
+	}
+	
+	{
+		// test null device 
+		FILE *fp = fopen("/dev/null", "r");
+		ASSERT_PTR_NE(fp, NULL);
+
+		f = open("/dev/null", O_RDONLY);
+		ASSERT_INT_NE(f, -1);
+	}
+
+	TEST_DONE();
+}
+
+void file_simple_fileio_mode()
+{
+	TEST_START("file io and mode");
+
+	char * small_write_buf = "sample payload", *c, small_read_buf[SMALL_RECV_BUF_SIZE];
+	int ret;
+	FILE* f;
+	struct stat st;
+
+	f = fopen(NULL, "w");
+	ASSERT_PTR_EQ(f, NULL);
+
+	c = fgets(NULL, 0, f);
+	ASSERT_PTR_EQ(c, NULL);
+
+	f = fopen("tmp.txt", "w");
+	ASSERT_PTR_NE(f, NULL);
+	fclose(f);
+	f = fopen("tmp.txt", "r");
+	ASSERT_PTR_NE(f, NULL);
+	c = fgets(small_read_buf, sizeof(small_read_buf), f);
+	ASSERT_PTR_EQ(c, NULL);
+	fclose(f);
+
+	ret = stat("tmp.txt", &st);
+	ASSERT_INT_EQ(ret, 0);
+	ASSERT_INT_EQ(st.st_size, 0);
+
+	f = fopen("tmp.txt", "w");
+	ASSERT_PTR_NE(f, NULL);
+	ret = fputs(small_write_buf, f);
+	ASSERT_INT_EQ(ret, 0);
+	fclose(f);
+
+	ret = stat("tmp.txt", &st);
+	ASSERT_INT_EQ(ret, 0);
+	ASSERT_INT_EQ(st.st_size, strlen(small_write_buf));
+
+	f = fopen("tmp.txt", "r");
+	ASSERT_PTR_NE(f, NULL);
+	c = fgets(small_read_buf, sizeof(small_read_buf), f);
+	ASSERT_PTR_NE(c, NULL);
+	ASSERT_STRING_EQ(small_write_buf, small_read_buf);
+
+	c = fgets(small_read_buf, sizeof(small_read_buf), f);
+	ASSERT_PTR_EQ(c, NULL);
+	fclose(f);
+	TEST_DONE();
+}
+
+void 
+file_nonblocking_io_tests()
+{
+	TEST_START("non blocking file io");
+
+	char* small_send_buf = "sample payload";
+	char small_recv_buf[SMALL_RECV_BUF_SIZE];	
+	int pipeio[2];
+
+	retValue = pipe(pipeio);
+	ASSERT_INT_EQ(retValue, 0);
+
+	r_pipe = pipeio[0];
+	w_pipe = pipeio[1];
+	retValue = set_nonblock(r_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = read(r_pipe, small_recv_buf, SMALL_RECV_BUF_SIZE);
+	ASSERT_INT_EQ(retValue, -1);
+	ASSERT_INT_EQ(errno, EAGAIN);
+	
+	retValue = unset_nonblock(w_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	retValue = write(w_pipe, small_send_buf, strlen(small_send_buf));
+	ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+	
+	retValue = unset_nonblock(r_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	retValue = read(r_pipe, small_recv_buf, SMALL_RECV_BUF_SIZE);
+	ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+	small_recv_buf[retValue] = '\0';
+	ASSERT_STRING_EQ(small_send_buf, small_recv_buf);
+
+	memset(small_recv_buf, 0, sizeof(small_recv_buf));
+	send_buf = malloc(10 * 1024);
+	ASSERT_PTR_NE(send_buf, NULL);
+	
+	retValue = set_nonblock(w_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	retValue = 1;
+	while (retValue > 0) {
+		retValue = write(w_pipe, send_buf, 10 * 1024);
+	}
+	ASSERT_INT_EQ(retValue, -1);
+	ASSERT_INT_EQ(errno, EAGAIN);
+	
+	retValue = close(r_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	retValue = close(w_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	free(send_buf);
+
+	TEST_DONE();
+}
+
+void
+file_select_tests() {
+	TEST_START("select on file fds");
+
+	int num_bytes = 1024 * 700; //700KB
+	int bytes_sent = 0;
+	int bytes_received = 0;
+	int seed = 326;
+	int eagain_results = 0;
+	
+	int pipeio[2];
+	retValue = pipe(pipeio);
+	ASSERT_INT_EQ(retValue, 0);
+
+	r_pipe = pipeio[0];
+	w_pipe = pipeio[1];
+	retValue = set_nonblock(w_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = set_nonblock(r_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+	
+	send_buf = malloc(num_bytes);
+	recv_buf = malloc(num_bytes + 1);
+	ASSERT_PTR_NE(send_buf, NULL);
+	ASSERT_PTR_NE(recv_buf, NULL);
+	
+	prep_input_buffer(send_buf, num_bytes, 17);
+	FD_ZERO(&read_set);
+	FD_ZERO(&write_set);
+	FD_SET(w_pipe, &write_set);
+	FD_SET(r_pipe, &read_set);
+	while (-1 != select(max(r_pipe, w_pipe) + 1, &read_set, &write_set, NULL, &time_val)) {
+		if (FD_ISSET(w_pipe, &write_set)) {
+			while ((bytes_sent < num_bytes) && ((retValue = write(w_pipe, send_buf + bytes_sent, num_bytes - bytes_sent)) > 0))
+				bytes_sent += retValue;
+			if (bytes_sent < num_bytes) {
+				ASSERT_INT_EQ(retValue, -1);
+				ASSERT_INT_EQ(errno, EAGAIN);
+				eagain_results++;
+			}
+		}
+
+		if (FD_ISSET(r_pipe, &read_set)) {
+			while ((retValue = read(r_pipe, recv_buf + bytes_received, num_bytes - bytes_received + 1)) > 0)
+				bytes_received += retValue;
+			if (retValue == 0)
+				break;
+			ASSERT_INT_EQ(retValue, -1);
+			ASSERT_INT_EQ(errno, EAGAIN);
+			eagain_results++;
+		}
+
+		if (bytes_sent < num_bytes)
+			FD_SET(w_pipe, &write_set);
+		else {
+			FD_CLR(w_pipe, &write_set);
+			retValue = close(w_pipe);
+			ASSERT_INT_EQ(retValue, 0);
+		}
+		FD_SET(r_pipe, &read_set);
+	}
+
+	/*ensure that we hit send and recv paths that returned EAGAIN. Else it would not have touched the async paths*/
+	/*if this assert is being hit, then num_bytes is too small. up it*/
+	ASSERT_INT_GT(eagain_results, 0);
+	ASSERT_INT_EQ(bytes_sent, bytes_received);
+	ASSERT_INT_EQ(memcmp(send_buf, recv_buf, num_bytes), 0);
+	retValue = close(r_pipe);
+	ASSERT_INT_EQ(retValue, 0);
+
+	free(send_buf);
+	free(recv_buf);
+
+	TEST_DONE();
+}
+
+void
+file_miscellaneous_tests()
+{
+	TEST_START("file miscellaneous");
+	
+	char cwd[PATH_MAX];
+	char *pcwd = getcwd(cwd, PATH_MAX);
+	ASSERT_PTR_NE(pcwd, NULL);
+
+	char thishost[NI_MAXHOST];	
+	retValue = gethostname(thishost, sizeof(thishost));
+	ASSERT_INT_NE(retValue, -1);
+
+	char *tmp = dup_str(thishost);
+	if (tmp == NULL)
+		goto out;
+	int len = strlen(tmp);
+
+	int f = dup(STDOUT_FILENO);
+	ASSERT_INT_NE(f, -1);
+	retValue = write(f, tmp, len);
+	ASSERT_INT_EQ(errno, 0);
+	ASSERT_INT_EQ(retValue, len);
+	close(f);
+
+	f = dup(STDIN_FILENO);
+	ASSERT_INT_NE(f, -1);
+	close(f);
+
+	f = dup(STDERR_FILENO);
+	ASSERT_INT_NE(f, -1);
+	close(f);
+
+	f = open(tmp_filename, O_RDWR | O_CREAT | O_TRUNC, 0600);
+	ASSERT_INT_NE(f, -1);
+	int f1 = dup(f);
+	ASSERT_INT_NE(f1, -1);
+	HANDLE h = w32_fd_to_handle(f);
+	ASSERT_HANDLE(h);
+	close(f);
+	close(f1);
+
+	char *tmp_filename_1 = "tmp_1.txt";
+	retValue = rename(tmp_filename, tmp_filename_1);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = unlink(tmp_filename_1);
+	ASSERT_INT_EQ(retValue, 0);
+
+	if(tmp)
+		free(tmp);
+
+	h = w32_fd_to_handle(STDIN_FILENO);
+	ASSERT_HANDLE(h);
+
+	h = w32_fd_to_handle(STDOUT_FILENO);
+	ASSERT_HANDLE(h);
+
+	h = w32_fd_to_handle(STDERR_FILENO);
+	ASSERT_HANDLE(h);
+
+	f = open(tmp_filename, O_RDWR | O_CREAT | O_TRUNC, 0666);
+	ASSERT_INT_NE(f, -1);
+	wchar_t *t = utf8_to_utf16(tmp_filename);
+	ASSERT_PTR_NE(t, NULL);
+	int perm = get_others_file_permissions(t, 0);
+	ASSERT_INT_EQ(perm, 7);
+	free(t);
+	close(f);
+	retValue = unlink(tmp_filename);
+	ASSERT_INT_EQ(retValue, 0);
+	
+
+	f = open(tmp_filename, O_RDWR | O_CREAT | O_TRUNC, 0666);
+	ASSERT_INT_NE(f, -1);
+	t = utf8_to_utf16(tmp_filename);
+	ASSERT_PTR_NE(t, NULL);
+	perm = get_others_file_permissions(t, 1);
+	ASSERT_INT_EQ(perm, 5);
+	free(t);
+	close(f);
+	retValue = unlink(tmp_filename);
+	ASSERT_INT_EQ(retValue, 0);	
+out:
+	TEST_DONE();
+}
+
+void
+file_symlink_tests()
+{
+	/* skip these unit tests if we cannot create symbolic links at all 
+	 * note: 0x2 = SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE
+	 */
+	DeleteFileW(L"admin_check");
+	if (CreateSymbolicLinkW(L"admin_check", L"admin_check", 0) == 0 &&
+		CreateSymbolicLinkW(L"admin_check", L"admin_check", 0x2 == 0)) {
+		return;
+	}
+	DeleteFileW(L"admin_check");
+
+	wchar_t curdir[PATH_MAX];
+	GetCurrentDirectoryW(PATH_MAX, curdir);
+
+	/* perform a variety of symlink tests using unicode, directory targets, 
+	 * file targets, absolute/relative links, absolute/relative targets 
+	 */
+	for (int do_unicode = 0; do_unicode <= 1; do_unicode++)
+	for (int do_dir = 0; do_dir <= 1; do_dir++)
+	for (int do_absolute_lnk = 0; do_absolute_lnk <= 1; do_absolute_lnk++)
+	for (int do_absolute_tgt = 0; do_absolute_tgt <= 1; do_absolute_tgt++)
+	{
+		char test_name[128];
+		sprintf(test_name, "Symlink: %s link, %s %s target, %s",
+			(do_absolute_lnk) ? "relative" : "absolute",
+			(do_absolute_tgt) ? "relative" : "absolute",
+			(do_dir) ? "directory" : "file",
+			(do_unicode) ? "unicode" : "ansi");
+		TEST_START(test_name);
+
+		/* cleanup / setup basic test structure */
+		_wsystem(L"RD /S /Q win32compat-tmp >NUL 2>&1");
+		_wsystem(L"MKDIR win32compat-tmp >NUL 2>&1");
+
+		wchar_t tgt_path[PATH_MAX] = L"";
+		wchar_t lnk_path[PATH_MAX] = L"";
+
+		/* prepend absolute path if doing absolute test */
+		if (do_absolute_tgt) {
+			wcscat(tgt_path, L"/");
+			wcscat(tgt_path, curdir);
+			wcscat(tgt_path, L"/");
+		}
+		if (do_absolute_lnk) {
+			wcscat(lnk_path, L"/");
+			wcscat(lnk_path, curdir);
+			wcscat(lnk_path, L"/");
+		}
+
+		/* append the test paths */
+		wcscat(tgt_path, L"win32compat-tmp/tgt");
+		wcscat(lnk_path, L"win32compat-tmp/lnk");
+
+		/* append unicode char if doing unicode test */
+		if (do_unicode) {
+			wcscat(tgt_path, L"Δ");
+			wcscat(lnk_path, L"Δ");
+		}
+
+		/* ensure target is in forward slash format since this is 
+		 * required for the readlink test output later *
+		 */
+		for (wchar_t * t = tgt_path; *t; t++) if (*t == '\\') *t = L'/';
+
+		/* create directory or file as target --- we have to offset
+		 * the first forward slash so the windows functions operate
+		 */
+		if (do_dir)
+			CreateDirectoryW(&tgt_path[do_absolute_tgt], NULL);
+		else
+			CloseHandle(CreateFileW(&tgt_path[do_absolute_tgt],
+				GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL));
+
+		/* convert to utf8 for test */
+		char * tgt_utf8 = utf16_to_utf8(tgt_path);
+		char * lnk_utf8 = utf16_to_utf8(lnk_path);
+
+		/* for relative link, the target is relative to the link */
+		char * tgt_name_utf8 = tgt_utf8;
+		if (!do_absolute_tgt) tgt_name_utf8 = strrchr(tgt_utf8, '/') + 1;
+
+		/* create symlink */
+		int symlink_ret = symlink(tgt_name_utf8, lnk_utf8);
+		ASSERT_INT_EQ(symlink_ret, 0);
+
+		/* verify readlink() output against symlink() input */
+		char readlink_buf[PATH_MAX] = "";
+		/* readlink returns the absolute path */
+		int readlink_ret = readlink(lnk_utf8, readlink_buf, PATH_MAX);
+		char tgt_name_uft8_realpath[PATH_MAX] = { 0 };
+		realpath(tgt_utf8, tgt_name_uft8_realpath);
+		ASSERT_INT_EQ(readlink_ret, strlen(tgt_name_uft8_realpath));
+		ASSERT_INT_EQ(0, memcmp(readlink_buf, tgt_name_uft8_realpath, readlink_ret));
+
+		/* verify lstat() gets the reference to the link */
+		struct w32_stat statbuf;
+		int lstat_ret = lstat(lnk_utf8, &statbuf);
+		ASSERT_INT_EQ(lstat_ret, 0);
+		ASSERT_INT_EQ(1, S_ISLNK(statbuf.st_mode));
+
+		/* verify stat() gets a reference to the dir or file */
+		int stat_ret = stat(lnk_utf8, &statbuf);
+		ASSERT_INT_EQ(stat_ret, 0);
+		ASSERT_INT_EQ(0, S_ISLNK(statbuf.st_mode));
+		ASSERT_INT_EQ(do_dir, S_ISDIR(statbuf.st_mode));
+
+		TEST_DONE();
+	}
+		
+	_wsystem(L"RD /S /Q win32compat-tmp >NUL 2>&1");
+}
+
+
+void
+file_link_tests()
+{
+	/* skip these unit tests if we cannot create hard links at all */
+	CloseHandle(CreateFileW(L"admin_check_tgt", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL));
+	int perm_test = CreateHardLinkW(L"admin_check", L"admin_check_tgt", 0);
+	DeleteFileW(L"admin_check");
+	DeleteFileW(L"admin_check_tgt");
+	if (perm_test == 0) return;
+
+	wchar_t curdir[PATH_MAX];
+	GetCurrentDirectoryW(PATH_MAX, curdir);
+
+	/* perform a variety of link tests using unicode, absolute/relative links,
+	 * absolute/relative targets
+	*/
+	for (int do_unicode = 0; do_unicode <= 1; do_unicode++)
+	for (int do_absolute_lnk = 0; do_absolute_lnk <= 1; do_absolute_lnk++)
+	for (int do_absolute_tgt = 0; do_absolute_tgt <= 1; do_absolute_tgt++)
+	{
+		char test_name[128];
+		sprintf(test_name, "link: %s link, %s file target, %s",
+			(do_absolute_lnk) ? "relative" : "absolute",
+			(do_absolute_tgt) ? "relative" : "absolute",
+			(do_unicode) ? "unicode" : "ansi");
+		TEST_START(test_name);
+
+		/* cleanup / setup basic test structure */
+		_wsystem(L"RD /S /Q win32compat-tmp >NUL 2>&1");
+		_wsystem(L"MKDIR win32compat-tmp >NUL 2>&1");
+
+		wchar_t tgt_path[PATH_MAX] = L"";
+		wchar_t lnk_path[PATH_MAX] = L"";
+
+		/* prepend absolute path if doing absolute test */
+		if (do_absolute_tgt) {
+			wcscat(tgt_path, L"/");
+			wcscat(tgt_path, curdir);
+			wcscat(tgt_path, L"/");
+		}
+		if (do_absolute_lnk) {
+			wcscat(lnk_path, L"/");
+			wcscat(lnk_path, curdir);
+			wcscat(lnk_path, L"/");
+		}
+
+		/* append the test paths */
+		wcscat(tgt_path, L"win32compat-tmp/tgt");
+		wcscat(lnk_path, L"win32compat-tmp/lnk");
+
+		/* append unicode char if doing unicode test */
+		if (do_unicode) {
+			wcscat(tgt_path, L"Δ");
+			wcscat(lnk_path, L"Δ");
+		}
+
+		/* create file as target */
+		CloseHandle(CreateFileW(&tgt_path[do_absolute_tgt],
+			GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL));
+
+		/* convert to utf8 for test */
+		char * tgt_utf8 = utf16_to_utf8(tgt_path);
+		char * lnk_utf8 = utf16_to_utf8(lnk_path);
+
+		/* create link */
+		int link_ret = link(tgt_utf8, lnk_utf8);
+		ASSERT_INT_EQ(link_ret, 0);
+
+		/* verify stat() gets a reference to the dir or file */
+		struct w32_stat statbuf;
+		int stat_ret = stat(lnk_utf8, &statbuf);
+		ASSERT_INT_EQ(stat_ret, 0);
+		ASSERT_INT_EQ(1, S_ISREG(statbuf.st_mode));
+
+		TEST_DONE();
+	}
+
+	_wsystem(L"RD /S /Q win32compat-tmp >NUL 2>&1");
+}
+
+void
+file_tests()
+{
+	file_simple_fileio();
+	file_simple_fileio_mode();
+	file_blocking_io_tests();
+	file_nonblocking_io_tests();
+	file_select_tests();
+	file_miscellaneous_tests();
+	file_symlink_tests();
+	file_link_tests();
+}
diff --git a/regress/unittests/win32compat/miscellaneous_tests.c b/regress/unittests/win32compat/miscellaneous_tests.c
new file mode 100644
index 000000000..536e2a75e
--- /dev/null
+++ b/regress/unittests/win32compat/miscellaneous_tests.c
@@ -0,0 +1,435 @@
+﻿#include "includes.h"
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <misc_internal.h>
+#include <sys/statvfs.h>
+#include <unistd.h>
+
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+int retValue;
+
+// The ioctl() testcase is failing when ran from Run-OpenSSHUnitTest.
+void 
+test_ioctl()
+{
+	if(!isatty(fileno(stdin))) return;
+
+	TEST_START("ioctl");
+
+	struct winsize ws;
+	memset(&ws, 0, sizeof(ws));
+	retValue = ioctl(fileno(stdin), TIOCGWINSZ, &ws);
+	ASSERT_INT_EQ(retValue, 0);
+	ASSERT_INT_NE(ws.ws_col, 0);
+	ASSERT_INT_NE(ws.ws_row, 0);
+	ASSERT_INT_NE(ws.ws_xpixel, 0);
+	ASSERT_INT_NE(ws.ws_ypixel, 0);	
+
+	TEST_DONE();
+}
+
+void
+test_path_conversion_utilities()
+{
+	TEST_START("path conversion utilities");
+
+	char *s = "c:\\testdir\\test";
+	char *windows_style_path = dup_str(s);
+	if (windows_style_path == NULL)
+		goto out;
+	int len = strlen(windows_style_path);
+	char *backup = malloc(len + 1);
+	if (backup == NULL)
+		goto out;
+	strncpy(backup, windows_style_path, len);
+	backup[len] = '\0';
+
+	convertToForwardslash(windows_style_path);
+
+	char *tmpStr = strstr(windows_style_path, "\\");
+	ASSERT_PTR_EQ(tmpStr, NULL);
+
+	convertToBackslash(windows_style_path);
+	tmpStr = strstr(windows_style_path, "/");
+	ASSERT_PTR_EQ(tmpStr, NULL);
+
+	retValue = strcmp(windows_style_path, backup);
+	ASSERT_INT_EQ(retValue, 0);
+out:
+	if (windows_style_path)
+		free(windows_style_path);
+
+	TEST_DONE();
+}
+
+void
+test_sanitizedpath()
+{
+	TEST_START("win32 program dir");
+	
+	char *win32prgdir_utf8 = __progdir;
+	ASSERT_PTR_NE(win32prgdir_utf8, NULL);
+
+	ASSERT_PTR_EQ(resolved_path_utf16(NULL), NULL);
+	ASSERT_INT_EQ(errno, EINVAL);
+
+	wchar_t *win32prgdir = utf8_to_utf16(win32prgdir_utf8);
+	wchar_t *ret = resolved_path_utf16(win32prgdir_utf8);
+	/* resolved path will return in unix file format ex - c:/test/1/ */
+	convertToBackslashW(ret);
+	retValue = wcscmp(win32prgdir, ret);
+	ASSERT_INT_EQ(retValue, 0);
+	free(ret);
+
+	size_t win32prgdir_len = strlen(win32prgdir_utf8);
+	char *tmp_path = malloc(win32prgdir_len + 2); /* 1-NULL and 1-adding "/" */
+	if (tmp_path == NULL)
+		goto out;
+	tmp_path[0] = '/';
+	strcpy(tmp_path+1, win32prgdir_utf8);
+	tmp_path[win32prgdir_len+1] = '\0';
+
+	ret = resolved_path_utf16(tmp_path);
+	/* resolved path will return in unix file format ex - c:/test/1/ */
+	convertToBackslashW(ret);
+	retValue = wcscmp(win32prgdir, ret);
+	ASSERT_INT_EQ(retValue, 0);
+	free(ret);
+
+	char s1[4];
+	wchar_t s2[4];
+	s1[0] = '/', s1[1] = win32prgdir[0],  s1[2] = ':', s1[3] = '\0';
+	s2[0] = win32prgdir[0], s2[1] = ':', s2[2] = '\\', s2[3] = '\0';	
+	ret = resolved_path_utf16(s1);
+	/* resolved path will return in unix file format ex - c:/test/1/ */
+	convertToBackslashW(ret);
+	retValue = wcscmp(ret, s2);
+	ASSERT_INT_EQ(retValue, 0);
+	free(ret);
+out:
+	free(win32prgdir);
+
+	TEST_DONE();
+}
+
+void
+test_pw()
+{
+	TEST_START("pw tests");
+
+	struct passwd *pw = NULL;
+	pw = getpwuid(0);
+	ASSERT_PTR_NE(pw, NULL);
+
+	struct passwd *pw1 = NULL;
+	char *user = dup_str(pw->pw_name);
+	if (user != NULL) {
+		pw1 = getpwnam(user);
+		ASSERT_PTR_NE(pw1, NULL);
+	}
+	TEST_DONE();
+}
+
+void
+test_statvfs()
+{
+	TEST_START("test statvfs");
+
+	struct statvfs st;
+	char cwd[PATH_MAX];
+
+	char *tmp = getcwd(cwd, PATH_MAX);
+	ASSERT_PTR_NE(tmp, NULL);
+
+	retValue = statvfs(NULL, &st);
+	ASSERT_INT_EQ(retValue, -1);
+
+	explicit_bzero(&st, sizeof(st));
+	retValue = statvfs(cwd, &st);
+	ASSERT_INT_EQ(retValue, 0);
+	ASSERT_INT_NE(st.f_bavail, 0);
+
+	TEST_DONE();
+}
+
+void test_realpath()
+{
+	TEST_START("test realpath");
+
+	char resolved_path[PATH_MAX];
+	char *ret = NULL;
+	char *expectedOutput1 = "/c:/windows/system32";
+	char *expectedOutput2 = "/c:/";
+
+	ret = realpath(NULL, NULL);
+	ASSERT_PTR_EQ(ret, NULL);
+
+	ret = realpath("c:\\windows\\system32", NULL);
+	ASSERT_PTR_EQ(ret, NULL);
+
+	ret = realpath(NULL, resolved_path);
+	ASSERT_PTR_EQ(ret, NULL);
+
+	ret = realpath("c:\\windows\\system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("/c:\\windows\\system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("/c:\\windows\\.\\system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("/c:\\windows\\.\\..\\windows\\system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("/c:\\windows/.\\..\\windows\\system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("c:/windows/system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("/c:/windows/system32", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput1);
+
+	ret = realpath("c:", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput2);
+
+	ret = realpath("c:\\", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput2);
+
+	ret = realpath("/c:", resolved_path);
+	ASSERT_STRING_EQ(ret, expectedOutput2);
+
+	ASSERT_PTR_NE(ret = realpath("/c:/..", resolved_path), NULL);
+	ASSERT_STRING_EQ(ret, "/");
+
+	ASSERT_PTR_NE(ret = realpath("/", resolved_path), NULL);
+	ASSERT_STRING_EQ(ret, "/");
+
+	ASSERT_PTR_NE(ret = realpath("\\", resolved_path), NULL);
+	ASSERT_STRING_EQ(ret, "/");
+
+
+	TEST_DONE();
+}
+
+void
+test_chroot()
+{
+	int fd;
+	FILE *f;
+	char path[PATH_MAX], test_root[PATH_MAX];
+
+	/* test directory setup */
+	_wsystem(L"RD /S /Q chroot-testdir >NUL 2>&1");
+	CreateDirectoryW(L"chroot-testdir", NULL);
+	CreateDirectoryW(L"chroot-testdir\\world", NULL);
+	_wsystem(L"echo in-world > chroot-testdir\\world\\w.Txt");
+	CreateDirectoryW(L"chroot-testdir\\jail", NULL);
+	CreateDirectoryW(L"chroot-testdir\\jail\\d1", NULL);
+	_wsystem(L"echo in-jail > chroot-testdir\\jail\\d1\\j.Txt");
+	/* create links to world within jail */
+	_wsystem(L"mklink /D chroot-testdir\\jail\\world-sl ..\\world");
+	_wsystem(L"mklink /J chroot-testdir\\jail\\world-jn chroot-testdir\\world");
+		
+	TEST_START("chroot on invalid path");
+	ASSERT_INT_EQ(chroot("blah"), -1);
+	ASSERT_INT_EQ(chroot("\\c:\\blah"), -1);
+	ASSERT_INT_EQ(chroot("/c:/blah"), -1);
+	TEST_DONE();
+
+	TEST_START("access world before chroot");
+	ASSERT_INT_NE(fd = open("chroot-testdir\\jail\\world-jn\\w.Txt", 0), -1);
+	close(fd);
+	ASSERT_PTR_NE(f = fopen("chroot-testdir\\jail\\world-jn\\w.Txt", "r"), NULL);
+	fclose(f);
+	TEST_DONE();
+
+	TEST_START("real chroot now");
+	getcwd(path, PATH_MAX);
+	getcwd(test_root, PATH_MAX);
+	strcat(path, "\\chroot-testdir\\jail");
+	ASSERT_INT_EQ(chdir(path), 0);
+	ASSERT_INT_EQ(chroot(path), 0);
+	TEST_DONE();
+
+	TEST_START("chdir; getcwd and realpath");
+	ASSERT_PTR_NE(getcwd(path, PATH_MAX), NULL);
+	ASSERT_STRING_EQ(path, "\\");
+	ASSERT_INT_NE(chdir(test_root), 0);
+	ASSERT_INT_EQ(chdir("d1"), 0);
+	ASSERT_PTR_NE(realpath("..", path), NULL);
+	ASSERT_STRING_EQ(path, "/");
+	ASSERT_PTR_NE(getcwd(path, PATH_MAX), NULL);
+	ASSERT_STRING_EQ(path, "\\d1");
+	ASSERT_PTR_NE(realpath(".", path), NULL);
+	ASSERT_STRING_EQ(path, "/d1");
+	ASSERT_PTR_EQ(realpath("..\\..\\", path), NULL);
+	ASSERT_INT_EQ(errno, EACCES);
+	TEST_DONE();
+
+	TEST_START("file io within jail");
+	ASSERT_INT_NE(fd = open("\\d1\\j.txt", 0), -1);
+	close(fd);
+	ASSERT_INT_NE(fd = open("\\d1/j.txt", 0), -1);
+	close(fd);
+	ASSERT_INT_NE(fd = open("/d1/j.txt", 0), -1);
+	close(fd);
+	ASSERT_INT_NE(fd = open("/dev/null", 0), -1);
+	close(fd);
+	ASSERT_PTR_NE(f = fopen("\\d1\\j.txt", "r"), NULL);
+	fclose(f);
+	ASSERT_PTR_NE(f = fopen("/dev/null", "w"), NULL);
+	fclose(f);
+	ASSERT_INT_EQ(chdir("/"), 0);
+	ASSERT_INT_NE(fd = open("d1/j.txt", 0), -1);
+	close(fd);
+	ASSERT_PTR_NE(f = fopen("d1\\j.txt", "r"), NULL);
+	fclose(f);
+	ASSERT_INT_EQ(chdir("\\d1"), 0);
+	ASSERT_INT_NE(fd = open("j.txt", 0), -1);
+	close(fd);
+	ASSERT_PTR_NE(f = fopen("j.txt", "r"), NULL);
+	fclose(f);
+	TEST_DONE();
+
+	TEST_START("access world after chroot");
+	ASSERT_INT_EQ(chdir("/"), 0);
+	ASSERT_INT_EQ(fd = open(test_root, 0), -1);
+	ASSERT_INT_EQ(errno, ENOENT);
+	ASSERT_INT_EQ(fd = open("..\\", 0), -1);
+	ASSERT_INT_EQ(errno, EACCES);
+	ASSERT_INT_EQ(fd = open("../", 0), -1);
+	ASSERT_INT_EQ(errno, EACCES);
+	ASSERT_INT_EQ(fd = open("../outofjail.txt", O_CREAT), -1);
+	ASSERT_INT_EQ(errno, EACCES);
+	/* ensure outofjail.txt is not created by the above call*/
+	path[0] = '\0';
+	strcat(path, test_root);
+	strcat(path, "\\chroot-testdir\\outofjail.txt");
+	ASSERT_INT_EQ(fd = _open(path, 0), -1);
+	ASSERT_INT_EQ(errno, ENOENT);
+	ASSERT_INT_EQ(fd = open("world-jn\\w.Txt", 0), -1);
+	ASSERT_INT_EQ(errno, EACCES);
+	ASSERT_PTR_EQ(f = fopen("world-jn\\w.Txt", "r"), NULL);
+	ASSERT_INT_EQ(errno, EACCES); 
+	ASSERT_INT_EQ(fd = open("world-sl\\w.Txt", 0), -1);
+	ASSERT_INT_EQ(errno, EACCES); 
+	ASSERT_PTR_EQ(f = fopen("world-sl\\w.Txt", "r"), NULL);
+	ASSERT_INT_EQ(errno, EACCES); 
+	TEST_DONE();
+
+
+	//_wsystem(L"RD /S /Q chroot-testdir >NUL 2>&1");
+}
+
+void
+test_build_exec_command()
+{
+	char *out;
+
+	TEST_START("arg is null");
+	out = build_exec_command(NULL);
+	ASSERT_PTR_EQ(out, NULL);
+	TEST_DONE();
+
+	TEST_START("scp tests");
+	out = build_exec_command("sCp -arg");	
+	ASSERT_STRING_EQ(out, "scp.exe -arg");
+	free(out);
+	out = build_exec_command("sCp.exe -arg1 -arg2");
+	ASSERT_STRING_EQ(out, "scp.exe -arg1 -arg2");
+	free(out);
+	TEST_DONE();
+
+	TEST_START("sftp tests");
+	out = build_exec_command("internal-sftp \"arg1 arg2\"");
+	ASSERT_STRING_EQ(out, "sftp-server.exe \"arg1 arg2\"");
+	free(out);
+	out = build_exec_command("SFTP-server.exe -arg");
+	ASSERT_STRING_EQ(out, "sftp-server.exe -arg");
+	free(out);
+	out = build_exec_command("sftp-SERVER -arg");	
+	ASSERT_STRING_EQ(out, "sftp-server.exe -arg");
+	free(out);
+	TEST_DONE();
+}
+
+void
+test_build_commandline_string()
+{
+	char *out, in[PATH_MAX], buf[PATH_MAX];
+
+	TEST_START("cmd is null");
+	out = build_commandline_string(NULL, NULL, TRUE);
+	ASSERT_PTR_EQ(out, NULL);
+	TEST_DONE();
+
+	TEST_START("arg is null");
+	out = build_commandline_string("\"c:\\windows\\system32\\cmd.exe\" /c arg", NULL, FALSE);
+	ASSERT_STRING_EQ(out, "\"c:\\windows\\system32\\cmd.exe\" /c arg");
+	free(out);
+	out = build_commandline_string("cmd.exe /c ping.exe", NULL, FALSE);
+	ASSERT_STRING_EQ(out, "\"cmd.exe\" /c ping.exe");
+	sprintf_s(in, PATH_MAX, "\"%s\\%s\"", __progdir, "ssh-shellhost.exe\" -c \"arg1 arg2\"");
+	out = build_commandline_string(in, NULL, TRUE);
+	ASSERT_STRING_EQ(out, in);
+	out = build_commandline_string("\"ssh-shellhost.exe\" -c \"arg1 arg2\"", NULL, TRUE);
+	sprintf_s(buf, PATH_MAX, "\"%s\\%s", __progdir, "ssh-shellhost.exe\" -c \"arg1 arg2\"");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	out = build_commandline_string("\"cmd.exe\" /c \"arg1 arg2\"", NULL, FALSE);
+	ASSERT_STRING_EQ(out, "\"cmd.exe\" /c \"arg1 arg2\"");
+	free(out);
+	TEST_DONE();
+
+	char *argv[4] = { NULL, };
+	argv[0] = "\"C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\"";
+	argv[1] = "-c";
+	argv[2] = "arg1 arg2";
+	TEST_START("arg is not null");
+	out = build_commandline_string(argv[0], argv + 1, TRUE);
+	sprintf_s(buf, PATH_MAX, "%s %s %s", argv[0], argv[1], "\"arg1 arg2\"");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	argv[0] = "C:\\my folder\\bash.exe";
+	argv[2] = "\"arg1\\arg2\"";
+	out = build_commandline_string(argv[0], argv + 1, TRUE);
+	sprintf_s(buf, PATH_MAX, "\"%s\" %s %s", argv[0], argv[1], "\\\"arg1\\arg2\\\"");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	argv[2] = "\"arg1 arg2\\\"";
+	out = build_commandline_string(argv[0], argv + 1, TRUE);
+	sprintf_s(buf, PATH_MAX, "\"%s\" %s %s", argv[0], argv[1], "\"\\\"arg1 arg2\\\\\\\"\"");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	argv[0] = "\"c:\\cygwin64\\bin\\ba.exe\"";
+	argv[2] = "arg1\\arg2";
+	out = build_commandline_string(argv[0], argv + 1, TRUE);
+	sprintf_s(buf, PATH_MAX, "%s %s %s", argv[0], argv[1], "arg1\\arg2");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	argv[0] = "\"c:\\cygwin64\\bin\\ba.exe\"";
+	argv[2] = "'arg1 \\arg2\\\"'";
+	out = build_commandline_string(argv[0], argv + 1, TRUE);
+	sprintf_s(buf, PATH_MAX, "%s %s %s", argv[0], argv[1], "'arg1 \\arg2\\\\\\\"'");
+	ASSERT_STRING_EQ(out, buf);
+	free(out);
+	TEST_DONE();
+}
+
+void
+miscellaneous_tests()
+{
+	//test_ioctl();
+	test_path_conversion_utilities();
+	test_sanitizedpath();
+	test_pw();
+	test_realpath();
+	test_statvfs();
+	test_chroot();
+	test_build_exec_command();
+	test_build_commandline_string();
+}
diff --git a/regress/unittests/win32compat/signal_tests.c b/regress/unittests/win32compat/signal_tests.c
new file mode 100644
index 000000000..d6fd492d2
--- /dev/null
+++ b/regress/unittests/win32compat/signal_tests.c
@@ -0,0 +1,175 @@
+/*
+* Author: Bryan Berns <berns@uwalumni.com>
+*/
+
+#include "includes.h"
+
+#include "signal_internal.h"
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+VOID CALLBACK
+signal_test_dummy_apc(_In_ ULONG_PTR dwParam)
+{
+	/* dummy */
+}
+
+DWORD WINAPI
+signal_test_send_apc(LPVOID lpParam)
+{
+	HANDLE thread = (HANDLE)lpParam;
+	Sleep(250);
+	QueueUserAPC(signal_test_dummy_apc, thread, (ULONG_PTR)NULL);
+	return TRUE;
+}
+
+unsigned __stdcall
+signal_test_set_event(LPVOID lpParam)
+{
+	HANDLE hevent = (HANDLE)lpParam;
+	Sleep(10);
+	SetEvent(hevent);
+	return TRUE;
+}
+
+unsigned __stdcall
+signal_create_abandoned_object(LPVOID lpParam)
+{
+	*((HANDLE *)lpParam) = CreateMutex(NULL, TRUE, 0);
+	return TRUE;
+}
+
+VOID TEST_RESOURCES(BOOL start)
+{
+	static DWORD initial_count = 0;
+	if (start) GetProcessHandleCount(GetCurrentProcess(), &initial_count);
+	else {
+		DWORD final_count = 0;
+		GetProcessHandleCount(GetCurrentProcess(), &final_count);
+		ASSERT_INT_EQ(initial_count, final_count);
+	}
+}
+
+void
+signal_test_wait_for_multiple_objects()
+{
+	/* shared test resources */
+	HANDLE current_thread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());
+	HANDLE current_process = GetCurrentProcess();
+
+	/* events for testing */
+	HANDLE hObjects[300];
+	const DWORD objects_size = ARRAYSIZE(hObjects);;
+	for (int i = 0; i < objects_size; i++)
+		hObjects[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
+
+	/* create abandoned mutex */
+	HANDLE abandoned_mutux = NULL;
+	HANDLE mutex_thread = (HANDLE) _beginthreadex(NULL, 0, signal_create_abandoned_object, &abandoned_mutux, 0, NULL);
+	WaitForSingleObject(mutex_thread, INFINITE);
+	CloseHandle(mutex_thread);
+
+	{
+		TEST_START("Signal: APC wakeup with select event counts (WAIT_IO_COMPLETION_ENHANCED)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) ResetEvent(hObjects[i]);
+		for (int i = 0; i < objects_size; i++) {
+			DWORD select = i % MAXIMUM_WAIT_OBJECTS;
+			if (select == 0 || select == 1 || select == MAXIMUM_WAIT_OBJECTS - 1 || select == MAXIMUM_WAIT_OBJECTS - 2) {
+				CloseHandle(CreateThread(NULL, 0, signal_test_send_apc, current_thread, 0, NULL));
+				DWORD ret = wait_for_multiple_objects_enhanced(i + 1, hObjects, 10000, TRUE);
+				ASSERT_INT_EQ(ret, WAIT_IO_COMPLETION_ENHANCED);
+			}
+		}
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("Signal: Wait-any with one invalid event in positions 1-300 (WAIT_FAILED_ENHANCED)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) ResetEvent(hObjects[i]);
+		for (int i = 0; i < objects_size; i++) {
+			HANDLE event = hObjects[i];
+			hObjects[i] = NULL;
+			DWORD ret = wait_for_multiple_objects_enhanced(objects_size, hObjects, 10000, FALSE);
+			ASSERT_INT_EQ(ret, WAIT_FAILED_ENHANCED);
+			hObjects[i] = event;
+		}
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("Signal: Wait-any with signaled event in positions 1-300 (WAIT_OBJECT_0_ENHANCED)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) {
+			SetEvent(hObjects[i]);
+			DWORD ret = wait_for_multiple_objects_enhanced(i + 1, hObjects, 10000, FALSE);
+			ASSERT_INT_EQ(ret, i + WAIT_OBJECT_0_ENHANCED);
+			ResetEvent(hObjects[i]);
+		}
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("Signal: Wait-any with latent events (WAIT_TIMEOUT_ENHANCED)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) ResetEvent(hObjects[i]);
+		DWORD ret = wait_for_multiple_objects_enhanced(objects_size, hObjects, 250, FALSE);
+		ASSERT_INT_EQ(ret, WAIT_TIMEOUT_ENHANCED);
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("Signal: Wait-any with async event in positions 1-300 (WAIT_OBJECT_0_ENHANCED offset)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) ResetEvent(hObjects[i]);
+		for (int i = 0; i < objects_size; i++) {
+			CloseHandle((HANDLE) _beginthreadex(NULL, 0, signal_test_set_event, hObjects[i], 0, NULL));
+			DWORD ret = wait_for_multiple_objects_enhanced(objects_size, hObjects, 10000, FALSE);
+			ASSERT_INT_EQ(ret, i + WAIT_OBJECT_0_ENHANCED);
+			ResetEvent(hObjects[i]);
+		}
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("Signal: Wait-any with abandoned mutex in positions 1-300 (WAIT_ABANDONED_0_ENHANCED offset)");
+		//TEST_RESOURCES(TRUE);
+
+		for (int i = 0; i < objects_size; i++) ResetEvent(hObjects[i]);
+		for (int i = 0; i < objects_size; i++) {
+			HANDLE original_event = hObjects[i];
+			hObjects[i] = abandoned_mutux;
+			DWORD ret = wait_for_multiple_objects_enhanced(objects_size, hObjects, 10000, FALSE);
+			ASSERT_INT_EQ(ret, i + WAIT_ABANDONED_0_ENHANCED);
+			hObjects[i] = original_event;
+		}
+
+		//TEST_RESOURCES(FALSE);
+		TEST_DONE();
+	}
+
+	for (int i = 0; i < objects_size; i++) CloseHandle(hObjects[i]);
+	CloseHandle(current_thread);
+}
+
+void
+signal_tests()
+{
+	signal_test_wait_for_multiple_objects();
+}
diff --git a/regress/unittests/win32compat/socket_tests.c b/regress/unittests/win32compat/socket_tests.c
new file mode 100644
index 000000000..8169cf4b0
--- /dev/null
+++ b/regress/unittests/win32compat/socket_tests.c
@@ -0,0 +1,711 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*/
+
+#include "includes.h"
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+#define PORT "34912"  
+#define BACKLOG 2  
+#define SMALL_RECV_BUF_SIZE 128
+
+#pragma warning(disable:4267)
+
+int listen_fd, accept_fd, connect_fd, retValue;
+struct addrinfo hints, *servinfo;
+fd_set read_set, write_set, except_set;
+struct timeval time_val;
+struct sockaddr_storage their_addr;
+int their_addr_len = sizeof(their_addr);
+char *send_buf, *recv_buf;
+
+int
+w32_unw32_set_nonblock(int fd)
+{
+	int val;
+
+	val = fcntl(fd, F_GETFL, 0);
+	if (val < 0)
+		return (-1);
+
+	if (!(val & O_NONBLOCK))
+		return (0);
+	
+	val &= ~O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, val) == -1)
+		return (-1);
+	
+	return (0);
+}
+
+int
+w32_set_nonblock(int fd)
+{
+	int val;
+
+	val = fcntl(fd, F_GETFL, 0);
+	if (val < 0)
+		return (-1);
+
+	if (val & O_NONBLOCK)
+		return (0);
+	
+	val |= O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, val) == -1)
+		return (-1);
+	
+	return (0);
+}
+
+void 
+prep_input_buffer(char* buf, int size, int seed)
+{
+	int ctr = 1;
+	int *cur = (int*)buf;
+	for (; size; size -= 4) {
+		*(cur++) = ctr;
+		ctr += seed;
+	}
+}
+
+void 
+socket_fd_tests()
+{
+	fd_set set, *pset;
+	pset = &set;
+
+	{
+		TEST_START("fd_set initial state");
+		
+		FD_ZERO(pset);
+		ASSERT_CHAR_EQ(0, FD_ISSET(0, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(1, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(2, pset));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("FD_SET");
+
+		FD_SET(0, pset);
+		FD_SET(1, pset);
+		ASSERT_CHAR_EQ(1, FD_ISSET(0, pset));
+		ASSERT_CHAR_EQ(1, FD_ISSET(1, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(2, pset));
+
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("FD_CLR");
+		
+		FD_CLR(0, pset);
+		ASSERT_CHAR_EQ(0, FD_ISSET(0, pset));
+		ASSERT_CHAR_EQ(1, FD_ISSET(1, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(2, pset));
+
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("FD_ZERO");
+		
+		FD_ZERO(pset);
+		ASSERT_CHAR_EQ(0, FD_ISSET(0, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(1, pset));
+		ASSERT_CHAR_EQ(0, FD_ISSET(2, pset));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("BAD FDs");
+		
+		ASSERT_INT_EQ(accept(-1, NULL, NULL), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(setsockopt(MAX_FDS, 0, 0, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		/*0,1,2 fd's are initialized */
+		ASSERT_INT_EQ(getsockopt(3, 0, 0, NULL, NULL), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(getsockname(4, NULL, NULL), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(getpeername(5, NULL, NULL), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(listen(6, 2), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(bind(7, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(connect(8, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(recv(9, NULL, 0, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(send(10, NULL, 0, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(shutdown(11, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(read(MAX_FDS + 1, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(write(INFINITE, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(fstat(11, NULL), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(isatty(12), 0);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_PTR_EQ(fdopen(13, NULL), NULL);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(close(14), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(fcntl(15, 1), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(dup(16), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		ASSERT_INT_EQ(dup2(17, 18), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		FD_ZERO(&read_set);
+		FD_SET(20, &read_set);
+		ASSERT_INT_EQ(select(21, &read_set, NULL, NULL, &time_val), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		FD_ZERO(&write_set);
+		FD_SET(21, &write_set);
+		ASSERT_INT_EQ(select(22, NULL, &write_set, NULL, &time_val), -1);
+		ASSERT_INT_EQ(errno, EBADF);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("socket failures");
+		
+		ASSERT_INT_EQ(setsockopt(0, 0, SO_RCVTIMEO, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, ENOTSOCK);
+		connect_fd = socket(AF_UNSPEC, SOCK_STREAM, IPPROTO_TCP);
+		ASSERT_INT_NE(connect_fd, -1);
+		ASSERT_INT_EQ(setsockopt(connect_fd, 0, SO_RCVTIMEO, NULL, 0), -1);
+		ASSERT_INT_EQ(errno, ENOTSUP);
+		close(connect_fd);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("min fd allocation");
+		
+		connect_fd = socket(AF_INET, SOCK_STREAM, 0);
+		ASSERT_INT_EQ(connect_fd, 3);
+		listen_fd = socket(AF_INET, SOCK_STREAM, 0);
+		ASSERT_INT_EQ(listen_fd, 4);
+		close(connect_fd);
+		connect_fd = socket(AF_INET, SOCK_STREAM, 0);
+		ASSERT_INT_EQ(connect_fd, 3); /*minimum free fd gets allocated*/
+		close(connect_fd);
+		close(listen_fd);
+		
+		TEST_DONE();
+	}
+}
+
+void 
+socket_blocking_io_tests()
+{
+	char* small_send_buf = "sample payload";
+	char small_recv_buf[SMALL_RECV_BUF_SIZE];
+
+	{
+		TEST_START("Basic IPv4 client server connection setup");
+		
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		retValue = getaddrinfo("127.0.0.1", PORT, &hints, &servinfo);
+		ASSERT_INT_EQ(retValue, 0);
+		listen_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(listen_fd, -1);
+		retValue = bind(listen_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = listen(listen_fd, BACKLOG);
+		ASSERT_INT_EQ(retValue, 0);
+		//call listen again??
+		connect_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(connect_fd, -1);
+		retValue = connect(connect_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		//call connect again??
+		their_addr_len = sizeof(their_addr);
+		accept_fd = accept(listen_fd, (struct sockaddr*)&their_addr, &their_addr_len);
+		ASSERT_INT_NE(accept_fd, -1);
+		retValue = close(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		//call accept after listen_fd is closed??
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("send failures");
+		
+		retValue = send(accept_fd, NULL, 4, 0);/*invalid buffer*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EINVAL);
+		retValue = send(accept_fd, small_send_buf, 0, 0); /*invalid buffer*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EINVAL);
+		retValue = send(accept_fd, small_send_buf, strlen(small_send_buf), 4); /*flags not supported yet*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, ENOTSUP);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("basic send s->c");
+
+		retValue = send(accept_fd, small_send_buf, strlen(small_send_buf), 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("recv failures");
+
+		retValue = recv(connect_fd, NULL, SMALL_RECV_BUF_SIZE, 0); /* invalid buffer*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EINVAL);
+		retValue = recv(connect_fd, small_recv_buf, 0, 0); /*invalid buffer*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EINVAL);
+		retValue = recv(connect_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 6); /*flags not supported yet*/
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, ENOTSUP);
+
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("basic recv s->c");
+
+		retValue = recv(connect_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		small_recv_buf[retValue] = '\0';
+		ASSERT_STRING_EQ(small_send_buf, small_recv_buf);
+		memset(small_recv_buf, 0, sizeof(small_recv_buf));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("basic send recv c->s");
+
+		retValue = send(connect_fd, small_send_buf, strlen(small_send_buf), 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		retValue = recv(accept_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		small_recv_buf[retValue] = '\0';
+		ASSERT_STRING_EQ(small_send_buf, small_recv_buf);
+		memset(small_recv_buf, 0, sizeof(small_recv_buf));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("shutdown SD_SEND");
+
+		retValue = shutdown(connect_fd, SD_SEND);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = recv(accept_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0); /* send on other side is shutdown*/
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = shutdown(accept_fd, SD_SEND);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = recv(connect_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0); /* send on other side is shutdown*/
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("shutdown SD_RECEIVE");
+
+		retValue = shutdown(connect_fd, SD_RECEIVE);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = send(accept_fd, small_send_buf, strlen(small_send_buf), 0);
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, ECONNRESET);
+		retValue = shutdown(accept_fd, SD_RECEIVE);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = send(connect_fd, small_send_buf, strlen(small_send_buf), 0);
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, ECONNRESET);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("basic close");
+
+		retValue = close(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = close(accept_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	freeaddrinfo(servinfo);
+}
+
+void 
+socket_nonblocking_io_tests()
+{
+	char* small_send_buf = "sample payload";
+	char small_recv_buf[SMALL_RECV_BUF_SIZE];
+
+	{
+		TEST_START("IPv6 sockets setup");
+		
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		retValue = getaddrinfo("::1", PORT, &hints, &servinfo);
+		ASSERT_INT_EQ(retValue, 0);
+		listen_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(listen_fd, -1);
+		retValue = bind(listen_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = listen(listen_fd, BACKLOG);
+		ASSERT_INT_EQ(retValue, 0);
+		connect_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(connect_fd, -1);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("non blocking accept and connect");
+
+		retValue = w32_set_nonblock(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		accept_fd = accept(listen_fd, NULL, NULL);
+		ASSERT_INT_EQ(accept_fd, -1);
+		ASSERT_INT_EQ(errno, EAGAIN);
+		retValue = w32_set_nonblock(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = connect(connect_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		/* connect is too fast to block
+		ASSERT_INT_EQ(ret, -1);
+		ASSERT_INT_EQ(errno, EINPROGRESS); */
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = w32_unw32_set_nonblock(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		accept_fd = accept(listen_fd, NULL, NULL);
+		ASSERT_INT_NE(accept_fd, -1);
+		retValue = close(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("non blocking recv");
+
+		retValue = w32_set_nonblock(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = recv(connect_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0);
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EAGAIN);
+		retValue = w32_unw32_set_nonblock(accept_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = send(accept_fd, small_send_buf, strlen(small_send_buf), 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		retValue = w32_unw32_set_nonblock(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = recv(connect_fd, small_recv_buf, SMALL_RECV_BUF_SIZE, 0);
+		ASSERT_INT_EQ(retValue, strlen(small_send_buf));
+		small_recv_buf[retValue] = '\0';
+		ASSERT_STRING_EQ(small_send_buf, small_recv_buf);
+		memset(small_recv_buf, 0, sizeof(small_recv_buf));
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("non blocking send");
+		
+		send_buf = malloc(10 * 1024);
+		ASSERT_PTR_NE(send_buf, NULL);
+		retValue = w32_set_nonblock(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = 1;
+		while (retValue > 0) {
+			retValue = send(connect_fd, send_buf, 10 * 1024, 0);
+		}
+		ASSERT_INT_EQ(retValue, -1);
+		ASSERT_INT_EQ(errno, EAGAIN);
+		retValue = close(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = close(accept_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	free(send_buf);
+	freeaddrinfo(servinfo);
+}
+
+void 
+socket_select_tests() {
+	int s, r;
+	int num_bytes = 1024 * 1024 * 4; //4 MB
+	int bytes_sent = 0;
+	int bytes_received = 0;
+	int seed = 326;
+	int eagain_results = 0;
+
+	{
+		TEST_START("select listen");
+
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		retValue = getaddrinfo("127.0.0.1", PORT, &hints, &servinfo);
+		ASSERT_INT_EQ(retValue, 0);
+		listen_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(listen_fd, -1);
+		retValue = bind(listen_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = listen(listen_fd, BACKLOG);
+		ASSERT_INT_EQ(retValue, 0);
+		connect_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(connect_fd, -1);
+		retValue = connect(connect_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = w32_set_nonblock(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		time_val.tv_sec = 60;
+		time_val.tv_usec = 0;
+		FD_ZERO(&read_set);
+		FD_SET(listen_fd, &read_set);
+		retValue = select(listen_fd + 1, &read_set, NULL, NULL, &time_val);
+		ASSERT_INT_NE(retValue, -1);
+		ASSERT_INT_EQ(FD_ISSET(listen_fd, &read_set), 1);
+		accept_fd = accept(listen_fd, NULL, NULL);
+		ASSERT_INT_NE(accept_fd, -1);
+		retValue = close(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("select send and recv");
+
+		s = accept_fd;
+		r = connect_fd;
+		retValue = w32_set_nonblock(s);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = w32_set_nonblock(r);
+		ASSERT_INT_EQ(retValue, 0);
+		send_buf = malloc(num_bytes);
+		recv_buf = malloc(num_bytes + 1);
+		ASSERT_PTR_NE(send_buf, NULL);
+		ASSERT_PTR_NE(recv_buf, NULL);
+		prep_input_buffer(send_buf, num_bytes, 17);
+		FD_ZERO(&read_set);
+		FD_ZERO(&write_set);
+		FD_SET(s, &write_set);
+		FD_SET(r, &read_set);
+		while (-1 != select(max(r, s) + 1, &read_set, &write_set, NULL, &time_val)) {
+			if (FD_ISSET(s, &write_set)) {
+				while ((bytes_sent < num_bytes) && ((retValue = send(s, send_buf + bytes_sent, num_bytes - bytes_sent, 0)) > 0))
+					bytes_sent += retValue;
+				if (bytes_sent < num_bytes) {
+					ASSERT_INT_EQ(retValue, -1);
+					ASSERT_INT_EQ(errno, EAGAIN);
+					eagain_results++;
+				}
+			}
+
+			if (FD_ISSET(r, &read_set)) {
+				while ((retValue = recv(r, recv_buf + bytes_received, num_bytes - bytes_received + 1, 0)) > 0)
+					bytes_received += retValue;
+				if (retValue == 0)
+					break;
+				ASSERT_INT_EQ(retValue, -1);
+				ASSERT_INT_EQ(errno, EAGAIN);
+				eagain_results++;
+			}
+
+			if (bytes_sent < num_bytes)
+				FD_SET(s, &write_set);
+			else {
+				FD_CLR(s, &write_set);
+				retValue = shutdown(s, SD_SEND);
+				ASSERT_INT_EQ(retValue, 0);
+			}
+			FD_SET(r, &read_set);
+		}
+
+		/*ensure that we hit send and recv paths that returned EAGAIN. Else it would not have touched the async paths*/
+		/*if this assert is being hit, then num_bytes is too small. up it*/
+		ASSERT_INT_GT(eagain_results, 0);
+		ASSERT_INT_EQ(bytes_sent, bytes_received);
+		ASSERT_INT_EQ(memcmp(send_buf, recv_buf, num_bytes), 0);
+		retValue = close(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = close(accept_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	freeaddrinfo(servinfo);
+}
+
+void 
+socket_typical_ssh_payload_tests() {
+	int s, r;
+	int max_bytes = 1024 * 700; //700KB
+	int max_packetsize = 1024 * 5, bytes_sent = 0;
+	int packets_sent = 0;
+	int packets_received = 0;
+	int send_packet_remaining = 0, recv_packet_remaining = 0;
+	int eagain_results = 0;
+
+	{
+		TEST_START("connection setup");
+		
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_socktype = SOCK_STREAM;
+		retValue = getaddrinfo("127.0.0.1", PORT, &hints, &servinfo);
+		ASSERT_INT_EQ(retValue, 0);
+		listen_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(listen_fd, -1);
+		retValue = bind(listen_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = listen(listen_fd, BACKLOG);
+		ASSERT_INT_EQ(retValue, 0);
+		connect_fd = socket(servinfo->ai_family, servinfo->ai_socktype, servinfo->ai_protocol);
+		ASSERT_INT_NE(connect_fd, -1);
+		retValue = connect(connect_fd, servinfo->ai_addr, servinfo->ai_addrlen);
+		ASSERT_INT_EQ(retValue, 0);
+		accept_fd = accept(listen_fd, NULL, NULL);
+		ASSERT_INT_NE(accept_fd, -1);
+		retValue = close(listen_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	{
+		TEST_START("select send and recv packets");
+
+		r = accept_fd;
+		s = connect_fd;
+		retValue = w32_set_nonblock(s);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = w32_set_nonblock(r);
+		ASSERT_INT_EQ(retValue, 0);
+		send_buf = malloc(max_bytes);
+		recv_buf = malloc(max_bytes + 1);
+		ASSERT_PTR_NE(send_buf, NULL);
+		ASSERT_PTR_NE(recv_buf, NULL);
+		FD_ZERO(&read_set);
+		FD_ZERO(&write_set);
+		FD_SET(s, &write_set);
+		FD_SET(r, &read_set);
+
+		int total = 0;
+		while (-1 != select(max(r, s) + 1, &read_set, &write_set, NULL, &time_val)) {
+			if (FD_ISSET(s, &write_set)) {
+				while ((send_packet_remaining) && ((retValue = send(s, send_buf, send_packet_remaining, 0)) > 0)) {
+					send_packet_remaining -= retValue;
+					bytes_sent += retValue;
+				}
+
+				if (send_packet_remaining) {
+					ASSERT_INT_EQ(retValue, -1);
+					ASSERT_INT_EQ(errno, EAGAIN);
+				}
+				else if (bytes_sent < max_bytes) {
+					send_packet_remaining = (rand()*(max_packetsize - 100) / RAND_MAX) + 100;
+					retValue = send(s, &send_packet_remaining, 4, 0);
+					if (retValue == -1) {
+						send_packet_remaining = 0; //we'll try again when io is ready
+					}
+					else if (retValue < 4)
+						/*unfortunate - sent half the header, we'll bail the test out*/
+						ASSERT_INT_EQ(1, 0);
+					else {
+						ASSERT_INT_EQ(retValue, 4);
+						packets_sent++;
+						//printf("sending packet of size %d\n", send_packet_remaining);
+					}
+				}
+			}
+
+			if (FD_ISSET(r, &read_set)) {
+				while (recv_packet_remaining && ((retValue = recv(r, recv_buf, recv_packet_remaining, 0)) > 0)) {
+					recv_packet_remaining -= retValue;
+				}
+
+				if (recv_packet_remaining) {
+					ASSERT_INT_EQ(retValue, -1);
+					ASSERT_INT_EQ(errno, EAGAIN);
+				}
+				else {
+					retValue = recv(r, &recv_packet_remaining, 4, 0);
+					if (retValue == -1) {
+						ASSERT_INT_EQ(retValue, -1);
+						ASSERT_INT_EQ(errno, EAGAIN);
+					}
+					else if (retValue == 0)
+						break;
+					else if (retValue < 4)
+						/*unfortunate.. read partial header, bail out*/
+						ASSERT_INT_EQ(1, 0);
+					else {
+						ASSERT_INT_EQ(retValue, 4);
+						packets_received++;
+						//printf("recevied packet of size %d\n", recv_packet_remaining);
+					}
+				}
+			}
+
+			if ((bytes_sent >= max_bytes) && (send_packet_remaining == 0)) {
+				FD_CLR(s, &write_set);
+				retValue = shutdown(s, SD_SEND);
+				ASSERT_INT_EQ(retValue, 0);
+			}
+			else
+				FD_SET(s, &write_set);
+
+			FD_SET(r, &read_set);
+		}
+
+		ASSERT_INT_EQ(packets_sent, packets_received);
+		retValue = close(connect_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		retValue = close(accept_fd);
+		ASSERT_INT_EQ(retValue, 0);
+		
+		TEST_DONE();
+	}
+
+	freeaddrinfo(servinfo);
+}
+
+void
+socket_tests()
+{
+	socket_fd_tests();
+	socket_blocking_io_tests();
+	socket_nonblocking_io_tests();
+	socket_select_tests();
+	socket_typical_ssh_payload_tests();
+}
diff --git a/regress/unittests/win32compat/string_tests.c b/regress/unittests/win32compat/string_tests.c
new file mode 100644
index 000000000..7fc74cbe3
--- /dev/null
+++ b/regress/unittests/win32compat/string_tests.c
@@ -0,0 +1,43 @@
+#include "includes.h"
+#include <string.h>
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+int retValue;
+
+void
+str_simple_tests()
+{
+	TEST_START("string testcases");
+
+	char *s1 = "test_dir";
+	char *s2 = NULL;
+
+	s2 = strdup(NULL);
+	ASSERT_PTR_EQ(s2, NULL);
+
+	s2 = strdup(s1);
+	ASSERT_PTR_NE(s2, NULL);
+
+	retValue = strcasecmp(s1, s2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = strncasecmp(s1, s2, strlen(s1));
+	ASSERT_INT_EQ(retValue, 0);
+
+	s2[0] = 'T';
+	retValue = strcasecmp(s1, s2);
+	ASSERT_INT_EQ(retValue, 0);
+
+	retValue = strncasecmp(s1, s2, strlen(s1));
+	ASSERT_INT_EQ(retValue, 0);
+	free(s2);
+
+	TEST_DONE();
+}
+
+void
+str_tests()
+{
+	str_simple_tests();
+}
diff --git a/regress/unittests/win32compat/tests.c b/regress/unittests/win32compat/tests.c
new file mode 100644
index 000000000..ae27730dc
--- /dev/null
+++ b/regress/unittests/win32compat/tests.c
@@ -0,0 +1,77 @@
+/*
+* Author: Manoj Ampalam <manoj.ampalam@microsoft.com>
+*/
+/* disable inclusion of compatability defitnitions in CRT headers */
+#define __STDC__ 1
+#include "includes.h"
+#include <inc/dirent.h>
+#include <fcntl.h>
+#include <sys\types.h>
+#include <sys\stat.h>
+
+#include "../test_helper/test_helper.h"
+#include "tests.h"
+
+extern void log_init(char *av0, int level, int facility, int on_stderr);
+
+void 
+tests()
+{
+	_set_abort_behavior(0, 1);
+	log_init(NULL, 7, 2, 0);
+	signal_tests();
+	socket_tests();
+	file_tests();
+	dir_tests();
+	str_tests();
+	miscellaneous_tests();
+}
+
+char *
+dup_str(char *inStr)
+{
+	if(NULL == inStr)
+		return NULL;
+
+	int len = strlen(inStr);
+	char *outStr = malloc(len + 1);
+	if (NULL == outStr)
+		return NULL;
+	strncpy(outStr, inStr, len);
+	outStr[len] = '\0';
+	return outStr;
+}
+
+void
+delete_dir_recursive(char *full_dir_path)
+{
+	DIR *dirp = opendir(full_dir_path);
+	if (!dirp) return;
+
+	struct stat st;
+	struct dirent *dp;
+	char mode[12];
+	char *tmpFullPath = malloc(PATH_MAX + 1);
+	if (NULL == tmpFullPath) return;
+
+	strcpy(tmpFullPath, full_dir_path);
+	int tmpStrLen = strlen(tmpFullPath);
+	tmpFullPath[tmpStrLen++] = '\\';
+
+	while (dp = readdir(dirp)) {
+		strcpy(tmpFullPath + tmpStrLen, dp->d_name);
+		tmpFullPath[tmpStrLen + strlen(dp->d_name)] = '\0';
+
+		stat(tmpFullPath, &st);
+		strmode(st.st_mode, mode);
+		if (mode[0] == '-') /* regular file */
+			unlink(tmpFullPath);
+		else if (mode[0] == 'd') /* directory */
+			delete_dir_recursive(tmpFullPath);
+	}
+
+	closedir(dirp);
+	rmdir(full_dir_path);
+
+	free(tmpFullPath);
+}
diff --git a/regress/unittests/win32compat/tests.h b/regress/unittests/win32compat/tests.h
new file mode 100644
index 000000000..580cf063f
--- /dev/null
+++ b/regress/unittests/win32compat/tests.h
@@ -0,0 +1,14 @@
+#pragma once
+void signal_tests();
+void socket_tests();
+void file_tests();
+void miscellaneous_tests();
+
+char *dup_str(char *inStr);
+void delete_dir_recursive(char *full_dir_path);
+
+#define ASSERT_HANDLE(handle) \
+{\
+	ASSERT_PTR_NE(handle, INVALID_HANDLE_VALUE); \
+	ASSERT_PTR_NE(handle, 0); \
+}
diff --git a/sshfileperm.h b/sshfileperm.h
new file mode 100644
index 000000000..1604139aa
--- /dev/null
+++ b/sshfileperm.h
@@ -0,0 +1,30 @@
+/*
+* Copyright (c) 2004, 2005 Darren Tucker.  All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+* THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef _SSH_FILE_PERM_H
+#define _SSH_FILE_PERM_H
+
+int check_secure_file_permission(const char *, struct passwd *, int);
+int check_secure_folder_permission(const wchar_t*, int);
+#endif /* _SSH_FILE_PERM_H */
-- 
2.25.1

